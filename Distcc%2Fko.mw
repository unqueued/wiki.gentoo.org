<languages />

Distcc는 네트워크를 통해 호스트가 참여하여 분산 컴파일 작업을 수행하도록 설계한 프로그램입니다.  distccd 서버와 distcc 클라이언트로 구성되어 있습니다. Distcc는 ccache, Portage, 약간의 설정 과정을 거치는 automake로 눈에 보이지 않도록 작업을 수행할 수 있습니다.

[http://distcc.samba.org Distcc] 는 네트워크를 통해 호스트가 참여하여 분산 컴파일 작업을 수행하도록 설계한 프로그램입니다.  <code>distccd</code> 서버와 <code>distcc</code> 클라이언트로 구성되어 있습니다. Distcc는 [http://ccache.samba.org ccache], Portage, 약간의 설정 과정을 거치는 automake로 눈에 보이지 않도록 작업을 수행할 수 있습니다. 

젠투 설치 초기에 도움을 받기 위해 distcc를 사용하려 한다면, [[#Using_Distcc_to_Bootstrap|설치 초기에 distcc 사용하기]] 섹션을 읽어보십시오. 

== 설치 ==

=== 의존성 ===

distcc를 사용하려면 네트워크상의 모든 컴퓨터에 같은 gcc 버전이 있어야 합니다. 예를 들어 3.3.x(x는 바뀔 수 있음)는 괜찮지만 3.3.x와 3.2.x를 같이 사용하면 '''아마도''' 컴파일 오류 또는 실행시간 오류가 나타날것입니다. 

=== Distcc 설치하기 ===

distcc 설치를 시작하기 전에 알아두어야 할 몇가지 옵션이 있습니다. 

distcc는 여러분의 컴퓨터가 컴파일하는 동안 보내는 모니터링 작업에 대해 그래픽 환경의 감시 프로그램을 제공합니다. 만약 여러분이 Gnome을 사용한다면 여러분의 USE 플래그에 'gnome'을 넣어두십시오. 하지만, Gnome을 사용하지 않으면서 모니터를 쓰려면, 'gtk'를 USE 플래그에 넣어두십시오. 

{{Emerge|distcc}}

{{Important|여러분의 모든 컴퓨터에 distcc가 설치되어 있는지 확인하는 것을 잊지 마십시오.}}

=== Distcc를 사용하도록 포티지 설정하기 ===

distcc를 사용하도록 portage를 설정하는 것은 쉽습니다. 각 시스템이 분산 컴파일 작업에 참여하도록 하려면 다음 단계를 실행하십시오: 

{{Emerge|distcc}}

이제 <code>MAKEOPTS</code> 변수와 <code>FEATURES</code> 변수를 아래처럼 설정하십시오.
일반적인 전략은 CPU 전체(로컬+원격) 갯수 + 1 을 N의 값으로 설정하고 로컬 CPU의 갯수를 M으로 설정하는 것입니다. distcc 호스트를 사용할 수 없거나, ebuild에서 로컬 전용 컴파일(gcc)을 필요로 한다면, <code>-IM</code> 플래그를 적용하여 과도한 작업을 분담하지 않도록 막으십시오.

{{RootCmd|nano -w /etc/portage/make.conf|output=<pre>
MAKEOPTS="-jN -lM"
FEATURES="distcc"
</pre>
}}

=== 참여 호스트 지정 ===

호스트의 목록을 설정하려면 <code>distcc-config</code> 명령을 사용하십시오. 설정값이 될 몇가지 호스트 예제가 있습니다. 

{{Code|호스트 정의 예제|<pre>
192.168.0.1          192.168.0.2                       192.168.0.3
192.168.0.1/2        192.168.0.2                       192.168.0.3/10
192.168.0.1:4000/2   192.168.0.2/1                     192.168.0.3:3632/4
@192.168.0.1         @192.168.0.2:/usr/bin/distccd     192.168.0.3
</pre>
}}

호스트를 설정하는데 다른 여러가지 방법도 있습니다. 자세한 내용은 distcc 맨페이지를 보십시오.

만약 여러분들이 지역 장치에서 컴파일 하기를 원한다면 여러분들은 'localhost'를 호스트 목록에 추가해야 합니다. 반대로 지역 장치가 컴파일을 하기를 원치 않으신다면(대부분의 경우) 호스트 목록에서 생략해야 합니다. 느린 장치에서 로컬호스트를 사용하는 것은 실제로 컴파일을 느리게 만듭니다. 성능을 위해 설정을 시험하여 확인하십시오.

모든 것이 복잡한 것 같지만, 대부분 첫번째 줄 또는 두번째 줄로도 충분히 작동합니다. 

대부분 3번째 혹은 4번째의 줄을 쓰지 않으므로, distcc 실행을 SSH 연결을 통할 수 있게 하는 설정내용이 들어간 distcc 설명서를 [http://distcc.samba.org/man/distcc_1.html 참조]하겠습니다. 

예를 들어 앞의 예제에서 첫 줄을 설정한다면: 

{{RootCmd|/usr/bin/distcc-config --set-hosts "192.168.0.1 192.168.0.2 192.168.0.3"}}

Edit {{Path|/etc/conf.d/distccd}} to your needs and be sure to set the <code>--allow</code> directive to allow only hosts you trust. For added security, you should also use the <code>--listen</code> directive to tell the distcc daemon what IP to listen on (for multi-homed systems). More information on distcc security can be found at [http://distcc.samba.org/security.html Distcc Security Design] . 

{{Important/ko|--allow와 --listen 지시자의 사용은 중요합니다. 더 많은 내용은 distccd 맨페이지나 상위의 보안 문서를 읽어주십시오.}}

이제 distcc 데몬을 모든 참여 머신에서 시작하십시오: 

{{RootCmd|rc-update add distccd default
|/etc/init.d/distccd start}}

=== automake가 동작하도록 Distcc 설정 ===

이 경우 포티지 설정보다 쉽습니다. 여러분이 해야 할 일은 여러분의 <code>PATH</code> 변수에 gcc를 포함하는 디렉터리({{Path|/usr/bin}})앞에 {{Path|/usr/lib/distcc/bin}} 을 포함하도록 업데이트 하는 것입니다. 하지만 여기서 주의할 점이 있습니다. 만약 여러분이 ccache를 사용한다면 여러분들은 ccache 다음에 distcc를 놓아야 합니다: 

{{RootCmd|export PATH{{=}}"/usr/lib/ccache/bin:/usr/lib/distcc/bin:${PATH}"}}

로그인 할 때마다 PATH를 설정하기 위해 ~/.bashrc같은 파일에 추가할 수 있습니다.

Then, as you would normally type <code>make</code> , you would type <code>make -jN</code> (where N is an integer). The value of N depends on your network and the types of computers you are using to compile. Test your own settings to find the number that yields the best performance. 

== 크로스 컴파일 ==

크로스 컴파일은 다른 아키텍쳐에 대해 프로그램을 빌드하는데 사용합니다. Athlon(i686)을 사용하여 K6-2(i586)에 대한 프로그램을 빌드할 때나, Sparc을 사용하여 ppc에 대한 프로그램을 빌드할 때처럼 간단합니다. 이것은 젠투의 [[Distcc/Cross-Compiling|DistCC 크로스 컴파일 안내서]]에 문서화되어 있습니다.

== 부트스트랩에 distcc 사용 ==

=== 1단계: 포티지 설정 ===

젠투리눅스 LiveCD가 들어간 새 컴퓨터를 부팅하고 부트스트랩 부분까지 [http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?part=1 설치 과정]을 따라하십시오(부트스트랩에 대한 더 많은 정보를 얻고자 하신다면 [http://www.gentoo.org//doc/en/faq.xml#stage12 젠투 FAQ]를 보십시오). 다음 distcc를 사용하도록 포티지를 설정하십시오: 

{{RootCmd|nano -w /etc/portage/make.conf|output=<pre>
FEATURES="distcc"
MAKEOPTS="-jN"
</pre>
}}

{{RootCmd|export PATH{{=}}"/usr/lib/ccache/bin:/usr/lib/distcc/bin:${PATH}"}}

=== 2단계: distcc 가져오기 ===

distcc를 설치하십시오: 

{{RootCmd|USE{{=}}'-*' emerge --nodeps sys-devel/distcc}}

=== 3단계: distcc 설정 ===

distcc를 설정하려면 <code>distcc-config --install</code>을 실행하십시오. <code>host*</code>를 참여하는 distcc 노드의 IP주소 또는 호스트 이름으로 바꾸십시오.

{{RootCmd|/usr/bin/distcc-config --set-hosts "localhost host1 host2 host3 ..."}}

이제 distcc 부트스트랩을 설정했습니다! 공식 설치 설명서 내용에 따라 계속 진행하시고, <code>emerge system</code>을 실행한 후에 distcc를 다시 이머지 하는 것을 ''잊지 마십시오''. 이 절차는 원한 바대로 설치한 그대로의 모든 의존성을 확인하는 절차입니다. 

{{Note/ko|부트스트랩과 <code>emerge system</code>을 처리하는 동안 distcc를 사용하지 않는 것으로 나타납니다. 일부 ebuild가 distcc와 제대로 동작하지 않는 것으로 보이기 때문에, 일부러 distcc를 사용하지 않습니다.}}

== 문제 해결 ==

=== 일부 패키지가 distcc를 활용할 수 없습니다 ===

다양한 패키지를 emerge 하면서, 패키지중 일부를 분산처리하지 않는다는 점(그리고 병렬로 빌드하지 않는다는 점)을 주의하셔야 합니다. 이것은 패키지의 Makefile이 병렬 처리를 지원하지 않거나 ebuild의 관리자가 알려진 문제점때문에 확실하게 병렬 처리를 사용하지 않도록 했기 때문입니다. 

때때로 distcc는 컴파일에 실패하는 요인이 되기도 합니다. 만약 이런 일이 여러분들에게 일어난다면, 저희에게 [http://bugs.gentoo.org 알려주십시오]. 

=== 혼합 GCC 버전 ===

각기 다른 GCC 버전이 호스트에 존재한다면 이상한 문제를 야기할 수 있습니다. 해결 방법은 모든 호스트의 GCC 버전을 같게 하는 것입니다. 

최근 포티지에서는 <code>gcc</code> 대신 <code>${CHOST}-gcc</code>를 사용하도록 업데이트 했습니다.  이는 i686 머신을 다른 형식(i386, i586)의 머신과 혼용해서 사용한다면 문제에 직면함을 의미합니다. 이에 대한 해결책은 <code>export CC='gcc' CXX='c++'</code> 명령을 입력하거나 이 변수값을 {{Path|/etc/portage/make.conf}}에 넣는 것입니다. 

{{Important/ko|이 설정 과정은 명백하게 포티지의 몇가지 동작을 재정의하는 것이며 나중에 이상한 결과가 나타납니다. 오로지 CHOST 값을 섞어 쓸 때에만 설정하십시오.}}

=== -march=native ===

GCC 4.3.0부터, GCC가 동작하는 프로세서에서 CPU 자동 감지 및 최적화를 활성화 하는 <code>-march=native</code> 스위치를 지원합니다. (AMD 애슬론과 인텔 펜티움과 같은) 각기 다른 프로세서에서 최적화 한 코드가 섞일 수 있기 때문에 <code>distcc</code>에는 문제가 될 수 있습니다. <code>distcc</code>로 컴파일 할때 <code>CFLAGS</code> 또는 <code>CXXFLAGS</code>에 <code>-march=native</code> 또는 <code>-mtune=native</code> 스위치를 ''사용하지 마십시오''.

GCC를 <code>-march=native</code>로 호출할 때 사용하는 플래그를 알아보려면 다음 명령을 실행하십시오:

{{Cmd|gcc -march{{=}}native -E -v - &lt;/dev/null 2&gt;&amp;1 {{!}} grep cc1|output=<pre>
/usr/libexec/gcc/x86_64-pc-linux-gnu/4.7.3/cc1 -E -quiet -v - -march=corei7-avx \
  -mcx16 -msahf -mno-movbe -mno-aes -mpclmul -mpopcnt -mno-abm -mno-lwp -mno-fma \
  -mno-fma4 -mno-xop -mno-bmi -mno-bmi2 -mno-tbm -mavx -mno-avx2 -msse4.2 -msse4.1 \
  -mno-lzcnt -mno-rdrnd -mno-f16c -mno-fsgsbase --param l1-cache-size=32 \
  --param l1-cache-line-size=64 --param l2-cache-size=6144 -mtune=corei7-avx
</pre>}}

== 추가 distcc 요소 ==

=== distcc 감시 프로그램 ===

distcc에는 두가지 감시 프로그램이 들어있습니다. 항상 빌드하는 텍스트 기반 프로그램을 <code>distccmon-text</code>라고 합니다. 처음 실행하는게 약간 혼동스러울 수도 있지만, 사용 방법은 아주 쉽습니다. 프로그램을 아무런 매개 변수없이 실행한다면 처음 한 번만 실행합니다. 하지만, 숫자를 전달한다면 매 N초마다 업데이트 합니다. 여기에서 N은 여러분이 전달하는 숫자 인자입니다. 

다른 감시 프로그램은 여러분들이 <code>gtk</code>나 <code>gnome</code>을 여러분의 <code>USE</code> 플래그에 두었을 때에만 실행할 수 있습니다. GTK+ 기반의 프로그램이며, X환경에서 구동되고 정말 사랑스럽습니다. 젠투에서의 GUI 감시 프로그램은 혼동을 피하기 위해 <code>distccmon-gui</code>로 불립니다. 이 감시 프로그램은 다른 프로그램에서 <code>distccmon-gnome</code>으로 참조합니다. 

{{RootCmd|distccmon-text N}}

또는 <code>distccmon-gui</code>를 실행하십시오:

{{RootCmd|distccmon-gui}}

포티지의 distcc 사용 상태를 감시한다면 다음 명령을 사용할 수 있습니다:{{RootCmd|DISTCC_DIR{{=}}"/var/tmp/portage/.distcc/" distccmon-text N |DISTCC_DIR{{=}}"/var/tmp/portage/.distcc/" distccmon-gui}}

{{Important/ko|distcc 디렉터리가 어디에도 없다면, DISTCC_DIR 변수를 올바르게 바꾸십시오.}}

== 감사문 ==

이 안내서에 제공한 노고에 대해 다음 작성자와 편집자분들께 감사의 말을 전하고자 합니다:

* Lisa Seelye
* Mike Frysinger
* Erwin
* Sven Vermeulen
* Lars Weiler
* Tiemo Kieft
* nightmorph
