<languages />

Distcc는 네트워크를 통해 호스트가 참여하여 분산 컴파일 작업을 수행하도록 설계한 프로그램입니다.  distccd 서버와 distcc 클라이언트로 구성되어 있습니다. Distcc는 ccache, Portage, 약간의 설정 과정을 거치는 automake로 눈에 보이지 않도록 작업을 수행할 수 있습니다.

[http://distcc.samba.org Distcc] 는 네트워크를 통해 호스트가 참여하여 분산 컴파일 작업을 수행하도록 설계한 프로그램입니다.  <code>distccd</code> 서버와 <code>distcc</code> 클라이언트로 구성되어 있습니다. Distcc는 [http://ccache.samba.org ccache], Portage, 약간의 설정 과정을 거치는 automake로 눈에 보이지 않도록 작업을 수행할 수 있습니다. 

젠투 설치 초기에 도움을 받기 위해 distcc를 사용하려 한다면, [[#Using_Distcc_to_Bootstrap|설치 초기에 distcc 사용하기]] 섹션을 읽어보십시오. 

== 설치 ==

=== 의존성 ===

distcc를 사용하려면 네트워크상의 모든 컴퓨터에 같은 gcc 버전이 있어야 합니다. 예를 들어 3.3.x(x는 바뀔 수 있음)는 괜찮지만 3.3.x와 3.2.x를 같이 사용하면 '''아마도''' 컴파일 오류 또는 실행시간 오류가 나타날것입니다. 

=== Distcc 설치하기 ===

distcc 설치를 시작하기 전에 알아두어야 할 몇가지 옵션이 있습니다. 

distcc에는 컴파일 작업을 보내는 컴퓨터의 작업을 지켜볼 때 사용하는 그래픽 감시 프로그램이 있으며 <code>gtk</code> <code>USE</code> 플래그로 활성화 합니다.

{{Emerge|distcc}}

{{Important/ko|여러분의 모든 컴퓨터에 distcc가 설치되어 있는지 확인하는 것을 잊지 마십시오.}}

=== Distcc를 사용하도록 포티지 설정하기 ===

distcc를 사용하도록 portage를 설정하는 것은 쉽습니다. 각 시스템이 분산 컴파일 작업에 참여하도록 하려면 다음 단계를 실행하십시오: 

{{Emerge|distcc}}

이제 <code>MAKEOPTS</code> 변수와 <code>FEATURES</code> 변수를 아래처럼 설정하십시오.
일반적인 전략은 CPU 전체(로컬+원격) 갯수 + 1 을 N의 값으로 설정하고 로컬 CPU의 갯수를 M으로 설정하는 것입니다. distcc 호스트를 사용할 수 없거나, ebuild에서 로컬 전용 컴파일(gcc)을 필요로 한다면, <code>-IM</code> 플래그를 적용하여 과도한 작업을 분담하지 않도록 막으십시오.

{{RootCmd|nano -w /etc/portage/make.conf|output=<pre>
MAKEOPTS="-jN -lM"
FEATURES="distcc"
</pre>
}}

=== 참여 호스트 지정 ===

호스트의 목록을 설정하려면 <code>distcc-config</code> 명령을 사용하십시오. 설정값이 될 몇가지 호스트 예제가 있습니다. 

{{Code|호스트 정의 예제|<pre>
192.168.0.1          192.168.0.2                       192.168.0.3
192.168.0.1/2        192.168.0.2                       192.168.0.3/10
192.168.0.1:4000/2   192.168.0.2/1                     192.168.0.3:3632/4
@192.168.0.1         @192.168.0.2:/usr/bin/distccd     192.168.0.3
</pre>
}}

호스트를 설정하는데 다른 여러가지 방법도 있습니다. 자세한 내용은 distcc 맨페이지를 보십시오.

만약 여러분들이 지역 장치에서 컴파일 하기를 원한다면 여러분들은 'localhost'를 호스트 목록에 추가해야 합니다. 반대로 지역 장치가 컴파일을 하기를 원치 않으신다면(대부분의 경우) 호스트 목록에서 생략해야 합니다. 느린 장치에서 로컬호스트를 사용하는 것은 실제로 컴파일을 느리게 만듭니다. 성능을 위해 설정을 시험하여 확인하십시오.

모든 것이 복잡한 것 같지만, 대부분 첫번째 줄 또는 두번째 줄로도 충분히 작동합니다. 

대부분 3번째 혹은 4번째의 줄을 쓰지 않으므로, distcc 실행을 SSH 연결을 통할 수 있게 하는 설정내용이 들어간 distcc 설명서를 [http://distcc.samba.org/man/distcc_1.html 참조]하겠습니다. 

예를 들어 앞의 예제에서 첫 줄을 설정한다면: 

{{RootCmd|/usr/bin/distcc-config --set-hosts "192.168.0.1 192.168.0.2 192.168.0.3"}}

여러분의 필요에 따라 {{Path|/etc/conf.d/distccd}} 를 편집하십시오. 그리고 여러분이 신뢰하는 호스트들만 허용하도록 <code>--allow</code> 지시자를 설정하였는지 확인하십시오. 보안성을 더하기 위해, 여러분은 distcc 데몬이 (여러 군데에 위치한 시스템들에 대해) 어떤 IP로 수신받고 있는지 알려줄 <code>--listen</code> 지시자를 사용할 수 있습니다. distcc 보안에 대한 더 많은 정보는 [http://distcc.samba.org/security.html Distcc 보안 설계]에서 찾을 수 있습니다. 

{{Important/ko|--allow와 --listen 지시자의 사용은 중요합니다. 더 많은 내용은 distccd 맨페이지나 상위의 보안 문서를 읽어주십시오.}}

이제 distcc 데몬을 모든 참여 머신에서 시작하십시오: 

{{RootCmd|rc-update add distccd default
|/etc/init.d/distccd start}}

=== automake가 동작하도록 Distcc 설정 ===

이 경우 포티지 설정보다 쉽습니다. 여러분이 해야 할 일은 여러분의 <code>PATH</code> 변수에 gcc를 포함하는 디렉터리({{Path|/usr/bin}})앞에 {{Path|/usr/lib/distcc/bin}} 을 포함하도록 업데이트 하는 것입니다. 하지만 여기서 주의할 점이 있습니다. 만약 여러분이 ccache를 사용한다면 여러분들은 ccache 다음에 distcc를 놓아야 합니다: 

{{RootCmd|export PATH{{=}}"/usr/lib/ccache/bin:/usr/lib/distcc/bin:${PATH}"}}

로그인 할 때마다 PATH를 설정하기 위해 ~/.bashrc같은 파일에 추가할 수 있습니다.

그런 다음, 여러분이 보통 <code>make</code>라고 입력하는 바와 같이, <code>make -jN</code>(N은 정수형 숫자)을 입력합니다. N의 값은 여러분의 네트워크와 여러분이 컴파일에 사용하는 컴퓨터의 형식에 달려있습니다. 최고의 성능을 부여할 숫자를 찾기 위해 여러분의 설정을 시험해보십시오. 

=== distcc가 ssh와 동작하도록 설정 ===

ssh를 통한 distcc 설정은 알아야 할 몇가지 함정이 존재합니다. 먼저 암호 설정을 뺀 상태의 ssh 키 쌍을 만들어야 합니다. portage 사용자가 포티지로 프로그램을 컴파일 함을 아셔야 합니다. portage  사용자의 폴더는 {{Path|/var/tmp/portage}}이며 ssh 키를 {{Path|/var/tmp/portage/.ssh}}에 저장해야 한다는 의미입니다.

{{RootCmd|ssh-keygen -b 2048 -t rsa -f /var/tmp/portage/.ssh/id_rsa}}

두번째로, ssh 설정 파일에 각 호스트에 대한 섹션을 만드십시오:

{{RootCmd|nano -w /var/tmp/portage/.ssh/config|output=<pre>
Host test1
    HostName 123.456.789.1
    Port 1234
    User UserName

Host test2
    HostName 123.456.789.2
    Port 1234
    User UserName
</pre>
}}

{{Path|known_hosts}}파일에 존재하는 각각의 호스트가 있는지 확인하시고 호스트의 {{Path|authorized_keys}} 파일에 공용키를 추가하십시오. test1과 test2 호스트를 설정하려면 다음 명령을 실행하십시오

{{RootCmd|/usr/bin/distcc-config --set-hosts "@test1 @test2"}}

<code>distcc</code>에 대한 ssh 호스트를 지정할 때 '@'  기호를 붙이지 마십시오.

== Cross-Compiling ==

어떤 아키텍처에서 다른 아키텍처에 대해 프로그램을 빌드할 때 사용하는 방법이 크로스 컴파일입니다. 애슬론(i686)에서 K6-2에 대해, 또는 스파크 머신에서 파워PC에 대한 프로그램을 빌드하는 것 만큼 간단합니다. 이 방법은 [[Distcc/Cross-Compiling/ko|DistCC 크로스 컴파일 안내서]] 에 있습니다.

== Using Distcc to Bootstrap ==

=== 1단계: 포티지 설정 ===

젠투리눅스 LiveCD가 들어간 새 컴퓨터를 부팅하고 부트스트랩 부분까지 [http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?part=1 설치 과정]을 따라하십시오(부트스트랩에 대한 더 많은 정보를 얻고자 하신다면 [http://www.gentoo.org//doc/en/faq.xml#stage12 젠투 FAQ]를 보십시오). 다음 distcc를 사용하도록 포티지를 설정하십시오: 

{{RootCmd|nano -w /etc/portage/make.conf|output=<pre>
FEATURES="distcc"
MAKEOPTS="-jN"
</pre>
}}

{{RootCmd|export PATH{{=}}"/usr/lib/ccache/bin:/usr/lib/distcc/bin:${PATH}"}}

=== 2단계: distcc 가져오기 ===

distcc를 설치하십시오: 

{{RootCmd|USE{{=}}'-*' emerge --nodeps sys-devel/distcc}}

=== 3단계: distcc 설정 ===

distcc를 설정하려면 <code>distcc-config --install</code>을 실행하십시오. <code>host*</code>를 참여하는 distcc 노드의 IP주소 또는 호스트 이름으로 바꾸십시오.

{{RootCmd|/usr/bin/distcc-config --set-hosts "localhost host1 host2 host3 ..."}}

이제 distcc 부트스트랩을 설정했습니다! 공식 설치 설명서 내용에 따라 계속 진행하시고, <code>emerge system</code>을 실행한 후에 distcc를 다시 이머지 하는 것을 ''잊지 마십시오''. 이 절차는 원한 바대로 설치한 그대로의 모든 의존성을 확인하는 절차입니다. 

{{Note/ko|부트스트랩과 <code>emerge system</code>을 처리하는 동안 distcc를 사용하지 않는 것으로 나타납니다. 일부 ebuild가 distcc와 제대로 동작하지 않는 것으로 보이기 때문에, 일부러 distcc를 사용하지 않습니다.}}

== 문제 해결 ==

=== 일부 패키지가 distcc를 활용할 수 없습니다 ===

다양한 패키지를 emerge 하면서, 패키지중 일부를 분산처리하지 않는다는 점(그리고 병렬로 빌드하지 않는다는 점)을 주의하셔야 합니다. 이것은 패키지의 Makefile이 병렬 처리를 지원하지 않거나 ebuild의 관리자가 알려진 문제점때문에 확실하게 병렬 처리를 사용하지 않도록 했기 때문입니다. 

때때로 distcc는 컴파일에 실패하는 요인이 되기도 합니다. 만약 이런 일이 여러분들에게 일어난다면, 저희에게 [http://bugs.gentoo.org 알려주십시오].

=== 혼합 GCC 버전 ===

If you have different GCC versions on your hosts, there will likely be very weird problems. The solution is to make certain all hosts have the same GCC version. 

Recent Portage updates have made Portage use <code>${CHOST}-gcc</code> instead of <code>gcc</code> . This means that if you're mixing i686 machines with other types (i386, i586) you will run into problems. A workaround for this may be to <code>export CC='gcc' CXX='c++'</code> or to put it in {{Path|/etc/portage/make.conf}} . 

{{Important/ko|이 설정 행위는 명백하게 포티지의 몇가지 동작을 재정의하는 것이며 나중에 이상한 결과가 나타날지도 모릅니다. 오로지 CHOST 값을 섞어 쓸 때에만 설정하십시오.}}

=== -march=native ===

Starting with GCC 4.3.0, the compiler supports the <code>-march=native</code> switch which turns on CPU autodetection and optimizations that are worth being enabled on the processor the GCC is running at. This is a problem with <code>distcc</code> as it allows mixing of code optimized for different processors (like AMD Athlon and Intel Pentium). ''Don't'' use <code>-march=native</code> or <code>-mtune=native</code> in your <code>CFLAGS</code> or <code>CXXFLAGS</code> when compiling with <code>distcc</code> .

To know the flags that GCC would enable when called with <code>-march=native</code>, execute the following:

{{Cmd|gcc -march{{=}}native -E -v - &lt;/dev/null 2&gt;&amp;1 {{!}} grep cc1|output=<pre>
/usr/libexec/gcc/x86_64-pc-linux-gnu/4.7.3/cc1 -E -quiet -v - -march=corei7-avx \
  -mcx16 -msahf -mno-movbe -mno-aes -mpclmul -mpopcnt -mno-abm -mno-lwp -mno-fma \
  -mno-fma4 -mno-xop -mno-bmi -mno-bmi2 -mno-tbm -mavx -mno-avx2 -msse4.2 -msse4.1 \
  -mno-lzcnt -mno-rdrnd -mno-f16c -mno-fsgsbase --param l1-cache-size=32 \
  --param l1-cache-line-size=64 --param l2-cache-size=6144 -mtune=corei7-avx
</pre>}}

== Distcc Extras ==

=== distcc 감시 프로그램 === 

Distcc ships with two monitors. The text-based one is always built and is called <code>distccmon-text</code>. Running it for the first time can be a bit confusing, but it is really quite easy to use. If you run the program with no parameter it will run once. However, if you pass it a number it will update every N seconds, where N is the argument you passed. 

The other monitor is only enabled through the <code>gtk</code> <code>USE</code> flag.  This one is GTK+ based, runs in an X environment and it is quite lovely.  For Gentoo, the GUI monitor has been called <code>distccmon-gui</code> for less confusion.  Elsewhere it may be referred to as <code>distccmon-gnome</code>.

{{RootCmd|distccmon-text N}}

또는 <code>distccmon-gui</code>를 실행하십시오:

{{RootCmd|distccmon-gui}}

포티지의 distcc 사용 상태를 감시한다면 다음 명령을 사용할 수 있습니다:{{RootCmd|DISTCC_DIR{{=}}"/var/tmp/portage/.distcc/" distccmon-text N
|DISTCC_DIR{{=}}"/var/tmp/portage/.distcc/" distccmon-gui}}

{{Important/ko|distcc 디렉터리가 어디에도 없다면, DISTCC_DIR 변수를 적절하게 바꾸십시오.}}

== 감사문 ==

이 안내서에 제공한 노고에 대해 다음 작성자와 편집자분들께 감사의 말을 전하고자 합니다:

* Lisa Seelye
* Mike Frysinger
* Erwin
* Sven Vermeulen
* Lars Weiler
* Tiemo Kieft
* nightmorph
