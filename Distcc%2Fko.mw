<languages />

{{Metadata|abstract=Distcc는 네트워크를 통해 호스트가 참여하여 분산 컴파일 작업을 수행하도록 설계한 프로그램입니다.  distccd 서버와 distcc 클라이언트로 구성되어 있습니다. Distcc는 ccache, Portage, 약간의 설정 과정을 거치는 automake로 눈에 보이지 않도록 처리할 수 있습니다.}}

{{InfoBox stack
|{{InfoBox homepage|https://code.google.com/p/distcc/|header=true}}
|{{InfoBox wikipedia}}
|{{InfoBox github|distcc/distcc}}
}}

[http://code.google.com/p/distcc/ distcc] 는 네트워크를 통해 호스트가 참여하여 분산 컴파일 작업을 수행하도록 설계한 프로그램입니다.  {{c|distccd}} 서버와 {{c|distcc}} 클라이언트로 구성되어 있습니다. distcc는 [http://ccache.samba.org ccache], [[Portage|포티지]]<sup style="color:#ff0077">en</sup>, 약간의 설정 과정을 거치는 automake로 감쪽같이 처리할 수 있습니다. 

젠투 설치 초기에 도움을 받으려 {{c|distcc}}를 사용한다면, [[#.EB.B6.80.ED.8A.B8.EC.8A.A4.ED.8A.B8.EB.9E.A9_.EA.B3.BC.EC.A0.95.EC.97.90_distcc_.EC.82.AC.EC.9A.A9|부트스트랩 과정에 distcc 사용]] 섹션을 읽어보십시오. 

== 설치 ==

{{c|distcc}}를 설정하기 전, 우선 모든 호스트에 대한 {{Package|sys-devel/distcc}} 꾸러미 설치 과정을 살펴보겠습니다.

=== 모든 호스트에 대한 의존성 ===

{{c|distcc}}를 사용하려면 네트워크상의 모든 컴퓨터에 같은 gcc 버전이 있어야 합니다. 예를 들어 3.3.x(x는 바뀔 수 있음)는 괜찮지만 3.3.x와 3.2.x를 같이 사용하면, 컴파일 오류 또는 실행시간 오류가 나타날지도 모릅니다. 

=== 프로그램 설치 ===

distcc에는 컴파일 작업을 보내는 컴퓨터의 작업을 지켜볼 때 사용하는 그래픽 감시 프로그램이 있습니다. 이 감시 프로그램은 <code>gtk</code> USE 플래그를 설정했을 때 쓸 수 있습니다.

USE 플래그 설정 후, {{Package|sys-devel/distcc}} 꾸러미를 설치하십시오:

{{Emerge|sys-devel/distcc}}

{{Important/ko|모든 컴퓨터에 {{Package|sys-devel/distcc}}를 설치하십시오.}}

=== distcc 데몬 자동 시작 ===

{{c|distccd}}를 자동으로 시작하려면 사용하는 초기화 시스템에 따라 다음 절차를 진행하십시오.

==== OpenRC 사용 ====

Edit {{Path|/etc/conf.d/distccd}} and make sure to set the <code>--allow</code> directive to allow only trusted clients. For added security, use the <code>--listen</code> directive to tell the {{c|distccd}} daemon what IP to listen on (for multi-homed systems). More information on {{c|distcc}} security can be found at [http://distcc.googlecode.com/svn/trunk/doc/web/security.html Distcc security notes].

다음 예제에서는 <code>192.168.0.4</code>와 <code>192.168.0.5</code> 주소에서 동작하는 distcc 클라언트에서 근접 네트워크 영역에서 동작하는 {{c|distccd}} 서버에 접속할 수 있도록합니다:

{{FileBox|filename=/etc/conf.d/distccd|title=distccd에 연결하는 개별 클라이언트 허용|lang=bash|1=
DISTCCD_OPTS="--port 3632 --log-level notice --log-file /var/log/distccd.log -N 15 --allow 192.168.0.4 --allow 192.168.0.5"
}}

{{Important/ko|<code>--allow</code>와 <code>--listen</code> 지시자의 사용은 중요합니다. 더 많은 내용은 {{c|distccd}} 맨 페이지나 상단의 보안 문서를 읽어보십시오.}}

이제 {{c|distccd}} 데몬을 모든 참여 머신에서 시작하십시오: 

{{RootCmd|rc-update add distccd default
|rc-service distccd start}}

==== systemd 사용 ====

{{Path|/etc/systemd/system/distccd.service.d/00gentoo.conf}} 설정 파일을 편집하고 CIDR형식의 주소로 허용 클라이언트를 추가하십시오. 예제는 다음과 같습니다:

{{FileBox|filename=/etc/systemd/system/distccd.service.d/00gentoo.conf|title=ALLOWED_SERVERS 설정|lang=bash|1=
Environment="ALLOWED_SERVERS=192.168.1.0/24"
}}

{{Note| The name "ALLOWED_SERVERS" here is rather confusing as it refers to the clients that are allowed to connect to the local distccd server. Nevertheless, it is this variable which is used in the distccd service as value for the --allow option – see {{Path|/usr/lib/systemd/system/distccd.service.}}}}

설정을 바꾸었다면 유닛 파일을 다시 읽으십시오:

{{RootCmd|systemctl daemon-reload}}

{{c|distccd}} 자동 시작을 활성화한 후 서비스를 시작하십시오:

{{RootCmd|systemctl enable distccd
|systemctl start distccd}}

== 설정 ==

Let's now look into the configuration of {{c|distcc}}.

=== 참여 호스트 지정 ===

Use the {{c|distcc-config}} command to set the list of hosts. 

The following is an example list of host definitions. In most cases, variants of lines 1 and 2 suffice. The latter uses the <code>/limit</code> syntax to inform {{c|distcc}} about the maximum amount of jobs to be launched on this node. More information about the syntax used in lines 3 and 4 can be found in the [http://distcc.googlecode.com/svn/trunk/doc/web/man/distcc_1.html distcc manual page].

{{CodeBox|title=호스트 정의 예제|1=
192.168.0.1          192.168.0.2                       192.168.0.3
192.168.0.1/2        192.168.0.2                       192.168.0.3/10
192.168.0.1:4000/2   192.168.0.2/1                     192.168.0.3:3632/4
@192.168.0.1         @192.168.0.2:/usr/bin/distccd     192.168.0.3
}}

There are also several other methods of setting up hosts.  See the {{c|distcc}} man page ({{c|man distcc}}) for more details.

만약 로컬 머신에서도 컴파일해야한다면 호스트 목록에 <code>localhost</code>를 추가해야 합니다. 반대로 로컬 머신을 컴파일할 때 활용하지 않으면 호스트 목록에서 생략해야 합니다. 느린 장치에서 로컬호스트를 사용하는 것은 실제로 컴파일을 느리게 만듭니다. 성능을 위해 설정을 시험하여 확인하십시오.

Let's configure {{c|distcc}} to use the hosts mentioned on the first line in the example:

{{RootCmd|/usr/bin/distcc-config --set-hosts "192.168.0.1 192.168.0.2 192.168.0.3"}}

=== 포티지와 distcc 사용 ===

Setting up [[Portage]] to use {{c|distcc}} is easy. It is a matter of enabling the {{c|distcc}} feature, and setting a decent value for the number of simultaneous build jobs (as {{c|distcc}} increases the amount of build resources).

Set the <var>MAKEOPTS</var> variable and <var>FEATURES</var> variable as shown below.

A common strategy is to
* set the value of <code>N</code> to ''twice'' the number of ''total'' (local + remote) CPU cores + 1, and
* set the value of <code>M</code> to the number of ''local'' CPU cores

The use of <code>-lM</code> in the <var>MAKEOPTS</var> variable will prevent spawning too many tasks when some of the {{c|distcc}} cluster hosts are unavailable (increasing the amount of simultaneous jobs on the other systems) or when an ebuild is configured to disallow remote builds (such as with gcc). This is accomplished by refusing to start additional jobs when the system load is at or above the value of <code>M</code>.

{{FileBox|filename=/etc/portage/make.conf|title=Setting MAKEOPTS and FEATURES|lang=bash|1=
# Replace N and M with the right value as calculated previously
MAKEOPTS="-jN -lM"
FEATURES="distcc distcc-pump"
}}

For instance, when there are two quad-core host PCs running {{c|distccd}} and the local PC has a dual core CPU, then the <var>MAKEOPTS</var> variable could look like this:

{{FileBox|filename=/etc/portage/make.conf|title=2대의 쿼드코어 칩 머신(호스트)과 1대의 듀얼 코어 PC(로컬) 에 대한 MAKEOPTS 예제|lang=bash|1=
# 2 remote hosts with 4 cores each = 8 cores remote
# 1 local host with 2 cores = 2 cores local
# total number of cores is 10, so N = 2*10+1 and M=2
MAKEOPTS="-j21 -l2"
}}

While editing the {{Path|make.conf}} file, make sure that it does not have <code>-march=native</code> in the <var>CFLAGS</var> or <var>CXXFLAGS</var> variables. {{c|distccd}} will not distribute work to other machines if <code>march</code> is set to <code>native</code>. The appropriate <code>-march=</code> value can be obtained by running the following command:

{{Cmd|gcc -v -E -x c -march{{=}}native -mtune{{=}}native - < /dev/null 2>&1 {{!}} grep cc1 {{!}} perl -pe 's/ -mno-\S+//g; s/^.* - //g;'}}

See [http://blogs.gentoo.org/mgorny/2014/06/23/inlining-marchnative-for-distcc/ Inlining <code>-march=native</code> for distcc] for more information.

=== automake와 distcc 사용 ===

This is, in some cases, easier than the Portage setup. All that is needed is to update the <var>PATH</var> variable to include {{Path|/usr/lib/distcc/bin/}} in front of the directory that contains {{c|gcc}} ({{Path|/usr/bin/}}). However, there is a caveat. If {{c|ccache}} is used, then put the {{c|distcc}} location after the {{c|ccache}} one: 

{{RootCmd|export PATH{{=}}"/usr/lib/ccache/bin:/usr/lib/distcc/bin:${PATH}"}}

Put this in the user's {{Path|~/.bashrc}} or equivalent file to have the <var>PATH</var> set every time the user logs in, or set it globally through an {{Path|/etc/env.d/}} file.

Instead of calling {{c|make}} alone, add in <code>-jN</code> (where <code>N</code> is an integer). The value of <code>N</code> depends on the network and the types of computers that are used to compile. A heuristic approach to the right value is given earlier in this article.

== 부트스트랩 과정에 distcc 사용 ==

Using {{c|distcc}} to bootstrap (i.e. build a working toolchain before installing the remainder of the system) requires some additional steps to take.

=== 1단계: 포티지 설정 ===

Boot the new box with a Gentoo Linux LiveCD and follow the [[Handbook:AMD64|installation instructions]], while keeping track of the instructions in the [[FAQ|Gentoo FAQ]] for information about bootstrapping. Then configure Portage to use {{c|distcc}}: 

{{FileBox|filename=/etc/portage/make.conf|title=포티지에서 distcc를 사용하도록 설정|lang=bash|1=
FEATURES="distcc"
MAKEOPTS="-jN"
}}

마찬가지로 설치 세션에서 <code>PATH</code> 변수를 업데이트하십시오:

{{RootCmd|export PATH{{=}}"/usr/lib/ccache/bin:/usr/lib/distcc/bin:${PATH}"}}

=== 2단계: distcc 가져오기 ===

{{Package|sys-devel/distcc}}를 설치하십시오: 

{{RootCmd|USE{{=}}'-*' emerge --nodeps sys-devel/distcc}}

=== 3단계: distcc 설정 ===

Run {{c|distcc-config --install}} to setup distcc; substitute the <code>host#</code> in the example with the IP addresses or hostnames of the participating nodes.

{{RootCmd|/usr/bin/distcc-config --set-hosts "localhost host1 host2 host3 ..."}}

Distcc is now set up to bootstrap! Continue with the proper installation instructions and do ''not'' forget to run {{c|emerge distcc}} after running {{c|emerge @system}}. This is to make sure that all of the necessary dependencies are installed. 

{{Note|During bootstrap and {{c|emerge @system}} {{c|distcc}} may not appear to be used. This is expected as some ebuilds do not work well with distcc, so they intentionally disable it.}}

== 추가 distcc 요소 ==

The {{c|distcc}} application has additional features and applications to support working in a {{c|distcc}} environment.

=== distcc 감시 프로그램 === 

distcc에는 두 가지 감시 프로그램이 들어있습니다. 항상 빌드하는 텍스트 기반 프로그램을 {{c|distccmon-text}}라고 합니다. 처음 실행하는게 약간 혼동스러울 수도 있지만, 사용 방법은 아주 쉽습니다. 프로그램을 아무런 매개 변수없이 실행하면 단 한번만 실행합니다. 하지만, 숫자를 전달하면 매 <code>N</code>초마다 업데이트 합니다. 여기에서 <code>N</code>은 여러분이 전달한 숫자 인자입니다.

{{Cmd|distccmon-text 10}}

다른 감시 유틸리티는 <code>gtk</code>를 USE 플래그로 설정했을 때만 실행할 수 있습니다. GTK+ 기반의 프로그램이며, X 환경에서 구동되고 정말 사랑스럽습니다 *-_-*. 젠투에서의 GUI 감시 프로그램은 혼동을 피하기 위해 {{c|distccmon-gui}}로 이름을 바꾸었습니다(보통 {{c|distccmon-gnome}}이라고 합니다).

{{Cmd|distccmon-gui}}

포티지의 {{c|distcc}} 사용 상태를 감시하려면:

{{RootCmd|DISTCC_DIR{{=}}"/var/tmp/portage/.distcc/" distccmon-text 10
|DISTCC_DIR{{=}}"/var/tmp/portage/.distcc/" distccmon-gui}}

{{Important|If the distcc directory is elsewhere, change the <var>DISTCC_DIR</var> variable accordingly.}}

<var>DISTCC_DIR</var> 환경 변수를 설정하는 꼼수를 진행하십시오:

{{RootCmd|echo 'DISTCC_DIR{{=}}"/var/tmp/portage/.distcc/"' >> /etc/env.d/02distcc}}

이제 환경을 업데이트하십시오:

{{RootCmd|env-update
|source /etc/profile}}

마지막으로, GUI 프로그램을 시작하십시오:

{{RootCmd|distccmon-gui}}

=== distcc 통신 용도로 ssh 사용 ===

ssh를 통한 distcc 설정에 몇가지 함정이 있습니다. 먼저 암호 설정을 뺀 상태의 SSH 키 쌍을 만들어야 합니다. {{c|portage}} 사용자가 포티지로 프로그램을 컴파일 함을 잊지 마십시오. {{c|portage}} 사용자 폴더는 {{Path|/var/tmp/portage/}}이며 ssh 키를 {{Path|/var/tmp/portage/.ssh/}}에 저장해야 함을 의미합니다.

{{RootCmd|ssh-keygen -b 2048 -t rsa -f /var/tmp/portage/.ssh/id_rsa}}

두번째로, SSH 설정 파일에 각 호스트에 대한 섹션을 만드십시오:

{{FileBox|filename=/var/tmp/portage/.ssh/config|title=호스트 단위 섹션 추가|1=
Host test1
    HostName 123.456.789.1
    Port 1234
    User UserName
 
Host test2
    HostName 123.456.789.2
    Port 1234
    User UserName
}}

각 컴파일 노드에 공개키를 보내십시오:

{{RootCmd|ssh-copy-id -i /var/tmp/portage/.ssh/id_rsa.pub UserName@CompilationNode}}

또한 각 호스트에 {{Path|known_hosts}} 파일이 있는지 확인하십시오:

{{RootCmd|ssh-keyscan -t rsa <compilation-node-1> <compilation-node-2> [...] > /var/tmp/portage/.ssh/known_hosts}}

다음과 같이 소유권을 수정하십시오:

{{RootCmd|chown -R portage:portage /var/tmp/portage/.ssh/}}

<code>test1</code>과 <code>test2</code> 호스트를 설정하려면 다음 명령을 실행하십시오:

{{RootCmd|/usr/bin/distcc-config --set-hosts "@test1 @test2"}}

<code>@</code> 기호는 distcc용 ssh 호스트를 지정할 때 사용하는 기호임을 참고하십시오.

마지막으로, 어떤 SSH 바이너리를 활용할지  {{c|distcc}}에 알리십시오:

{{FileBox|filename=/etc/portage/make.conf|lang=bash|1=
DISTCC_SSH="ssh"
}}

{{c|distcc}}가 SSH로 통신하면, 호스트에서 {{Path|distccd}} 초기화 스크립트를 실행할 필요가 없습니다.

== 문제 해결 ==

<!-- Consider moving this section to a separate subpage if it becomes too large -->

{{c|distcc}}를 사용하는 동안 문제가 발한다면, 이 부분이 문제를 해결하는데 도움이 될 것입니다.

=== ERROR: failed to open {{Path|/var/log/distccd.log}} ===

<!-- To be removed when the bug is resolved and the fixed package is stable -->

2015년 1월 22일 이머징 과정에서 {{Path|/var/log/}}에 올바른 {{Path|distccd.log}} 파일을 만드는 과정에 실패했습니다. distcc 3.1-r8 버전에만 영향을 받는 것 같습니다. 이 버그({{Bug|477630}} 참고)는 (현재 2015년 11월 14일에도 여전히)수정중입니다. 직접 로그 파일을 만들고, 적당한 소유권을 부여한 다음 distccd 데몬을 다시 시작하면 문제를 피해갈 수 있습니다:

{{RootCmd
|mkdir -p /var/log/distcc
|touch /var/log/distcc/distccd.log
|chown distcc:daemon /var/log/distcc/distccd.log
}}

다음, {{Path|/etc/conf.d/distccd}}의 {{c|distccd}} 설정 파일 경로인 {{Path|/var/log}} 디렉터리를 이전 단계에서 만든 {{Path|distcc}} 디렉터리로 업데이트하십시오:

{{FileBox|filename=/etc/conf.d/distccd|title=기록 경로 업데이트|lang=bash|1=
DISTCCD_OPTS="--port 3632 --log-level notice --log-file /var/log/distcc/distccd.log -N 15 
}}

마지막으로 distccd 서비스를 다시 시작하십시오:

{{RootCmd|/etc/init.d/distccd restart}}

=== 일부 꾸러미가 distcc를 활용하지 않음 ===

다양한 꾸러미를 emerge 할 때, 꾸러미 일부를 분산처리하지 않는다는 점(그리고 병렬로 빌드하지 않는다는 점)을 주의하셔야 합니다. 이것은 꾸러미의 {{Path|Makefile}}이 병렬 처리를 지원하지 않거나 ebuild의 관리자가 알려진 문제점때문에 확실하게 병렬 처리를 사용하지 않도록 했기 때문입니다. 

때론 {{c|distcc}}가 컴파일의 실패 요인이기도 합니다. 이런 일이 일어난다면, 저희에게 [http://bugs.gentoo.org 알려주십시오].

=== 혼합 GCC 버전 ===

각각의 환경에서 다른 GCC 버전을 사용하면, 이상한 문제가 생길 수 있습니다. 해결 방법은 모든 호스트의 GCC 버전을 같게 하는 것입니다. 

최근 포티지에서는 <code>gcc</code> 대신 <code>${CHOST}-gcc</code>(마이너스 gcc)를 사용하도록 업데이트 했습니다.  이는 i686 머신을 다른 형식(i386, i586)의 머신과 혼용해서 사용한다면, 빌드한 결과에 문제가 생김을 의미합니다:

{{RootCmd|export CC{{=}}'gcc' CXX{{=}}'c++'}}

위 명령처럼 {{Path|/etc/portage/make.conf}} 에  <var>CC</var> 변수와 <var>CXX</var> 변수 값을 넣을 수 있습니다.

{{Important/ko|이 설정 행위는 명백하게 포티지의 몇가지 동작을 재정의하는 것이며 나중에 이상한 결과가 나타날지도 모릅니다. 오로지 <var>CHOST</var> 값을 섞어써야 할 때에만 설정하십시오.}}

=== -march=native ===

GCC 4.3.0부터, GCC가 동작하는 프로세서에서 CPU 자동 감지 및 최적화를 활성화하는 <code>-march=native</code> 스위치를 지원합니다. {{c|distcc}}를 사용할 때, 다른 프로세서에 대한 최적화 코드를 뒤섞는 일이 발생하므로 문제가 생길 수 있습니다. 예를 들어, AMD 애슬론 프로세서 시스템에서 {{c|distcc}}에 <code>-march=native</code> 옵션을 넣어 실행하고 인텔 펜티엄 프로세서가 붙은 ''다른'' 시스템에서 똑같이 실행하면 두 시스템에서 코드가 뒤섞입니다.

다음 경고에 주의하십시오:

{{Warning/ko|{{c|distcc}}로 컴파일할 때, {{Path|make.conf}}의 <var>CFLAGS</var>변수 또는 <var>CXXFLAGS</var>변수에서 <code>-march{{=}}native</code> 또는 <code>-mtune{{=}}native</code>값을 사용하지 ''마십시오''.}}

GCC를 <code>-march=native</code>로 호출할 때 사용하는 플래그를 알아보려면 다음 명령을 실행하십시오:

{{Cmd|gcc -march{{=}}native -E -v - &lt;/dev/null 2&gt;&amp;1 {{!}} grep cc1|output=<pre>
/usr/libexec/gcc/x86_64-pc-linux-gnu/4.7.3/cc1 -E -quiet -v - -march=corei7-avx \
  -mcx16 -msahf -mno-movbe -mno-aes -mpclmul -mpopcnt -mno-abm -mno-lwp -mno-fma \
  -mno-fma4 -mno-xop -mno-bmi -mno-bmi2 -mno-tbm -mavx -mno-avx2 -msse4.2 -msse4.1 \
  -mno-lzcnt -mno-rdrnd -mno-f16c -mno-fsgsbase --param l1-cache-size=32 \
  --param l1-cache-line-size=64 --param l2-cache-size=6144 -mtune=corei7-avx
</pre>}}

== 추가 참조 ==

* [[Distcc/Cross-Compiling/ko|DistCC 크로스 컴파일 안내서]]에서는 어떤 아키텍처에서 다른 아키텍처를 대상으로 {{c|distcc}}를 통해 프로그램을 빌드하는 방법을 설명합니다. 이 과정은 Athlon (i686)에서 K6-2 (i586) 용 프로그램을 빌드하거나 SPARC에서 PowerPC용 프로그램을 빌드하는 것 만큼 간단할 수 있습니다.

== 외부 자료 ==

* [http://blogs.gentoo.org/mgorny/2014/06/23/inlining-marchnative-for-distcc/ distcc에 맞게 <code>-march=native</code> 옵션 넣기]
* [https://code.google.com/p/distcc/ distcc 홈페이지]

{{Migrated|originalauthors=Lisa Seelye, Mike Frysinger, Erwin, Sven Vermeulen, Lars Weiler, Tiemo Kieft and nightmorph}}
