Guest daemon:
In short, the guest daemon fetches the first package to build from the build
list and builds it.

Portage:
We copy some of the portage files and patch them. First, we patch so we can
pass build_dict and session so it can be used later on in the calculating
dependencies process. We make a wrapper for the function backtrack_depgraph 
in the code so we can add USE flags or make the needed changes. 
The scheduler is patched so we can pass package, trees and settings to the log
function add_buildlog_main. Emerge --info is patched so we can get a list from
instead of displaying to the screen. We copy the main from Repoman and set it up
so we can use it and get the output. The last thing to patch is so we can get
unresolvable from action_depclean.

Main loop:
First read the config file and set up the connection to the db.  Then it looks
at the job list to see if we have any work to do for example update configs.
When that is done, it checks the profile for errors.  Next we check if the
host needs to do any work that affects the guest like update the gentoo tree
or database. Finally, we check the build list for building packages.

Build job:
We look in the database for the next package to build with the Waiting status.
This is done in the get_packages_to_build method. Then we configure settings
and portdb so we can call make_build_list to get needed use flags changes and
check manifest for errors. If all is okay, we call build_process. In that
function we add any use changes we need to package.use. Next we unmerge the
package if it exists already. Then set up args and call emerge_main. When we
call the dependencies process it use our wrapper of the function
build_mydepgraph. In build_mydepgraph we call backtrack_depgraph multiple
times depend on the success of the first time when we check if we need to do
anything with the deps. When the package build completes successfully or
fails, we call our log function add_buildlog_main. When emerge is done check
if we need to run depclean. Clean the package.* files and return to the main
loop.

Build log:
We read the config file and set up the connection to the db.  If the pkg type
is binary we don't log it else we try to get the package info from the db. We
call get_buildlog_info to search the log and run repoman on the package. In
the search_buildlog, we load the search regex from the db which is anything
that re.search supports and is run line by line against the file.  When finish
we search for any QA or repoman error. Next, we hash the summary so we don't
repost the same log. Lastly, get emerge --info and save everything to the DB.
