<languages />


{{Metadata|abstract=이 안내서에서는 distcc에서의 다른 프로세서 아키텍처간 크로스컴파일 설정 방법을 보여줍니다.}}

이 안내서에서는 distcc에서의 다른 프로세서 아키텍처간 크로스컴파일 설정 방법을 보여줍니다.

== distcc로 크로스컴파일 ==

== 도입부 ==

<code>distcc</code>는 네트워크에 연결한 다양한 컴퓨터에게 덩치가 큰 프로그램을 컴파일하도록 일감을 공유하는 도구입니다. 같은 프로세서 아키텍처로 만들어진 같은 툴체인을 네트워크에 연결한 여러대의 머신이 사용하면 <code>distcc</code> 설정을 따로 할 필요가 없습니다. 다만 각기 다른 아키텍처를 지닌 다른 컴퓨터로 컴파일해야 한다면 어떻게 해야 할까요? 이 안내서에서는 각기 다른 아키텍처에 대해 <code>distcc</code>로 컴파일하는 방법을 알려드리도록 하겠습니다. 

=== 필요한 유틸리티 이머지 ===

먼저 컴파일 과정에 관여할 모든 머신에 <code>crossdev</code>를 이머지해야 합니다. <code>crossdev</code>는 크로스 아키텍처 툴체틴을 쉽게 빌드할 수 있게 만든 툴입니다. 초기에 Joshua Kinard가 작성한 프로그램을 Mike Frysinger가 재작성했습니다. 사용 방법은 상당히 쉽습니다. <code>crossdev -t sparc</code>라고 명령을 실행하면 스파크 아키텍처를 대상으로 하는 크로스 툴체인을 만듭니다. 여기에 binutils, gcc, glibc, linux-headers가 들어갑니다. 도움이 더 필요하다면 <code>crossdev --help</code>를 실행해보십시오. 확실히 말하자면 모든 도우미 머신에 적당한 크로스 툴체인을 이머지해야 합니다. 

그 다음, 컴파일 과정에 관여하는 모든 머신에  <code>distcc</code>를 이머지해야 합니다. 이 과정에서는 머신이 이머지를 실행하게끔해서 크로스 컴파일러로 무장할 수 있도록 합니다. <code>distcc</code> 설정 및 사용법에 대해 더 많이 알아보고 싶다면 [http://www.gentoo.org//doc/en/distcc.xml 젠투 distcc 문서]를 살펴보십시오.

=== 아키텍처별 참고 ===

==== 인텔 x86 하위 아키텍처 ====

If you are cross-compiling between different subarchitectures for Intel x86 (e.g. i586 and i686), you must still build a full cross-toolchain for the desired CHOST, or else the compilation will fail. This is because i586 and i686 are actually different CHOSTs, despite the fact that they are both considered "x86." Please keep this in mind when you build your cross-toolchains. For example, if the target box is i586, this means that you must build i586 cross-toolchains on your i686 helper boxes. 

==== 스파크 ====

<code>crossdev -t sparc</code>를 실행하면 다음 오류중 하나로 실패합니다:

{{Code|crossdev -t sparc를 실행할 때 나타나는 오류|<pre>
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
</pre>}}

여기서 문제가 있다면 다음 명령을 대신 사용하십시오:

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== 올바르게 크로스컴파일 하도록 distcc 설정 ===

In the default distcc setup, cross-compiling will ''not'' work properly. The problem is that many builds just call <code>gcc</code> instead of the full compiler name (e.g. <code>sparc-unknown-linux-gnu-gcc</code> ). When this compile gets distributed to a distcc helper box, the native compiler gets called instead of your shiny new cross-compiler. 

Fortunately, there is a workaround for this little problem. All it takes is a wrapper script and a few symlinks on the box that will be running <code>emerge</code> . I'll use my Sparc box as an example. Wherever you see <code>sparc-unknown-linux-gnu</code> below, you will want to insert your own CHOST ( <code>x86_64-pc-linux-gnu</code> for an AMD64 box, for example). When you first emerge distcc, the {{Path|/usr/lib/distcc/bin}} directory looks like this: 

{{Note|The following instructions are to be performed only on the box running the emerge. Do not perform these steps on the helper boxes.}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

여러분이 처리하려는 명령입니다: 

{{RootCmd|rm c++ g++ gcc cc}}

Next, we'll create the new script on this box. Fire up your favorite editor and create a file with the following text in it, then save it as {{Path|sparc-unknown-linux-gnu-wrapper}} . Remember to change the CHOST (in this case, <code>sparc-unknown-linux-gnu</code> ) to the actual CHOST of the box that will be running the emerge. 

{{Code|새 래퍼 스크립트|<pre>
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
</pre>
}}

다음 실행 스크립트를 만들고 적당한 심볼릭 링크를 만들도록 하겠습니다: 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

끝났다면 {{Path|/usr/lib/distcc/bin}}은 다음과 같은 모습을 띠게 됩니다: 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

축하합니다. 이제 (원하는 대로) 동작하도록 cross-distcc를 설정했습니다. 

== 동작 원리 ==

When <code>distcc</code> is called, it checks to see what it was called as (e.g. <code>i686-pc-linux-gnu-gcc</code> , <code>sparc-unknown-linux-gnu-g++</code> , etc.) When distcc then distributes the compile to a helper box, it passes along the name it was called as. The distcc daemon on the other helper box then looks for a binary with that same name. If it sees just <code>gcc</code> , it will look for <code>gcc</code> , which is likely to be the native compiler on the helper box, if it is not the same architecture as the box running <code>emerge</code> . When the ''full'' name of the compiler is sent (e.g. <code>sparc-unknown-linux-gnu-gcc</code> ), there is no confusion. 

== 감사문 ==

이 안내서에 제공한 노고에 대해 다음 작성자와 편집자분들께 감사의 말을 전하고자 합니다:

* Andrew Gaffney
* Joshua Saddler
