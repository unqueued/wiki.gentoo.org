<languages />


{{Metadata|abstract=이 안내서에서는 distcc에서의 다른 프로세서 아키텍처간 크로스컴파일 설정 방법을 보여줍니다.}}

이 안내서에서는 distcc에서의 다른 프로세서 아키텍처간 크로스컴파일 설정 방법을 보여줍니다.

== distcc로 크로스컴파일 ==

== 도입부 ==

{{c|distcc}}는 네트워크에 연결한 다양한 컴퓨터에게 덩치가 큰 프로그램을 컴파일하도록 일감을 공유하는 도구입니다. 같은 프로세서 아키텍처로 만들어진 같은 툴체인을 네트워크에 연결한 여러대의 머신이 사용하면 {{c|distcc}} 설정을 따로 할 필요가 없습니다. 

'''이 안내서는 다양한 아키텍처를 대상으로 컴파일 하도록 distcc를 설정하는 방법의 절차를 담고 있습니다.''' 

=== 필요한 유틸리티 이머지 ===

먼저 컴파일 과정에 관여할 모든 머신에 {{c|crossdev}}를 이머지해야 합니다. {{c|crossdev}}는 크로스 아키텍처 툴체인을 쉽게 빌드할 수 있게 만든 툴입니다. 사용 방법은 상당히 간단합니다. {{c|crossdev -t sparc}} 명령을 실행하면 스파크 아키텍처를 대상으로 하는 크로스 툴체인을 만듭니다. 여기에 binutils, gcc, glibc, linux-headers가 들어갑니다. 

보조 머신에 적당한 크로스 툴체인을 이머지해야합니다. 도움이 필요하면 {{c|crossdev --help}}를 실행하십시오.

크로스 툴체인을 최상의 상태로 만들려면 도우미 머신에 빌드할 정확한 버전의 크로스 개발 꾸러미를 만들 스크립트를 마련했습니다(스크립트는 대상 머신에서 실행합니다).

{{CodeBox|title=교차 개발도구를 세밀하게 조절하는 스크립트|lang=bash|1=
#! /bin/bash
A="sys-devel/binutils" ; B=`equery l $A` ; BINUTILS_VER=`echo $B {{!}} cut -d- -f3-`
A=`/usr/bin/gcc-config -c` ; B=`echo $A {{!}} cut -d- -f5` ; GCC_VER=`equery l sys-devel/gcc {{!}} grep $B {{!}} cut -d- -f3-`
KERNEL_VER=`uname -r {{!}} sed s/-gentoo//`
A="sys-libs/glibc" ; B=`equery l $A` ; LIBC_VER=`echo $B {{!}} cut -d- -f3-`
echo "crossdev --b =$BINUTILS_VER --g =$GCC_VER --k =$KERNEL_VER --l =$LIBC_VER -t `uname -m`"
}}

그 다음, 컴파일 과정에 관여하는 모든 머신에  {{c|distcc}}를 이머지해야 합니다. 이 과정에서는 머신이 이머지를 실행하게끔해서 크로스 컴파일러로 무장할 수 있도록 합니다. {{c|distcc}} 설정 및 사용법에 대해 더 많이 알아보고 싶다면 [[Distcc/ko|젠투 distcc 문서]]를 살펴보십시오.

{{Note|Current versions of {{c|crossdev}} have a <code>-S</code> (<code>--stable</code>) flag for installing only stable versions of compiler tools.  (ie. {{c|crossdev -t i686-pc-linux-gnu --stable --ex-gcc --ex-gdb --portage --pretend}}). Without this option, {{c|crossdev}} installs the latest experimental compiler tools packages! 

When using this option, the above script is no longer needed, unless specific versions of package tools and/or headers have been unmasked.}}

=== 아키텍처별 참고 ===

{{Note|Obtain the architecture name by looking at the compile target's <var>CHOST</var> variable within {{Path|/etc/make.conf}}. When mangling the architecture name for the {{c|crossdev -t}} option, {{c|crossdev}} will merrily guess and install tools using the mangled architecture name for folder names within {{Path|/usr}} (ie. {{Path|/usr/i686-pc-linux-gnu/}}, {{Path|/usr/i686-linux-gnu/}}, ...). To resolve this, specify each mangled architecture/folder name to {{c|crossdev --clean}} for uninstalling, or manually remove the folders from the system.}}

==== 인텔 x86 하위 아키텍처 ====

If you are cross-compiling between different subarchitectures for Intel {{Keyword|x86}} (e.g. i586 and i686), you must still build a full cross-toolchain for the desired <var>CHOST</var>, or else the compilation will fail. This is because i586 and i686 are actually different CHOSTs, despite the fact that they are both considered "x86." Please keep this in mind when you build your cross-toolchains. For example, if the target box is i586, this means that you must build i586 cross-toolchains on your i686 helper boxes. 

==== 스파크 ====

Using {{c|crossdev -t sparc}} might fail with one of the following errors:

{{CodeBox|title=crossdev -t sparc를 실행할 때 나타나는 오류|1=
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
}}

여기서 문제가 있다면 다음 명령을 대신 사용하십시오:

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== 올바르게 크로스컴파일 하도록 distcc 설정 ===

기본 distcc 설정에는, 크로스 컴파일이 제대로 동작하지 "않습니다".이 문제는 완전한 컴파일러 이름(예:{{c|sparc-unknown-linux-gnu-gcc}}) 대신에 {{c|gcc}}를 호출하기 때문입니다. 부분부분 쪼갠 컴파일 작업물을 distcc 도우미 머신으로 보내면 새로 만든 윤기가 좔좔 흐르는 크로스 컴파일러가 아닌 자체 컴파일러를 호출합니다. 

다행스럽게도 다른 해결책이 있긴 합니다. {{c|emerge}}를 실행할 머신의 몇가지 심볼릭 링크와 래퍼 스크립트가 있습니다. 예로서 제가 가진 스팍 머신을 사용하도록 하겠습니다. <code>sparc-unknown-linux-gnu</code>를 아래서 보는 곳마다, (예를 들어 AMD64 머신에 대해 <code>x86_64-pc-linux-gnu</code>라고 하는 것처럼) 자체 <var>CHOST</var> 값을 넣으려 할 것입니다. distcc를 처음 emerge할 때, {{Path|/usr/lib/distcc/bin}} 디렉터리는 다음과 같은 모습을 띱니다: 

{{Note/ko|다음 절차는 emerge를 실행하는 머신에서만 수행합니다. 다른 도우미 머신에서 아래 과정을 밟지 마십시오.}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

여러분이 실행할 명령입니다: 

{{RootCmd|rm c++ g++ gcc cc}}

다음 이 머신에 새 스크립트를 만들겠습니다. 여러분 취향에 맞는 편집기를 여시고 다음 텍스트를 만들 파일에 넣은 다음에 {{Path|sparc-unknown-linux-gnu-wrapper}}라고 저장하십시오. 기억하셔야 할 것은 emerge를 실행할 머신의 <var>CHOST</var>가 값을 바꾸려는 <var>CHOST</var>(이 경우 <code>sparc-unknown-linux-gnu</code>)입니다. 

{{CodeBox|title=새 래퍼 스크립트|lang=bash|1=
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
}}

다음 실행 스크립트를 만들고 적당한 심볼릭 링크를 만들도록 하겠습니다: 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

끝났다면 {{Path|/usr/lib/distcc/bin}}은 다음과 같은 모양새를 띱니다: 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

다음 심볼릭 링크를 중복적용할 distcc 꾸러미를 업그레이드 하고 나서도 래퍼를 계속 존재하게 내버려 둘 지 확인하려 할 것입니다. 다음처럼 {{Path|/etc/portage/bashrc}} 파일을 편집하면 원하는대로 할 수 있습니다:

{{FileBox|filename=/etc/portage/bashrc|lang=bash|1=
case ${CATEGORY}/${PN} in
<pre>                 sys-devel/distcc | sys-devel/gcc)</pre>
			if [ "${EBUILD_PHASE}" == "postinst" ]; then
				/usr/local/sbin/distcc-fix &
			fi
		;;
esac
}}

이 파일을 만드십시오:

{{FileBox|filename=/usr/local/sbin/distcc-fix|lang=bash|1=
#!/bin/bash	                
 
sleep 20
# change TUPLE to match your machine
TUPLE="sparc-unknown-linux-gnu"
cd /usr/lib/distcc/bin
rm cc c++ gcc g++ ${TUPLE}-wrapper
echo '#!/bin/bash' > ${TUPLE}-wrapper
echo "exec ${TUPLE}-g\${0:\$[-2]}" "\"\$@\"" >> ${TUPLE}-wrapper
chmod 755 ${TUPLE}-wrapper
ln -s ${TUPLE}-wrapper cc
ln -s ${TUPLE}-wrapper c++
ln -s ${TUPLE}-wrapper gcc
ln -s ${TUPLE}-wrapper g++
}}

적당한 퍼미션을 부여하십시오:

{{RootCmd|chmod 755 /usr/local/sbin/distcc-fix}}

축하합니다. 이제 (원하는 대로) 동작하도록 cross-distcc를 설정했습니다.

== 동작 원리 ==

{{c|distcc}}를 호출하면, 어떤 머신(예:<code>i686-pc-linux-gnu-gcc</code>, <code>sparc-unknown-linux-gnu-g++</code>, 등)이 보조 머신을 호출했는지 찾고, distcc가 보조 머신에 컴파일 일감을 던지면, 호출한 이름에 따라 전달합니다. 다른 보조 머신의 distcc 데몬은 같은 이름의 바이너리를 찾습니다. {{c|gcc}}만을 찾는다면, 보조 머신의 자체 컴파일러 같은 {{c|gcc}}를 그냥 찾습니다. {{c|emerge}}를 실행하는 머신과 아키텍처가 다르다면 컴파일러 ''전체'' 이름을 보냈을 경우에 (예: <code>sparc-unknown-linux-gnu-gcc</code>) 혼동하지 않습니다.

=== Troubleshooting ===

This section covers a number of common problems when using {{c|distcc}} for cross-compiling.

==== Remote host distccd COMPILE ERRORS ====

When receiving the message <code>COMPILE ERRORS</code> within a remote host's {{Path|/var/log/distccd.log}} file, see the above notes concerning specifying the correct architecture name (ie. {{c|crossdev -t $TARGET}}).

Another solution is to uninstall and re-install {{c|crossdev}} compiler tools, using the {{c|crossdev --clean}} option, or ensuring {{Path|/usr/$TARGET}} no longer exists, and then completely reinstall the cross compiler.

It might also be wise to edit the remote host's {{Path|/usr/$TARGET/etc/portage/make.conf}}, and ensure the contents of the <var>CFLAGS</var> variable are similar on all computers or hosts performing compiler operations.

==== Failed to exec $TARGET-uknown-linux-gnu-gcc: No such file or directory ====

The wrapper scripts might fail to execute, even with correct permissions:

{{CodeBox|title=Error message from wrapper|1=
distcc[6195] (dcc_execvp) ERROR: failed to exec i686-unknown-linux-gnu-gcc: No such file or directory)
}}

To resolve this, make sure to have the wrapper script created with the complete name of the architecture target:

{{Cmd|ls -alh /usr/lib/distcc/bin/c++|output=<pre>
/usr/lib/distcc/bin/c++ ->./i686-pc-linux-gnu-wrapper
</pre>}}


{{Migrated|originalauthors=Andrew Gaffney, Joshua Saddler}}
