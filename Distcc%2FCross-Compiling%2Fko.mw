<languages />


{{Metadata|abstract=이 안내서에서는 distcc에서의 다른 프로세서 아키텍처간 크로스컴파일 설정 방법을 보여줍니다.}}

이 안내서에서는 distcc에서의 다른 프로세서 아키텍처간 크로스컴파일 설정 방법을 보여줍니다.

== distcc로 크로스컴파일 ==

== 도입부 ==

<code>distcc</code>는 네트워크에 연결한 다양한 컴퓨터에게 덩치가 큰 프로그램을 컴파일하도록 일감을 공유하는 도구입니다. 같은 프로세서 아키텍처로 만들어진 같은 툴체인을 네트워크에 연결한 여러대의 머신이 사용하면 <code>distcc</code> 설정을 따로 할 필요가 없습니다. 다만 각기 다른 아키텍처를 지닌 다른 컴퓨터로 컴파일해야 한다면 어떻게 해야 할까요? 이 안내서에서는 각기 다른 아키텍처에 대해 <code>distcc</code>로 컴파일하는 방법을 알려드리도록 하겠습니다. 

=== 필요한 유틸리티 이머지 ===

먼저 컴파일 과정에 관여할 모든 머신에 <code>crossdev</code>를 이머지해야 합니다. <code>crossdev</code>는 크로스 아키텍처 툴체인을 쉽게 빌드할 수 있게 만든 툴입니다. 초기에 Joshua Kinard가 작성한 프로그램을 Mike Frysinger가 재작성했습니다. 사용 방법은 상당히 쉽습니다. <code>crossdev -t sparc</code>라고 명령을 실행하면 스파크 아키텍처를 대상으로 하는 크로스 툴체인을 만듭니다. 여기에 binutils, gcc, glibc, linux-headers가 들어갑니다. 도움이 더 필요하다면 <code>crossdev --help</code>를 실행해보십시오. 확실히 말하자면 모든 도우미 머신에 적당한 크로스 툴체인을 이머지해야 합니다. 

그 다음, 컴파일 과정에 관여하는 모든 머신에  <code>distcc</code>를 이머지해야 합니다. 이 과정에서는 머신이 이머지를 실행하게끔해서 크로스 컴파일러로 무장할 수 있도록 합니다. <code>distcc</code> 설정 및 사용법에 대해 더 많이 알아보고 싶다면 [http://www.gentoo.org//doc/en/distcc.xml 젠투 distcc 문서]를 살펴보십시오.

=== 아키텍처별 참고 ===

==== 인텔 x86 하위 아키텍처 ====

x86에 대해 각기 다른 하위 아키텍처(예: i586, i686)간에 크로스 컴파일링을 수행한다면, CHOST로 바라는대로의 완전한 크로스 툴체인을 만들어야 합니다. 그렇지 않으면 컴파일이 실패합니다. 왜냐하면 실제로는 i586과 i686 두 아키텍처를 "x86"으로 간주함에도 불구하고 CHOST값은 다릅니다. 크로스 툴 체인을 빌드할때 염두에 두시기 바랍니다. 예를 들어 대상 머신이 i586이라면 i686 도우미 머신에 i586 크로스 툴체인을 설치해야 함을 의미합니다. 

==== 스파크 ====

<code>crossdev -t sparc</code>를 실행하면 다음 오류중 하나로 실패합니다:

{{Code|crossdev -t sparc를 실행할 때 나타나는 오류|<pre>
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
</pre>}}

여기서 문제가 있다면 다음 명령을 대신 사용하십시오:

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== 올바르게 크로스컴파일 하도록 distcc 설정 ===

기본 distcc 설정에는, 크로스 컴파일이 제대로 동작하지 "않습니다".이 문제는 완전한 컴파일러 이름(예:<code>sparc-unknown-linux-gnu-gcc</code>) 대신에 <code>gcc</code>를 호출하기 때문입니다. 부분부분 쪼갠 컴파일 작업물을 distcc 도우미 머신으로 보내면 새로 만든 윤기가 좔좔 흐르는 크로스 컴파일러가 아닌 자체 컴파일러를 호출합니다. 

Fortunately, there is a workaround for this little problem. All it takes is a wrapper script and a few symlinks on the box that will be running <code>emerge</code> . I'll use my Sparc box as an example. Wherever you see <code>sparc-unknown-linux-gnu</code> below, you will want to insert your own CHOST ( <code>x86_64-pc-linux-gnu</code> for an AMD64 box, for example). When you first emerge distcc, the {{Path|/usr/lib/distcc/bin}} directory looks like this: 

{{Note|The following instructions are to be performed only on the box running the emerge. Do not perform these steps on the helper boxes.}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

여러분이 처리하려는 명령입니다: 

{{RootCmd|rm c++ g++ gcc cc}}

다음 이 머신에 새 스크립드를 만들겠습니다. 여러분 취향에 맞는 편집기를 여시고 다음 텍스트를 만들 파일에 넣은 다음에 {{Path|sparc-unknown-linux-gnu-wrapper}}라고 저장하십시오. 기억하셔야 할 것은 emerge를 실행할 머신의 CHOST가 값을 바꾸려는 CHOST(이 경우 <code>sparc-unknown-linux-gnu</code>)입니다. 

{{Code|새 래퍼 스크립트|<pre>
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
</pre>
}}

다음 실행 스크립트를 만들고 적당한 심볼릭 링크를 만들도록 하겠습니다: 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

끝났다면 {{Path|/usr/lib/distcc/bin}}은 다음과 같은 모습을 띱니다: 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

축하합니다. 이제 (원하는 대로) 동작하도록 cross-distcc를 설정했습니다. 

== 동작 원리 ==

<code>distcc</code>를 호출하면, 어떤 머신(예:<code>i686-pc-linux-gnu-gcc</code>, <code>sparc-unknown-linux-gnu-g++</code>, 등)이 도우미 머신을 호출했는지 찾고, distcc가 도우미 머신에 컴파일 일감을 던지면, 호출한 대로의 이름에 따라 전달합니다. 다른 도우미 머신의 distcc 데몬은 같은 이름의 바이너리를 찾습니다. <code>gcc</code>만을 찾는다면, 도우미 머신의 자체 컴파일러 같은 <code>gcc</code>를 그냥 찾습니다. <code>emerge</code>를 실행하는 머신과 아키텍처가 다르다면 컴파일러 ''전체'' 이름을 보냈을 경우 (예: <code>sparc-unknown-linux-gnu-gcc</code>) 혼동이 없습니다. 

== 감사문 ==

이 안내서에 제공한 노고에 대해 다음 작성자와 편집자분들께 감사의 말을 전하고자 합니다:

* Andrew Gaffney
* Joshua Saddler
