<languages />


{{Metadata|abstract=이 작은 안내서에서는 보안 통신용 도구인 GnuPG 기본 사용 방법을 알려드립니다.}}

이 작은 안내서에서는 보안 통신용 도구인 GnuPG 기본 사용 방법을 알려드립니다.

== 도입부 ==

=== 이 안내서에서 무얼 배울 수 있을까 ===

이 안내서에서는 독자 여러분이 공용키 암호화 기법, 암호화, 디지털 서명에 대해 잘 알고 있음을 가정합니다. 만약 그렇지 않다면 [[#doc_chap7]]이나 [http://www.gnupg.org/documentation/guides.html GnuPG 핸드북] 2장을 보시고 여기로 다시 돌아오십시오. 

이 안내서에서는 GnuPG 설치 방법, 키 쌍 만드는 방법, 키 모음에 키 추가하는 방법, 키 서버에 공용키를 제출하고 서명, 암호화, 검증, 보내고 받은 메시지 해독에 대한 모든 내용을 알려드립니다. 다른 사람들이 사용자 로컬 컴퓨터의 내용을 훔쳐보는걸 막기 위해 어떻게 파일을 암호화 하는지도 배웁니다. 

=== 필요한 프로그램 설치 ===

간단한 수준에서 필요한 일은 <code>emerge gnupg</code> 명령의 실행입니다. 오늘날 많은 프로그램이 gpg 같은 기능을 지원하기에, USE 변수에 ''crypt'' 플래그를 추가하는 것이 좋습니다. 전자메일 클라이언트로 gnupg를 사용하려면 pine ( <code>emerge pinepgp</code> ), mutt ( <code>emerge mutt</code> ), 모질라 썬더버드 ( <code>emerge thunderbird</code> ), 에볼루션 (에볼루션은 그놈의 마이크로소프트 아웃룩처럼 동작하는 프로그램입니다), KDE의 KMail을 사용하시면 됩니다. 

KDE를 사용한다면 <code>Kgpg</code>에 관심있을 것입니다. 이 조그마한 프로그램은 키 쌍을 만들고 ASCII 파일에서 키를 가져오며 가져온 키로 서명하고, 키를 내보내는 등 몇가지 기능을 가지고 있습니다. 

== 공용 키 모음에 키 만들고 추가하기 ==

=== 키 만들기 ===

키를 만들려면 그냥 <code>gpg --gen-key</code>를 실행하십시오. 처음에 실행할 때 몇가지 디렉터리를 만듭니다. 키를 만들려면 다시 실행하십시오: 

{{Cmd|gpg --gen-key|output=<pre>
gpg (GnuPG) 1.0.7; Copyright (C) 2002 Free Software Foundation, Inc.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions. See the file COPYING for details.
  
Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
   Your selection? 1
</pre>
}}

사용하려는 키의 형식을 선택할 수 있습니다. 대부분 사용자는 기본 RSA 와 RSA를 사용합니다. 그 다음은 키 크기 입니다. 크면 클수록 좋지만, DSA/ElGamal 키로는 2048바이트 이상 사용할 수 없습니다. 일반적으로 보통 이메일에 대해서는 2048 바이트면 충분합니다. 

경과 기간이 도래하면, 조금 작은 키가 낫지만, 대부분 사용자는 유효 기간을 없애거나 2~3년 정도 설정할 수 있습니다. 

{{Code|키 크기 지정|<pre>
RSA keypair will have 1024 bits.
RSA keys may be between 1024 and 4096 bits long.
    What keysize do you want? (2048) 2048
Requested keysize is 2048 bits       
Please specify how long the key should be valid.
         0 = key does not expire
 <n>= key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
 Key is valid for? (0) 0
Key does not expire at all
</pre>
}}

이제 여러분의 신상 정보를 입력할 떄입니다. 다른 사람에게 공용키를 보내려면 실제 전자 메일 주소를 사용해야 합니다. 

{{Code|사용자 정보 입력|<pre>
Is this correct (y/n)? y
                          
GnuPG needs to construct a user ID to identify your key.
  
Real name: John Doe
Email address: john@nowhere.someplace.flick
Comment: The Real John Doe
You selected this USER-ID:
"John Doe (The Real John Doe) <john@nowhere.someplace.flick>"
  
Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O 
You need a Passphrase to protect your secret key.    
  
Enter passphrase: 
</pre>
}}

이제 키 암호를 두 번 입력하십시오. 강력한 암호를 사용하는 것이 좋습니다. 누군가가 개인키를 얻거나 암호를 깨면, "여러분"이 서명한 메시지를 보낼 수 있으며, 다른 사람들은 "여러분"이 보낸 메일로 착각하게 할 수 있습니다. 

그러면, GnuPG가 키를 만듭니다. 마우스를 움직이거나 백그라운드에 mp3를 재생하면 임의 데이터를 만드는 처리 과정을 더욱 빨리 진행하는데 도움이 됩니다. 

=== 폐기 인증 만들기 ===

{{Important/ko|이 부분은 굉장히 중요하므로 ''지금 당장'' 해야합니다.}}

키를 만들고 나면 폐기 인증을 만들어야 합니다. 이 과정을 진행하면 여러분의 키에 대해 심각한 일이 벌어졌을 경우(누군가가 키 또는 암호를 가로챘을 때) 키 폐기를 할 수 있도록 합니다. 

{{Cmd|gpg --list-keys|output=<pre>
/home/humpback/.gnupg/pubring.gpg
---------------------------------
pub  1024D/75447B14 2002-12-08 John Doe (The Real John Doe) <john@nowhere.someplace.flick>
sub  2048g/96D6CDAD 2002-12-08
</pre>}}

{{Cmd|gpg --output revoke.asc --gen-revoke 75447B14|output=<pre>
sec  1024D/75447B14 2002-12-08   John Doe (The Real John Doe) <john@nowhere.someplace.flick>
  
Create a revocation certificate for this key? y
Please select the reason for the revocation:   
  0 = No reason specified
  1 = Key has been compromised
  2 = Key is superseded
  3 = Key is no longer used
  Q = Cancel
(Probably you want to select 1 here)
Your decision? 1
Enter an optional description; end it with an empty line:
> Someone cracked me and got my key and passphrase
>
Reason for revocation: Key has been compromised
Someone cracked me and got my key and passphrase
Is this okay? y
  
You need a passphrase to unlock the secret key for
user: "John Doe (The Real John Doe) <john@nowhere.someplace.flick>"
1024-bit DSA key, ID 75447B14, created 2002-12-08
  
ASCII armored output forced.
Revocation certificate created.
  
Please move it to a medium which you can hide away; if Mallory gets
access to this certificate he can use it to make your key unusable.
It is smart to print this certificate and store it away, just in case
your media become unreadable.  But have some caution:  The print system of
your machine might store the data and make it available to others!
</pre>
}}

<code>gpg --list-keys</code> 명령은 공용 키 모음의 키를 보여줍니다. 키 ID를 볼 때 이 명령을 사용해서 폐기 인증을 만들 수 있습니다. 이제, 모든 키를 .gnupg 디렉터리에, 안전한 매체(두 장의 플로피디스크 또는 안전한 위치에 보관할 CD-R)에 폐기 인증을 복사하시는 것이 좋습니다. {{Path|revoke.asc}} 파일은 키를 폐기할 때 사용할 수 있으며, 한 번 사용하고 나면 나중에 다시 사용할 수 없음을 기억하십시오. 

{{Note/ko|이 키를 활용할 전자 메일 주소가 여러개가 있다면 <code>gpg --edit-key YOUR_ID</code> 명령을 실행한 후 <code>adduid</code> 명령을 사용할 수 있습니다. 이름, 전자메일 주소, 사용할 두번째 ID에 대한 설명을 물어봅니다.}}

=== 키 내보내기 ===

키를 내보내려면 <code>gpg --armor --output john.asc --export john@nowhere.someplace.flick</code>와 같이 입력하십시오. 거의 언제든 키 ID 또는 키를 식별할 만한 문자열(여기서는 이메일 주소를 사용합니다)을 사용할 수 있습니다. John은 이제 친구에게 보내거나 웹 페이지에 넣어 다른 사람들이 John과 안전하게 통신할 수 있도록 하는 {{Path|john.asc}} 파일을 가집니다. 

=== 키 가져오기 ===

공용 키 모음에 파일을 추가하려면, 먼저 키를 가져온 다음, 키 지문을 확인해야 합니다. 지문을 인정한 다음에는 검증해야 합니다. 

{{Note/ko|키를 검증할 때 만전을 기해야 합니다. 공용키 암호화에 있어 가장 취약할 때입니다. }}

이제 Luis Pinto(원 저자 친구)의 공용키를 공용 키 모음에 추가해보도록 하겠습니다. 친구를 불러 키 지문을 요청한 다음, <code>fpr</code> 명령으로 출력한 지문과 비교하도록 하겠습니다. 키를 확인하고 나면 공용 키 모음에 추가합니다. 이 경우, Luis의 키는 2003년 12월 1일에 무효화되며, 유효기간이 경과하는 날에 키가 필요하면 다시 요청할 것입니다. 

{{Cmd|gpg --import luis.asc|output=<pre>
gpg: key 462405BB: public key imported
gpg: Total number processed: 1
gpg:               imported: 1
</pre>}}

{{Cmd|gpg --list-keys|output=<pre>
/home/humpback/.gnupg/pubring.gpg
---------------------------------
pub  1024D/75447B14 2002-12-08 John Doe (The Real John Doe) <john@nowhere.someplace.flick>
sub  2048g/96D6CDAD 2002-12-08
  
pub  1024D/462405BB 2002-12-01 Luis Pinto <lmpinto@student.dei.uc.pt>
uid                            Luis Pinto <lmpinto@dei.uc.pt>
sub  4096g/922175B3 2002-12-01 [expires: 2003-12-01]
</pre>}}

{{Cmd|gpg --edit-key lmpinto@dei.uc.pt|output=<pre>
gpg (GnuPG) 1.0.7; Copyright (C) 2002 Free Software Foundation, Inc.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions. See the file COPYING for details.
  
gpg: checking the trustdb
gpg: checking at depth 0 signed=0 ot(-/q/n/m/f/u)=0/0/0/0/0/1
pub  1024D/462405BB  created: 2002-12-01 expires: 2003-12-01 trust: -/-
sub  4096g/922175B3  created: 2002-12-01 expires: 2003-12-01
(1)  Luis Pinto <lmpinto@dei.uc.pt>
(2). Luis Pinto <lmpinto@student.dei.uc.pt>
</pre>}}

{{Cmd|fpr|prompt=Command> |output=<pre>
pub  1024D/462405BB 2002-12-01 Luis Pinto <lmpinto@dei.uc.pt>
             Fingerprint: F056 3697 ADE3 CF98 B80B  8494 0AD3 E57B 4624 05BB
</pre>}}

{{Cmd|sign|prompt=Command> |output=<pre>
Really sign all user IDs? y
                           
pub  1024D/462405BB  created: 2002-12-01 expires: 2003-12-01 trust: -/-
             Fingerprint: F056 3697 ADE3 CF98 B80B  8494 0AD3 E57B 4624 05BB
  
     Luis Pinto <lmpinto@dei.uc.pt>
     Luis Pinto <lmpinto@student.dei.uc.pt>
  
This key is due to expire on 2003-12-01.
Do you want your signature to expire at the same time? (Y/n) Y
How carefully have you verified the key you are about to sign actually belongs
to the person named above?  If you don't know what to answer, enter "0".
  
   (0) I will not answer. (default)
   (1) I have not checked at all.
   (2) I have done casual checking.
   (3) I have done very careful checking.
  
   Your selection? 3
Are you really sure that you want to sign this key
with your key: "John Doe (The Real John Doe) <john@nowhere.someplace.flick>"
  
I have checked this key very carefully.
  
Really sign? y
              
You need a passphrase to unlock the secret key for
user: "John Doe (The Real John Doe) <john@nowhere.someplace.flick>"
1024-bit DSA key, ID 75447B14, created 2002-12-08
</pre>}}

{{Cmd|check|prompt=Command> |output=<pre>
uid  Luis Pinto <lmpinto@dei.uc.pt>
sig!3       462405BB 2002-12-01   [self-signature]
sig!3       75447B14 2002-12-08   John Doe (The Real John Doe) <john@nowhe
uid  Luis Pinto <lmpinto@student.dei.uc.pt>
sig!3       462405BB 2002-12-01   [self-signature]
sig!3       75447B14 2002-12-08   John Doe (The Real John Doe) <john@nowhe
</pre>
}}

== 키 서버와의 키 교환 ==

=== 키 서버로 키 보내기 ===

Now that you have your key, it is probably a good idea to send it to the world key server. There are a lot of keyservers in the world and most of them exchange keys between them. Here we are going to send John Doe's key to the subkeys.pgp.net server. This uses HTTP, so if you need to use a proxy for HTTP traffic don't forget to set it ( <code>export http_proxy=http://proxy_host:port/</code> ). The command for sending the key is: <code>gpg --keyserver subkeys.pgp.net --keyserver-options honor-http-proxy --send-key 75447B14</code> where <code>75447B14</code> is the key ID. If you don't need a HTTP proxy you can remove the ''--keyserver-options honor-http-proxy'' . 

You can also send other people's keys that you have signed to the keyserver. We could send Luis Pinto's key to the keyserver. This way someone who trusts your key can use the signature that you have placed there to trust Luis's key. 

=== 키 서버에서 키 가져오기 ===

Now we are going to search for Gustavo Felisberto's key and add it to the keyring of John Doe (just in case you did not notice Gustavo Felisberto is the author this guide :)). 

{{Cmd|gpg --keyserver subkeys.pgp.net --keyserver-options honor-http-proxy --search-keys humpback@felisberto.net|output=<pre>
gpg: searching for "humpback@felisberto.net" from HKP server subkeys.pgp.net
Keys 1-5 of 5 for "humpback@felisberto.net"
(1)Gustavo Felisberto (apt-get install anarchy) <humpback@felisberto.net> 1024
  created 2002-12-06, key B9F2D52A
(2)Gustavo Felisberto <humpback@altavista.net> 1024
  created 1999-08-03, key E97E0B46
(3)Gustavo A.S.R. Felisberto <humpback@altavista.net> 1024
  created 1998-12-10, key B59AB043
(4)Gustavo Adolfo Silva Ribeiro Felisberto <humpback@altavista.net> 1024
  created 1998-08-26, key 39EB133D
(5)Gustavo Adolfo Silva Ribeiro Felisberto <humpback@altavista.net> 1024
  created 1998-06-14, key AE02AF87
  Enter number(s), N)ext, or Q)uit >1
gpg: requesting key B9F2D52A from HKP keyserver subkeys.pgp.net
gpg: key B9F2D52A: public key imported
gpg: Total number processed: 1
gpg:               imported: 1
</pre>
}}

As you can see from the server response I have a few keys submitted to the key server, but I currently only use ''B9F2D52A'' . Now John Doe can get it and sign it if he trusts it. 

== GPG 에이전트 사용 ==

=== GPG 에이전트가 무엇인가요? ===

Sometimes working with certain applications requires you to use your GPG key very frequently, which means that you have to type your passphrase a lot of times. Several applications used to support a passphrase caching mechanism to make life easier for users. However, this disallowed sharing this cache across programs (how secure would that be?) and forced applications to reinvent the wheel over and over again. 

A GPG agent is a separate application that GPG uses to cache the passphrase in a standard and secure way. It allows applications to use GPG concurrently: if you enter your passphrase while working in one application, the other application can work with GPG without reiterating the request for the passphrase to unlock the key - if the GPG agent is configured to allow so, of course. 

Gentoo provides a few GPG agent applications. The <code>app-crypt/gnupg</code> package contains what could be considered the reference one, and will be the one we'll use in this document. 

=== Configuring gpg-agent and pinentry ===

GnuPG includes <code>gpg-agent</code> and <code>pinentry</code> . <code>pinentry</code> is the helper application that gpg-agent uses to request the passphrase in a graphical window. It comes in three flavors: it can popup a window using the gtk+, Qt, or curses library (depending on your USE flags in {{Path|/etc/portage/make.conf}} ). 

If you installed <code>pinentry</code> with more than one popup window type, you can choose between them with <code>eselect-pinentry</code> : 

{{RootCmd|eselect pinentry list|output=<pre>
Available pinentry implementations:
  [1]   pinentry-gtk-2 *
  [2]   pinentry-curses
  [3]   pinentry-qt4
</pre>}}

{{RootCmd|eselect pinentry set 1}}

Now create a file called {{Path|~/.gnupg/gpg-agent.conf}} and enter the following lines which define the default timeout of the passphrase (e.g. 30 minutes) and the application to be called for when the passphrase should be retrieved the first time (e.g. the gtk+ version of pinentry). 

{{File|~/.gnupg/gpg-agent.conf||<pre>
pinentry-program /usr/bin/pinentry-gtk-2
no-grab
default-cache-ttl 1800
</pre>
}}

Now configure GnuPG to use an agent when appropriate. Edit {{Path|~/.gnupg/gpg.conf}} and add the following line: 

{{File|~/.gnupg/gpg.conf|Configuring GnuPG to use a GPG Agent|<pre>
use-agent
</pre>
}}

이제 GPG 에이전트를 시스템에서 사용할 수 있도록 설정이 (거의) 다 되었습니다. 

=== GPG 에이전트 자동으로 시작하기 ===

그래픽 환경으로 KDE를 사용한다면, {{Path|/etc/kde/startup/agent-startup.sh}}를 편집하여 (시스템 전체) 또는 {{Path|~/.kde4/env/gpg-agent.sh}} (로컬 사용자)에 따라 주석을 제거한 후 다음 명령을 추가하여 KDE를 시작할때 자동으로 GPG 에이전트를 시작할 수 있게 하십시오: 

{{File|/etc/kde/startup/agent-startup.ksh|Make KDE automatically start the GPG agent|<pre>
eval "$(gpg-agent --daemon)"
</pre>
}}

Additionally, uncomment the following in {{Path|/etc/kde/shutdown/agent-shutdown.sh}} (system-wide) or add it to {{Path|~/.kde4/shutdown/gpg-agent.sh}} (local user): 

{{File|/etc/kde/shutdown/agent-shutdown.sh|Make KDE shut down the GPG agent|<pre>
if [ -n "${GPG_AGENT_INFO}" ]; then
  kill $(echo ${GPG_AGENT_INFO} | cut -d':' -f 2) >/dev/null 2>&1
fi
</pre>
}}

If you use a different graphical environment, put that line (the same one as mentioned above) in {{Path|~/.xinitrc}} (if you use <code>startx</code> ) or {{Path|~/.xsession}} (if you use XDM/GDM/KDM/...). 

== 문서 작성시 활용하기 ==

== 암호화 및 서명 ==

Let's say that you have a file that you wish to send Luis. You can encrypt it, sign it, or encrypt it and sign it. Encrypting means that only Luis will be able to open it. The signature tells Luis that it was really you who created the file. 

The next three commands will do just that, encrypt, sign and encrypt/sign. 

{{Cmd|gpg --output doc.gpg --encrypt --recipient lmpinto@dei.uc.pt doc_to_encrypt
|gpg --output doc.gpg --sign --recipient lmpinto@dei.uc.pt doc_to_sign
|gpg --output doc.gpg --encrypt --sign --recipient lmpinto@dei.uc.pt doc_to_encrypt_and_sign}}

This will create binary files. If you wish to create ASCII files, just add a <code>--clearsign</code> to the beginning of the command. 

=== 해독 및 서명 검증===

Suppose that you have received a file which is encrypted to you. The command to decrypt it is <code>gpg --output document --decrypt encrypted_doc.gpg</code> . This will decrypt the document and verify the signature (if there is one). 

=== 키 없이 암호화 및 해독 ===

It is also possible to encrypt files using passwords instead of keys. Well, the password itself will function as the key - it will be used as a ''symmetric cypher'' . You can encrypt the file using <code>gpg</code> 's <code>--symmetric</code> argument; decrypting uses the same command as we talked about before. 

{{Cmd|gpg --output document.gpg --symmetric document}}

GnuPG will ask for a passphrase and a passphrase verification.


=== 고급 기능 ===

There are some nice advanced features in GnuPG. To find them, open the {{Path|~/.gnupg/gpg.conf}} file. 

{{File|~/.gnupg/gpg.conf||<pre>
#keyserver x-hkp://subkeys.pgp.net
#keyserver-options auto-key-retrieve include-disabled include-revoked
</pre>
}}

Search for the above two lines and uncomment them. With this any time GnuPG needs to check a signature and it does not find the public key on the local keyring it will contact the key server at [http://subkeys.pgp.net:11371/ subkeys.pgp.net] and will try to fetch it from there. 

Another nice command is <code>gpg --refresh-keys</code> . This will contact the keyserver defined in the options file and refresh public keys in your local key ring from there, searching for revoked keys, new IDs, and new signatures on keys. You should probably run this once or twice a month so that if someone revokes his key you will be notified. 

== GnuPG 인터페이스 ==

=== 전자메일 서명하기 ===

95% of the time you will use GnuPG with email, signing/encrypting your outgoing messages and reading signed/encrypted messages. So it is only fair that I talk about that first. 

There are two ways two sign/encrypt a email with GnuPG, the old way and the new way :). In the old way messages would appear in plain text, with no possible formatting and attached files would be unsigned/unencrypted. Here is an example of a message signed the old way: 

{{Code|A plain text signature|<pre>
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
  
Test message
  
-----BEGIN PGP SIGNATURE-----
Version: PGPfreeware 6.5.8 for non-commercial use
  
iQA/AwUBP8461jMX0745gR7AEQIEOwCg011GbufXO3ED3FkLWXmfzg7xm1cAoJD0
0EU3Kd2EKNCqataEqM5qjpPs
=LchZ
-----END PGP SIGNATURE-----
</pre>
}}

Messages this way are no good in today's world, where we have nice GUIs and email readers that understand html. 

To solve this an addition to the MIME (Multipurpose Internet Mail Extensions) was created. This adds a field to the email that tells the mail reader that the full content of the message is signed and/or encrypted. The problem with this is that not all mail readers support this. And some even mess up the content; Microsoft's Outlook is famous for not working with this. 

=== Kgpg ===

Kgpg is a nice GUI for GnuPG. In the main screen you can paste the text that you wish to sign or encrypt, and you can also paste the ASCII armored text that you which to decrypt. 

From within the main screen you can decrypt text (you will have to provide your password), encrypt other files, paste new text to sign.... 

=== Seahorse ===

Seahorse aims to be a GnuPG GUI interface for the Gnome desktop. The software has been evolving fast, but it still lacks many important features that can be found in Kgpg or the command line version. 

=== KMail ===

If you have the <code>crypt</code> USE flag set, KMail will be compiled with gpg support, and will be able to encrypt and decrypt inline PGP mails automatically as well as encrypting OpenPGP/MIME mails. If you want to decrypt OpenPGP/MIME mails as well (which you probably want) you need to have a running GPG agent. 

You can verify if KMail is properly configured by going to <code>Settings</code>, <code>Configure KMail</code>, <code>Security</code>, <code>Crypto Backends</code>. You should see a GpgME-based backend listed and you should be able to fill the OpenPGP checkbox. If it is listed but grayed out, click on <code>Rescan</code> . If the GpgME-based backend remains grayed out, KMail is not working properly. 

If you still are unable to get KMail to behave, please see the [http://kmail.kde.org/kmail-pgpmime-howto.html KMail PGP HowTo] page for more information. 

=== Claws-Mail ===

This mail reader is ''very'' fast with big mailboxes, has all the nice features one wants in mail readers and works pretty well with gpg. The only problem is that it does not work with the old PGP signatures, so when you receive those kind of mails you have to hand check the signatures. 

To use your gpg key with Claws-Mail just go to the account configuration and select the privacy tab. Once there just choose which key to use, probably most users will go with the default key. 

== 공용키 암호화 ==

=== 기본 공용키 암호화 기법 ===

The concept of public key cryptography was originally devised by Whitfield Diffie and Martin Hellman in 1976. When I first heard the words "public key" and "cryptography" in the same sentence back in '93 I thought to myself that it would be impossible to do such a thing. In those days there was no Internet (well there was, but not for me) so I went to the public library and asked for books on Cryptography. I must say that I was 16 at the time so the clerk there looked to me in astonishment and brought me a book for children on substitution cyphers (those where you change a letter for another like the famous Caesar Cypher or ROT-13 (Tragbb Ebpxf, naq lbh xabj vg vf tbbq orpnhfr lbh ner ernqvat guvf qbp.), ( <code>emerge rotix</code> if you cannot read the preceding text)). I was very upset with this and started to search for more info. It is good to have mathematicians in the family, because as soon as I talked to one of them I was introduced to a new world. 

그리고 약간의 수학 개념이 들어갑니다: 

{{Code|수학적 개념|<pre>
정의:
  
1- 소수는 1보다 큰 양의 정수이며 1과 그 자신으로 나뉩니다 (나머지 값은 0).
처음 8 개의 소수는 2,3,5,7,11,13,17,19 입니다.
  
정리 (증명 없음)
1- 양의 소수가 아닌 어떤 수로서 소수의 곱으로 깨질 수 있고 곱한 결과는 유일함.
4=2*2
6=2*3
8=2*4=2*2*2
10=2*5
12=2*6=2*2*3
  
"진실":
1- 두 개의 큰 정수를 곱하는건 수학적으로 쉽다
2- 주어진 양의 정수에 대한 소인수를 찾기는 어렵다.
</pre>
}}

If I give you the number 35 and I tell you that this number is the product of two prime numbers it is easy to find that it was 5 and 7. But if I tell you the same for 1588522601 you will spend alot of time (or CPU cycles) to find it was 49811*31891. And if this number is really really big this task becomes "impossible". So now if I give the world my large number that is the product of two primes I know something about that number that no one else knows. 

This is the basis for Public Key Cryptography (PKC) implementations today. As an (unrealistic) example, I give anyone my number and that someone will use if for cyphering a message to me. Anyone can see the cyphered message, because I am the only one who knows a shortcut to read it, anyone else will first have to "split" that big number to be able to read the message, and it is a "fact" that it is impossible to do that in a short amount of time (todays methods and the fastest computers in the world would take thousands of years to do that). In this setup the two large prime numbers would be called the PRIVATE KEY, and the large non prime number is the PUBLIC KEY. 

In practice this is not 100% accurate with reality, but will give a good idea to the newcomer. For more information, check Wikipedia on the [http://en.wikipedia.org/wiki/Diffie-Hellman Diffie-Hellman] protocol. For even more info go to the public library and grab a copy of the [http://www.cacr.math.uwaterloo.ca/hac/ "Handbook of Applied Cryptography"] by Alfred J. Menezes, Paul C. van Oorschot and Scott A. Vanstone. This book is also available online for free at the above site. 

One consequence of the above is that if you cypher a message to me, and you loose the original uncyphered message you will no longer be able to retrieve it from the cyphered version. 

=== 서명 ===

We already saw how someone can send us a cyphered message if they have our public key. But how do we know that the author of the message is really who he claims to be? Or in other words: If I receive an email from you how do I really know it was you and not someone else claiming to be you? 

Remember me saying that PKC was not as simple as I had said? The idea is that when you cypher a message to me you sign it with your private key so that, when I receive it, I can first use your public key to check your signature and then use my private key to decypher the message. As you can see we could not do that in the setup I described before. 

It's also very important to sign messages so that you don't have to cypher them beforehand. Now you can create messages that can be read by anyone, but that come with your "branding". And if any single character is changed in the message it can (and will) be detected. 

=== 키 서버와 서명 키 ===

But let's say that I have no previous contact with you until you send me a message: how do I get your public key, and how do I really know it is yours? 

To solve this problem public Key Servers were created. When you create your key pair (Public and Private key), you send your public key to the key server. After this everyone can retrieve your key from there. This solves the problem of finding the key. But how do I really know that that key is the author's key? For this another concept must be introduced, and that is key signing: 

Key signing means that if I have the public key of another person, and I know ''for sure'' that it is really that persons key (it is my personal friend, someone I know in real life, etc.) I can sign that public key and send it to keyservers, that way I am telling the world: "This key really belongs to the person it claims to belong.". That way persons that have my public key and trust me can use that trust to trust other keys. 

This can sometimes be confusing so let's see a real world situation. 

Let's imagine a 3 person situation: John, Mary, and Lisa. John is a good friend of Mary but does not know Lisa; Lisa is a good friend of Mary but does not know John. One day Lisa sends John a signed email. John will fetch Lisa's Public Key from the keyserver and test the message, if all went ok he will see that whoever wrote that message also created that key. But how do I know it was really the person it claims to be? 

He then sees that it is signed by Mary, which he can check because he already has Mary's key and he trusts that key. With this ring of trust he continues to conclude that the email he received was really written by Lisa. 

You are now ready to use this guide, you can go back to chapter 1 and learn how to use gpg. 

== 마무리 생각과 고마운 사람들 ==

=== 몇가지 문제 ===

I had some problems with photos in keys. Check the version you are using. If you have GnuPG 1.2.1-r1 and up you are probably OK, older versions may have problems. Also most keyservers don't like keys with photos, so you are better if you don't add photos. 

The latest versions of gnupg don't seem to work with the <code>gpg --send-keys</code> that was used so send all keys in your keyring to the public server. 

=== What is not here ===

<code>gpg</code> is a very complex tool, it lets you do much more than what I have covered here. This document is for the user who is new to GnuPG. For more information, you should check the[http://www.gnupg.org GnuPG Website] . 

I did not write about other tools like <code>pgp4pine</code> , <code>gpgpine</code> , <code>evolution</code> and maybe Windows tools, but I will probably extend this document in the future. 

=== 고마운 사람들 ===

John Michael Ashley의 [http://www.gnupg.org GnuPG 핸드북]은 초보자들에게 굉장히 좋은 책입니다. 

Swift (Sven Vermeulen) for pushing me to re-write this. 

Everyone in the #gentoo-doc team you guys rock. 

Tiago Serra for getting me back to the privacy track. 

== Acknowledgements ==

이 안내서에 제공한 노고에 대해 다음 작성자와 편집자분들께 감사의 말을 전하고자 합니다:


* Gustavo Felisberto
* John P. Davis
* Sven Vermeulen
* nightmorph

[[Category:Server and Security]]
