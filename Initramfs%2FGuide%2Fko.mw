<languages />


{{Metadata|abstract=상당히 많은 시스템이 부팅을 제대로 수행하려면 initramfs를 필요로 합니다. 이 안내서에서는 initramfs의 개념을 파헤치고, 어떻게 제대로 만드는지 어떻게 initramfs 인스턴스를 관리하는지 다루도록 하겠습니다.}}

상당히 많은 시스템이 부팅을 제대로 수행하려면 initramfs를 필요로 합니다. 이 안내서에서는 initramfs의 개념을 파헤치고, 어떻게 제대로 만드는지 어떻게 initramfs 인스턴스를 관리하는지 다루도록 하겠습니다.

== initramfs 개념 ==

=== 도입부 ===

For many users, an initramfs system is of no concern. Their system uses a simple partitioning schema with no exotic drivers or setups (like encrypted file systems), so the Linux kernel is entirely capable to hand over control to the {{c|init}} binary on their system. But for many systems, an initramfs is mandatory. 

initramfs가 무엇인지(무엇에 필요한지) 이해할 핵심 개념은 리눅스가 어떻게 부팅 과정을 처리하는지, 상위 레벨의 관점에서 이해하는 것입니다. 

=== 리눅스 부팅 과정 ===

Once the Linux kernel has control over the system (which it gets after being loaded by the boot loader), it prepares its memory structures and drivers. It then hands over control to an application (usually {{c|init}}) whose task it is to further prepare the system and make sure that, at the end of the boot process, all necessary services are running and the user is able to log on. The {{c|init}} application does that by launching, among other services, the {{c|udev}} daemon who will further load up and prepare the system based on the detected devices. When {{c|udev}} is launched, all remaining file systems that have not been mounted are mounted, and the remainder of services is started. 

For systems where all necessary files and tools reside on the same file system, the {{c|init}} application can perfectly control the further boot process. But when multiple file systems are defined (or more exotic installations are done), this might become a bit more tricky: 

* {{Path|/usr}} 파티션이 다른 파일 시스템에 있을 경우, {{Path|/usr}}에 있는 도구와 드라이버는 {{Path|/usr}}를 사용할 수 있기 전에는 사용할 수 없습니다. 이들 도구가 {{Path|/usr}}을 사용할 수 있게 하는 과정이 필요하다면, 시스템을 부팅할 수 없습니다.

* If the root file system is encrypted, then the Linux kernel will not be able to find the {{c|init}} application, resulting in an unbootable system.

이 문제를 해결하는 방법으로 오래전부터 ''initrd''(초기 루트 장치)를 사용하는 방법이 있습니다. 

=== 초기 루트 디스크 ===

The '''initrd''' is an in-memory disk structure (ramdisk) that contains the necessary tools and scripts to mount the needed file systems ''before'' control is handed over to the {{c|init}} application on the root file system. The Linux kernel triggers the setup script (usually called {{Path|linuxrc}} but that name is not mandatory) on this root disk, which prepares the system, switches to the real root file system and then calls {{c|init}}. 

비록 initrd 방식이 필요한 그 전부 자체겠지만, 몇가지 문제가 있긴 합니다: 

* 완전히 구색을 갖춘 블록 장치이며 전체 파일 시스템에 대한 오버헤드를 필요로 하고, 고정 크기를 지니고 있습니다. 작은 inintrd를 사용하면 모든 필요한 스크립트를 넣을 수 없고 너무 크게 잡으면, 메모리를 쓸데 없이 많이 사용하게 됩니다.

* 실제 장치이기 때문에, 리눅스 커널의 캐시 메모리를 소모하며, 메모리 및 파일 관리 방식(페이징)을 사용하는 중에 메모리 소모 동작이 잘못될 수도 있습니다.

이 (아마도 말하기 힘든) 문제를 해결하기 위해 initramfs가 만들어졌습니다. 

=== 초기 램 파일 시스템 ===

An '''initramfs''' is an initial ram file system based on ''tmpfs'' (a size-flexible, in-memory lightweight file system), which also did not use a separate block device (so no caching was done and all overhead mentioned earlier disappears). Just like the initrd, it contains the tools and scripts needed to mount the file systems before the {{c|init}} binary on the real root file system is called. These tools can be decryption abstraction layers (for encrypted file systems), logical volume managers, software raid, bluetooth driver based file system loaders, etc. 

The content of the initramfs is made by creating a cpio archive. {{c|cpio}} is an old (but proven) file archiver solution (and its resulting archive files are called cpio files). cpio is definitely comparable to the {{c|tar}} archiver. The choice of {{c|cpio}} here was because it was easier to implement (code-wise) and supported (back then) device files which {{c|tar}} could not. 

All files, tools, libraries, configuration settings (if applicable), etc. are put into the cpio archive. This archive is then compressed using the {{c|gzip}} utility and stored alongside the Linux kernel. The boot loader will then offer it to the Linux kernel at boot time so the kernel knows an initramfs is needed. 

initramfs를 커널이 감지하고 나면 tmpfs 파일 시스템을 만들고, 내용을 이 파일 시스템에 추출한 다음, tmpfs 파일 시스템의 루트에 위치한 {{Path|init}} 스크립트를 실행합니다. 그 다음 이 스크립트로 실제 루트 파일 시스템을 마운트하고(다음 마운트를 확실하게 한 다음에는, 추가 모듈을 불러온다든지 하는 식으로, 암호화된 추상 레이어 같은 요소를 준비합니다) 이와 같이 다른 파일 시스템({{Path|/usr}} 또는 {{Path|/var}})을 활성화합니다. 

루트 파일 시스템과 다른 실제 파일 시스템을 마운트 하고 나면 initramfs의 {{Path|init}} 스크립트는 실제 루트 시스템으로 전환하고, 실제 루트 시스템의 {{Path|/sbin/init}}을 호출하여 부팅 과정을 계속 진행합니다.

== initramfs 만들기 ==

=== 도입부 및 부트로더 설정 ===

To create an initramfs, it is important to know what additional drivers, scripts and tools will be needed to boot the system. For instance, if LVM is used, then LVM tools will be needed in the initramfs. Likewise, if software RAID is used, {{c|mdadm}} utilities will be needed, etc. 

Some tools exist that help users create initramfs' (compressed {{c|cpio}} archives) for their system. But for those who want total control can easily create personal, custom initramfs' as well. 

이를 만들고 나면, 사용할 initramfs에 사용 정보를 알릴 부트로더 설정을 건드려야 합니다. 예를 들어 {{Path|/boot/initramfs-3.2.2-gentoo-r5}}에 initramfs 파일을 저장했다면, {{Path|/boot/grub/grub.conf}} 설정은 다음과 같습니다. 

{{FileBox|filename=grub.conf|title=initramfs로 부팅하는 grub.conf 항목 예제|1=
title Gentoo Linux 3.2.2-r5
root (hd0,0)
kernel /boot/kernel-3.2.2-gentoo-r5
initrd /boot/initramfs-3.2.2-gentoo-r5
}}

=== genkernel 사용하기 ===

Gentoo's kernel building utility, {{c|genkernel}}, can be used to generate an initramfs, even if {{c|genkernel}} was not used to configure and build the kernel. 

To use {{c|genkernel}} for generating an initramfs, it is recommended all necessary drivers and code that is needed to mount the {{Path|/}} and {{Path|/usr}} file systems be included in the kernel (not as modules). Then, call {{c|genkernel}} as follows: 

{{RootCmd|genkernel --install --no-ramdisk-modules initramfs}}

시스템에 따라, 다음과 같이 하나 이상의 옵션 추가가 필요할 수도 있습니다: 

{| class="table" style="text-align: left;" 
|- 
! Option
! Description
|- 
| <code>--disklabel</code>
| Add support for <code>LABEL=</code> settings in {{Path|/etc/fstab}} 
|- 
| <code>--dmraid</code>
| Add support for fake hardware RAID.
|- 
| <code>--firmware</code>
| Add in firmware code found on the system.
|- 
| <code>--gpg</code>
| Add in GnuPG support.
|- 
| <code>--iscsi</code>
| Add support for iSCSI.
|- 
| <code>--luks</code>
| Add support for LUKS encryption containers.
|- 
| <code>--lvm</code>
| Add support for LVM.
|- 
| <code>--mdadm</code>
| Add support for software RAID.
|- 
| <code>--multipath</code>
| Add support for multiple I/O access towards a SAN.
|- 
| <code>--zfs</code>
| Add support for ZFS.
|-
|}

실행이 끝나면, 결과 initramfs파일은 {{Path|/boot}}에 들어갑니다.

=== Dracut 활용하기 ===

{{Warning|이 글을 쓰는 시점에 dracut이 아직 안정화 되지 않은 상태로 확인되었으므로, 계속하려면 마스크를 해제할 필요가 있습니다.}}

The {{c|dracut}} utility is created for the sole purpose of managing initramfs files. It uses a highly modular approach on what support is to be included and what is not to be included. 

To install {{c|dracut}}, make special care to include support for the correct value(s) in the <var>DRACUT_MODULES</var> variable. This variable can be set in {{Path|/etc/portage/make.conf}} to include support for system specific setups: 

{{FileBox|filename=make.conf|title=Dracut 설치 준비|lang=bash|1=<pre>
DRACUT_MODULES="dmraid lvm syslog -biosdevname -btrfs -caps -crypt -crypt-gpg
-dmsquash-live -gensplash -iscsi -livenet -mdraid -multipath -nbd -nfs -plymouth
-ssh-client"
</pre>
}}

It is advisable to set (or unset) the modules needed. After configuring the <var>DRACUT_MODULES</var> variable in {{Path|/etc/portage/make.conf}}, {{c|emerge dracut}} to install the Dracut utility. 

The next step is to configure {{c|dracut}} by editing {{Path|/etc/dracut.conf}}. In the configuration file, which is well commented, in order to add support for needed modules.

Once configured, create an initramfs by calling {{c|dracut}} as follows: 

{{RootCmd|dracut}}

The resulting image supports generic system boots based on the configuration in {{Path|/etc/dracut.conf}}. It is also possible to generate an initramfs specifically tailored to ''your'' system (which {{c|dracut}} tries to detect the needed tools, drivers, etc. from the existing system). If the modules and drivers are built into the kernel (not as separate modules and references to the firmware), then the <code>--no-kernel</code> option can be added: 

{{RootCmd|dracut --host-only --no-kernel}}

더 많은 정보는 dracut과 dracut.cmdline 맨페이지를 확인하십시오:
{{Cmd
|man dracut
|man dracut.cmdline
}}

== 추가 참조 ==

* 공식 젠투 위키의 [[Initramfs]]
* 공식 젠투 위키의 [[Dracut]]

== 외부 자료 ==

* The [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt ramfs-rootfs-initramfs.txt] file within the Linux kernel documentation.


[[Category:Initramfs]]
