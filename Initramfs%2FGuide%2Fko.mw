<languages />


{{Metadata|abstract=상당히 많은 시스템이 부팅을 제대로 수행하려면 initramfs를 필요로 합니다. 이 안내서에서는 initramfs의 개념을 파헤치고, 어떻게 제대로 만드는지 어떻게 initramfs 인스턴스를 관리하는지 설명하도록 하겠습니다.}}

상당히 많은 시스템이 부팅을 제대로 수행하려면 initramfs를 필요로 합니다. 이 안내서에서는 initramfs의 개념을 파헤치고, 어떻게 제대로 만드는지 어떻게 initramfs 인스턴스를 관리하는지 설명하도록 하겠습니다.

== initramfs 개념 ==

=== 도입부 ===

대부분의 사용자는 initramfs 시스템을 신경쓰지 않습니다. 사용자들은 단순한 파티션 구조와, (암호화된 파일 시스템같이)낯설지 않은 드라이버 또는 설정을 사용하기 때문에 리눅스 커널은 시스템에서 <code>init</code> 바이너리로 제어권을 넘길 수 있습니다. 다만 대부분의 시스템은 initramfs는 거의 필수나 다름 없습니다. 

initramfs가 무엇인지(무엇에 필요한지) 이해할 핵심 개념은 리눅스가 어떻게 부팅 과정을 처리하는지, 상위 레벨의 관점에서 이해하는 것입니다. 

=== 리눅스 부팅 과정 ===

리눅스 커널이 (부트로더에서 불러오고 난 후의)시스템에 제어권을 넘기면, 메모리 구조와 드라이버를 가능한한 준비하는 것입니다. 그 다음 시스템을 더 많이 준비하는 작업을 하는 (보통 <code>init</code>) 프로그램으로 제어권을 넘기며, 부팅 과정의 마지막에는 모든 필요한 서비스가 동작하는지 확인하며 사용자가 로그온 할 수 있게 처리합니다. <code>init</code> 프로그램은 실행으로 처리하는데, 다른 서비스 중에, 더 많은 요소를 불러올 <code>udev</code> 데몬은 감지한 장치를 기반으로 시스템을 준비합니다. <code>udev</code>를 실행하면, 아직 마운트 안된 모든 남아있는 파일 시스템을 마운트하며, 나머지 서비스를 시작합니다. 

모든 필요한 파일과 도구가 같은 파일 시스템에 존재하는 시스템에서, <code>init</code> 프로그램은 훨씬 더 많은 부팅 과정을 완벽하게 제어합니다만, 여러가지 파일 시스템을 정의했을 경우(또는 좀 더 낯선 방식의 설치요소를 올려두었다면), 좀 더 복잡해질 수 있습니다: 

* {{Path|/usr}} 파티션이 다른 파일 시스템에 있을 경우, {{Path|/usr}}에 있는 도구와 드라이버는 {{Path/usr}}를 사용할 수 있기 전에는 사용할 수 없습니다. 이들 도구가 {{Path|/usr}}을 사용할 수 있게 하는 과정이 필요하다면, 시스템을 부팅할 수 없습니다.

* If the root file system is encrypted, then the Linux kernel will not be able to find the <code>init</code> application, resulting in an unbootable system.

The solution for this problem has since long been to use an ''initrd'' (initial root device). 

=== The initial root disk ===

The ''initrd'' is an in-memory disk structure (ramdisk) that contains the necessary tools and scripts to mount the needed file systems before control is handed over to the <code>init</code> application on the root file system. The Linux kernel triggers the setup script (usually called <code>linuxrc</code> but that is not mandatory) on this root disk, which prepares the system, switches to the real root file system and then calls <code>init</code>. 

Although the initrd method is all that is needed, it had a few drawbacks: 

* It is a full-fledged block device, requiring the overhead of an entire file system on it, and has a fixed size. Choose an initrd that is too small, and you won't be able to fit in all needed scripts. Make it too big, and you're wasting memory.

* Because it is a real device, it also consumes cache memory in the Linux kernel and is prone to the memory- and file management methods in use (such as paging), making it even worse in memory consumption.

To resolve these (for some perhaps hardly called) problems, the initramfs was created. 

=== The initial ram file system ===

An ''initramfs'' is an initial ram file system based on ''tmpfs'' (a size-flexible, in-memory lightweight file system), which also didn't use a separate block device (so no caching was done and all overhead mentioned earlier disappears). Just like the initrd, it contains the tools and scripts needed to mount the file systems before the <code>init</code> binary on the real root file system is called. These tools can be decryption abstraction layers (for encrypted file systems), logical volume managers, software raid, bluetooth driver based file system loaders, etc. 

The content of the initramfs is made by creating a cpio archive. <code>cpio</code> is an old (but proven) file archiver solution (and its resulting archive files are called ''cpio files''). You can definitely compare it to <code>tar</code>. The choice of <code>cpio</code> here was because it is easier to implement (code-wise) and supported (back then) device files (which <code>tar</code> couldn't). 

All files, tools, libraries, configuration settings (if applicable), etc. are put into the cpio archive. This archive is then compressed using the <code>gzip</code> utility and stored alongside the Linux kernel. The boot loader will then offer it to the Linux kernel at boot time so the kernel knows an initramfs is needed. 

Once detected, the Linux kernel will create a tmpfs file system, extract the contents of the archive on it, and then launches the <code>init</code> script located in the root of the tmpfs file system. This script will then mount the real root file system (after making sure it can mount it, for instance by loading additional modules, preparing an encryption abstraction layer, etc.) as well as vital other file systems (such as {{Path|/usr}} and {{Path|/var}} ). 

Once the root file system and the other vital file systems are mounted, the <code>init</code> script from the initramfs will switch the root towards the real root file system and finally call the <code>/sbin/init</code> on that system to continue the boot process. 

== Creating an initramfs ==

=== Introduction and bootloader configuration ===

To create an initramfs, it is important that you know what additional drivers, scripts and tools you need to boot your system. For instance, if you use LVM, then you will need to support LVM tools on the initramfs. Likewise, if you use software RAID, you need <code>mdadm</code>, etc. 

Some tools exist that help you create initramfs' (compressed cpio archives) for your system. But for those that want total control, you can easily create your own initramfs as well. 

Once created, you will need to adjust the bootloader configuration to tell it that an initramfs is to be used. For instance, if the initramfs file is stored as {{Path|/boot/initramfs-3.2.2-gentoo-r5}} , then the configuration in {{Path|/boot/grub/grub.conf}} could look like so: 

{{File|grub.conf|Example entry in grub.conf for booting with an initramfs|<pre>
title Gentoo Linux 3.2.2-r5
root (hd0,0)
kernel /boot/kernel-3.2.2-gentoo-r5
initrd /boot/initramfs-3.2.2-gentoo-r5
</pre>
}}

=== Using genkernel ===

Gentoo's kernel building utility, <code>genkernel</code>, can be used to generate an initramfs, even if you didn't use <code>genkernel</code> to configure and build your kernel. 

To use <code>genkernel</code> for generating an initramfs, it is recommended that you include all necessary drivers and code that is needed to mount your {{Path|/}} and {{Path|/usr}} file systems in the kernel (and not as modules). Then, call <code>genkernel</code> as follows: 

{{RootCmd|genkernel --install --no-ramdisk-modules initramfs}}

Depending on your system, you might want to add one or more of the following options: 

{| class="wikitable" style="text-align: left;" 
|- 
! Option
! Description
|- 
| --disklabel
| Add support for <code>LABEL=</code> settings in your {{Path|/etc/fstab}} 
|- 
| --dmraid
| Add support for fake hardware RAID
|- 
| --firmware
| Add in firmware code found on the system
|- 
| --gpg
| Add in GnuPG support
|- 
| --iscsi
| Add support for iSCSI
|- 
| --luks
| Add support for luks encryption containers
|- 
| --lvm
| Add support for LVM
|- 
| --mdadm
| Add support for software RAID
|- 
| --multipath
| Add support for multiple I/O access towards a SAN
|- 
| --zfs
| Add support for ZFS
|-
|}

When finished, the resulting initramfs file will be stored in your {{Path|/boot}} . 

=== Using dracut ===

{{Warning|At the time of writing, dracut is not marked stable yet, so you might need to unmask it before continuing.}}

The <code>dracut</code> utility is created for the sole purpose of managing initramfs files. It uses a highly modular approach on which support you want to include and which not. 

When you install <code>dracut</code>, you will need to take care to include support for the correct <code>DRACUT_MODULES</code> . This is a variable you can set in {{Path|/etc/portage/make.conf}} to include support for specific setups: 

{{File|make.conf|Preparing to install dracut|<pre>
DRACUT_MODULES="dmraid lvm syslog -biosdevname -btrfs -caps -crypt -crypt-gpg
-dmsquash-live -gensplash -iscsi -livenet -mdraid -multipath -nbd -nfs -plymouth
-ssh-client"
</pre>
}}

It is advisable to set (or unset) those modules you need (and don't need). Afterwards, <code>emerge dracut</code> to install the utility on your system. 

The next step is to configure <code>dracut</code> by editing {{Path|/etc/dracut.conf}}. In the configuration file, which is well commented, you can add in support for specific modules where needed. 

Once configured, create an initramfs by calling <code>dracut</code> as follows: 

{{RootCmd|dracut}}

The resulting image supports generic system boots based on the configuration in {{Path|/etc/dracut.conf}}. You can also opt to generate an initramfs specifically tailored to your system (in which <code>dracut</code> tries to detect the needed tools, drivers, etc. from your existing system). If you know that the needed support (code and drivers) is built in in your kernel (and not as module), then you can even add in <code>--no-kernel</code>: 

{{RootCmd|dracut --host-only --no-kernel}}

For more information, check out the <code>dracut</code> and <code>dracut.cmdline</code> manual pages. 

== Additional resources ==

=== Gentoo-specific ===

* [[Initramfs]] on the official Gentoo Wiki
* [[Dracut]] on the official Gentoo Wiki

=== General resources ===

* [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt ramfs-rootfs-initramfs.txt] within the Linux kernel documentation

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:


* Sven Vermeulen
