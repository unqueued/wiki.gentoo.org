{{lowercase title}}
{{InfoBox stack
|{{InfoBox homepage|https://www.skarnet.org/software/s6-rc/|header=true}}
|{{InfoBox gitweb|raw=yes|text=Git repository browser|https://git.skarnet.org/cgi-bin/cgit.cgi/s6-rc}}
|{{InfoBox github|text=GitHub mirror|skarnet/s6-rc}}
|{{InfoBox package|sys-apps/s6-rc}}
}}

s6-rc is [[Article description::a service manager for [[s6]]-based systems]], i.e. a suite of programs that can start and stop services, both long-running daemons and one-time initialization scripts, in the proper order according to a dependency tree. It can be used as an init system component, with a role similar to that of [[OpenRC]] for [[sysvinit]] + OpenRC systems. A high level overview of s6-rc is available [https://www.skarnet.org/software/s6-rc/overview.html here]. The package's documentation is provided in HTML format, and can be read on a text user interface using for example {{Package|www-client/links}}.

__TOC__

== Installation ==

=== USE flags ===

{{USEflag|package=sys-apps/s6-rc}}

=== Emerge ===

{{Emerge|sys-apps/s6-rc}}

{{Important|s6-rc is currently on the testing branch. Users with systems on the stable branch will need to add the package to {{Path|/etc/portage/package.accept_keywords}} (if using Portage) to be able to install it, and also add {{Package|dev-libs/skalibs}}, {{Package|dev-lang/execline}} and {{Package|sys-apps/s6}}. While it is generally not advised to mix packages of stable and testing branches, the skarnet.org software stack only depends on the [[libc]], so in this case it should be safe.}}

== Configuration ==

=== Files ===

* {{Path|/run/s6-rc}} - Default live state directory.
* {{Path|/etc/s6-rc/compiled}} - Default pathname of the compiled service database used by {{C|s6-rc-init}} to initialize s6-rc.

== Usage ==

s6-rc manages ''services''. A service is usually thought of as being provided by a ''server program'' that runs as a long-lived process. In this case, the service is ''up'' while the program is running and ready to provide the service, and ''down'' otherwise. s6-rc calls this kind of service a ''longrun'', and arranges to run the corresponding program as a ''supervised process'' using [[s6]] tools.

A service can also be thought of as being provided after some sequence of actions is performed, without involving a long-lived process. For example, making a filesystem available by mounting it, or making a network interface ready for traffic by bringing it up and configuring it with a static address, could also be considered services. In this case the service is up after the corresponding actions are successfully performed. s6-rc calls this kind of service a ''oneshot'', and arranges to perform the corresponding actions in a controlled, reproducible environment. This environment is also set up by an s6 supervision tree even though oneshots do not involve supervised processes. For a oneshot, a transition to down state might mean just doing nothing and 'forgetting' that the corresponding actions were performed, so a subsequent transition to up would simply redo them. Or it might mean performing some sort of inverse procedure, like e.g. unmounting a filesystem or bringing down a network interface.

Services can also ''depend'' on other services. This generally means that a service can only transition to and remain in up state only as long as all of the services it depends on are also in up state. The dependencies of a service might in turn have dependencies themselves, creating dependency chains. s6-rc supports dependency specifications and arranges to perform service state transitions accordingly.
{{anchor|database}}
=== Compiled service databases ===

Performing requested state transitions for a set of services submitted to s6-rc (called ''the selection'') requires it to compute a ''dependency graph'', and then use it to compute, from the full set of managed services, the complete subset of those that need state transitions (called ''the closed selection''), so that the requested operation can be performed while also honoring all dependency specifications. For this purpose, s6-rc stores its managed longruns and oneshots in a ''compiled service database''. This database is a directory that contains a set of files and subdirectories with formats optimized for efficient computation of dependency graphs and closed selections. A compiled database is created with the {{C|s6-rc-compile}} program. It cannot be modified except by using the {{C|s6-rc-bundle}} program (see [[#s6rcupdate|live updates to the service database]]), and can be placed in a read-only filesystem.

{{C|s6-rc-compile}} accepts the (absoulte or relative to its working directory) pathname of the database to create, and a nonempty set of directory pathnames. These directories must contain ''service definitions'' in a format called {{C|s6-rc-compile}}'s ''source format''. A service definition is a subdirectory, or symbolic link to directory, that must contain a regular file named {{Path|type}}. This file specifies one of the s6-rc's supported service types: longrun, oneshot and ''bundle'' (see [[#bundles|service bundles]]). The contents of a service definition directory depend on the service's type. The name of the directory defines the ''service name'' that is used by all s6-rc programs to refer to the service. Service names cannot be duplicated and cannot contain a slash ('/') or a newline; they can contain spaces and tabs, but using anything other than alphanumerical characters, underscores ('_') and dashes ('-') is discouraged.

Currently, {{C|s6-rc-compile}} also unconditionally adds two s6-rc support services to each compiled service database: {{Path|s6rc-oneshot-runner}}, a longrun that is used to implement oneshots (see [[#oneshots|oneshot definitions]]), and {{Path|s6rc-fdholder}}, a longrun that is used to implement pipelines (see [[#pipelines|longrun pipelining]]). Service names that start with '''s6rc-''' or '''s6-rc-''' are reserved, and {{C|s6-rc-compile}} fails with an error if it finds one in the submitted service definitions. {{C|s6-rc-compile}} also ignores, in any of the supplied directories, files that are not directories or symbolic links to directory, and files with names that start with a dot ('.'). For the full description of {{C|s6-rc-compile}}, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

The {{Path|examples/source}} directory in the package's {{Path|/usr/share/doc}} subdirectory contains an example set of service definitions in {{C|s6-rc-compile}}'s source format for a few programs, taken from a working Linux system running Busybox and skarnet.org packages (without private information and without the supporting files elsewhere, like e.g. configuration files in {{Path|/etc}}).

==== Longrun definitions ====

A longrun definition in {{C|s6-rc-compile}}'s source format is a variation of an [[s6#Usage|s6 service directory]]. It must contain a file named {{Path|run}}, and can contain files named {{Path|finish}}, {{Path|notification-fd}}, {{Path|nosetsid}}, {{Path|timeout-finish}}, and {{Path|timeout-kill}}, with the same meaning and required content as for s6. On the other hand, {{Path|down}} files are ignored because longruns are managed using s6-rc tools that take care of these files themselves. And {{Path|log}} subdirectories or symbolic links are ignored too, because their functionality is replaced by pipelines (see [[#pipelines|longrun pipelining]]).

The {{Path|type}} file of a longrun definition must contain the word '''longrun''' followed by a newline. A longrun definition can also contain optional, regular files named {{Path|dependencies}} (see [[#dependencies|service dependencies]]), {{Path|timeout-up}} and {{Path|timeout-down}} (see [[#manage|managing services]]). If the service is a member of a pipeline, the longrun definition must also contain a regular file named {{Path|producer-for}} or {{Path|consumer-for}}, and can contain an optional, regular file named {{Path|pipeline-name}}. And finally, a longrun definition can also contain subdirectories named {{Path|data}} and {{Path|env}}, for use by the {{Path|run}} and {{Path|finish}} files. Their content is ignored by {{C|s6-rc-compile}}. {{Path|env}} is customarily an environment directory used by an {{C|s6-envdir}} invocation in {{Path|run}} or {{Path|finish}}, and {{Path|data}} is customarily used for other support files. For example, to hold rules directories or rules files for tools like {{C|[[s6#fdholder|s6-fdholderd]]}} and {{C|[[s6#superserver|s6-ipcserver-access]]}}, or to hold a {{Path|check}} file for {{C|s6-notifyoncheck}}.

Longrun definitions are 'compiled' by {{C|s6-rc-compile}} to actual s6 service directories. The program automatically sets appropriate permissions for files with meaning defined by s6 (e.g. '''0755''' for {{Path|run}} and {{Path|finish}}, '''0644''' for {{Path|notification-fd}}, etc.), so s6-rc service definitions do not need to have them set correctly. It only matters that {{C|s6-rc-compile}}'s effective user is allowed to read them. The compiled s6 service directories are copied to the live state directory and linked from the scan directory of a running {{C|s6-svscan}} process by the {{C|s6-rc-init}} program (see [[#initialization|initializing s6-rc]]). The {{Path|data}} and {{Path|env}} subdirectories are copied verbatim to the s6 service directory, and {{Path|down}} files are created or removed in it as needed by s6-rc programs. For the full description of the longrun definition source format, please consult {{C|s6-rc-compile}}'s HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

Example definition in source format for a longrun named ''test-longrun'':
{{Cmd|ls -l test-longrun|
output=<pre>total 16
-rw-r--r-- 1 user user 130 Mar 20 12:00 finish
-rw-r--r-- 1 user user   2 Mar 20 12:00 notification-fd
-rw-r--r-- 1 user user  94 Mar 20 12:00 run
-rw-r--r-- 1 user user   8 Mar 20 12:00 type</pre>}}

{{FileBox|filename=test-longrun/type|1=longrun}}

{{FileBox|lang=bash|filename=test-longrun/run|
1=#!/bin/execlineb -P
foreground { echo test-daemon starting }
fdmove -c 2 1
test-daemon --s6=3}}

{{FileBox|filename=test-longrun/notification-fd|1=3}}

{{FileBox|lang=bash|filename=test-longrun/finish|
1=#!/bin/execlineb -S0
ifelse { test $1 = 256 } {
   echo test-daemon killed by signal $2
}
   echo test-daemon exited with code $1}}

This service's transition to up state spawns a long-lived process that executes a hypothetical {{C|test-daemon}} program. It is assumed that it supports the [[s6#s6readiness|s6 readiness notification protocol]] when passed an <code>--s6</code> option. The notification channel's file descriptor is '''3''', so there is a {{Path|notification-fd}} file specifying that. The {{Path|type}} file indicates that this service is a longrun, and the rest of the files are standard s6 service directory files. Messages are printed to {{Path|run}}'s and {{Path|finish}}'s standard output, so that service events can be tracked.
{{anchor|oneshots}}
==== Oneshot definitions ====

A oneshot definition in {{C|s6-rc-compile}}'s source format is a directory that must contain a regular file named {{Path|up}}, and can optionally contain a regular file named {{Path|down}}. This files encode the actions that must be performed to transition the service to up and down state, respectively. When s6-rc is asked to start or stop the service, it behaves '''as if''' it executed an <kbd>s6-sudo -e supervision-socket up</kbd> or <kbd>s6-sudo -e supervision-socket down</kbd> command, respectively, where ''supervision-socket'' would be the UNIX domain socket of an {{C|[[s6#s6sudo|s6-sudod]]}} process that runs with the same environment that is set up for longruns, and has been invoked as <kbd>s6-sudod execlineb -P</kbd>. {{C|execlineb}} is the script parser and launcher from the execline package ({{Package|dev-lang/execline}}). This means that the {{Path|up}} and {{Path|down}} files can have [https://www.skarnet.org/software/execline/execlineb.html execline syntax] (quoted strings, {}-blocks, backslash sequences, #-coments, etc.), and that it is possible to have them contain full execline scripts. However, because a program name that can be found by <var>PATH</var> search, or a program's absolute pathname, followed by program arguments, is a valid execline script, it is possible to use shell scripts for the oneshot's actions by simply invoking them in the {{Path|up}} and {{Path|down}} files.

An absent {{Path|down}} file is equivalent to an empty {{Path|down}} file. Because invoking {{C|execlineb}} with an empty file does nothing but making it exit with a 0 code, stopping the corresponding service performs no actions other than updating s6-rc's notion of the service state. The {{Path|type}} file of a oneshot definition must contain the word '''oneshot''' followed by a newline. A oneshot definition can also contain regular files named {{Path|dependencies}} (see [[#dependencies|service dependencies]]), {{Path|timeout-up}} and {{Path|timeout-down}} (see [[#manage|managing services]]). For the full description of the oneshot definition source format, please consult {{C|s6-rc-compile}}'s HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

Oneshot definitions are 'compiled' by {{C|s6-rc-compile}} to an array of strings, suitable as the 'argv' argument of a POSIX <code>execve()</code> call. {{C|s6-rc-compile}} actually performs execlineb-style parsing itself using the execline package's library, {{Path|libexecline}}. At the time of a service state transition, what s6-rc actually does is perform an {{C|s6-sudo}} invocation with the <code>-e</code> option and the UNIX domain socket of an internal support service named '''s6rc-oneshot-runner'''. {{Path|s6rc-oneshot-runner}} spawns a long-lived {{C|s6-sudod}} process; when a connection is made by an {{C|s6-sudoc}} client to this process' socket, an s6-rc internal program, {{C|s6-rc-oneshot-run}}, is executed with the arguments supplied by the client. {{C|s6-rc-oneshot-run}} accepts an action name ('up' or 'down') and the numerical encoding of a oneshot, that it uses to retrieve the corresponding compiled array of strings from the service database, and makes the <code>execve()</code> call that actually performs the oneshot's actions. This ensures that the {{C|s6-sudoc}} - {{C|s6-sudod}} mechanism is only used to run {{C|s6-rc-oneshot-run}}, so that only actions explicitly encoded in the database are executed. Because the {{Path|s6rc-oneshot-runner}} service is an s6-rc longrun, the corresponding {{C|s6-sudod}} process is supervised. Therefore, it runs with the environment set up by the s6 supervision tree used for longruns, which is inherited by its {{C|s6-rc-oneshot-run}} child process. This ensures that oneshot's actions are always performed in this known environment, and using {{C|s6-sudo}}'s <code>-e</code> option ensures that it is not accidentally modified by the {{C|s6-sudoc}} client's environment. {{C|s6-rc-compile}} automatically makes {{Path|s6rc-oneshot-runner}} a direct dependency of every oneshot. For further information about {{C|s6-rc-oneshot-run}}, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

Example definition in source format for a oneshot named ''test-oneshot'':
{{Cmd|ls -l test-oneshot|
output=<pre>total 12
-rw-r--r-- 1 user user 118 Mar 20 12:00 down
-rw-r--r-- 1 user user   8 Mar 20 12:00 type
-rw-r--r-- 1 user user 119 Mar 20 12:00 up</pre>}}

{{FileBox|filename=test-oneshot/type|1=oneshot}}

{{FileBox|lang=bash|filename=test-oneshot/up|
1=foreground { echo "Calling /home/user/s6-rc-scripts/real-script.sh..." }
/home/user/s6-rc-scripts/real-script.sh start}}

{{FileBox|lang=bash|filename=test-oneshot/down|
1=foreground { echo "Calling /home/user/s6-rc-scripts/real-script.sh..." }
/home/user/s6-rc-scripts/real-script.sh stop}}

This service's transition to up state executes a hypothetical {{C|real-script.sh}} shell script, located in {{Path|/home/user/s6-rc-scripts}}, with a '''start''' argument. Its transition to down state executes the same script, but with a '''stop''' argument instead. This shows how to use shell scripts, or any external executable file, with s6-rc. Messages are printed before the script's invocation so that service events can be tracked. The {{Path|type}} file indicates that this service is a oneshot. The oneshot's actions are actually encoded in {{C|real-script.sh}}:
{{FileBox|lang=bash|filename=/home/user/s6-rc-scripts/real-script.sh|
1=#!/bin/sh
echo real-script.sh invoked with arguments $@
case "$1" in
   start) echo Performing start actions ;;
   stop) echo Performing stop actions ;;
   *) echo Unrecognized argument ;;
esac}}
{{anchor|bundles}}
==== Service bundles ====

A service bundle is just a named group of services, created for administrative purposes. Because a bundle is also created with a service definition directory supplied to {{C|s6-rc-compile}}, and bundle names can be used in most places that expect a service name, the term ''service'' is loosely used to also refer to bundles, and the term ''atomic service'' is used to refer to either longruns or oneshots, but not bundles, when the distinction matters. In particular, bundles can be used to implement runlevel-like functionality if so desired, combined with the {{C|s6-rc -pu change}} command (see [[#dependencies|service dependencies]]). For examples of this, see [[#s6rcupdate|live updates to the service database]].

A service bundle definition in {{C|s6-rc-compile}}'s source format must contain a regular file named {{Path|contents}}. The {{Path|type}} file must contain the word '''bundle''' followed by a newline. The {{Path|contents}} file must contain a list of service names, one per line; the bundle will cointain all the corresponding services. Whitespace at the beginning of a line is ignored, but trailing whitespace is not. Lines starting with a hash sign ('#') are ignored. Names that refer to other bundles can be used in {{Path|contents}}; {{C|s6-rc-compile}} interprets them as referring to the set of atomic services contained in the named bundle. For the full description of the bundle definition source format, please consult {{C|s6-rc-compile}}'s HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

Example definition in source format for a service bundle named ''test-bundle'':
{{Cmd|ls -l test-bundle|
output=<pre>total 8
-rw-r--r-- 1 user user 26 Mar 20 12:00 contents
-rw-r--r-- 1 user user  7 Mar 20 12:00 type</pre>}}

{{FileBox|filename=test-bundle/type|1=bundle}}

{{FileBox|filename=test-bundle/contents|
1=test-longrun
test-oneshot}}

This bundle is comprised by atomic services ''test-longrun'' and ''test-oneshot''. The {{Path|type}} file indicates that this service is not an atomic service, but a bundle.
{{anchor|s6rcdb}}
====  Extracting information from a compiled database ====

Because the format of an s6-rc compiled service database is not human-readable, the package provides the {{C|s6-rc-db}} program for analyzing a compiled database, extracting information from it, and printing it in a user-friendly format. By default, the database read by {{C|s6-rc-db}} is the one currently associated with live state directory {{Path|/run/s6-rc}} (see [[#initialization|initializing s6-rc]]), unless it is passed an <code>-l</code> option followed by the (absolute or relative to the working directory) pathname of a different live state directory, or it is passed a <code>-c</code> option followed by the pathname of the database.

{{C|s6-rc-db}} accepts a ''subcommand'' that tells it what to print. Some of these subcommands are:

* '''help''': prints a help message.
* '''list''': lists service names that satisfy some condition specified by the subcommand's argument:
** '''all''' (i.e. <kbd>s6-rc-db list all</kbd>): lists the names of all atomic services and service bundles contained in the database.
** '''services''': lists the names of all atomic services contained in the database, i.e. the list does no include service bundle names.
** '''bundles''': lists the names of all service bundles contained in the database.
** '''longruns''': lists the names of all longruns contained in the database. This includes the s6-rc supporting services automatically added by {{C|s6-rc-compile}}.
** '''oneshots''': lists the names of all oneshots contained in the database.
* '''type''': displays the type of the service ('oneshot', 'longrun' or 'bundle') corresponding to the name supplied as the subcommand's argument.
* '''contents''': displays the list of atomic services contained in the service bundle corresponding to the name supplied as the subcommand's argument.
* '''atomics''': displays the fully resolved list of atomic services represented by a list of service names supplied as the subcommand's arguments. Atomic service names in the list will be displayed in the output as-is, and service bundle names will be replaced in the output by the names of its contained atomic services. Each service name will be listed only once, with no repetitions. This computation of an atomic service list is also performed by the {{C|s6-rc}} program, see [[#manage|managing services]].
* '''script''': displays the actions executed during state transitions of the oneshot corresponding to the name supplied as the subcommand's argument. If a <code>-u</code> option is passed to {{C|s6-rc-db}} (''before'' the subcommand name), the output is the string sequence produced by {{C|s6-rc-compile}}'s parsing of the {{Path|up}} file from the oneshot's definition in {{C|s6-rc-compile}}'s source format. If a <code>-d</code> option is passed to {{C|s6-rc-db}}, the output is the string sequence produced by {{C|s6-rc-compile}}'s parsing of the {{Path|down}} file from the oneshot's definition. If there is neither a <code>-u</code> option nor a <code>-d</code> option, {{C|s6-rc-db}} behaves as if the <code>-u</code> option had been specified. Each string in the sequence is terminated by a null character, so it is usually necessary to pipe {{C|s6-rc-db}}'s output to something like {{C|xargs -0}}.

Other {{C|s6-rc-db}} subcommands can be used to display dependency information (see [[#dependencies|service dependencies]]), state transition timeouts (see [[#manage|managing services]]) and pipeline information (see [[#pipelines|longrun pipelining]]). For the full description of {{C|s6-rc-db}}, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

Example directories ''srv-src1'' and ''srv-src2'' containing service definition subdirectories in {{C|s6-rc-compile}}'s source format:
{{Cmd|ls -l srv-src*|
output=<pre>srv-src1:
total 12
drwxr-xr-x 2 user user 4096 Mar 20 12:00 test-bundle
drwxr-xr-x 2 user user 4096 Mar 20 12:00 test-longrun
drwxr-xr-x 2 user user 4096 Mar 20 12:00 test-oneshot

srv-src2:
total 12
drwxr-xr-x 2 user user 4096 Mar 20 12:00 all-services
drwxr-xr-x 2 user user 4096 Mar 20 12:00 another-longrun
drwxr-xr-x 2 user user 4096 Mar 20 12:00 another-oneshot</pre>}}

Directory {{Path|srv-src1}} contains definitions for the example services described in previous sections. Directory {{Path|srv-src2}} contains another set of service definitions. ''all-services'' is a bundle:
{{FileBox|filename=srv-src2/all-services/type|1=bundle}}

{{FileBox|filename=srv-src2/all-services/contents|
1=test-bundle
another-longrun
another-oneshot}}

Note that the {{Path|contents}} file contains names of both atomic services (''another-longrun'' and ''another-oneshot'') and bundles (''test-bundle'').

An s6-rc compiled service database ''test-database1'' can be created from {{Path|srv-src1}} and {{Path|srv-src2}} by invoking {{C|s6-rc-compile}} with their pathnames as arguments:
{{Cmd|collapse-output=true |s6-rc-compile -v 3 -u $(id -u) test-database1 srv-src1 srv-src2|
output=<pre>s6-rc-compile: info: parsing srv-src1/test-bundle
s6-rc-compile: info: test-bundle has type bundle
s6-rc-compile: info: parsing srv-src1/test-longrun
s6-rc-compile: info: test-longrun has type longrun
s6-rc-compile: info: parsing srv-src1/test-oneshot
s6-rc-compile: info: test-oneshot has type oneshot
s6-rc-compile: info: parsing srv-src2/all-services
s6-rc-compile: info: all-services has type bundle
s6-rc-compile: info: parsing srv-src2/another-longrun
s6-rc-compile: info: another-longrun has type longrun
s6-rc-compile: info: parsing srv-src2/another-oneshot
s6-rc-compile: info: another-oneshot has type oneshot
s6-rc-compile: info: making bundles for pipelines
s6-rc-compile: info: resolving bundle names
s6-rc-compile: info: converting bundle array
s6-rc-compile: info: resolving service names
s6-rc-compile: info: converting service dependency array
s6-rc-compile: info: checking database correctness
s6-rc-compile: info: writing compiled information to test-database1
s6-rc-compile: info: writing test-database1/n
s6-rc-compile: info: writing test-database1/resolve.cdb
s6-rc-compile: info: writing test-database1/db
s6-rc-compile: info: writing test-database1/servicedirs</pre>}}

The <code>-u</code> option is needed so that the {{C|s6-rc}} program can be used to manage oneshots by the nonprivileged user that created the database. The <code>-v 3</code> option makes the output of {{C|s6-rc-compile}} more verbose. The resulting database is a directory:
{{Cmd|ls -l test-database1|
output=<pre>total 16
-rw-r--r-- 1 user user  646 Mar 20 12:05 db
-rw-r--r-- 1 user user    0 Mar 20 12:05 lock
-rw-r--r-- 1 user user   24 Mar 20 12:05 n
-rw-r--r-- 1 user user 2397 Mar 20 12:05 resolve.cdb
drwxr-xr-x 6 user user 4096 Mar 20 12:05 servicedirs</pre>}}

The {{Path|servicedirs}} subdirectory contains the s6 service directories generated for all longruns, including those of automatically included s6-rc supporting services:
{{Cmd|ls -l test-database1/servicedirs|
output=<pre>total 16
drwxr-xr-x 2 user user 4096 Mar 20 12:05 another-longrun
drwxr-xr-x 3 user user 4096 Mar 20 12:05 s6rc-fdholder
drwxr-xr-x 3 user user 4096 Mar 20 12:05 s6rc-oneshot-runner
drwxr-xr-x 2 user user 4096 Mar 20 12:05 test-longrun</pre>}}

{{Cmd|ls -l test-database1/servicedirs/test-longrun|
output=<pre>total 12
-rwxr-xr-x 1 user user 130 Mar 20 12:05 finish
-rw-r--r-- 1 user user   2 Mar 20 12:05 notification-fd
-rwxr-xr-x 1 user user  94 Mar 20 12:05 run</pre>}}

This shows that the {{Path|run}} and {{Path|finish}} files are executable, as expected by {{C|s6-supervise}}, even if the corresponding ones in the s6-rc service definition were not. Listing all service names in the resulting compiled database:
{{Cmd|s6-rc-db -c test-database1 list all {{!}} sort|
output=<pre>all-services
another-longrun
another-oneshot
s6rc-fdholder
s6rc-oneshot-runner
test-bundle
test-longrun
test-oneshot</pre>}}

This shows that the created database contains the union of the services defined in subdirectories of {{Path|srv-src1}}, and the services defined in subdirectories of {{Path|srv-src2}}. Listing service names by type:
{{Cmd|s6-rc-db -c test-database1 list longruns {{!}} sort|
output=<pre>another-longrun
s6rc-fdholder
s6rc-oneshot-runner
test-longrun</pre>}}

{{Cmd|s6-rc-db -c test-database1 list oneshots {{!}} sort|
output=<pre>another-oneshot
test-oneshot</pre>}}

{{Cmd|s6-rc-db -c test-database1 list bundles {{!}} sort|
output=<pre>all-services
test-bundle</pre>}}

Displaying the type of different services:
{{Cmd|s6-rc-db -c test-database1 type all-services|output=<pre>bundle</pre>}}

{{Cmd|s6-rc-db -c test-database1 type test-longrun|output=<pre>longrun</pre>}}

{{Cmd|s6-rc-db -c test-database1 type another-oneshot|output=<pre>oneshot</pre>}}

Displaying the contents of service bundles:
{{Cmd|s6-rc-db -c test-database1 contents test-bundle {{!}} sort|
output=<pre>test-longrun
test-oneshot</pre>}}

{{Cmd|s6-rc-db -c test-database1 contents all-services {{!}} sort|
output=<pre>another-longrun
another-oneshot
test-longrun
test-oneshot</pre>}}

This shows that, because the {{Path|contents}} file in the definition of bundle {{Path|all-services}} named the bundle {{Path|test-bundle}}, all atomic services contained in the latter became members of the former. Displaying the string sequence compiled from the {{Path|up}} and {{Path|down}} files of a oneshot:
{{Cmd|s6-rc-db -uc test-database1 script test-oneshot {{!}} xargs -0 printf '"%s"\n'|
output=<pre>"foreground"
" echo"
" Calling /home/user/s6-rc-scripts/real-script.sh..."
""
"/home/user/s6-rc-scripts/real-script.sh"
"start"</pre>}}

{{Cmd|s6-rc-db -dc test-database1 script test-oneshot {{!}} xargs -0 printf '"%s"\n'|
output=<pre>"foreground"
" echo"
" Calling /home/user/s6-rc-scripts/real-script.sh..."
""
"/home/user/s6-rc-scripts/real-script.sh"
"stop"</pre>}}

Notice the result of execlineb-style processing: the quoted strings that were arguments of the {{C|echo}} utility become single elements in the compiled sequence of strings even if they contain whitespace, and {}-blocks become a sequence of arguments that start with a space, terminated by an empty string, [https://www.skarnet.org/software/execline/el_semicolon.html a format recognized by all execline programs], including {{C|foreground}}.

Resolving some atomic service sets:
{{Cmd|s6-rc-db -c test-database1 atomics another-oneshot test-bundle {{!}} sort|
output=<pre>another-oneshot
test-longrun
test-oneshot</pre>}}

This shows that because {{Path|another-oneshot}} is an atomic service, it is included as-is in the output, and because {{Path|test-bundle}} is a bundle, it is replaced in the output by the set of atomic services it contains.
{{Cmd|s6-rc-db -c test-database1 atomics another-longrun all-services {{!}} sort|
output=<pre>another-longrun
another-oneshot
test-longrun
test-oneshot</pre>}}

This shows that bundle ''all-services'' is replaced by the set of atomic services it contains, and because that set includes {{Path|another-longrun}}, this service is listed only once.
{{anchor|initialization}}
=== Initializing s6-rc ===

s6-rc must be initialized with a [[#database|compiled service database]] and an [[s6#Usage|s6 supervision tree]], that is used to supervise longruns and to provide the environment used for performing oneshots' actions. The program that performs this initialization is {{C|s6-rc-init}}.

{{C|s6-rc-init}} accepts the absolute pathname of a scan directory, that must have a corresponding {{C|s6-svscan}} process already running. The service database is assumed to be {{Path|/etc/s6-rc/compiled}}. A different (absolute) pathname can be specified with a <code>-c</code> option. {{C|s6-rc-init}} creates a ''live state directory'' that associates the s6-rc service database with the s6 supervision tree, and keeps track of service states. The live state directory must be in a read-write filesystem, and defines an s6-rc 'instance'. The live state directory is {{Path|/run/s6-rc}} by default; a different (absolute) pathname can be specified with an <code>-l</code> option. {{Path|/run/s6-rc}} is actually a symbolic link to a directory created by {{C|s6-rc-init}} in {{Path|/run}}; this is necessary for the operation of the {{C|s6-rc-update}} program (see [[#s6rcupdate|live updates to the service database]]). Similarly, if the <code>-l</code> option is used, {{C|s6-rc-init}} it will create both a symbolic link with that pathname, and a subdirectory in the directory containing the symlink.

A compiled database that becomes associated with a live state directory by using {{C|s6-rc-init}}, {{C|s6-rc-update}} or {{C|s6-rc-format-upgrade}} is said to ''be live''. A database that is not live can be freely moved around in the filesystem, but once it becomes live, it must not move anymore and must not be deleted. A database stops being live if it is deassociated from the live state directory by {{C|s6-rc-update}} or {{C|s6-rc-format-upgrade}}, or if the corresponding s6 supervision torn down (e.g. by {{C|s6-svscanctl -t}}).

The s6-rc live state directory also contains a copy of the compiled s6 service directories of all longruns in the service database. {{C|s6-rc-init}} creates a symbolic link to each of them in the specified scan directory, so that the corresponding program can be run as a supervised process, and performs the equivalent an {{C|s6-svscanctl -a}} command to make {{C|s6-svscan}} perform a scan. The initial state of all atomic services after the invocation of {{C|s6-rc-init}} is '''down'''. In the case of longruns, {{C|s6-rc-init}} enforces this by creating {{Path|down}} files in each of their service directories, so that their {{C|s6-supervise}} processes do not execute the {{Path|run}} file. {{C|s6-rc-init}} also accepts a <code>-p</code> option followed by a prefix, that prepends the specified prefix to the name of every longrun when creating the symlinks in the scan directory. For example, if a longrun's name is ''name'', <kbd>s6-rc-init -p instance-1:</kbd> will name the symlink ''instance-1:name''. This allows the sharing of a single s6 supervision tree among different 'instances' of s6-rc, i.e. among s6-rc-managed services associated with different live state directories.

Support services {{Path|s6rc-oneshot-runner}} and {{Path|s6rc-fdholfer}} use UNIX domain sockets, and s6 access control tools to decide whether to grant or refuse service to clients that connect to these sockets. By default, they only grant access to ''root'', but this can be modified by passing <code>-u</code> and <code>-g</code> options to {{C|s6-rc-compile}}, followed by a comma-separated list of numerical user IDs and group IDs, respectively. These options are used to construct [[s6#superserver|rules directories]]: user IDs specified with <code>-u</code> are used for the {{Path|uid}} subdirectory, and group IDs specified with <code>-g</code> are used for the {{Path|gid}} subdirectory. If any of these options are used, root's UID or the GID of a group it is a member of must be explicitly specified to grant it access. For further information about {{C|s6-rc-compile}}, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

Example s6 scan directory containing a supervised logger with a FIFO, that logs supervision tree messages in a similar way to that of [[s6 and s6-rc-based init system#logger|the catch-all logger of an s6 and s6-rc-based init system]]:
{{Cmd|ls -ld * .s6-svscan|
output=<pre>drwxr-xr-x 2 user user 4096 Mar 30 12:00 logger
drwxr-xr-x 2 user user 4096 Mar 30 12:00 .s6-svscan</pre>}}

{{Cmd|ls -l logger|
output=<pre>total 4
prw------- 1 user user   0 Mar 30 12:00 fifo
-rwxr-xr-x 1 user user 144 Mar 30 12:00 run</pre>}}

{{FileBox|lang=bash|filename=logger/run|
1=#!/bin/execlineb -P
redirfd -w 1 /dev/null
redirfd -rnb 0 fifo
foreground {
   fdmove -c 1 2
   echo Starting logger...
}
s6-log t ../../logdir}}

Starting the supervision tree, assuming that the working directory is the scan directory:

{{Cmd|redirfd -wnb 1 logger/fifo s6-svscan &|
output=<pre>[1] 2460
Starting logger...</pre>}}

{{Cmd|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre> PID  PPID  PGRP EUSER    COMMAND
...
2130  2123  2130 user     -bash
2460  2130  2460 user      \_ s6-svscan
2461  2460  2460 user          \_ s6-supervise logger
2462  2461  2462 user              \_ s6-log t ../../logdir
...</pre>}}

Initializing s6-rc with this supervision tree and the example database ''test-database1'' from section [[#s6rcdb|"extracting information from a compiled database"]], assuming that it is located in {{Path|/home/user}}:

{{Cmd|s6-rc-init -c /home/user/test-database1 -l /home/user/live "$(pwd)"|ls -l|
output=<pre>total 12
lrwxrwxrwx 1 user user   43 Mar 30 12:10 another-longrun -> /home/user/live/servicedirs/another-longrun
drwxr-xr-x 4 user user 4096 Mar 30 12:05 logger
lrwxrwxrwx 1 user user   41 Mar 30 12:10 s6rc-fdholder -> /home/user/live/servicedirs/s6rc-fdholder
lrwxrwxrwx 1 user user   47 Mar 30 12:10 s6rc-oneshot-runner -> /home/user/live/servicedirs/s6rc-oneshot-runner
lrwxrwxrwx 1 user user   40 Mar 30 12:10 test-longrun -> /home/user/live/servicedirs/test-longrun</pre>}}

This creates the live state directory in {{Path|/home/user}}, and, as shown, symbolic links in the scan directory.
{{Cmd|ls -l ../live|
output=<pre>lrwxrwxrwx 1 user user 22 Mar 30 12:10 ../live -> live:s6-rc-init:peEEK3</pre>}}

This shows that {{Path|/home/user/live}} is actually a symbolic link to subdirectory {{Path|live:s6-rc-init:peEEK3}} of {{Path|/home/user}}:
{{Cmd|ls -l ../live:s6-rc-init:peEEK3|
output=<pre>total 8
lrwxrwxrwx 1 user user   25 Mar 30 12:10 compiled -> /home/user/test-database1
-rw-r--r-- 1 user user    0 Mar 30 12:10 prefix
lrwxrwxrwx 1 user user   15 Mar 30 12:10 scandir -> /home/user/scan
drwxr-xr-x 6 user user 4096 Mar 30 12:10 servicedirs
-rw-r--r-- 1 user user    6 Mar 30 12:10 state</pre>}}

Updated supervision tree:
{{Cmd|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre> PID  PPID  PGRP EUSER    COMMAND
...
2130  2123  2130 user     -bash
2460  2130  2460 user      \_ s6-svscan
2461  2460  2460 user          \_ s6-supervise logger
2462  2461  2462 user          |   \_ s6-log t ../../logdir
2471  2460  2460 user          \_ s6-supervise test-longrun
2472  2460  2460 user          \_ s6-supervise s6rc-oneshot-runner
2473  2460  2460 user          \_ s6-supervise s6rc-fdholder
2474  2460  2460 user          \_ s6-supervise another-longrun
...</pre>}}

This shows that none of the longruns is in up state: only their supervisor is running. Service directory of ''test-longrun'':
{{Cmd|ls -l ../live/servicedirs/test-longrun|
output=<pre>total 20
-rw-r--r-- 1 user user    0 Mar 30 12:10 down
drwx-ws--T 2 user user 4096 Mar 30 12:10 event
-rwxr-xr-x 1 user user  130 Mar 30 12:10 finish
-rw-r--r-- 1 user user    2 Mar 30 12:10 notification-fd
-rwxr-xr-x 1 user user   94 Mar 30 12:10 run
drwx------ 2 user user 4096 Mar 30 12:10 supervise</pre>}}

This shows that {{C|s6-rc-init}} created a {{Path|down}} file. Subdirectories {{Path|event}} and {{Path|supervise}} are created by the corresponding {{C|s6-supervise}} process (process 2471 in this example). From s6's point of view, the service is down:
{{Cmd|s6-svstat test-longrun|
output=<pre>down (exitcode 0) 337 seconds, ready 337 seconds</pre>}}

Another example using prefixes:
{{Cmd|mv srv-src2/all-services srv-src2/.all-services|s6-rc-compile -u $(id -u) db-instance-1 srv-src1|s6-rc-compile -u $(id -u) db-instance-2 srv-src2}}

Service definitions in directories {{Path|srv-src1}} and {{Path|srv-src2}} are now compiled to separate databases, ''db-instance-1'' and ''db-instance-2''. The definition directory of bundle {{Path|all-services}} was renamed to start with a dot so that {{C|s6-rc-compile}} ingores it. After changing to scan directory {{Path|/home/user/scan}} and starting a supervision tree again with command <kbd>redirfd -wnb 1 logger/fifo s6-svscan &</kbd>:
{{Cmd|s6-rc-init -c /home/user/db-instance-1 -p instance-1: -l /home/user/live1 /home/user/scan|s6-rc-init -c /home/user/db-instance-2 -p instance-2: -l /home/user/live2 /home/user/scan|ls -l *|
output=<pre>total 24
lrwxrwxrwx 1 user user   42 Apr 29 12:10 instance-1:s6rc-fdholder -> /home/user/live1/servicedirs/s6rc-fdholder
lrwxrwxrwx 1 user user   48 Apr 29 12:10 instance-1:s6rc-oneshot-runner -> /home/user/live1/servicedirs/s6rc-oneshot-runner
lrwxrwxrwx 1 user user   41 Apr 29 12:10 instance-1:test-longrun -> /home/user/live1/servicedirs/test-longrun
lrwxrwxrwx 1 user user   44 Apr 29 12:11 instance-2:another-longrun -> /home/user/live2/servicedirs/another-longrun
lrwxrwxrwx 1 user user   42 Apr 29 12:11 instance-2:s6rc-fdholder -> /home/user/live2/servicedirs/s6rc-fdholder
lrwxrwxrwx 1 user user   48 Apr 29 12:11 instance-2:s6rc-oneshot-runner -> /home/user/live2/servicedirs/s6rc-oneshot-runner
drwxr-xr-x 4 user user 4096 Apr 29 12:05 logger</pre>}}

This shows that the symbolic links to the s6 service directories have different prefixes depending on which live state directory the corresponding logrun is associated with. Live state directory {{Path|/home/user/live1}} is associated with compiled service database {{Path|db-instance-1}}, and live state directory {{Path|/home/user/live2}} is associated with compiled service database {{Path|db-instance-2}}. Each of these can be thought as a different s6-rc 'instance', even if they share the same s6 supervision tree and scan directory. The corresponding services are independent:
{{Cmd|ls -l ../live*|
output=<pre>lrwxrwxrwx 1 user user   23 Apr 29 12:10 ../live1 -> live1:s6-rc-init:ISOd2e
lrwxrwxrwx 1 user user   23 Apr 29 12:11 ../live2 -> live2:s6-rc-init:AtGbln

'../live1:s6-rc-init:ISOd2e':
total 12
lrwxrwxrwx 1 user user   24 Apr 29 12:10 compiled -> /home/user/db-instance-1
-rw-r--r-- 1 user user   11 Apr 29 12:10 prefix
lrwxrwxrwx 1 user user   15 Apr 29 12:10 scandir -> /home/user/scan
drwxr-xr-x 5 user user 4096 Apr 29 12:10 servicedirs
-rw-r--r-- 1 user user    4 Apr 29 12:10 state

'../live2:s6-rc-init:AtGbln':
total 12
lrwxrwxrwx 1 user user   24 Apr 29 12:11 compiled -> /home/user/db-instance-2
-rw-r--r-- 1 user user   11 Apr 29 12:11 prefix
lrwxrwxrwx 1 user user   15 Apr 29 12:11 scandir -> /home/user/scan
drwxr-xr-x 5 user user 4096 Apr 29 12:11 servicedirs
-rw-r--r-- 1 user user    4 Apr 29 12:11 state
</pre>}}

{{Cmd|s6-rc-db -l ../live1 list all {{!}} sort|
output=<pre>s6rc-fdholder
s6rc-oneshot-runner
test-bundle
test-longrun
test-oneshot</pre>}}

{{Cmd|s6-rc-db -l ../live2 list all {{!}} sort|
output=<pre>another-longrun
another-oneshot
s6rc-fdholder
s6rc-oneshot-runner
</pre>}}
{{anchor|manage}}
=== Managing services ===

The s6-rc package provides one program, also named {{C|s6-rc}}, to perform most of the service management tasks after initialization has been done. {{C|s6-rc}} accepts a ''subcommand'' that specifies what to do. The subcommands are:

* '''help''': prints a help message.
* '''list''': displays the fully resolved list of atomic services represented by a list of service names supplied as the subcommand's arguments, just like {{C|s6-rc-db atomics}} (see [[#s6rcdb|extracting information from a compiled database]]). This list of atomic services is called ''the selection''.
* '''change''': computes the selection in the same way as the <code>list</code> subcommand, and performs state transitions for all atomic services in the resulting list. If a <code>-u</code> option ('up') is passed to {{C|s6-rc}} (''before'' the subcommand name), the requested action is to start all services in the selection, i.e. transition them to up state. If a <code>-d</code> option ('down') is passed to {{C|s6-rc}}, the requested action is to stop all services in the selection, i.e. transition them to down state. If there is neither a <code>-u</code> nor a <code>-d</code> option, {{C|s6-rc}} behaves as if the <code>-u</code> option had been supplied. If an <code>-n</code> option ('dry run') followed by an integral value is passed to {{C|s6-rc}}, state transitions are simulated instead of actually performed (see later).
* '''diff''': checks the consistency between s6-rc's view of the state of all longruns (as recorded in the live state directory), and s6's view (as recorded in the {{Path|state}} file of the service's {{Path|supervise}} control directory). This subcommand should normally report nothing, but directly using some s6 programs with s6-rc-managed longruns can cause state discrepancies. For example, if a longrun is in down state, and an {{C|s6-svc -u}} command with its symlink in the scan directory is used instead of an {{C|s6-rc -u change}} command with its service name, not only would that run the underlying program (without also starting services that were specified as dependencies), but it would also make s6 view the process' state as up (as reported by {{C|s6-svstat}}), while s6-rc would still view the corresponding service as down. The <code>diff</code> subcommand prints a line for each longrun it finds that has a state inconsistency, prepended by a plus sign ('+') if s6 considers it to be up, and a minus plus sign ('-') if s6 considers it to be down.
* '''listall''': displays the computed closed selection, see [[#dependencies|service dependencies]]).

Unlike {{C|s6-rc-db}}, which operates exclusively on a compiled database, {{C|s6-rc}} operates on the live state directory. Therefore, it has knowledge of not only the associated database, but also of service states. The live state directory is {{Path|/run/s6-rc}} by default, but a different one can be used by passing an <code>-l</code> option to {{C|s6-rc}} with the directory's pathname (absoulte or relative to {{C|s6-rc}}'s working directory). {{C|s6-rc-db}} can be used both with live and non-live databases, but in the latter case, the database's pathname has to be specified with a <code>-c</code> option.

Because {{C|s6-rc}} is aware of service states, it accepts an <code>-a</code> ('active') option for both its <code>list</code> and <code>change</code> subcommands, that adds the current set of atomic services in up state to the initial selection derived from the subcomannd's arguments. {{C|s6-rc}} also accepts the <code>-d</code> option for its <code>list</code> subcommand, but the meaning in this case is to ''complement'' the initial selection derived from the subcomannd's arguments (plus the active services if the <code>-a</code> option is also present), i.e. the final selection is the set of all atomic services in the live state directory's associated database that '''are not''' in the initial selection. For completeness, {{C|s6-rc}} also accepts an explicit <code>-u</code> option for its <code>list</code> subcommand, that does nothing. For both <code>list</code> and <code>change</code>, the supplied list of service names can be empty, meaning an (initial) ''empty selection''. {{C|s6-rc list}} is mostly useful in conjunction with the <code>-a</code> or <code>-d</code> options.

s6-rc also has a notion of ''transition success'' and ''transition failure''. For a longrun, if its underlying program supports the [[s6#s6readiness|s6 readiness notification protocol]], transition to up state is considered successful if the supervised process is up and ready before the expiry of a timeout. Otherwise, transition to up is considered successful if the supervised process is up before the expiry of a timeout, i.e. when its supervisor has spawned a {{Path|run}} child. The {{C|s6-rc -u change}} command uses an {{C|s6-svc -uwU}} or {{C|s6-svc -uwu}} command, respectively, to start the supervised process, so it will wait until it [[s6#s6notification|receives a notification]] of the relevant event from {{C|s6-supervise}}. Transition to down state is considered successful if the supervised process is really down before the expiry of a timeout, i.e. if it is down and the {{C|finish}} file, if present, was executed and has exited (or got killed by {{C|s6-supervise}} because of a {{Path|timeout-finish}} file). The {{C|s6-rc -d change}} command uses an {{C|s6-svc -dwD}} command to stop the supervised process, so it will wait until it receives the really down notification from {{C|s6-supervise}}. If a transition to up fails, the {{C|s6-rc -u change}} command then uses an {{C|s6-svc -d}} command to bring the supervised process to a known down state. For a oneshot, transition to up or down state is considered successful if the equivalent of executing the {{Path|up}} or {{Path|down}} file from its service definition, respectively, that is performed by the {{C|s6-rc-oneshot-run}} program, exits with code 0 before the expiry of a timeout (see [[#oneshots|oneshot definitions]]). The {{C|s6-rc change}} command waits for {{C|s6-rc-oneshot-run}} to finish. For the full description of the {{C|s6-rc}} program, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

Supporting service {{Path|s6rc-oneshot-runner}} uses a rules directory to decide whether to grant or refuse service to clients that connect to its UNIX domain socket. The {{C|s6-rc}} program executes a {{C|sudo -e}} command with {{Path|s6rc-oneshot-runner}}'s socket to start or stop a oneshot, so {{C|s6-rc}}'s effective user must be allowed by this service's rules directory. Setup of {{Path|s6rc-oneshot-runner}}'s rules directory can be done using {{C|s6-rc-compile}}'s <code>-u</code> and <code>-g</code> options, see [[#initialization|initializing s6-rc]].

The timeout for a state transition can be configured by including regular files named {{Path|timeout-up}} and {{Path|timeout-down}} in the definition of an atomic service submitted to {{C|s6-rc-compile}}, that must contain an integral time value in milliseconds. The former specifies the timeout for the transition to up, and the latter, for the transition to down. If any of these files is absent or contains the value '''0''', the corresponding timeout is infinite, i.e. the {{C|s6-rc change}} command will wait forever for the notification of the relevant event from {{C|s6-supervise}} in the case of a longrun, and will wait forever for {{C|s6-rc-oneshot-run}} to exit, in the case of a oneshot. For further information about configuration of state transition timeouts, please consult {{C|s6-rc-compile}}'s HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory. The '''timeout''' subcommand of the {{C|s6-rc-db}} program prints the state transition timeouts. The up timeout is printed if a <code>-u</code> option is passed to {{C|s6-rc-db}}, and the down timeout is printed if a <code>-d</code> option is passed to {{C|s6-rc-db}}. If there is neither a <code>-u</code> option nor a <code>-d</code> option, {{C|s6-rc-db}} behaves as if the <code>-u</code> option had been specified. For further information, please consult {{C|s6-rc-db}}'s HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory. 

{{C|s6-rc change}} calls the internal program {{C|s6-rc-dryrun}} instead of {{C|s6-svc}} or {{C|s6-sudo}} when the <code>-n</code> option is specified, which makes {{C|s6-rc}} print to standard output what the command would have done without the <code>-n</code> option. The option must be followed by integral time value in milliseconds; {{C|s6-rc-dryrun}} will sleep for the specified time before exiting, to simulate an {{C|s6-svc}} or {{C|s6-sudo}} invocation that does not complete immediately. For further information about {{C|s6-rc-dryrun}}, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

Example usage of {{C|s6-rc}} to print a list of all atomic services in the compiled database that is live, assuming the setup from the first example of section [[#initialization|"initializing s6-rc"]]:
{{Cmd|s6-rc -dl ../live list {{!}} sort|
output=<pre>another-longrun
another-oneshot
s6rc-fdholder
s6rc-oneshot-runner
test-longrun
test-oneshot</pre>}}

This works because no service names are provided, so the initial selection is empty, and then the <code>-d</code> option complements the selection. The complement of the empty set is 'the universe', i.e. the set of all atomic services in the compiled database. So this is the same as using an <kbd>s6-rc-db -l ../live list services | sort</kbd> command. Simulating a transition to up for service ''test-longrun'':
{{Cmd|s6-rc -n 10 -ul ../live change test-longrun|
output=<pre>s6-rc-dryrun: s6-svc -uwU -T 0 -- ../live/servicedirs/test-longrun</pre>}}

The service is a longrun, so this shows that it would be started with an {{C|s6-svc -u}} command. Option <code>-wU</code> makes the command wait for an up and ready notification from {{C|s6-supervise}}. Actually starting the service:
{{Cmd|time s6-rc -ul ../live change test-longrun|
output=<pre>
real	0m10.010s
user	0m0.002s
sys	0m0.000s</pre>}}

{{Cmd|cat ../logdir/current {{!}} s6-tai64nlocal|
output=<pre>2018-03-30 12:19:25.012770836 test-daemon starting</pre>}}

{{Cmd|s6-svstat test-longrun|
output=<pre>up (pid 2448) 38 seconds, ready 28 seconds</pre>}}

This shows that {{C|s6-rc -u change}} waited the approximately 10 seconds that were necessary for {{C|test-daemon}} become ready and notify {{C|s6-supervise}}.
{{Cmd|ls -l ../live/servicedirs/test-longrun|
output=<pre>total 20
drwx-ws--T 2 user user 4096 Mar 30 12:19 event
-rwxr-xr-x 1 user user  130 Mar 30 12:10 finish
-rw-r--r-- 1 user user    2 Mar 30 12:10 notification-fd
-rwxr-xr-x 1 user user   94 Mar 30 12:10 run
drwx------ 2 user user 4096 Mar 30 12:19 supervise</pre>}}

This shows that the {{Path|down}} file created by {{C|s6-rc-init}} was removed from {{Path|test-longrun}}'s compiled s6 service directory by the {{C|s6-rc -u change}} command. Simulating a transition to up for service ''test-oneshot'':
{{Cmd|s6-rc -n 10 -ul ../live change test-oneshot|
output=<pre>s6-rc-dryrun: s6-svc -uwU -T 0 -- ../live/servicedirs/s6rc-oneshot-runner
s6-rc-dryrun: s6-sudo -el0 -t 30000 -T 0 -- ../live/servicedirs/s6rc-oneshot-runner/s up 3  # test-oneshot</pre>}}

The service is a oneshot, so this shows that it would be started with an {{C|s6-sudo -e}} command that connects to {{Path|s6rc-oneshot-runner}}'s socket ({{Path|/home/user/live/servicedirs/s6rc-oneshot-runner/s}}), and passes arguments 'up' and '3'. This in turn triggers execution of an {{C|s6-rc-oneshot-run up 3}} command. The output of {{C|s6-rc-dryrun}} is intended to be human readable, so it shows that numeric identifier '''3''' corresponds indeed to service {{Path|test-oneshot}} in the compiled service database. Because {{Path|s6rc-oneshot-runner}} is a dependency of {{Path|test-oneshot}} and was in down state, {{C|s6-rc}} would start it first (see [[#dependencies|service dependencies]]), and because {{Path|s6rc-oneshot-runner}} is a longrun, it would use an {{C|s6-svc -u}} command to do that. Actually starting the service:
{{Cmd|s6-rc -ul ../live change test-oneshot|
output=<pre>Calling /home/user/s6-rc-scripts/real-script.sh...
real-script.sh invoked with arguments start
Performing start actions</pre>}}

Because the {{C|s6-sudoc}} - {{C|s6-sudod}} mechanism is used for oneshots, and {{C|s6-sudoc}} transmits the file descriptors of its standard input, output and error to {{C|s6-sudod}} [[s6#fdholder|via fd-passing]], messages from the oneshot's executed programs are printed on {{C|s6-rc}}'s standard output, which is the interactive shell's controlling terminal in this case. Displaying the list of atomic services in up state:
{{Cmd|s6-rc -al ../live list {{!}} sort|
output=<pre>s6rc-oneshot-runner
test-longrun
test-oneshot</pre>}}

This works because no service names are provided, so the initial selection is empty, and then the <code>-a</code> option adds the set of atomic services in up state to it. It is also shown that {{Path|s6rc-oneshot-runner}} is also in up state.

Service bundle names can be used with {{C|s6-rc}} as a substitute of their contained atomic services:
{{Cmd|s6-rc-db -l ../live contents test-bundle {{!}} sort|
output=<pre>test-longrun
test-oneshot</pre>}}

{{Cmd|s6-rc -n 10 -dl ../live change test-bundle|
output=<pre>s6-rc-dryrun: s6-sudo -el0 -t 30000 -T 0 -- ../live/servicedirs/s6rc-oneshot-runner/s down 3  # test-oneshot
s6-rc-dryrun: s6-svc -dwD -T 0 -- ../live/servicedirs/test-longrun</pre>}}

This shows that stopping bundle ''test-bundle'' is the same as individually stopping {{Path|test-longrun}} and {{Path|test-oneshot}}. {{Path|test-longrun}} would be stopped with an {{C|s6-svc -d}} command; option <code>-wD</code> makes the command wait for a really down notification from {{C|s6-supervise}}. {{Path|test-oneshot}} would be stopped with an {{C|s6-sudo -e}} command that connects to {{Path|s6rc-oneshot-runner}}'s socket, and passes arguments 'down' and '3'. This in turn triggers execution of an {{C|s6-rc-oneshot-run down 3}} command.
{{Cmd|s6-rc -dl ../live change test-bundle|
output=<pre>Calling /home/user/s6-rc-scripts/real-script.sh...
real-script.sh invoked with arguments stop
Performing stop actions</pre>}}

{{Cmd|s6-svstat test-longrun|
output=<pre>down (exitcode 0) 17 seconds, ready 17 seconds</pre>}}

{{Cmd|cat ../logdir/current {{!}} s6-tai64nlocal|
output=<pre>2018-03-30 12:19:25.012770836 test-daemon starting
2018-03-30 12:25:50.314271979 test-daemon exited with code 0</pre>}}

This shows that {{C|s6-rc -d change}} stopped all atomic services contained in the bundle.
{{Cmd|ls -l ../live/servicedirs/test-longrun|
output=<pre>total 20
-rw-r--r-- 1 user user    0 Mar 30 12:25 down
drwx-ws--T 2 user user 4096 Mar 30 12:25 event
-rwxr-xr-x 1 user user  130 Mar 30 12:10 finish
-rw-r--r-- 1 user user    2 Mar 30 12:10 notification-fd
-rwxr-xr-x 1 user user   94 Mar 30 12:10 run
drwx------ 2 user user 4096 Mar 30 12:25 supervise</pre>}}

This shows that {{C|s6-rc -d change}} created a {{Path|down}} file in this longrun's service directory.
{{Cmd|s6-rc -ul ../live list all-services {{!}} sort|
output=<pre>another-longrun
another-oneshot
test-longrun
test-oneshot</pre>}}

Here the resulting selection of the {{C|s6-rc list}} command is the contents of bundle ''all-service'', so that's what is shown. This is the same as using an <kbd>s6-rc-db -l ../live atomics all-services | sort</kbd> command. Starting all atomic services in this selection:
{{Cmd|s6-rc -ul ../live change all-services|
output=<pre>Calling /home/user/s6-rc-scripts/real-script.sh...
real-script.sh invoked with arguments start
Performing start actions</pre>}}

{{Cmd|s6-rc -al ../live list {{!}} sort|
output=<pre>
another-longrun
another-oneshot
s6rc-oneshot-runner
test-longrun
test-oneshot
</pre>}}

Updated supervision tree:
{{Cmd|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre> PID  PPID  PGRP EUSER    COMMAND
...
2130  2123  2130 user     -bash
2460  2130  2460 user      \_ s6-svscan
2461  2460  2460 user          \_ s6-supervise logger
2462  2461  2462 user          |   \_ s6-log t ../../logdir
2471  2460  2460 user          \_ s6-supervise test-longrun
2496  2471  2496 user          |   \_ test-daemon --s6=3
2472  2460  2460 user          \_ s6-supervise s6rc-oneshot-runner
2495  2472  2495 user          |   \_ s6-ipcserverd -1 -- s6-ipcserver-access ... -- s6-sudod ... -- /usr/libexec/s6-rc-oneshot-run ...
2473  2460  2460 user          \_ s6-supervise s6rc-fdholder
2474  2460  2460 user          \_ s6-supervise another-longrun
2494  2474  2494 user              \_ test-daemon
...</pre>}}

This shows that longrun {{Path|another-longrun}} just spawns another {{C|test-daemon}} process, with readiness notification turned off, and that {{Path|s6rc-oneshot-runner}} launches an {{C|s6-ipcserverd}} process that, in turn, spawns an {{C|s6-sudod}} child for each client connection to its corresponding socket. {{C|s6-sudod}} executes program {{C|s6-rc-oneshot-run}} with the arguments supplied by the client.
{{Cmd|s6-svc -d another-longrun|s6-svstat another-longrun|
output=<pre>down (exitcode 0) 21 seconds, normally up, ready 21 seconds</pre>}}

Service {{Path|another-longrun}} is now actually in down state, because the underlying program is no longer running, but s6-rc doesn't know about it. This type of inconsistencies can be reported by an {{C|s6-rc diff}} command:
{{Cmd|s6-rc -l ../live diff|
output=<pre>-another-longrun</pre>}}

The minus sign ('-') confirms that s6 considers it down. A subsequent {{C|s6-rc -d change}} command that that contains {{Path|another-longrun}} in its closed selection (see [[#dependencies|service dependencies]]) will bring the service state in sync again:
{{Cmd|s6-rc -dl ../live change another-longrun|s6-rc -l ../live diff|s6-svstat another-longrun|
output=<pre>down (exitcode 0) 48 seconds, ready 48 seconds</pre>}}

The {{C|s6-rc -d change}} command uses an {{C|s6-svc -dwD}} command, which is a no operation and returns immediatly because the supervised process is already down, but the service state is now also down in s6-rc's view, so the the output of {{C|s6-rc diff}} is empty.

Stopping all services in the live compiled database:

{{Cmd|s6-rc -dal ../live change|
output=<pre>Calling /home/user/s6-rc-scripts/real-script.sh...
real-script.sh invoked with arguments stop
Performing stop actions</pre>}}

{{Cmd|cat ../logdir/current {{!}} s6-tai64nlocal|
output=<pre>2018-03-30 12:19:25.012770836 test-daemon starting
2018-03-30 12:25:50.314271979 test-daemon exited with code 0
2018-03-30 12:41:08.974825979 test-daemon starting
2018-03-30 12:43:25.258589540 test-daemon exited with code 0</pre>}}

This shows all of {{Path|test-longrun}}'s state transitions, as reported by messages printed by its {{Path|run}} and {{Path|finish}} scripts and logged by the supervised {{C|s6-log}} process. Requesting a list of atomic services in up state using <kbd>s6-rc -al ../live list</kbd> should now return an empty result.

To demonstrate usage of {{C|s6-rc diff}} once again, service {{Path|test-longrun}} can transition to up with an {{C|s6-svc -u}} command without s6-rc noticing:
{{Cmd|s6-svc -u test-longrun|s6-svstat test-longrun|
output=<pre>up (pid 2847) 6 seconds, normally down</pre>}}

{{Cmd|s6-rc -l ../live diff|
output=<pre>+test-longrun</pre>}}

The plus sign ('+') confirms that s6 considers it up. Consistency can be restored by using an <kbd>s6-rc -ul ../live change test-longrun</kbd> command to align s6-rc's view of service state with s6's, or an <kbd>s6-svc -d test-longrun</kbd> command to align s6's view of service state with s6-rc's.
{{anchor|dependencies}}
=== Service dependencies ===

s6-rc supports the specification of dependencies between services. Service A can be defined to ''directly depend'' on service B, with the following meaning:

* If s6-rc it is asked to start A, then B is automatically started first, and if that transition was successful, the requested operation is performed.
* If s6-rc it is asked to stop B, then A is automatically stopped first, and if that transition was successful, the requested operation is performed.

Therefore, transition failures (see [[#manage|managing services]]) might result in not performing the requested operation, leaving the service in the state it was before.

In turn, a service's dependencies can have dependencies themselves, forming dependency chains: if service A directly depends on service B, and B directly depends on service C, then service A is said to ''depend'' (with no qualification) on both B and C. The aforementioned procedure for state transitions is performed recursively when there are dependency chains, so asking s6-rc to start A will result in a cascade of transitions to up to honor dependencies: C first, B second, A last. Similarly, asking s6-rc to stop C will result in transitions to down for A, B and C, in that order. This means that dependencies introduce, for the purpose of state transitions, a partial ordering of services. The {{C|s6-rc change}} command parallelizes the transitions as much as it can. Independent services are processed in parallel, but ordering constraints introduced by dependencies may result in serial processing for one or more subsets of services.

A service definition in {{C|s6-rc-compile}}'s source format can specify direct dependencies by including a regular file named {{Path|dependencies}}, that must contain a list of service names, one per line. Whitespace at the beginning of a line is ignored, but trailing whitespace is not. Lines starting with a hash sign ('#') are ignored. Only atomic service definitions can contain a {{Path|dependencies}} file, [[#bundles|service bundle definitions]] cannot. {{Path|dependencies}} files ''can'' contain service bundle names; s6-rc considers the service being defined to directly depend on every atomic service contained in the specified bundle. For further information about configuration of service dependencies, please consult {{C|s6-rc-compile}}'s HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory. 

Because dependencies may cause state transitions for services that are not in the computed selection of an {{C|s6-rc change}} command, the {{C|s6-rc}} program must also compute a ''forward dependency graph'' for transitions to up, or a ''reverse dependency graph'' for transitions to down, and then it must computed the ''closed selection'', which is the set of all atomic services in the database that need a state transition. An atomic service is in the command's closed selection if:
* it is in the selection, or
* a service in the selection depends on it and the requested operation was to start services, or
* it depends on a service in the selection and the requested operation was to stop services.

The format of a compiled service database allows {{C|s6-rc}} to perform these computations efficiently. Dependency correctness, i.e. the absence of dependency cycles in the submitted set of service definitions, is verified by {{C|s6-rc-compile}} at the time of database creation.

The {{C|s6-rc-db}} program (see [[#s6rcdb|extracting information from a compiled database]]) has two subcommands that display depencency information:
* '''dependencies''': displays the direct dependencies of the service corresponding to the name supplied as the subcommand's argument. If the name corresponds to a service bundle, it displays the union of the direct dependencies of all the atomic services contained in the bundle.
* '''all-dependencies''': displays the fully resolved list of atomic services represented by the list of service names supplied as the subcommand's arguments, in the same way as the <code>atomics</code> subcommand, and all services in either the forward or the reverse dependency graph. The forward dependency graph is used if the <code>-u</code> option is passed to {{C|s6-rc-db}}, and the reverse dependency graph is used if the <code>-d</code> option is passed to {{C|s6-rc-db}}.

Finally, the {{C|s6-rc}} program has a '''listall''' subcommand that displays the closed selection computed from the service names supplied as arguments. Since this is done with a depencency graph, the result is the same as that of <kbd>s6-rc-db all-dependencies</kbd>, except that the latter can also be used with a compiled database that is not live. The forward dependency graph is used if the <code>-u</code> option is passed to {{C|s6-rc}}, and the reverse dependency graph is used if the <code>-d</code> option is passed to {{C|s6-rc}}. If a <code>-p</code> option ('prune') is passed to {{C|s6-rc}} combined with the <code>change</code> command, if a transition to up was requested, services in the computed closed selection are started and every other service not in down state is stopped. If a transition to down was requested, services in the computed closed selection are stopped and every other service not in up state is started. In both cases, all transitions to down are performed before all transitions to up.

For further information about the {{C|s6-rc}} and {{C|s6-rc-db}} programs, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

Example set of service defitions with dependencies:
{{Cmd|ls -l srv-src3/*|
output=<pre>srv-src3/service-A:
total 24
drwxr-xr-x 2 user user 4096 Apr 11 12:00 env
-rw-r--r-- 1 user user   44 Apr 11 12:00 finish
-rw-r--r-- 1 user user    2 Apr 11 12:00 notification-fd
-rw-r--r-- 1 user user  161 Apr 11 12:00 run
-rw-r--r-- 1 user user    6 Apr 11 12:00 timeout-up
-rw-r--r-- 1 user user    8 Apr 11 12:00 type

srv-src3/service-B:
total 20
-rw-r--r-- 1 user user 10 Apr 11 12:00 dependencies
-rw-r--r-- 1 user user 44 Apr 11 12:00 finish
-rw-r--r-- 1 user user  2 Apr 11 12:00 notification-fd
-rw-r--r-- 1 user user 92 Apr 11 12:00 run
-rw-r--r-- 1 user user  8 Apr 11 12:00 type

srv-src3/service-C:
total 12
-rw-r--r-- 1 user user  50 Apr 11 12:00 down
-rw-r--r-- 1 user user   8 Apr 11 12:00 type
-rw-r--r-- 1 user user 150 Apr 11 12:00 up

srv-src3/service-D:
total 16
-rw-r--r-- 1 user user 20 Apr 11 12:00 dependencies
-rw-r--r-- 1 user user 44 Apr 11 12:00 finish
-rw-r--r-- 1 user user 85 Apr 11 12:00 run
-rw-r--r-- 1 user user  8 Apr 11 12:00 type

srv-src3/service-E:
total 20
drwxr-xr-x 2 user user 4096 Apr 11 12:00 env
-rw-r--r-- 1 user user  177 Apr 11 12:00 finish
-rw-r--r-- 1 user user    2 Apr 11 12:00 notification-fd
-rw-r--r-- 1 user user  158 Apr 11 12:00 run
-rw-r--r-- 1 user user    8 Apr 11 12:00 type

srv-src3/service-F:
total 16
-rw-r--r-- 1 user user 10 Apr 11 12:00 dependencies
-rw-r--r-- 1 user user 76 Apr 11 12:00 down
-rw-r--r-- 1 user user  8 Apr 11 12:00 type
-rw-r--r-- 1 user user 50 Apr 11 12:00 up

srv-src3/service-G:
total 12
-rw-r--r-- 1 user user 44 Apr 11 12:00 finish
-rw-r--r-- 1 user user 85 Apr 11 12:00 run
-rw-r--r-- 1 user user  8 Apr 11 12:00 type</pre>}}

Dependency specifications for this set of services are set up according to this diagram:
<pre>
A <-- B <--+ D
           |
      C <--+

      E <--  F

             G</pre>

Legend <code>X <-- Y</code> means "Y directly depends on X". This diagram shows that service D depends on services A, B and C. Service A is a longrun with no dependencies:

{{FileBox|filename=srv-src3/service-A/type|1=longrun}}

{{FileBox|lang=bash|filename=srv-src3/service-A/run|
1=#!/bin/execlineb -P
foreground { echo Service A starting }
s6-envdir env
foreground {
   importas -D 1 T LONGRUN_TIME
   sleep $T
}
fdmove -c 2 1
test-daemon --s6=3}}

{{FileBox|filename=srv-src3/service-A/notification-fd|1=3}}

{{FileBox|filename=srv-src3/service-A/timeout-up|1=15000}}

{{FileBox|lang=bash|filename=srv-src3/service-A/finish|
1=#!/bin/execlineb -P
echo Service A stopping}}

The underlying program is a hypothetical {{C|test-daemon}} program that supports the [[s6#|s6 readiness notification protocol]] when passed an <code>--s6</code> option. The notification channel's file descriptor is '''3''', so there is a {{Path|notification-fd}} file specifying that. The time taken by this service to be up and ready is the value of environment variable <var>LONGRUN_TIME</var> ('''1 second''' if unset), plus the actual time {{C|test-daemon}} takes to be up and ready. A timeout value of '''15 seconds''' (15000 milliseconds) is set for this service's transition to up. The environment is set by the s6 supervision tree and modified by the contents of environment subdirectory {{Path|env}}, which will be copied verbatim to service A's compiled s6 service directory. Both the {{Path|run}} and {{Path|finish}} scripts print messages to standard output, so that service events can be tracked.

Service B also runs {{C|test-daemon}}, and has service A as a direct dependency:
{{FileBox|filename=srv-src3/service-B/type|1=longrun}}

{{FileBox|filename=srv-src3/service-B/dependencies|1=service-A}}

{{FileBox|lang=bash|filename=srv-src3/service-B/run|
1=#!/bin/execlineb -P
foreground { echo Service B starting }
fdmove -c 2 1
test-daemon --s6=3}}

{{FileBox|filename=srv-src3/service-B/notification-fd|1=3}}

{{FileBox|lang=bash|filename=srv-src3/service-B/finish|
1=#!/bin/execlineb -P
echo Service B stopping}}

Service C is a oneshot with no dependencies that prints messages to standard output, so that service events can be tracked, but does nothing else:
{{FileBox|filename=srv-src3/service-C/type|1=oneshot}}

{{FileBox|lang=bash|filename=srv-src3/service-C/up|
1=foreground {
   pipeline -d { echo Service C starting }
   s6-tai64n
}
s6-envdir -I /home/user/s6-rc-env/service-C
importas -D 0 E ONESHOT_STATUS
exit $E}}

{{FileBox|lang=bash|filename=srv-src3/service-C/down|
1=pipeline -d { echo Service C stopping }
s6-tai64n}}

The {{Path|up}} and {{Path|down}} files contain full execline scripts in this case. The former can have different exit codes depending on environment variable <var>ONESHOT_STATUS</var> ('''0''' if unset). The environment is set by the s6 supervision tree, inherited by {{C|s6-rc-oneshot-run}}, and modified by the contents of environment directory {{Path|/home/user/s6-rc-env/service-C}}. Because oneshots don't have a corresponding s6 service directory, this envdir must be elsewhere, and specified via an absolute pathname. {{C|s6-tai64n}} invocations are used to prepend a timestamp to printed messages.

Service D also runs {{C|test-daemon}} with readiness notification turned off, and has two direct dependencies:
{{FileBox|filename=srv-src3/service-D/type|1=longrun}}

{{FileBox|filename=srv-src3/service-D/dependencies|
1=service-B
service-C}}

This means it has both a longrun (service B) and a oneshot (service C) as dependencies.
{{FileBox|lang=bash|filename=srv-src3/service-D/run|
1=#!/bin/execlineb -P
foreground { echo Service D starting }
fdmove -c 2 1
test-daemon}}

{{FileBox|lang=bash|filename=srv-src3/service-D/finish|
1=#!/bin/execlineb -P
echo Service D stopping}}

Service E is a longrun with no dependencies:
{{FileBox|filename=srv-src3/service-E/type|1=longrun}}

{{FileBox|lang=bash|filename=srv-src3/service-E/run|
1=#!/bin/execlineb -P
foreground { echo Service E starting }
s6-envdir env
importas -D no Y LONGRUN_FAIL
if { test $Y != yes }
fdmove -c 2 1
test-daemon --s6=3}}

{{FileBox|filename=srv-src3/service-E/notification-fd|1=3}}

This {{Path|run}} execline script exits 1 if environment variable <var>LONGRUN_FAIL</var> has the value '''yes''', and runs {{C|test-daemon}} otherwise. The environment is set by the s6 supervision tree and modified by the contents of environment subdirectory {{Path|env}}.
{{FileBox|lang=bash|filename=srv-src3/service-E/finish|
1=#!/bin/execlineb -P
s6-envdir env
importas -D no Y LONGRUN_FAIL
ifte {
   echo Service E stopping
} {
   foreground { echo Service E failed permanently }
   exit 125
}
test $Y != yes}}

This {{Path|finish}} execline script exits '''125''' if environment variable <var>LONGRUN_FAIL</var> has the value '''yes''', signalling permanent failure to {{C|s6-supervise}}.

Service F is a oneshot that only prints messages to standard output, and that has a longrun as its direct dependency:
{{FileBox|filename=srv-src3/service-F/type|1=oneshot}}

{{FileBox|filename=srv-src3/service-F/dependencies|1=service-E}}

{{FileBox|lang=bash|filename=srv-src3/service-F/up|
1=pipeline -d { echo Service F starting }
s6-tai64n}}

{{FileBox|lang=bash|filename=srv-src3/service-F/down|
1=foreground {
   pipeline -d { echo Service F stopping }
   s6-tai64n
}
sleep 10}}

And finally, service G is a longrun with no dependencies and no relation with any other service, that also runs {{C|test-daemon}} with readiness notification turned off:
{{FileBox|filename=srv-src3/service-G/type|1=longrun}}

{{FileBox|lang=bash|filename=srv-src3/service-G/run|
1=#!/bin/execlineb -P
foreground { echo Service G starting }
fdmove -c 2 1
test-daemon}}

{{FileBox|lang=bash|filename=srv-src3/service-G/finish|
1=#!/bin/execlineb -P
echo Service G stopping}}

Creating an s6-rc compiled database with this set of services and using {{C|s6-rc-db}} to show direct dependencies:
{{Cmd|s6-rc-compile -u $(id -u) test-database2 srv-src3|for i in A B C D E F G|
output=<pre>> do echo service-$i:
> s6-rc-db -c test-database2 dependencies service-$i
> echo
> done
service-A:

service-B:
service-A

service-C:
s6rc-oneshot-runner

service-D:
service-C
service-B

service-E:

service-F:
service-E
s6rc-oneshot-runner

service-G:
</pre>}}

Note that for every oneshot the implicit dependency on service ''s6rc-oneshot-runner'' is also displayed (see [[#oneshots|oneshot definitions]]). Initializing s6-rc, assuming that there is a supervision tree with {{Path|/home/user/scan}} as the scan directory and with a logger like in the example from section [[#initialization|"initializing s6-rc"]], that database ''test-database2'' is in {{Path|/home/user}}, and that the working directory is the scan directory:

{{Cmd|s6-rc-init -c /home/user/test-database2 -l /home/user/live /home/user/scan|s6-rc -ul ../live list service-<nowiki>{D,F,G}</nowiki> {{!}} sort|
output=<pre>service-D
service-F
service-G</pre>}}

{{Cmd|s6-rc -ul ../live listall service-<nowiki>{D,F,G}</nowiki> {{!}} sort|
output=<pre>s6rc-oneshot-runner
service-A
service-B
service-C
service-D
service-E
service-F
service-G</pre>}}

Here {{C|s6-rc}}'s selection is the same as the list of services provided as arguments, because they are all atomic services, and {{C|s6-rc -u listall}} shows the resulting closed selection using the forward dependency graph: services D, F and G are included because they are in the selection, services A, B and C are included because they are dependencies of service D, service E is included because it is a dependency of service F, and {{Path|s6rc-oneshot-runner}} is included because services C and F are oneshots and depend on it. An <kbd>s6-rc-db -ul ../live all-dependencies service-<nowiki>{D,F,G}</nowiki> | sort</kbd> command would have produced the same output. Simulating the transition of services to up state:

{{Cmd|s6-rc -n 10 -ul ../live change service-<nowiki>{D,F,G}</nowiki>|
output=<pre>s6-rc-dryrun: s6-svc -uwu -T 0 -- ../live/servicedirs/service-G
s6-rc-dryrun: s6-svc -uwU -T 0 -- ../live/servicedirs/service-E
s6-rc-dryrun: s6-svc -uwU -T 15000 -- ../live/servicedirs/service-A
s6-rc-dryrun: s6-svc -uwU -T 0 -- ../live/servicedirs/s6rc-oneshot-runner
s6-rc-dryrun: s6-svc -uwU -T 0 -- ../live/servicedirs/service-B
s6-rc-dryrun: s6-sudo -el0 -t 30000 -T 0 -- ../live/servicedirs/s6rc-oneshot-runner/s up 8  # service-F
s6-rc-dryrun: s6-sudo -el0 -t 30000 -T 0 -- ../live/servicedirs/s6rc-oneshot-runner/s up 7  # service-C
s6-rc-dryrun: s6-svc -uwu -T 0 -- ../live/servicedirs/service-D</pre>}}

Services D and G are longruns that don't use readiness notificacion, so {{C|s6-svc}}'s <code>-wu</code> option (wait for the up notification) is used instead of <code>-wU</code> (wait for the up and ready notification). An because service A's definition specified an up timeout of 15 seconds, the corresponding {{C|s6-svc}} invocation uses a <code>-T 15000</code> option instead of <code>-T 0</code> ("infinite").

Actually starting the services:
{{Cmd|time s6-rc -ul ../live change service-<nowiki>{D,F,G}</nowiki> {{!}} s6-tai64nlocal|
output=<pre>2018-04-12 11:39:59.886267000 Service C starting
2018-04-12 11:40:09.801486747 Service F starting

real	0m21.194s
user	0m0.015s
sys	0m0.010s</pre>}}
{{Cmd|cat ../logdir/current {{!}} s6-tai64nlocal|
output=<pre>2018-04-12 11:39:59.683503297 Service G starting
2018-04-12 11:39:59.685378175 Service E starting
2018-04-12 11:39:59.686330763 Service A starting
2018-04-12 11:40:10.784500674 Service B starting
2018-04-12 11:40:20.793244854 Service D starting</pre>}}

This shows how {{C|s6-rc change}} tried to paralellize state transitions as much as it could: services A, C, E and G were started immediately and in paralell, but services B, D and F were not. Service B's transition happens approximately 11 seconds after service A's, because it is a dependency and that is the time it took service A to become up and ready, and service D's transition happens approximately 10 seconds after service B's for the same reason. It didn't happen later than that because its other dependencies, services A and C, had already successfully transitioned to up. Service F's transition happens approximately 10 seconds after service E's, because it is a dependency and that is the time it took service E to become up and ready. Service D's, F's, and G's transitions are almost instant, because service F is a oneshot, and services D and G {{C|s6-rc}} do not wait for readiness, so the whole operation took about 21 seconds, and finished after service D's transition to up. Because all state transitions were successful, all services in the selection are now in up state. Stopping all services:
{{Cmd|time s6-rc -dal ../live change {{!}} s6-tai64nlocal|
output=<pre>2018-04-12 11:42:37.012906156 Service F stopping
2018-04-12 11:42:37.022828479 Service C stopping

real	0m10.019s
user	0m0.005s
sys	0m0.006s</pre>}}
{{Cmd|cat ../logdir/current {{!}} s6-tai64nlocal|
output=<pre>2018-04-12 11:39:59.683503297 Service G starting
2018-04-12 11:39:59.685378175 Service E starting
2018-04-12 11:39:59.686330763 Service A starting
2018-04-12 11:40:10.784500674 Service B starting
2018-04-12 11:40:20.793244854 Service D starting
2018-04-12 11:42:37.014092710 Service G stopping
2018-04-12 11:42:37.017188595 Service D stopping
2018-04-12 11:42:37.022690818 Service B stopping
2018-04-12 11:42:37.029667303 Service A stopping
2018-04-12 11:42:47.023984194 Service E stopping</pre>}}

This shows that most state transitions were almost instant except service F's, because of the {{C|sleep 10}} command in its {{Path|down}} file. Service E's transition happens after service F's transition completed because it is a dependency, so the whole operation took about 10 seconds and finished after service E's transition to down.

Forcing a rotation of the logging directory with an {{C|s6-svc -a logger}} command so that the {{Path|current}} file gets emptied, and redoing the steps with one modification:
{{Cmd|echo 10 >service-A/env/LONGRUN_TIME|time s6-rc -ul ../live change service-<nowiki>{D,F,G}</nowiki> {{!}} s6-tai64nlocal|
output=<pre>2018-04-12 11:47:02.955608987 Service C starting
2018-04-12 11:47:12.969170358 Service F starting
s6-svlisten1: fatal: timed out
s6-rc: warning: unable to start service service-A: command exited 99

real	0m15.025s
user	0m0.003s
sys	0m0.005s</pre>}}
{{Cmd|cat ../logdir/current {{!}} s6-tai64nlocal|
output=<pre>2018-04-12 11:47:02.943057415 Service G starting
2018-04-12 11:47:02.948378126 Service E starting
2018-04-12 11:47:02.948776158 Service A starting
2018-04-12 11:47:17.962572120 Service A stopping</pre>}}

This shows that the attempt to start service A failed: an extra delay of 10 seconds caused by the setting of environment variable <var>LONGRUN_TIME</var> caused the transition to take longer than the maximum 15 seconds configured in its service definiton. And because of that failure, services that depend on service A were not started -in this case, services B and D-. The whole operation took about 15 seconds and finished after service A's transition timed out. The final "Service A stopping" message in the log is caused by the extra {{C|s6-svc -d}} command that {{C|s6-rc -u change}} executes for longruns that fail to start.
{{Cmd|s6-rc -ual ../live list {{!}} sort|
output=<pre>s6rc-oneshot-runner
service-C
service-E
service-F
service-G</pre>}}

This shows that after the {{C|s6-rc -u change}} command, services A, B and D are not in up state. Stopping all services with an <kbd>s6-rc -dal ../live change</kbd>, forcing another rotation of the logging directory, and redoing the steps with more modifications:
{{Cmd|rm service-A/env/LONGRUN_TIME|echo 7 >/home/user/s6-rc-env/service-C/ONESHOT_STATUS|time s6-rc -ul ../live change service-<nowiki>{D,F,G}</nowiki> {{!}} s6-tai64nlocal|
output=<pre>2018-04-12 11:53:24.643007310 Service C starting
s6-rc: warning: unable to start service service-C: command exited 7
2018-04-12 11:53:34.642459632 Service F starting

real	0m21.031s
user	0m0.004s
sys	0m0.005s</pre>}}
{{Cmd|cat ../logdir/current {{!}} s6-tai64nlocal|
output=<pre>2018-04-12 11:53:24.632173839 Service E starting
2018-04-12 11:53:24.637136736 Service G starting
2018-04-12 11:53:24.637411837 Service A starting
2018-04-12 11:53:35.650247605 Service B starting</pre>}}

This shows that the attempt to start service C failed: the equivalent of executing the {{Path|up}} file of its service definition that program {{C|s6-rc-oneshot-run}} performs exited with a nonzero code ('''7'''), caused by the setting of environment variable <var>ONESHOT_STATUS</var>. And because service D depends on service C, the former was not stated. The whole operation took about 21 seconds and finished after service B's transition to up.
{{Cmd|s6-rc -al ../live list {{!}} sort|
output=<pre>s6rc-oneshot-runner
service-A
service-B
service-E
service-F
service-G</pre>}}

This shows that after the {{C|s6-rc -u change}} command, services C and D are not in up state. Stopping all services, forcing another rotation of the logging directory, and redoing the steps with more modifications:
{{Cmd|rm /home/user/s6-rc-env/service-C/ONESHOT_STATUS|echo yes >service-E/env/LONGRUN_FAIL|time s6-rc -ul ../live change service-<nowiki>{D,F,G}</nowiki> {{!}} s6-tai64nlocal|
output=<pre>s6-svlisten1: fatal: ../live/servicedirs/service-E failed permanently: the finish script exited 125
s6-rc: warning: unable to start service service-E: command exited 1
2018-04-12 12:08:45.991490743 Service C starting

real	0m21.238s
user	0m0.006s
sys	0m0.011s</pre>}}
{{Cmd|cat ../logdir/current {{!}} s6-tai64nlocal|
output=<pre>2018-04-12 12:08:45.689700612 Service G starting
2018-04-12 12:08:45.720197503 Service E starting
2018-04-12 12:08:45.740891903 Service A starting
2018-04-12 12:08:45.880561107 Service E failed permanently
2018-04-12 12:08:56.846140697 Service B starting
2018-04-12 12:09:06.853497873 Service D starting</pre>}}

This shows that the attempt to start service E failed: the setting of environment variable <var>LONGRUN_FAIL</var> to '''yes''' caused the {{Path|run}} script in its s6 service directory to exit immediately, and the {{Path|finish}} script to exit with code 125, which signals permanent failure to s6. And because service F depends on service E, the former was not stated. The whole operation took about 21 seconds and finished after service D's transition to up.
{{Cmd|s6-rc -al ../live list {{!}} sort|
output=<pre>s6rc-oneshot-runner
service-A
service-B
service-C
service-D
service-G</pre>}}

This shows that after the {{C|s6-rc -u change}} command, services E and F are not in up state.
{{anchor|s6rcupdate}}
=== Live updates to the service database ===

The s6-rc package provides a program, {{C|s6-rc-bundle}}, that allows adding or removing [[#bundles|service bundles]] to or from a compiled database, without having to recompile it from source using {{C|s6-rc-compile}}. It is also notable in that it can be used even if the database is live, i.e. already associated with an s6 supervision tree and an s6-rc live state directory. {{C|s6-rc-bundle}} accepts a subcommand that tells it what to do:
* '''add''': adds a service bundle to the database. It accepts a list of service names: the first one is the name of the bundle, and the others are the contents of the bundle. The effect is the same as that of a bundle definition in {{C|s6-rc-compile}}'s source format that contains those service names in the {{Path|contents}} file.
* '''delete''': removes a service bundle from the database. It accepts a single argument specifying the name of the bundle.
* '''multiple''': allows removal and addition of several service bundles in one go. It expects its arguments to be in the format execline's {{C|execlineb}} program [https://skarnet.org/software/execline/el_semicolon.html generates when parsing the block syntax], so the forward compatible way to use it is in an execline script or {{C|execlineb -c}} command: the invocation can be written using a the syntax <kbd>s6-rc-bundle multiple { d1 d2 ... } n1 { c11 c12 ... } n2 { c21 c22 ... } ...</kbd>, where ''d1'', ''d2'', ... are service names specifying bundles to delete, ''n1'', ''n2'', ... are service names specifying bundles to add, ''c11'', ''c12'', ... are service names specifying the contents of bundle ''n1'', ''c21'', ''c22'', ... are service names specifying the contents of bundle ''n2'', and so on. The list ''d1 d2 ...'' can be empty, resulting in no deletions. Everything after the first {}-block can be ommited, resulting in no additions.

{{C|s6-rc-bundle}} operates on the database associated with live state directory {{Path|/run/s6-rc}}, unless it is passed an <code>-l</code> option followed by the (absolute or relative to the working directory) pathname of a different live state directory, or it is passed a <code>-c</code> option followed by the pathname of a database. For more information about {{C|s6-rc-bundle}}, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

Using {{C|s6-rc-bundle}} is the only way to modify a compiled database. Any other modification has to be done on the service definitions in source format that were used to create the database, and then {{C|s6-rc-compile}} must be used to make a new database. Because a database that is live cannot be deleted, the s6-rc package provides a tool that allows its ''replacement'': the {{C|s6-rc-update}} program, an ''online service database switcher''. If the replaced database contained a service that is not present in the replacing database, the affected service will be ''deleted'': its name will no longer be recognized as valid by tools like the {{C|s6-rc}} and {{C|s6-rc-db}} programs. Therefore, the replacing database must contain all wanted services, both modified and unmodified ones, and generally means that service definitions in {{C|s6-rc-compile}}'s source format must be kept around.

{{C|s6-rc-update}} accepts the replacing database's absolute pathname as an argument, and performs the database switch for live state directory {{Path|/run/s6-rc}}, unless it is passed an <code>-l</code> option followed by the absolute pathname of a different live state directory. It also ensures consistency of service states: it analyses both the replaced and replacing database's contents to determine which services are present in both (based on name), and preserves their corresponding state, except for services that change types (longrun to oneshot and vice-versa, atomic service to bundle and vice-versa) or direct dependencies. In those cases, if the service is in up state at program startup, {{C|s6-rc-update}} ''restarts'' it: it stops it before the database replacement, and then starts it after the database replacement, so if there are new services defined as direct dependencies, {{C|s6-rc-update}} starts them too after the database replacement. Deleted services are stopped before the replacement.

{{C|s6-rc-update}} also accepts an <code>-f</code> option followed by the pathname of a file, the ''conversion file'', that can currently be used for two purposes: service renaming and forced restarts. The file must contain a sequence of lines of text, each of which is independently lexed into words as if by the {{C|execlineb}} program, so it can contain #-comments, quoted strings, etc. Lines of the form <code>old-service -> new-service</code> rename service ''old-service'' to ''new-service''. Therefore, all appearances of name ''old-service'' in service definitions of the replaced database, and all appearances of name ''new-service'' in service definitions of the replacing database, are understood to refer to the same service for the purpose of computing needed state transitions. Otherwise, they are considered to name unrelate services. Lines of the form <code>service-name restart</code> makes {{C|s6-rc-update}} forcibly restart service ''service-name'', and lines of the form <code>old-service -> new-service restart</code> make {{C|s6-rc-update}} perform both a rename and a forced restart.

{{Note|If a renamed service is a longrun that does not end up getting restarted by {{C|s6-rc-update}}, and the {{C|ps}} utility is used after the service database switch, its {{C|s6-supervise}} parent will appear in the output with the old service name as agrument, because that is how it was invoked by {{C|s6-svscan}}. This is purely cosmetic and has no impact on the service; nevertheless, if the 'correct' ouput is desired, the file supplied with the <code>-f</code> option must also specify a forced restart of the longrun.}}

{{C|s6-rc-update}} performs the computed state transitions using an {{C|s6-rc -d change}} command before the database switch, and an {{C|s6-rc -u change}} command after the database switch. It also accepts an <code>-n</code> ('dry run') option that makes it simulate the state transitions without switching the database, printing the {{C|s6-rc}} invocations to standard output with the {{C|s6-rc-dryrun}} internal program. For the full description of {{C|s6-rc-compile}}, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

{{Important|The absolute pathname specified to {{C|s6-rc-update}} with an <code>-l</code> option must be that of the symbolic link to directory created by {{C|s6-rc-init}}, not that of the actual directory.}}

Finally, s6-rc provides the {{C|s6-rc-format-upgrade}} program, that can be used to upgrade the format of a compiled service database that is live and was created with an earlier incompatible version of {{C|s6-rc-compile}}. It is intended to be used after upgrading the s6-rc package to a backwards-incompatible version, without disrupting the live state directory and associated s6 supervision tree (e.g. if s6-rc is used as an init system component) and currently works for upgrades from version 0.3.0.0 to version 0.4.0.0. It actually performs a database switch like {{C|s6-rc-update}} does, it accepts the absolute path of a compiled database, and operates on live state directory {{Path|/run/s6-rc}}, unless it is passed an <code>-l</code> option followed by the (absolute or relative to the working directory) pathname of a different live state directory. For more information about {{C|s6-rc-format-upgrade}}, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

{{Important|The replacing database submitted to {{C|s6-rc-format-upgrade}} must have been created with the {{C|s6-rc-compile}} program from the same version of s6-rc, i.e. the upgraded package, and must be created from the same service definitions as the replaced database. So, for example, if database A was created from service definitions ''S1'', ''S2'', ..., ''SN'' with {{C|s6-rc-compile}} from version 0.3.0.0, and an upgrade is made to s6-rc version 0.4.0.0, then a new database B must be created from the exact same ''S1'', ''S2'', ..., ''SN'', but with {{C|s6-rc-compile}} from version 0.4.0.0, and then {{C|s6-rc-format-upgrade}} from version 0.4.0.0 must be invoked with database B (and the pathname of the live state directory A is currently associated with using the <code>-l</code> option, if it is not {{Path|/run/s6-rc}}. Please carefully review the details of the upgrade procedure in {{C|s6-rc-format-upgrade}}'s HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory. {{C|s6-rc-update}} '''cannot be used''' with a live state directory currently associated with a database created with the {{C|s6-rc-compile}} program from an earlier backwards-incompatible version of s6-rc.}}

{{Note|s6-rc packages have four number verions of the form A.B.C.D. For the purpose of deciding whether {{C|s6-rc-format-upgrade}} should be used, two versions are considered incompatible if their they differ in either the first (A) or second (B) number.}}

Example usage of {{C|s6-rc-update}}, assuming the setup from section [[#dependencies|"service dependencies"]], and assuming that the working directory is the scan directory:
{{Cmd|ls -l ../live|
output=<pre>lrwxrwxrwx 1 user user 22 Apr 16 12:14 ../live -> live:s6-rc-init:y0jVfr</pre>}}

{{Cmd|ls -l|
output=<pre>total 8
drwxr-xr-x 4 user user 4096 Apr 16 12:00 logger
lrwxrwxrwx 1 user user   41 Apr 16 12:14 s6rc-fdholder -> /home/user/live/servicedirs/s6rc-fdholder
lrwxrwxrwx 1 user user   47 Apr 16 12:14 s6rc-oneshot-runner -> /home/user/live/servicedirs/s6rc-oneshot-runner
lrwxrwxrwx 1 user user   37 Apr 16 12:14 service-A -> /home/user/live/servicedirs/service-A
lrwxrwxrwx 1 user user   37 Apr 16 12:14 service-B -> /home/user/live/servicedirs/service-B
lrwxrwxrwx 1 user user   37 Apr 16 12:14 service-D -> /home/user/live/servicedirs/service-D
lrwxrwxrwx 1 user user   37 Apr 16 12:14 service-E -> /home/user/live/servicedirs/service-E
lrwxrwxrwx 1 user user   37 Apr 16 12:14 service-G -> /home/user/live/servicedirs/service-G</pre>}}

List of services in up state:
{{Cmd|s6-rc -ual ../live list {{!}} sort|
output=<pre>s6rc-oneshot-runner
service-A
service-B
service-C
service-D
service-E
service-F
service-G</pre>}}

The associated service database is going to be replaced by one created from this set of service definitions in {{C|s6-rc-compile}}'s source format:
{{Cmd|ls -l srv-src4/*|
output=<pre>lrwxrwxrwx 1 user user   21 Apr 14 12:00 srv-src4/service-C-renamed -> ../srv-src3/service-C
lrwxrwxrwx 1 user user   21 Apr 14 12:00 srv-src4/service-F -> ../srv-src3/service-F
lrwxrwxrwx 1 user user   21 Apr 14 12:00 srv-src4/service-G -> ../srv-src3/service-G

srv-src4/service-B:
total 0
lrwxrwxrwx 1 user user 31 Apr 14 12:00 finish -> ../../srv-src3/service-B/finish
lrwxrwxrwx 1 user user 40 Apr 14 12:00 notification-fd -> ../../srv-src3/service-B/notification-fd
lrwxrwxrwx 1 user user 28 Apr 14 12:00 run -> ../../srv-src3/service-B/run
lrwxrwxrwx 1 user user 29 Apr 14 12:00 type -> ../../srv-src3/service-B/type

srv-src4/service-D:
total 4
-rw-r--r-- 1 user user 28 Apr 14 12:00 dependencies
lrwxrwxrwx 1 user user 31 Apr 14 12:00 finish -> ../../srv-src3/service-D/finish
lrwxrwxrwx 1 user user 28 Apr 14 12:00 run -> ../../srv-src3/service-D/run
lrwxrwxrwx 1 user user 29 Apr 14 12:00 type -> ../../srv-src3/service-D/type

srv-src4/service-E:
total 12
-rw-r--r-- 1 user user 50 Apr 14 12:00 down
-rw-r--r-- 1 user user  8 Apr 14 12:00 type
-rw-r--r-- 1 user user 50 Apr 14 12:00 up</pre>}}

This shows that directories containing service definitions are allowed to have symbolic links to files and directories placed elsewhere. The new database is mostly the same as database ''test-database2'', except that it contains no service A, so it will be removed after the database switch, renames service C, and turn service E into a oneshot. So all references to service A must be removed, and all references to service C must use the new name:
{{FileBox|filename=srv-src4/service-D/dependencies|
1=service-B
service-C-renamed}}

Service A is gone from {{Path|service-D/dependencies}}, and so is file {{Path|service-B/dependencies}}. Service E needs a new definition:

{{FileBox|filename=srv-src4/service-E/type|1=oneshot}}

{{FileBox|lang=bash|filename=srv-src4/service-E/up|
1=pipeline -d { echo Service E starting }
s6-tai64n}}

{{FileBox|lang=bash|filename=srv-src4/service-E/down|
1=pipeline -d { echo Service E stopping }
s6-tai64n}}

To actually rename service C, a conversion file must be supplied:
{{FileBox|filename=conversion-file1|
1=service-C -> service-C-renamed}}

Compiling the new database using an <kbd>s6-rc-compile -u $(id -u) test-database3 srv-src4</kbd> command, assuming it will be placed in {{Path|/home/user}} along with the conversion file, and simulating the effect of invoking {{C|s6-rc-update}}:
{{Cmd|s6-rc-update -n -l /home/user/live -f ../conversion-file1 /home/user/test-database3|
output=<pre>s6-rc-dryrun: s6-rc -v 1 -t 0 -l /home/user/live -d -- change service-E service-A
s6-rc-dryrun: s6-rc -v 1 -t 0 -l /home/user/live -u -- change service-F service-E service-D service-B</pre>}}

This shows that {{C|s6-rc-update}} would use an {{C|s6-rc -d change}} command to stop some services, switch the database, and then use an {{C|s6-rc -u change}} command to start some other services, which implies that (possibly updated) dependency specifications would be honored. Actually performing the database switch:
{{Cmd|time s6-rc-update -l /home/user/live -f ../conversion-file1 /home/user/test-database3 {{!}} s6-tai64nlocal|
output=<pre>2018-04-16 12:17:38.591813680 Service F stopping
2018-04-16 12:17:48.616989175 Service E starting
2018-04-16 12:17:48.623626677 Service F starting

real	0m20.040s
user	0m0.006s
sys	0m0.012s</pre>}}

{{Cmd|cat ../logdir/current {{!}} s6-tai64nlocal|
output=<pre>2018-04-16 12:14:29.899306549 Service G starting
2018-04-16 12:14:29.902011519 Service E starting
2018-04-16 12:14:29.906354333 Service A starting
2018-04-16 12:14:40.917018474 Service B starting
2018-04-16 12:14:50.926763361 Service D starting
2018-04-16 12:17:38.591475904 Service D stopping
2018-04-16 12:17:38.596463367 Service B stopping
2018-04-16 12:17:38.603899826 Service A stopping
2018-04-16 12:17:48.601233571 Service E stopping
2018-04-16 12:17:48.617483162 Service B starting
2018-04-16 12:17:58.624084755 Service D starting</pre>}}

This shows that because service E changes type, the original longrun was stopped, and the new oneshot was started. Longruns' messages appear in the supervision tree's logging directory, but because of {{C|s6-sudoc}}'s fd-passing, oneshots' messages are printed to {{C|s6-rc-update}}'s standard output. Therefore, the "Service E stopping" and "Service E starting" messages appear in different places. This also shows that because service A was removed, it was stopped first, and because services B and D depended on it and were up before the database switch, both were restarted. Note that transitions to down have to be serial in the order D, B, A, and transitions to up have to be serial in the order B, D. Finally, because service F continues to depend on service E, and the latter had to restart, F was restarted too, again using serial transitions. Service F was stopped first, and service E was stopped about 10 seconds later, because that was the duration of service F's transition. Then, after the database switch, their transitions to up were almost instant. The whole operation took about 20 seconds: 10 to stop service F plus 10 to start service B.

The symbolic link to the live state directory was updated:
{{Cmd|ls -l ../live|
output=<pre>lrwxrwxrwx 1 user user 24 Apr 16 12:17 ../live -> live:s6-rc-update:SGBH3e</pre>}}

The output of {{C|ls}} previously showed {{Path|live:s6-rc-init:y0jVfr}}. The s6 scan directory has also updated all symbolic links:
{{Cmd|ls -l|
output=<pre>total 8
drwxr-xr-x 4 user user 4096 Apr 16 12:00 logger
lrwxrwxrwx 1 user user   41 Apr 16 12:17 s6rc-fdholder -> /home/user/live/servicedirs/s6rc-fdholder
lrwxrwxrwx 1 user user   47 Apr 16 12:17 s6rc-oneshot-runner -> /home/user/live/servicedirs/s6rc-oneshot-runner
lrwxrwxrwx 1 user user   37 Apr 16 12:17 service-B -> /home/user/live/servicedirs/service-B
lrwxrwxrwx 1 user user   37 Apr 16 12:17 service-D -> /home/user/live/servicedirs/service-D
lrwxrwxrwx 1 user user   37 Apr 16 12:17 service-G -> /home/user/live/servicedirs/service-G</pre>}}

There is neither a {{Path|service-A}} symlink, because the corresponding service no longer exists, nor a {{Path|service-E}} symlink, because the corresponding service is no longer a longrun.
{{Cmd|s6-rc -ual ../live list {{!}} sort|
output=<pre>s6rc-oneshot-runner
service-B
service-C-renamed
service-D
service-E
service-F
service-G</pre>}}

This shows that, except for service A, the same set of services are in up state after the database switch, and that the renaming of service C has been performed indeed. Note that the service has not been restarted; there were no "Service C starting" or "Service C stopping" messages printed to {{C|s6-rc-update}}'s standard output.

One more example with another set of service definitions:
{{Cmd|ls -l srv-src5/*|
output=<pre>lrwxrwxrwx 1 user user   21 Apr 14 12:00 srv-src5/service-B-renamed -> ../srv-src4/service-B
lrwxrwxrwx 1 user user   21 Apr 14 12:00 srv-src5/service-C-renamed -> ../srv-src3/service-C
lrwxrwxrwx 1 user user   21 Apr 14 12:00 srv-src5/service-E -> ../srv-src4/service-E
lrwxrwxrwx 1 user user   21 Apr 14 12:00 srv-src5/service-F -> ../srv-src3/service-F
lrwxrwxrwx 1 user user   21 Apr 14 12:00 srv-src5/service-G -> ../srv-src3/service-G

srv-src5/service-D:
total 4
-rw-r--r-- 1 user user 46 Apr 14 12:00 dependencies
lrwxrwxrwx 1 user user 31 Apr 14 12:00 finish -> ../../srv-src3/service-D/finish
lrwxrwxrwx 1 user user 28 Apr 14 12:00 run -> ../../srv-src3/service-D/run
lrwxrwxrwx 1 user user 29 Apr 14 12:00 type -> ../../srv-src3/service-D/type

srv-src5/service-H:
total 12
-rw-r--r-- 1 user user 44 Apr 14 12:00 finish
-rw-r--r-- 1 user user 85 Apr 14 12:00 run
-rw-r--r-- 1 user user  8 Apr 14 12:00 type</pre>}}

Service B is is going to be renamed, and a new service H is going to be created as a dependency of service D:
{{FileBox|filename=srv-src5/service-D/dependencies|
1=service-B-renamed
service-C-renamed
service-H}}

Service H is a longrun with no dependencies that runs program {{C|test-daemon}} with readiness notification turned off:
{{FileBox|filename=srv-src5/service-H/type|1=longrun}}

{{FileBox|lang=bash|filename=srv-src5/service-H/run|
1=#!/bin/execlineb -P
foreground { echo Service H starting }
fdmove -c 2 1
test-daemon}}

{{FileBox|lang=bash|filename=srv-src5/service-H/finish|
1=#!/bin/execlineb -P
echo Service H stopping}}

Conversion file for renaming service B that also forces a restart of service G (which is otherwise unmodified):
{{FileBox|filename=conversion-file2|
1=service-B -> service-B-renamed
service-G restart}}

Compiling a new database with these service definitions using a <kbd>s6-rc-compile -u $(id -u) test-database4 srv-src5</kbd> command, assuming it will also be placed in {{Path|/home/user}} along with the conversion file, forcing a rotation of the supervision tree's logging directory with an <kbd>s6-svc -a logger</kbd>, and then performing the database switch:
{{Cmd|time s6-rc-update -l /home/user/live -f ../conversion-file2 /home/user/test-database4|
output=<pre>
real	0m0.127s
user	0m0.007s
sys	0m0.007s</pre>}}

{{Cmd|cat ../logdir/current {{!}} s6-tai64nlocal|
output=<pre>2018-04-16 12:23:07.375107786 Service G stopping
2018-04-16 12:23:07.376383751 Service D stopping
2018-04-16 12:23:07.478780248 Service H starting
2018-04-16 12:23:07.479606503 Service G starting
2018-04-16 12:23:07.496890435 Service D starting</pre>}}

This shows that service G was restarted indeed because of the conversion file, but also service D, because it was in up state before the database switch and its dependencies changed: service H was added as a direct dependency after the database switch. On the other hand, service B was only renamed, so it didn't restart. The whole operation took place almost instantly, because not waiting for readiness notification makes service D's, G's and H's transitions almost instant.
{{Cmd|ls -l ../live|
output=<pre>lrwxrwxrwx 1 user user 24 Apr 16 12:23 ../live -> live:s6-rc-update:5RCX6s</pre>}}

This shows that the live state directory symlink was modified once again; the output of {{C|ls}} previously showed {{Path|live:s6-rc-update:SGBH3e}}
{{Cmd|ls -l|
output=<pre>total 12
drwxr-xr-x 4 user user 4096 Apr 16 12:00 logger
lrwxrwxrwx 1 user user   41 Apr 16 12:23 s6rc-fdholder -> /home/user/live/servicedirs/s6rc-fdholder
lrwxrwxrwx 1 user user   47 Apr 16 12:23 s6rc-oneshot-runner -> /home/user/live/servicedirs/s6rc-oneshot-runner
lrwxrwxrwx 1 user user   45 Apr 16 12:23 service-B-renamed -> /home/user/live/servicedirs/service-B-renamed
lrwxrwxrwx 1 user user   37 Apr 16 12:23 service-D -> /home/user/live/servicedirs/service-D
lrwxrwxrwx 1 user user   37 Apr 16 12:23 service-G -> /home/user/live/servicedirs/service-G
lrwxrwxrwx 1 user user   37 Apr 16 12:23 service-H -> /home/user/live/servicedirs/service-H</pre>}}

This shows that the symlink for service B in the s6 scan directory was renamed, and that a new symlink was created for service H.
{{Cmd|s6-rc -ual ../live list {{!}} sort|
output=<pre>s6rc-oneshot-runner
service-B-renamed
service-C-renamed
service-D
service-E
service-F
service-G
service-H</pre>}}

This shows again that the same set of services are in up state after the database switch, and that the renaming of service B has been performed indeed. Adding two runlevel-like bundles to the compiled service database while it is live:
{{Cmd|s6-rc-db -l ../live list bundles|execlineb -Pc '|
output=<pre>> s6-rc-bundle -l ../live multiple { } runlevel-X { service-D } runlevel-Y { service-F service-G }'</pre>}}

{{Cmd|s6-rc-db -l ../live list bundles {{!}} sort|
output=<pre>runlevel-X
runlevel-Y</pre>}}

This shows that both bundles were simultaneously added. It is equivalent to using an <kbd>s6-rc-bundle -l ../live add runlevel-X service-D</kbd> command followed by an <kbd>s6-rc-bundle -l ../live add runlevel-Y service-F service-G</kbd> command. Forcing another rotation of the supervision tree's logging directory, and then using an <kbd>s6-rc -pu change</kbd> command to emulate a runlevel change:
{{Cmd|s6-rc -pul ../live change runlevel-X {{!}} s6-tai64nlocal|
output=<pre>2018-04-16 12:26:08.604157313 Service F stopping
2018-04-16 12:26:18.632999649 Service E stopping</pre>}}

{{Cmd|cat ../logdir/current {{!}} s6-tai64nlocal|
output=<pre>2018-04-16 12:26:08.603648681 Service G stopping</pre>}}

{{Cmd|s6-rc -ual ../live list {{!}} sort|
output=<pre>s6rc-oneshot-runner
service-B-renamed
service-C-renamed
service-D
service-H</pre>}}

This shows that only atomic services members of bundle ''runlevel-X'' are now up. Deleting the bundle from the compiled service database:
{{Cmd|s6-rc-bundle -l ../live delete runlevel-X|s6-rc-db -l ../live list bundles|
output=<pre>runlevel-Y</pre>}}

This shows that only bundle ''runlevel-Y'' remains. It is equivalent to using an <kbd>execlineb -Pc 's6-rc-bundle -l ../live multiple { runlevel-X }'</kbd> command. Performing another 'runlevel change':
{{Cmd|s6-rc -pul ../live change runlevel-Y {{!}} s6-tai64nlocal|
output=<pre>2018-04-16 12:29:39.558335051 Service C stopping
2018-04-16 12:29:39.569330382 Service E starting
2018-04-16 12:29:39.576582824 Service F starting</pre>}}

{{Cmd|cat ../logdir/current {{!}} s6-tai64nlocal|
output=<pre>2018-04-16 12:26:08.603648681 Service G stopping
2018-04-16 12:29:39.552344150 Service D stopping
2018-04-16 12:29:39.559029637 Service B stopping
2018-04-16 12:29:39.561047890 Service H stopping
2018-04-16 12:29:39.569014150 Service G starting</pre>}}

{{Cmd|s6-rc -ual ../live list {{!}} sort|
output=<pre>s6rc-oneshot-runner
service-E
service-F
service-G</pre>}}

This shows that atomic services members of (former) bundle ''runlevel-X'' were stopped, and only atomic services members of bundle ''runlevel-Y'' are now up.
{{anchor|pipelines}}
=== Longrun pipelining ===

The s6 supervision tools support the [[daemontools-encore#logging|daemontools mechanism]] that allows connecting the standard output of a supervised process to the standard input of another one with a pipe, normally for logging purposes. This mechanism is used when a subdirectory or symbolic link to directory named {{Path|log}} is present in a service directory. s6-rc generalizes this idea with ''pipelines'': it allows arbirary length chains of longruns that have their standard output connected to the standard input of the next one in the chain with a pipe. Moreover, as of version 0.4.0.0, s6-rc also allows tying the standard input of a longrun with the standard output of two or more other longruns, so that multiple streams of messages from different supervised processes can be collapsed into a single stream. This means that s6-rc pipelines are really ''funnels'', but the name 'pipeline' is retained for compatibility with earlier versions that did not support this feature.

The {{C|s6-rc-compile}} program creates pipelines when the definition directories of their member services contain regular files named {{Path|producer-for}} and {{Path|consumer-for}}. A {{Path|producer-for}} file must contain a single service name; the standard output of the service being defined will then be connected to the standard input of the service named in the file as a result. s6-rc requires that the definition directory of the latter also contain a {{Path|consumer-for}} file that names the former, and {{C|s6-rc-compile}} implicitly makes the latter a direct dependency of the former, as if by the presence a {{Path|dependencies}} file. This ensures that if the pipeline mechanism is used for logging, loggers will be up before starting the 'main' services. A {{Path|consumer-for}} file must contain a list of service names. If more that one service is named in a {{Path|consumer-for}} file, the funnel-style collapsing of message streams will take place. Pipeline consistency, e.g. absence of collisions or cycles, is verified by {{C|s6-rc-compile}} at service database creation time, as well as the existence of a {{Path|consumer-for}} file in the definition of each service named in a {{Path|producer-for}} file, and a {{Path|producer-for}} file in the definition of each service named in a {{Path|consumer-for}} file. To create [[s6#loggingchain|a logging chain]] with s6-rc services, definitions of 'main' services must contain a {{Path|producer-for}} file naming their loggers, and the loggers must be created just like any other s6-rc service, with definitions that contain a {{Path|consumer-for}} file naming (only) their main services.

The definition directory of a service with a {{Path|consumer-for}} and no {{Path|producer-for}} file, named the corresponding pipeline's ''last consumer'', can also contain an optional, regular file named {{Path|pipeline-name}}, that must contain a single service name; {{C|s6-rc-compile}} will then create a service bundle with this name that contains all the services that are members of the pipeline. A {{Path|pipeline-name}} in the definition directory of a service that is not a pipeline's last consumer is ignored. For further information about pipelines, please consult {{C|s6-rc-compile}}'s HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

s6-rc implements pipelines using an internal support service named ''s6rc-fdholder''. This service spawns a long-lived process that executes the {{C|s6-fdholderd}} program, i.e. [[s6#fdholder|the fd-holder daemon from s6]], and runs an internal s6-rc program, {{C|s6-rc-fdholder-filler}}, chained from {{C|s6-ipcclient}}. {{C|s6-rc-fdholder-filler}} is a short-lived [[s6#superserver|UCSPI IPC client]], that reads a file containing service names, creates a pipe for each of them using the POSIX <code>pipe()</code> call, connects to the socket of an {{C|s6-fdholderd}} process, and transfers the file descriptors associated with the reading and writing end of all pipes to the server with a set dump operation, i.e. as if by {{C|s6-fdholder-setdumpc}}. The file with service names is created by {{C|s6-rc-compile}} in {{Path|s6rc-fdholder}}'s s6 service directory. {{C|s6-rc-compile}} also automatically makes {{Path|s6rc-fdholder}} a direct dependency of every longrun that is a member of a pipeline, and creates a wrapper {{Path|run}} execline script in their compiled s6 service directory. The wrapper script retrieves the file descriptors that correspond to the reading and / or writing ends of the pipes the service needs with {{C|s6-fdholder-retrieve}} invocations, and then executes the actual {{Path|run}} file supplied in its s6-rc definition (currently installed as {{Path|run.user}} in the compiled s6 service directory). The same happens with the {{Path|finish}} file, if there is one. For further information about {{C|s6-rc-fdholder-filler}}, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

{{Path|s6rc-fdholder}} uses a rules directory to decide whether to grant or refuse service to clients that connect to its UNIX domain socket of its {{C|s6-fdholderd}} process. The effective user of all processes in an s6 supervision tree is initially that of {{C|s6-svscan}}. The {{C|s6-supervise}} process of every longrun that is a member of a pipeline will spawn a child process that executes the wrapper {{Path|run}} execline script that contains {{C|s6-fdholder-retrieve}} invocations, so {{C|s6-svscan}}'s effective user must be allowed by {{Path|s6rc-fdholder}}'s rules directory. Setup of this rules directory can be done using {{C|s6-rc-compile}}'s <code>-u</code> and <code>-g</code> options, see [[#initialization|initializing s6-rc]]. If {{C|s6-svscan}}'s effective user is root, the effective user of the {{C|s6-fdholderd}} process can be adjusted by passing an <code>-h</code> option to {{C|s6-rc-compile}} followed by an account's username; {{Path|s6rc-fdholder}}'s {{Path|run}} script will then include an {{C|s6-envuidgid}} invocation to drop privileges. For further information about {{C|s6-rc-compile}}, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

Finally, the {{C|s6-rc-db}} program (see [[#s6rcdb|extracting information from a compiled database]]) has a '''pipeline''' subcommand that displays information about the pipeline that the service corresponding to the name supplied as the subcommand's argument is a member of. If the service is not a member of a pipeline, it just prints the name supplied as argument. For further information about {{C|s6-rc-db}}, please consult the HTML documentation in the package's {{Path|/usr/share/doc}} subdirectory.

Example set of service definitions using pipelines:
{{Cmd|ls -l srv-src6/*|
output=<pre>srv-src6/final-logger:
total 16
-rw-r--r-- 1 user user  18 Apr 18 12:00 consumer-for
-rw-r--r-- 1 user user  20 Apr 18 12:00 pipeline-name
-rw-r--r-- 1 user user 130 Apr 18 12:00 run
-rw-r--r-- 1 user user   8 Apr 18 12:00 type

srv-src6/reader-A:
total 16
-rw-r--r-- 1 user user  10 Apr 18 12:00 consumer-for
-rw-r--r-- 1 user user  13 Apr 18 12:00 producer-for
-rw-r--r-- 1 user user 115 Apr 18 12:00 run
-rw-r--r-- 1 user user   8 Apr 18 12:00 type

srv-src6/reader-B:
total 16
-rw-r--r-- 1 user user  10 Apr 18 12:00 consumer-for
-rw-r--r-- 1 user user  13 Apr 18 12:00 producer-for
-rw-r--r-- 1 user user 115 Apr 18 12:00 run
-rw-r--r-- 1 user user   8 Apr 18 12:00 type

srv-src6/service-A:
total 12
-rw-r--r-- 1 user user  9 Apr 18 12:00 producer-for
-rw-r--r-- 1 user user 32 Apr 18 12:00 run
-rw-r--r-- 1 user user  8 Apr 18 12:00 type

srv-src6/service-B:
total 12
-rw-r--r-- 1 user user  9 Apr 18 12:00 producer-for
-rw-r--r-- 1 user user 32 Apr 18 12:00 run
-rw-r--r-- 1 user user  8 Apr 18 12:00 type</pre>}}

Service A spawns a process that executes a hypothetical {{C|test-daemon}} program. It is assumed that this program prints a message of the form "Message #N", where ''N'' is an incrementing number, each time it receives a <code>SIGHUP</code> signal.
{{FileBox|filename=srv-src6/service-A/type|1=longrun}}

{{FileBox|lang=bash|filename=srv-src6/service-A/run|
1=#!/bin/execlineb -P
test-daemon}}

{{FileBox|filename=srv-src6/service-A/producer-for|1=reader-A}}

Reader A spawns a process that reads lines of text from its standard input and prints them to its standard output, prepended with the string "This comes from service A:":
{{FileBox|filename=srv-src6/reader-A/type|longrun}}

{{FileBox|lang=python|filename=srv-src6/reader-A/run|
1=#!/usr/bin/python
import sys
for line in sys.stdin: print ('This comes from service A:', line, end='', flush=True)}}

{{FileBox|filename=srv-src6/reader-A/consumer-for|1=service-A}}

Service A's standard ouput is connected to reader A's standard input with a pipe. Service B and reader B constitute a similar pair of services:

{{FileBox|filename=srv-src6/service-B/type|1=longrun}}

{{FileBox|lang=bash|filename=srv-src6/service-B/run|
1=#!/bin/execlineb -P
test-daemon}}

{{FileBox|filename=srv-src6/service-B/producer-for|1=reader-B}}

{{FileBox|filename=srv-src6/reader-B/type|1=longrun}}

{{FileBox|lang=python|filename=srv-src6/reader-B/run|
1=#!/usr/bin/python
import sys
for line in sys.stdin: print ('This comes from service B:', line, end='', flush=True)}}

{{FileBox|filename=srv-src6/reader-B/consumer-for|1=service-B}}

And finally, service ''final-reader'' spawns an {{C|s6-log}} process. Messages read from its standard input are logged in logging directory {{Path|/home/user/logdir}}:

{{FileBox|filename=srv-src6/final-logger/type|1=longrun}}

{{FileBox|lang=bash|filename=srv-src6/final-logger/run|
1=#!/bin/execlineb -P
redirfd -w 1 /dev/null
foreground {
   fdmove -c 1 2
   echo Starting final-logger
}
s6-log /home/user/logdir}}

The s6-rc pipeline ties reader A's and B's standard output with this logger's standard input:

{{FileBox|filename=srv-src6/reader-A/producer-for|1=final-logger}}

{{FileBox|filename=srv-src6/reader-B/producer-for|1=final-logger}}

{{FileBox|filename=srv-src6/final-logger/consumer-for|
1=reader-A
reader-B}}

This service is the last consumer, so it has a {{Path|pipeline-name}} file that specifies a name for the pipeline:
{{FileBox|filename=srv-src6/final-logger/pipeline-name|1=service-AB-pipeline}}

A diagram that represents this pipeline:
<pre>
service A --> reader A -->+
                          |
service B --> reader B -->+
                          |
                          +--> final-logger</pre>

After creating a database with these service definitions using a <kbd>s6-rc-compile -u $(id -u) test-database5 srv-src6</kbd> command:
{{Cmd|s6-rc-db -c test-database5 list all {{!}} sort|
output=<pre>final-logger
reader-A
reader-B
s6rc-fdholder
s6rc-oneshot-runner
service-A
service-AB-pipeline
service-B</pre>}}
{{Cmd|s6-rc-db -c test-database5 type service-AB-pipeline|
output=<pre>bundle</pre>}}

This shows that the database contains an actual service named ''service-AB-pipeline'', and that it is a bundle. {{C|s6-rc-compile}} must be invoked with an <code>-u</code> option so that the nonprivileged effective user of each longrun's process is allowed to retrieve the file descriptors associated with this pipeline from the fd-holder.

{{Cmd|s6-rc-db -c test-database5 contents service-AB-pipeline {{!}} sort|
output=<pre>final-logger
reader-A
reader-B
service-A
service-B</pre>}}

This shows that the bundle contains all services associated this pipeline.
{{Cmd|for i in <nowiki>{service,reader}-{A,B}</nowiki> final-logger|
output=<pre>> do echo $i:
> s6-rc-db -c test-database5 dependencies $i
> echo
> done
service-A:
reader-A
s6rc-fdholder

service-B:
reader-B
s6rc-fdholder

reader-A:
final-logger
s6rc-fdholder

reader-B:
final-logger
s6rc-fdholder

final-logger:
s6rc-fdholder</pre>}}

This shows that {{C|s6-rc-compile}} made {{Path|s6rc-fdholder}} a direct dependency of all members of the pipeline and made each service associated with the  writing end of a pipe a dependency of the service associated with the corresponding reading end. 

Starting all the services after launching an s6 supervision tree and initializing s6-rc, assuming that the working directory is the scan directory and that {{Path|../live}} is the relative pathname of the live state directory:
{{Cmd|s6-rc -ul ../live change service-AB-pipeline|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre> PID  PPID  PGRP EUSER    COMMAND
...
2128  2121  2128 user     -bash
2473  2128  2473 user      \_ s6-svscan
2477  2473  2473 user          \_ s6-supervise reader-A
2506  2477  2506 user          |   \_ /usr/lib/python-exec/python3.5/python ./run.user
2478  2473  2473 user          \_ s6-supervise service-B
2511  2478  2511 user          |   \_ test-daemon
2479  2473  2473 user          \_ s6-supervise s6rc-oneshot-runner
2480  2473  2473 user          \_ s6-supervise service-A
2515  2480  2515 user          |   \_ test-daemon
2481  2473  2473 user          \_ s6-supervise s6rc-fdholder
2489  2481  2489 user          |   \_ s6-fdholderd -1 -i data/rules
2482  2473  2473 user          \_ s6-supervise reader-B
2505  2482  2505 user          |   \_ /usr/lib/python-exec/python3.5/python ./run.user
2483  2473  2473 user          \_ s6-supervise final-logger
2498  2483  2498 user              \_ s6-log /home/user/logdir
...
</pre>}}

This shows that all services in the pipeline are now in up state, including {{Path|s6rc-fdholder}}, which is a supervised {{C|s6-fdholderd}} process. Sending a few <code>SIGHUP</code> signals to the {{C|test-daemon}} processes that correspond to services A and B:
{{Cmd|for i in A A B B A B B A|
output=<pre>>do
>s6-svc -h service-$i
>done</pre>}}
{{Cmd|cat /home/user/logdir/current|
output=<pre>This comes from service A: Message #1
This comes from service A: Message #2
This comes from service B: Message #1
This comes from service B: Message #2
This comes from service A: Message #3
This comes from service B: Message #3
This comes from service B: Message #4
This comes from service A: Message #4</pre>}}

This shows that all messages passed through the pipeline and got logged in the logging directory. Using {{C|s6-rc-db}} to display information about the pipeline:
{{Cmd|s6-rc-db -l ../live pipeline reader-B|
output=<pre>service-B | reader-B
reader-B | final-logger
service-A | reader-A
reader-A | final-logger
</pre>}}

Reader B is a member of pipeline {{Path|service-AB-pipeline}}, so that is what is printed.
{{anchor|initsystem}}
=== s6-rc as an init system component ===

s6-rc can be used as the service manager of [[s6 and s6-rc-based init system|an init system based on s6]]. Such an init system runs program {{C|s6-svscan}} from the s6 package as process 1 for most of the machine's uptime, and separate programs (usually execline scripts), the ''stage1 init'' and the ''stage3 init'', during the boot and shutdown sequences, respectively. Therefore, process 1 is the root of an s6 supervision tree for most of the machine's uptime, and has an associated scan directory, usually in a read-write tmpfs. s6-rc uses this supervision tree and a compiled service database, the ''boot-time service database'', that must be available during the machine's boot sequence, usually in the rootfs.

Because s6-rc must be initialized using the {{C|s6-rc-init}} program (see [[#initialization|initializing s6-rc]]) when the {{C|s6-svscan}} process is already running, this takes place in the ''stage2 init'', a program (usually an execline or shell script) that is launched by the stage1 init and blocks until the init system's catch-all logger is started. The s6-rc live state database is usually created in the same read-write tmpfs that is used for the init system's scan directory. The tmpfs is customarily mounted on {{Path|/run}}, and the live state directory is left to be {{Path|/run/s6-rc}}, s6-rc's default, so that no <code>-l</code> options have to be specified each time to s6-rc tools. After initializing s6-rc, atomic services (oneshots and longruns) that are needed to complete the machine's initialization, and longruns that are wanted in up state at the end of the boot sequence, must be started. This is can be usually done by defining [[#bundles|a service bundle]] containing all those services, and starting it in the stage2 init with an {{C|s6-rc -u change}} command naming that bundle.

The boot-time service database becomes live during the machine's boot sequence, so any service modification must be generally performed by creating a new service database using {{C|s6-rc-compile}}, and then replacing the current one with it using the {{C|s6-rc-update}} program (see [[#s6rcupdate|live updates to the service database]]). Service bundles can be direclty modified in the live database with the {{C|s6-rc-bundle}}, so a database switch is not strictly required in this case. If during the machine's uptime the s6-rc package is upgraded to a backwards-incompatible version, the current live database must be recompiled after the package upgrade using the same service definitions in  {{C|s6-rc-compile}}'s source format, and the {{C|s6-rc-format-upgrade}} program must be used to switch databases.

Here is a summary of possible ways of performing service modification:
* Bundle modifications in the live database performed with {{C|s6-rc-bundle}} are 'sticky' (i.e. are preserved across machine reboots).
* Contents of longrun's {{Path|env}} and {{Path|data}} subdirectories can be modified using the service directory symlinks in the init system's scan directory, but changes like this are not 'sticky'. They 'reset' to the contents in the corresponding service definition used to create the boot-time database after a machine reboot.
* Files with meaning defined by s6 ({{Path|run}}, {{Path|finish}}, etc.) ''could'' be modified directly using a longrun's service directory symlink in the init system's scan directory, but the modification of service directory contents is inherently a non-atomic operation that can have issues if the corresponding supervised process dies and gets restarted by its supervisor in the middle of the process<ref>Laurent Bercot, [https://www.skarnet.org/cgi-bin/archive.cgi?2:mss:1871:201710:nadggnhoigbpknlffnni On updating a live service directory]. Retrieved on April 29th, 2018.</ref>. Also, the changes are not 'sticky', so this is discouraged.
* Supporting files of oneshots (e.g. external scripts invoked from an {{Path|up}} or {{Path|down}} file) or longurns that are not placed in {{Path|env}} and {{Path|data}} subdirectories generally must referred to by absolute path, can be modified in their corresponding locations, and the changes are 'sticky'.
* Any other modification must generally be done with a new database and {{C|s6-rc-update}}, changes are 'sticky' this way and safe.

Finally, before {{C|s6-svscan}} replaces itself with the stage3 init during the shutdown sequence, all s6-rc-managed services must be stopped, usually with an {{C|s6-rc -da change}} command. This takes place in an an execline or shell script, the ''shutdown script'', that is invoked from an {{C|s6-svscan}} [[s6 and s6-rc-based init system#signals|diverted signal handler]].

== Removal ==

=== Unmerge ===

{{Unmerge|sys-apps/s6-rc}}

All live state directories, compiled service databases and service definitions in {{C|s6-rc-compile}}'s source format must be manually deleted if no longer wanted after removing the package. And obviously, if s6-rc is being used as an init system component, an alternative init system must be installed in parallel, and the machine rebooted to use it (possibly by reconfiguring the bootloader), before the package is removed, or otherwise the machine will become unbootable.

== See also ==

* {{See also|OpenRC}}
* {{See also|Systemd}}

== References ==

{{reflist}}

[[Category:Process Supervision]]
[[Category:Daemons]]
