<languages />

{{Metadata|abstract=Distcc は、ネットワーク越しの複数のホストにコンパイル作業を分散させられるようにするためのプログラムです。一つのサーバ（distccd）と一つのクライアントプログラム（distcc）からなっています。また、ちょっとした設定をすれば distcc は ccache, Portage, Automake などとうまく連携することができます。}}

{{InfoBox stack
|{{InfoBox homepage|https://github.com/distcc/distcc|header=true}}
|{{InfoBox wikipedia}}
}}

[https://github.com/distcc/distcc Distcc]はネットワーク上のホストで分散コンパイルを行うためのプログラムで、サーバー側である{{c|distccd}}とクライアント側である{{c|distcc}}で構成されています。また[http://ccache.samba.org ccache]、[[Portage]]、Automakeとの連携もちょっとしたセットアップで可能となります。 

Gentooのインストールに{{c|distcc}}を使いたい場合は、[[#ブートストラップに使う|ブートストラップに使う]]を参照してください。 

== インストール ==

{{c|distcc}}を構築する前に、まずは使用するすべてのホストに{{Package|sys-devel/distcc}} パッケージが導入されているかどうか確認しましょう。

=== 全てのホストで必要なこと ===

{{c|distcc}}を使用するには、ネットワークのすべてのコンピュータのGCCが同じバージョンでなければいけません。例を挙げますと、3.3.x(xは任意の数字)を混在させるのは問題ありませんが、3.3.xと3.2.xを混在させた場合はコンパイルエラーや実行時エラーが起きるかもしれません。 

=== USE フラグ ===

{{USEflag|package=sys-devel/distcc}}

=== Emerge ===

Distccには分散コンパイルしているタスクを監視するグラフィカルモニタが付属しています。<code>gtk</code> USEフラグをセットすると、このユーティリティーを使えるようにできます。

USEフラグの設定が終わったら{{Package|sys-devel/distcc}}パッケージをインストールします。

{{Emerge|sys-devel/distcc}}

{{Important|{{Package|sys-devel/distcc}}は分散コンパイルに使う全てのホストにインストールしてください。}}

== 設定 ==

=== サービス ===

{{c|distccd}}を自動的に起動するためには、次の方法に従ってください。

==== OpenRC ====

{{Path|/etc/conf.d/distccd}} を編集して <code>--allow</code> ディレクティブに信頼できるクライアントがセットされいるかどうかを確認してください。例えば multi-homded　システムを採用しているなどのように、さらにセキュリティを高めるには <code>--listen</code> ディレクティブで {{c|distccd}} デーモンにどのIPを受け付けるのかを知らせください。{{c|distcc}} のセキュリティについてもっと詳しく知りたいならば、[https://cdn.rawgit.com/distcc/distcc/master/doc/web/security.html Distcc security notes] を参照してください。

次の設定例では、<code>192.168.0.4</code>と<code>192.168.0.5</code>で実行されている distcc クライアントは、ローカルで実行されている {{c|distccd}} サーバへの接続が許されます:

{{FileBox|filename=/etc/conf.d/distccd|title=ある特定のクライアントがdistccに接続できるようにする|lang=bash|1=
DISTCCD_OPTS="--port 3632 --log-level notice --log-file /var/log/distccd.log -N 15 --allow 192.168.0.4 --allow 192.168.0.5"
}}

{{Important|重要なことは、 <code>--allow</code> と <code>--listen</code> を使用することです。{{c|distccd}} man ページか、もっと詳しくは上記のセキュリティについてのドキュメントをご覧ください。}}

それでは、分散コンパイルに参加する全てのコンピュータで {{c|distccd}} デーモンを起動しましょう: 

{{RootCmd
|rc-update add distccd default
|rc-service distccd start
}}

==== systemd ====

{{Path|/etc/systemd/system/distccd.service.d/00gentoo.conf}} ファイルを編集して、[[wikipedia:CIDR|CIDR]] フォーマットにて許可するクライアントを追加してください。192.168.1.xxxの範囲にあるすべてのIPアドレスを追加する例をあげますと:

{{FileBox|filename=/etc/systemd/system/distccd.service.d/00gentoo.conf|title=ALLOWED_SERVERS の設定|lang=bash|1=
Environment="ALLOWED_SERVERS=192.168.1.0/24"
}}

{{Note| ここで使われている "ALLOWED_SERVERS" という名前はいささか混乱を招きます。なぜなら、それはローカルの distccd サーバに接続を許されているクライアント（複数）を指し示しているからです。この変数は、 distccd サービスで使用される <code>--allow</code> オプションに引き渡されます。– さらなる情報については {{Path|/usr/lib/systemd/system/distccd.service}} ファイルを参照してください。}}

このような変更した後は、ユニット・ファイルをリロードしましょう。

{{RootCmd|systemctl daemon-reload}}

{{c|distccd}}の自動起動を有効にして、サービスを開始します:

{{RootCmd
|systemctl enable distccd
|systemctl start distccd
}}

=== 参加するホストを記述する ===

{{c|distcc-config}}コマンドを使用すれば、ホストのリストを設定することができます。 

ホストのリストの書き方の一例を下に記します。ほとんどのケースでは、１行目と２行目の書き方で十分でしょう。
２行目の書き方のように<code>/limit</code>シンタックスを使えば、{{c|distcc}}にこのノードで最大いくつのジョブを起動できるかを知らせることができます。[https://cdn.rawgit.com/distcc/distcc/master/doc/web/man/distcc_1.html distcc マニュアルページ] では、3行目や4行目のような書き方の詳しい説明が載っています。

{{CodeBox|title=ホスト定義の例|1=
192.168.0.1          192.168.0.2                       192.168.0.3
192.168.0.1/2        192.168.0.2                       192.168.0.3/10
192.168.0.1:4000/2   192.168.0.2/1                     192.168.0.3:3632/4
@192.168.0.1         @192.168.0.2:/usr/bin/distccd     192.168.0.3
}}

ホストをセッティングする方法にはここで挙げたほかにもいくつかやり方ありますので、詳細については、{{c|distcc}} man ページをご覧ください。

ローカルマシンでもコンパイル作業をさせたいのなら、ホストのリストに <code>localhost</code> と記入しましょう。逆に、ローカルマシンにコンパイル作業をさせたくない場合には、リストから外しましょう。遅いマシンでlocalhostを設定してると、実際すべてのことが遅くなってしまうでしょう。また、設定したものをテストするのも忘れないでください。

例の中の最初の一行目で書かれたホストを使用して、 {{c|distcc}} の環境を設定してみましょう。

{{RootCmd|/usr/bin/distcc-config --set-hosts "192.168.0.1 192.168.0.2 192.168.0.3"}}

Distccは、{{c|pump}}コマンドを実行することで、''pump''モードもサポートします。これは、複数のファイルが並行ビルドされる場合のビルド時間を大幅に減少させます。このモードは、プリプロセス済みのヘッダーをサーバー側にキャッシュし、結果としてこれらのヘッダーファイルが繰り返しアップロード・プリプロセスされないようにします。

ホストをpumpモード用に設定するには、 <code>,cpp,lzo</code> というサフィックスをホスト定義に加えます。pumpモードは <code>cpp</code> ''および'' <code>lzo</code> フラグを(ファイルがCであるかC++であるかに関わらず)必要とします。

{{RootCmd|/usr/bin/distcc-config --set-hosts "192.168.0.1,cpp,lzo 192.168.0.2,cpp,lzo 192.168.0.3,cpp,lzo"}}

== 使い方 ==

=== Portageで使用する ===

[[Portage]] が {{c|distcc}} を利用できるように設定するのは簡単です。 {{c|distcc}} feature を有効にして、同時にビルドに参加するジョブ数を設定する変数があるのですがこれに適当な数をいれてやるだけです (この数に従って {{c|distcc}} はビルドするリソースの量を増やします)。

下に示したように、<var>MAKEOPTS</var>変数と<var>FEATURES</var>変数を設定してください。

一般的な戦略としては、
* <code>N</code>の値を「トータルの」(ローカルとリモートの)CPUコアの個数の2倍 + 1に設定し、
* <code>M</code>の値を「ローカルの」CPUコアの個数に設定します。

<var>MAKEOPTS</var>変数で<code>-lM</code>を使用すると過剰なタスクが起動されてしまうのを防ぐことができます。例えば、{{c|distcc}}クラスタホストのいくつかが利用できなくなった時(他のシステムでの並列ジョブの量が増加した場合)や、ebuild でリモートビルドを禁止している時(gccなど)です。この仕組みは、システム負荷が <code>M</code>値以上になった時に、それ以上のジョブの追加を拒否することによって行われます。

{{FileBox|filename=/etc/portage/make.conf|title=MAKEOPTSとFEATURESの設定|lang=bash|1=
# NとMを計算した正しい値に置き換えてください
MAKEOPTS="-jN -lM"
FEATURES="distcc distcc-pump"
}}

{{Note|<code>network-sandbox</code> 値をクライアントの <var>FEATURES</var> 変数にセットすると、ネットワーク通信がブロックされるため、コンパイルデータを他のサーバーへ配布することができなくなるようです。必ずこの値を設定しないでおく(存在しないようにする)か、または無効化(<code>-network-sandbox</code>)するようにしてください。}}

{{Note|Distccのpumpモードは大きいパッケージのビルド時間を大幅に削減するでしょう。詳細については、 [[#参加するホストを記述する|参加するホストを記述する]] 節をご覧ください。}}

例えば、４コアＰＣのホスト２台と２コアＰＣのローカルがあったと仮定しましょう。すると <var>MAKEOPTS</var> 変数は次のようになります。

{{FileBox|filename=/etc/portage/make.conf|title=4コア２台(リモート)と2コア1台(ローカル)での MAKEOPTS の設定例example for 2 quad-core (remote) and one dual core (local) PC|lang=bash|1=
# 4コアのリモートホスト2台 = 8 コアのリモート
# 2コアのローカルホスト１台 = 2 コアのローカル
# コアの総数は、10　なので、 N = 2*10+1 と M=2
MAKEOPTS="-j21 -l2"
}}

==== CFLAGS と CXXFLAGS ====

{{Path|make.conf}}ファイルを編集するとき、<var>CFLAGS</var>や<var>CXXFLAGS</var>変数で<code>march=native</code>を設定してはいけません。これはよく確認してください。<code>march</code>が<code>native</code>に設定されていると、{{c|distccd}}は作業を他のマシンにうまく分散しなくなるでしょう。そのかわり、次のコマンドを実行すれば適切な<code>-march=</code>の値やだいたいのマシンフラグのセットを得ることができます:

{{Cmd|gcc -v -E -x c -march{{=}}native -mtune{{=}}native - < /dev/null 2>&1 {{!}} grep cc1 {{!}} perl -pe 's/^.* - //g;'}}

詳しくは、 [http://blogs.gentoo.org/mgorny/2014/06/23/inlining-marchnative-for-distcc/ Inlining <code>-march=native</code> for distcc] をご覧ください。

GCCの[https://gcc.gnu.org/bugzilla/show_bug.cgi?id=39851 バグ]は、適切なマシンフラグを推定するためのより信頼性が高く簡潔なメカニズムを促進する8.0 devツリーにて最近修正されました。この修正は 6 および 7 ブランチにバックポートされており、かなり近いうちにリリースされるはずです。それでもいくつかの処理はまだ必要であり、スクリプトは [https://github.com/daniel-santos/distccflags distccflags repo] あるいは wgetで見つけることができます:

{{Warning|スクリプトをなにも検証せずにダウンロードし実行することはセキュリティーリスクになります。こういったスクリプトを実行する前には、それがなにをしようとしているかよく確認し、内容・振舞いが不明なものや目的に沿わないものは実行しないようにしてください。}}

{{Cmd
|wget 'https://raw.githubusercontent.com/daniel-santos/distccflags/master/distccflags'
|chmod +x distccflags
|./distccflags -march{{=}}native
}}

=== automake で使用する ===

これは、場合によもりますが、Portageのセットアップよりも簡単です。<var>PATH</var>変数の{{c|gcc}} ({{Path|/usr/bin/}})のあるディレクトリよりも先頭に{{Path|/usr/lib/ditcc/bin/}}を書き込むだけでよいのです。ただし、ちょっと注意が必要です。もし {{c|ccache}}をご使用の場合は、{{c|ccache}}の後に{{c|distcc}}を配置してください: 

{{RootCmd|export PATH{{=}}"/usr/lib/ccache/bin:/usr/lib/distcc/bin:${PATH}"}}

これをユーザの {{Path|~/.bashrc}} 等のようなファイルに書き込んでおき、ユーザがログインするたびに設定されるようにしておきましょう。 もしくは、 {{Path|/etc/env.d/}} ファイルに書き込んでグローバルに設定するのもよいかもしれません。

何もつけずに{{c|make}}を呼び出すより、<code>-jN</code>(<code>N</code>は整数)をつけましょう。<code>N</code>は、コンパイルに使用するコンピュータのネットワークとタイプによって違います。このアーティクルの最初のところで適切な値の見つけ方をすでに書いておきましたのでご参考ください。

=== ブートストラップに使う ===

{{c|distcc}}をブートストラップに使う（たとえば、システムの残りをインストールする前にワーキングツールチェーンをビルドする）には、いくつか手間をかける必要があります。

==== Step 1: Portage の設定 ====

Gentoo Linux LiveCDで新しくマシンを立ち上げて[[Handbook:AMD64|installation instructions]]に従ってください。さらに、ブートストラップについての情報も[[FAQ|Gentoo FAQ]]にありますので参考にしましょう。その次に{{c|dsitcc}}を使用してPortageを初期設定してください。 

{{FileBox|filename=/etc/portage/make.conf|title= distccを使用するためのPortageの設定|lang=bash|1=
FEATURES="distcc"
MAKEOPTS="-jN"
}}

インストレーションセッションで<var>PATH</var>変数を次のように更新:

{{RootCmd|export PATH{{=}}"/usr/lib/ccache/bin:/usr/lib/distcc/bin:${PATH}"}}

==== Step 2: distcc をゲット ====

{{Package|sys-devel/distcc}}をインストール: 

{{RootCmd|USE{{=}}'-*' emerge --nodeps sys-devel/distcc}}

==== Step 3: distcc のセッティング ====

{{c|distcc-config --install}}を実行してdistccをセットアップしましょう。例中の<code>host#</code>には実際のIPアドレスやホスト名を入れてください。

{{RootCmd|/usr/bin/distcc-config --set-hosts "localhost host1 host2 host3 ..."}}

これでdistccはブートストラップ用に新しく設定されました。以降はインストレーションの手順に従ってください。{{c|emerge @system}}の後に{{c|emerge distcc}}を実行するのを''お忘れなく''。これは、すべての必要な依存関係のあるパッケージがインストールされているのかを確認するために行います。 

{{Note|ブートストラップと{{c|emerge @system}}の間、{{c|distcc}}が使われていないことを見つけてしまうかもしれません。これはdistccとうまくいかないようなebuildがり、そのようなebuildはわざとdistccを使用しないようにしているためだと思われます。
}}

=== Extras ===

{{c|distcc}}アプリケーションには、{{c|distcc}}環境での作業をサポートするための機能やアプリケーションがあります。

=== Monitoring utilities === 

Distccには2つの監視ユーティリティが付属しています。テキストベースの監視ユーティリティは {{c|distccmon-text}} で、必ずビルドされます。最初に実行するときは少々混乱するかもしれませんが、実際とても簡単に使うことができます。パラメータなしで実行したときは、プログラムは1回だけ実行されますが、引数に<code>N</code>を渡すと、<tt>N</tt>秒ごとに更新が行われます。

{{Cmd|distccmon-text 10}}

もうひとつの監視ユーティリティは <code>gtk</code> USE フラグがセットされた時のみ有効になります。これはGTK+ベースで、X環境で動作し、なかなか良い外見をしています。
Gentooでは、このGUIモニタは混乱を避けるため {{c|distccmon-gui}} にリネームされています(もともとの名前は{{c|distccmon-gnome}} です)。

{{Cmd|distccmon-gui}}

Portageでの{{c|distcc}}の使用をモニタするには:

{{RootCmd|DISTCC_DIR{{=}}"/var/tmp/portage/.distcc/" distccmon-text 10
|DISTCC_DIR{{=}}"/var/tmp/portage/.distcc/" distccmon-gui}}

{{Important|もしdistccディレクトリが別の場所にあるなら、それに合わせて<var>DISTCC_DIR</var>変数を変えてください。}}

<var>DISTCC_DIR</var>を環境変数にセットするための良い方法：

{{RootCmd|echo 'DISTCC_DIR{{=}}"/var/tmp/portage/.distcc/"' >> /etc/env.d/02distcc}}

ここで、環境を更新します:

{{RootCmd|env-update
|source /etc/profile}}

最後に、GUIアプリケーションを起動しましょう。

{{RootCmd|distccmon-gui}}

=== SSH for communication ===

Setting up distcc via SSH includes some pitfalls. First, generate an SSH key pair without password setup. Be aware that portage compiles programs as the Portage user (or as root if <code>FEATURES="userpriv"</code> is not set). The home folder of the Portage user is {{Path|/var/tmp/portage/}}, which means the keys need to be stored in {{Path|/var/tmp/portage/.ssh/}}

{{RootCmd|ssh-keygen -b 2048 -t rsa -f /var/tmp/portage/.ssh/id_rsa}}

Second, create a section for each host in the SSH configuration file:

{{FileBox|filename=/var/tmp/portage/.ssh/config|title=Add per-host sections|1=
Host test1
    HostName 123.456.789.1
    Port 1234
    User UserName
 
Host test2
    HostName 123.456.789.2
    Port 1234
    User UserName
}}

Send the public key to each compilation node:

{{RootCmd|ssh-copy-id -i /var/tmp/portage/.ssh/id_rsa.pub UserName@CompilationNode}}

Also make sure that each host is available in the {{Path|known_hosts}} file:

{{RootCmd|ssh-keyscan -t rsa <compilation-node-1> <compilation-node-2> [...] > /var/tmp/portage/.ssh/known_hosts}}

Fix the file ownership as follows:

{{RootCmd|chown -R portage:portage /var/tmp/portage/.ssh/}}

To set up the hosts <code>test1</code> and <code>test2</code>, run:

{{RootCmd|/usr/bin/distcc-config --set-hosts "@test1 @test2"}}

Please note the <code>@</code> (@ sign), which specifies ssh hosts for distcc.

Finally, tell {{c|distcc}} which SSH binary to use:

{{FileBox|filename=/etc/portage/make.conf|lang=bash|1=
DISTCC_SSH="ssh"
}}

It is not necessary to run the {{Path|distccd}} initscript on the hosts when {{c|distcc}} communicates via SSH.

=== Testing ===

To test {{c|distcc}}, write a simple ''Hello distcc'' program and run {{c|distcc}} in verbose mode to see if it communicates properly.

{{FileBox|filename=main.c|lang=c|1=
#include <stdio.h>
 
int main() {
    printf("Hello distcc!\n");
    return 0;
}
}}

Next, turn on verbose mode, compile the program using {{c|distcc}} and link the generated object file into an executable:

{{Cmd
|export DISTCC_VERBOSE{{=}}1
|distcc gcc -c main.c -o main.o # or 'pump distcc <...>'
|gcc main.o -o main
}}

{{Note|Replace {{c|distcc}} command with {{c|pump distcc}} for use pump mode.}}

There should be a bunch of output about {{c|distcc}} finding its configuration, selecting the host to connect to, starting to connect to it, and ultimately compile {{Path|main.c}}. If the output does not list the desired {{c|distcc}} hosts, check the configuration.

Finally, ensure the compiled program works properly. To test each host, enumerate each compile host in the hosts file.

{{Cmd|./main|output=<pre>Hello distcc!</pre>}}

== トラブルシューティング ==

<!-- このセクションがもっと大きくなるようでしたらサブページに分割するようにしてください。 -->

{{c|distcc}} をご使用中に問題が発生したときには、このセクションをお読みになれば問題解決の糸口となるかもしれません。

=== ERROR: failed to open {{Path|/var/log/distccd.log}} ===

<!-- バグが解決して修正されたパッケージが安定化すれば、この部分は削除してください -->

2015年1月22日以降、emergeすると {{Path|/var/log/}} に適切な {{Path|distccd.log}} ファイルを作るのに失敗します。これは、 distcc ver.3.1-r8 のみに起こることが明らかにされています。このバグは現在修正中ですが(参照:{{Bug|477630}})、手作業でそのログファイルを作成し、適切な所有者を設定し、distccデーモンを再起動することで何とかうまく動くようにできます。

{{RootCmd
|mkdir -p /var/log/distcc
|touch /var/log/distcc/distccd.log
|chown distcc:daemon /var/log/distcc/distccd.log
}}

次に、{{Path|/etc/conf.d/distccd}}にある{{c|distccd}}コンフィグレーションファイルの{{Path|/var/log}}の値を先ほど作成した{{Path|distcc}}ディレクトリに更新してください：

{{FileBox|filename=/etc/conf.d/distccd|title=Updating log path|lang=bash|1=
DISTCCD_OPTS="--port 3632 --log-level notice --log-file /var/log/distcc/distccd.log -N 15 
}}

最後に distccd サービスを再起動します。

{{RootCmd|/etc/init.d/distccd restart}}

=== distccをつかえないパッケージもあります ===

様々なパッケージをインストールしていく中で、分散されない（並列にビルドできない）パッケージがあることに気づくでしょう。これは、そのパッケージの{{Path|Makefile}}が並列オペレーションをサポートしていない、あるいはそのebuildのメインテナーが既知の問題があるために並列オペレーションを禁止しているからだと思われます。 

時として、{{c|distcc}}はパッケージのコンパイルに失敗することもあります。このようなことが起こりましたら、お手数ですが[https://bugs.gentoo.org/ 報告]してください。

=== GCC のバージョンが混在する場合 ===

もしdistcc環境のホスト間でGCCのバージョンが違っていたら、奇怪な問題が起こるかもしれません。解決法は、すべてのホストが同じバージョンのGCCであることをしっかり確認することです。 

最近のPortageのアップデートでは、<code>gcc</code>のかわりに<code>${CHOST}-gcc</code>(minus gcc)を使うようになっています。しかしながらこのことは、もしi686マシーンがほかのタイプのマシーン(i386,i586)と混在していた場合には、ビルドが失敗に終わってしまうことになります。この問題に対しては、次の対処をするとよいかもしれません:

{{RootCmd|export CC{{=}}'gcc' CXX{{=}}'c++'}}

{{Path|/etc/portage/make.conf}}の<var>CC</var>と<var>CXX</var>変数を上記のようにセットしてもよいでしょう。

{{Important|これを行うことでPortageの振る舞いを明らかに変えてしまい、将来において奇妙な結果を引き起こすことがあるかもしれません。ですので、混在するCHOSTがどうしても避けられないときにのみ行ってください。}}

{{Note|Having the right version of gcc as a slot on a server isn’t enough. Portage uses {{c|distcc}} as a replacement for the compiler referenced by the <var>CHOST</var> variable (i.e. <code>x86_64-pc-linux-gnu</code>) and {{c|distccd}} invokes it by exactly same name. The right version of gcc should be a default system’s compiler on all involved compilation hosts.}}

=== -march=native ===

GCC 4.3.0よりコンパイラは<code>-march=native</code>オプションをサポートするようになりました。これは、CPU自動判別と最適化の機能を有効にするものでで、GCCが実行されているプロセッサに対しては有効にしておく価値のあるものです。しかしながら、そのオプションで{{c|distcc}}を使用した場合には、一つ問題が引き起こされます。理由はそれぞれのプロセッサでの最適化されたコードが混在してしまうからです。例を挙げますと、<code>-march=native</code>とともに{{c|distcc}}を実行するとき、あるシステムでは AMD Athlon プロセッサで、別のシステムでは Intel Pentiumプロセッサの場合、両方のプロセッサのコンパイルしたコードが混在してしまうのです。

次の注意を心に留めておきましょう:

{{Warning|{{c|distcc}} でコンパイルするときには、{{Path|make.conf}} の <var>CFLAGS</var> 変数または <var>CXXFLAGS</var> 変数で <code>-march{{=}}native</code> や <code>-mtune{{=}}native</code>を '''使用しないでください'''。}}

See the [[#CFLAGS_and_CXXFLAGS|CFLAGS and CXXFLAGS section]] and [http://blogs.gentoo.org/mgorny/2014/06/23/inlining-marchnative-for-distcc/ Inlining <code>-march=native</code> for distcc] for more information.

=== Get more output from emerge logs ===

It is possible to obtain more logging by enabling verbose mode. This is accomplished by adding <var>DISTCC_VERBOSE</var> to {{Path|/etc/portage/bashrc}}:

{{FileBox|title=Enabling verbose logging|filename=/etc/portage/bashrc|lang=bash|1=
export DISTCC_VERBOSE=1
}}

The verbose logging can then be found in {{Path|/var/tmp/portage/$CATEGORY/$PF/temp/build.log}}.

Keep in mind that the first {{c|distcc}} invocation visible in {{Path|build.log}} isn’t necessary the first {{c|distcc}} call during a build process. For example a build server can get a one-minute backoff period during the configuration stage when some checks are performed using a compiler ({{c|distcc}} sets a backoff period when compilation on a remote server failed, it doesn’t matter whether it failed on local machine or not).

Dig into the {{Path|/var/tmp/portage/$CATEGORY/$PF/work/}} directory to investigate such situations. Find other logs, or call {{c|make}} explicitly from within the working directory.

Another interesting variable to use is <var>DISTCC_SAVE_TEMPS</var>. When set, it saves the standard output/error from a remote compiler which, for Portage builds, results in files in the {{Path|/var/tmp/portage/$CATEGORY/$PF/temp/}} directory.

{{FileBox|title=Saving temporary output|filename=/etc/portage/bashrc|lang=bash|1=
export DISTCC_SAVE_TEMPS=1
}}

== 参考 ==

[[Distcc/Cross-Compiling|DistCC Cross-compiling guide]]には、{{c|distcc}}を使ってどのようにあるアーキテクチャから別のアーキテクチャのプラグラムをビルドするかの説明があります。Athlon(i686)を使ってK6-2(i586)のプログラムをビルドしたり、SPARCを使ってPowerPCのプログラムをビルドをするように簡単に行うことができます。

== 外部の情報 ==

* [http://blogs.gentoo.org/mgorny/2014/06/23/inlining-marchnative-for-distcc/ Inlining <code>-march=native</code> for distcc]
* [https://github.com/distcc/distcc Distcc homepage]

[[Category:Compilation]]
{{Migrated|originalauthors=Lisa Seelye, {{Dev|floppym}}, Erwin, {{Dev|SwifT}}, Lars Weiler, Tiemo Kieft, and {{Dev|nightmorph}}}}
