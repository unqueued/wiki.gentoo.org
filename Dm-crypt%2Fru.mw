<languages />


{{Metadata|abstract=DM-Crypt – это система шифрования дисков с использованием платформы crypto API ядра Linux и подсистемы определения устройств.}}

{{InfoBox stack
|{{InfoBox homepage|https://gitlab.com/cryptsetup/cryptsetup|header=true}}
|{{InfoBox wikipedia}}
}}

'''dm-crypt''' – это система шифрования дисков с использованием платформы ядра crypto API и подсистемы определения устройств. С помощью dm-crypt администраторы могут зашифровать весь диск, логические тома, разделы, а также отдельные файлы.

Подсистема dm-crypt поддерживает структуру ''Linux Unified Key Setup (LUKS)'', которая позволяет с помощью различных ключей получать доступ к зашифрованным данным, а также управлять ключами (например, изменять ключи, добавлять дополнительные пароли, и др.) Хотя dm-crypt поддерживает установку без LUKS, данная статья будет в основном посвящена функционалу LUKS, в силу её гибкости, управляемости, а также широкой поддержки в обществе.

== Конфигурация ==

Существует два условия, необходимых для использования dm-crypt:

# Настройка ядра Linux
# Установка пакета {{Package|sys-fs/cryptsetup}}

=== Конфигурация ядра ===

Для использования dm-crypt необходимо настроить несколько параметров конфигурации.

Прежде всего, должна быть включена поддержка инфраструктуры ''device mapper'' и ''crypt target'':

{{KernelBox|title=Включение device mapper и crypt target|1=
[*] Enable loadable module support
Device Drivers --->
    [*] Multiple devices driver support (RAID and LVM) --->
        <*> Device mapper support
        <*>   Crypt target support
}}

Далее, ядро Linux должно поддерживать набор криптографических функций, которые администратор хочет использовать для шифрования. Они могут быть найдены в разделе ''Cryptographic API'':

{{KernelBox|title=Включение функций cryptographic API|1=
[*] Cryptographic API --->
    <*> XTS support
    <*> SHA224 and SHA256 digest algorithm
    <*> AES cipher algorithms
    <*> AES cipher algorithms (x86_64)
    <*> User-space interface for symmetric key cipher algorithms
}}

Если также будет зашифрована корневая файловая система, необходимо создать initramfs, в которой корневая файловая система будет расшифрована перед монтированием. Таким образом, требуется поддержка initramfs:

{{KernelBox|title=Включение поддержки initramfs|1=
General setup  --->
    [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support
}}

=== Установка Cryptsetup ===

Пакет {{Package|sys-fs/cryptsetup}} предоставляет команду {{c|cryptsetup}}, которая используется для открытия или закрытия зашифрованного хранилища, а также для управления паролями и связанными с ними ключами.

{{Emerge|sys-fs/cryptsetup}}

== Зашифрованное хранилище ==

=== Ключевой файл или пароль ===

Чтобы начать работу с зашифрованным хранилищем, администратор должен решить, какой метод использовать для создания ключа шифрования. Если используется {{c|cryptsetup}}, можно выбрать пароль или ключевой файл. Ключевой файл может быть любым файлом, но рекомендуется использовать надлежащим образом защищённый (ввиду того, что доступ к ключевому файлу подразумевает доступ к зашифрованным данным) файл с случайными данными.

Для создания ключевого файла, можно использовать команду {{c|dd}}:

{{RootCmd|dd if{{=}}/dev/urandom of{{=}}/etc/keys/enc.key bs{{=}}1 count{{=}}4096}}

В следующих разделах мы будем указывать каждую команду для обоих случаев: пароля и ключевого файла. Конечно, необходим только один метод.

=== Создание платформы зашифрованного хранилища ===

Чтобы создать платформу защищённого хранилища (которое может быть диском, разделом, файлом, ...) вызовите команду {{c|cryptsetup}} с параметром <code>luksFormat</code>.

К примеру, что использовать {{Path|/dev/vdb2}} как носитель зашифрованных данных:

{{RootCmd|cryptsetup -s 512 luksFormat /dev/vdb2|output=<pre>
This will overwrite data on /dev/vdb2 irrevocably.
  
Are you sure? (Type uppercase yes): YES
Enter LUKS passphrase: ...
Verify passphrase: ...
</pre>}}

Для использования ключевого файла вместо пароля:

{{RootCmd|cryptsetup -s 512 luksFormat /dev/vdb2 /etc/keys/enc.key|output=<pre>
This will overwrite data on /dev/vdb2 irrevocably.
  
Are you sure? (Type uppercase yes): YES
</pre>}}

Параметр <code>-s 512</code> сообщает {{c|cryptsetup}}, какую длину ключа использовать для настоящего ключа шифрования (который, в отличие от пароля или ключевого файла, используется непосредственно для доступа к данным).

=== Открытие зашифрованного хранилища ===

Чтобы открыть зашифрованное хранилище (т.е. сделать реальные данные доступными благодаря незаметной расшифровке), используйте параметр <code>luksOpen</code>.

{{RootCmd|cryptsetup luksOpen /dev/vdb2 myname|output=<pre>
Enter passphrase for /dev/vdb2: ...
</pre>}}

Если используется ключевой файл, команда будет выглядеть таким образом:

{{RootCmd|cryptsetup luksOpen -d /etc/keys/enc.key /dev/vdb2 myname}}

Когда команда успешно завершится, станет доступным новый файл устройства {{Path|/dev/mapper/myname}}. 

Если это зашифрованное устройство используется в первый раз, его необходимо отформатировать. Следующий пример использует файловую систему [[Btrfs]], но, конечно же, система может создать и любую другую:

{{RootCmd|mkfs.btrfs /dev/mapper/myname}}

Когда файловая система создана, или форматирование уже было произведено в прошлом, файл устройства может быть смонтирован:

{{RootCmd|mount /dev/mapper/myname /home}}

=== Закрытие зашифрованного хранилища ===

Чтобы закрыть зашифрованное хранилище (т.е. убедиться, что реальные данные больше не доступны благодаря незаметной расшифровке), используйте параметр <code>luksClose</code>:

{{RootCmd|cryptsetup luksClose myname}}

Конечно, убедитесь, что устройство больше не используется:

== Manipulating LUKS keys ==

LUKS keys are used to access the real encryption key. They are stored in slots in the header of the (encrypted) partition, disk or file.

=== Listing the slots ===

With the <code>luksDump</code> action, information about the encrypted partition, disk or file can be shown. This includes the slots:

{{RootCmd|cryptsetup luksDump /dev/vdb2|output=<pre>
LUKS header information for /dev/vdb2
  
Version:        1
Cipher name:    aes
Cipher mode:    xts-plain64
Hash spec:      sha1
Payload offset: 4096
MK bits:        512
MK digest:      34 3b ec ac 10 af 19 e7 e2 d4 c8 90 eb a8 da 3c e4 4f 2e ce
MK salt:        ff 7c 7f 53 db 53 48 02 a4 32 dc e0 22 fc a3 51
                06 ba b3 48 b3 28 13 a8 7a 68 43 d6 46 79 14 fe
MK iterations:  59375
UUID:           2921a7c9-7ccb-4300-92f4-38160804e08c
  
Key Slot 0: ENABLED
        Iterations:             241053
        Salt:                   90 0f 0f db cf 66 ea a9 6c 7c 0c 0d b0 28 05 2f
                                8a 5c 14 54 98 62 1a 29 f3 08 25 0c ec c2 b1 68
        Key material offset:    8
        AF stripes:             4000
Key Slot 1: ENABLED
        Iterations:             273211
        Salt:                   01 4c 26 ed ff 18 75 31 b9 89 5d a6 e0 b5 f4 14
                                48 d0 23 47 a9 85 78 fb 76 c4 a9 d0 cd 63 fb d7
        Key material offset:    512
        AF stripes:             4000
Key Slot 2: DISABLED
Key Slot 3: DISABLED
Key Slot 4: DISABLED
Key Slot 5: DISABLED
Key Slot 6: DISABLED
Key Slot 7: DISABLED
</pre>}}

In the above example, two slots are used. Note that <code>luksDump</code> does not give away anything sensitive - it is merely displaying the LUKS header content. No decryption key has to be provided in order to call <code>luksDump</code>.

=== Adding a keyfile or passphrase ===

In order to add an additional keyfile or passphrase to access the encrypted storage, use the <code>luksAddKey</code> action:

{{RootCmd|cryptsetup luksAddKey /dev/vdb2|output=<pre>
Enter any passphrase: (Enter a valid, previously used passphrase to unlock the key)
Enter new passphrase for key slot: ... 
Verify passphrase: ...
</pre>}}

To use a keyfile to unlock the key (but still add in a passphrase):

{{RootCmd|cryptsetup luksAddKey -d /etc/keys/enc.key /dev/vdb2|output=<pre>
Enter new passphrase for key slot: ...
Verify passphrase: '''
</pre>}}

If a keyfile is to be added (say {{Path|/etc/keys/backup.key}}):

{{RootCmd|cryptsetup luksAddKey /dev/vdb2 /etc/keys/backup.key}}

Or, to use the first keyfile to unlock the main key:

{{RootCmd|cryptsetup luksAddKey -d /etc/keys/enc.key /dev/vdb2 /etc/keys/backup.key}}

=== Removing a keyfile or passphrase ===

With the <code>luksRemoveKey</code> action, a keyfile or passphrase can be removed (so they can no longer be used to decrypt the storage):

{{RootCmd|cryptsetup luksRemoveKey /dev/vdb2|output=<pre>
Enter LUKS passphrase to be deleted: ...
</pre>}}

Or to remove a keyfile:

{{RootCmd|cryptsetup luksRemoveKey -d /etc/keys/backup.key /dev/vdb2}}

Make sure that at least one method for accessing the data is still available. Once a passphrase or keyfile is removed for use, this cannot be recovered again.

=== Emptying a slot ===

Suppose the passphrase or keyfile is no longer known, then the slot can be freed. Of course, this does require prior knowledge of which slot that the passphrase or keyfile was stored in.

For instance, to empty out slot 2 (which is the third slot as slots are numbered starting from 0):

{{RootCmd|cryptsetup luksKillSlot /dev/vdb2 2}}

This command will ask for a valid passphrase before continuing. Or one can pass on the keyfile to use:

{{RootCmd|cryptsetup luksKillSlot -d /etc/keys/enc.key /dev/vdb2 2}}

== Automate mounting encrypted file systems ==

Until now, the article focused on manual setup and mounting/unmounting of encrypted file systems. An init service {{Path|dmcrypt}} exists which automates the decrypting and mounting of encrypted file systems.

=== Configuring dm-crypt ===

Edit the {{Path|/etc/conf.d/dmcrypt}} file and add in entries for each file system. The supported entries are well documented in the file, the below example is just that - an example:

{{FileBox|filename=/etc/conf.d/dmcrypt|title=Automatically enabling two encrypted file systems|1=
# Definition for /dev/mapper/home (for /home)
target=home
source=UUID="abcdef12-321a-a324-a88c-cac412befd98"
key=/etc/keys/home.key
 
# Definition for /dev/mapper/local (for /usr/local)
target=local
source=UUID="fedcba34-4823-b423-a94c-cadbefda2943"
key=/etc/keys/local.key
}}

=== Configuring fstab ===

The next step is to configure {{Path|/etc/fstab}} to automatically mount the (decrypted) file systems when they become available. It is recommended to first obtain the UUID of the decrypted (mounted) file system:

{{RootCmd|blkid /dev/mapper/home|output=<pre>
/dev/mapper/home: UUID="4321421a-4321-a6c9-de52-ba6421efab76" TYPE="ext4"
</pre>}}

Then, update the {{Path|/etc/fstab}} file accordingly:

{{FileBox|filename=/etc/fstab|title=Automounting the decrypted file systems|1=
UUID="4321421a-4321-a6c9-de52-ba6421efab76"   /home        ext4   defaults   0   0
UUID="bdef2432-3bd1-4ab4-523d-badcf234a342"   /usr/local   ext4   defaults   0   0
}}

=== Add initscript to bootlevel ===

Don't forget to have the {{Path|dmcrypt}} init service launched at boot:

{{RootCmd|rc-update add dmcrypt boot}}

== Дополнительные ресурсы ==

* [[Dm-crypt full disk encryption]] on the Gentoo Wiki provides supplementary information on using encrypted file systems for Gentoo Linux installations
* The [https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions cryptsetup FAQ] hosted on GitLab covers a wide range of frequently asked questions.


[[Category:Core system]]
