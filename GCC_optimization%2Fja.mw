<languages />

{{Metadata|abstract=このガイドは、コンパイル済みコードを安全で分別のあるCFLAGSとCXXFLAGSを使って最適化する手法を紹介します。また、一般的な最適化の背景にある理論について述べます。}}

このガイドは、コンパイル済みコードを安全で分別のある<var>CFLAGS</var>と<var>CXXFLAGS</var>を使って最適化する手法を紹介します。また、一般的な最適化の背景にある理論について述べます。

== はじめに ==

=== CFLAGSとCXXFLAGSとは？ ===

<var>CFLAGS</var> and <var>CXXFLAGS</var> are among the environment variables conventionally used to specify compiler options to a build system when compiling C and C++ code. While these variables are not standardized, their use is essentially ubiquitous and any correctly written build should understand these for passing extra or custom options when it invokes the compiler. See the [https://www.gnu.org/software/make/manual/make.html#Implicit-Variables GNU make] info page for a list of some of the commonly used variables in this category.

Because such a large proportion of the packages that make up most Gentoo systems are written in C and C++, these are two variables administrators will definitely want to set correctly as they will greatly influence the way much of the system is built.

これらはプログラムのデバッグメッセージの量を減らすために使われたり、エラーや警告のレベルを増加させたり、また、もちろん生成されるコードの最適化にも使われます。[https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC manual]に利用可能なフラグとその効果の完全なリストが記載されています。

=== どのように使われているのでしょうか？ ===

Normally, <var>CFLAGS</var> and <var>CXXFLAGS</var> would be set in the environment when invoking a configure script or with makefiles generated by the {{c|automake}} program. In Gentoo-based systems, set the <var>CFLAGS</var> and <var>CXXFLAGS</var> variables in {{Path|/etc/portage/make.conf}}. Variables set in this file will be exported to the environment of programs invoked by portage such that all packages will be compiled using these options as a base.

{{CodeBox|title=/etc/portage/make.confのCFLAGS設定|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important/ja|'''USE'''フラグは複数の行で構成できますが、<var>CFLAGS</var>を複数の行で構成すると{{c|cmake}}のようなプログラムで問題が発生します。問題を避けるために、<var>CFLAGS</var>の宣言は極力スペースで区切られた単一行で構成するようにしてください。{{Bug|500034}}が参考になります。}}

As seen in the example above the <var>CXXFLAGS</var> variable is set to use all the options present in <var>CFLAGS</var>. Almost every system should be configured in this manner. Additional options for <var>CXXFLAGS</var> are less common and don't usually apply generally enough to deserve setting them globally.

=== よくある誤解 ===

While compiler optimizations enabled by various <var>CFLAGS</var> can be an effective means of producing smaller and/or faster binaries, they can also impair the function of the code, bloat its size, slow down its execution time, or simply cause a build failure. The point of diminishing performance returns is reached rather quickly when dealing with <var>CFLAGS</var>. Don't set them arbitrarily.

Remember, the global <var>CFLAGS</var> configured in {{Path|/etc/portage/make.conf}} will be applied to every package on the system so administrators typically only set general, widely-applicable options. Individual packages further modify these options either in the ebuild or the build system itself to generate the final set of flags used when invoking the compiler.

=== 準備はできましたか？ ===

リスクを伴うことを理解したところで、良識的、かつ安全な最適化の方法を見ていきましょう。そうすれば、この先[https://bugs.gentoo.org/ Bugzilla]で開発者に歓迎され、役立つ報告をすることができます。（開発者は、大抵、問題が再現するか確かめるために、最小限の<var>CFLAGS</var>でパッケージを再コンパイルすることを要求します。挑戦的なフラグはコードを破壊しうることを覚えておいてください!） 

== 最適化について ==

=== 基本 ===

The goal behind <var>CFLAGS</var> and <var>CXXFLAGS</var> is to create code tailor-made to the system; it should function perfectly while being lean and fast, if possible. Sometimes these conditions are mutually exclusive, so this guide will stick to combinations known to work well. Ideally, they are the best available for any CPU architecture. For informational purposes, aggressive flag use will be covered later. Not every option listed on the GCC manual (there are hundreds) will be discussed, but basic, most common flags will be reviewed. 

{{Note|When unaware of what a flag does refer to the relevant chapter of the [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual]. If still stumped after viewing the manual, try a search engine or check out the [https://gcc.gnu.org/lists.html GCC mailing lists].}}

=== -march ===

最初の、そしてもっとも重要なオプションは<code>-march</code>です。このオプションはコンパイラに対してどのシステム[https://en.wikipedia.org/wiki/Microarchitecture プロセッサアーキテクチャ] (もしくは"arch")のためのコードを生成するのかを指示します。つまり、特定のCPU向けのコードを生成すべきであるといっているのです。CPUが違えば、性能が異なり、異なる命令セットをサポートし、コードの実行方法も違います。<code>-march</code>フラグは、あなたのCPUの全ての性能、特徴、命令セット、癖などに合わせて特化したコードを生成するようにコンパイラに伝えます。 

たとえ{{Path|/etc/portage/make.conf}}に書いてある<code>CHOST</code>変数を一般的なアーキテクチャに設定していても、<code>-march</code>を設定すれば、プログラムは指定したプロセッサ向けに最適化されるでしょう。x86とx86-64のCPUは(とりわけ)<code>-march</code>フラグを使うべきです。 

どんな種類のCPUを使っていますか？以下のコマンドを実行すれば、それが分かります。 

{{Cmd|cat /proc/cpuinfo}}

さらに<code>march</code>と<code>mtune</code>の値を含む詳細な情報を得たい場合は、以下の2つのコマンドが使えます。

* 最初のコマンドはコンパイラにリンクを行わないようにさせ(<code>-c</code>)、また、<code>--help</code>をコマンドラインオプションを明らかにせよとではなく、あるオプションが有効か無効かを示せという意味に解釈させます(<code>-Q</code>)。ここでは、選択されたターゲットで有効なオプションが出力されます:
:{{Cmd|gcc -c -Q -march{{=}}native --help{{=}}target}}

* The second command will show the compiler directives for building the header file, but without actually performing the steps and instead showing them on the screen (<code>-###</code>). The final output line is the command that holds all the optimization options and architecture selection:
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

では実際に<code>-march</code>を見てみましょう。この例は古いPentium IIIチップ向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium IIIの例|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

こちらはAMD64向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64の例|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

CPUのタイプが決められない場合、またはどの設定を使えばいいかわからない場合、<code>-march=native</code>を使うことができます。このフラグを使った場合、GCCはプロセッサを判別して、自動的にふさわしいフラグを設定するでしょう。'''しかしながら、このフラグは異なるCPU向けにパッケージをコンパイルする目的では使用すべきではありません！''' 

{{Warning/ja|{{c|[[Distcc#-march.3Dnative|distcc]]}}を使ってコンパイルする場合、{{Path|make.conf}}の<var>CFLAGS</var>もしくは<var>CXXFLAGS</var>に<code>-march{{=}}native</code>や<code>-mtune{{=}}native</code>を使用しては'''いけません'''。}}

If compiling packages on one computer in order to run them on a different computer (such as when using a fast computer to build for an older, slower machine), then ''do not'' use <code>-march=native</code>. "Native" means that the code produced will run ''only'' on that type of CPU. The applications built with <code>-march=native</code> on an AMD Athlon 64 CPU will '''not''' be able to run on an old VIA C3 CPU. 

また、<code>-mtune</code>と<code>-mcpu</code>フラグも利用可能です。これらのフラグはたいてい<code>-march</code>フラグが利用できない場合にのみ使われます。例えば特定のプロセッサアーキテクチャは<code>-mtune</code>や<code>-mcpu</code>が必要になるかもしれません。残念ながら、GCCの挙動はそれぞれのフラグの振る舞いが、あるアーキテクチャから近いアーキテクチャであってもあまり一貫性はありません。 

x86とx86-64のCPUにおいて、<code>-march</code>は利用可能な命令セットと正しいABIを使い、そのCPUに特化したコードを生成するでしょう。そのため古かったり種類の異なるCPUとの後方互換性は持っていません。i386やi486のような古いCPU向けにコードを生成する必要があるときのみ、<code>-mtune</code>の使用を考慮するべきでしょう。<code>-mtune</code>は<code>-march</code>よりも一般的なコードを生成します。特定のCPUコードにチューニングしますが、利用可能な命令セットやABIを考慮しないのです。<code>-mcpu</code>はx86やx86-64のシステム上では非推奨となっているので、使わないでください。 

x86/x86-64でない(SparcやAlpha、PowerPCのような)CPUでのみ、<code>-march</code>の代わりに<code>-mtune</code>や<code>-mcpu</code>が必要になるでしょう。これらのアーキテクチャ上では、<code>-mtune</code>/<code>-mcpu</code>は(x86/x86-64上での)<code>-march</code>と同じように振る舞うでしょう･･･しかしフラグの名前は違うのです。繰り返しますが、GCCの振る舞いとフラグ名はアーキテクチャを超えて一貫していないので、システムでどのフラグを使うべきなのかをGCCの[http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options マニュアル]で必ず確認してください。 

{{Note|For more suggested <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> settings, please read chapter 5 of the appropriate [[HandBook:Main_Page|Gentoo Installation Handbook]] for the arch. Also, read the GCC manual's list of [https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options], as well as more detailed explanations about the differences between <code>-march</code>, <code>-mcpu</code>, and <code>-mtune</code>.}}

=== -O ===

次は<code>-O</code>フラグについてです。これは全体の最適化レベルをコントロールしますが、特にこの最適化レベルを上げることによって、ソースコードのコンパイルの時間がいくらか増えたり、よりたくさんのメモリを使用するようになります。 

７つの<code>-O</code>設定があります。<code>-O0</code>、<code>-O1</code>、<code>-O2</code>、<code>-O3</code>、<code>-Os</code>、<code>-Og</code>、<code>-Ofast</code>です。{{Path|/etc/portage/make.conf}}で指定できるのはこのうちの一つだけです。

With the exception of <code>-O0</code>, the <code>-O</code> settings each activate several additional flags, so be sure to read the GCC manual's chapter on [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimization options] to learn which flags are activated at each <code>-O</code> level, as well as some explanations as to what they do. 

では、それぞれの最適化レベルを見てみましょう。 

*  <code>-O0</code>: このレベル("O"のあとにゼロが続いてます)は、完全に最適化をオフにします。<var>CFLAGS</var>や<var>CXXFLAGS</var>の中に<code>-O</code>が定義されていない場合のデフォルトです。このレベルはコンパイル時間を短縮して、生成するデバッグ情報を改善しますが、いくつかのアプリケーションは最適化がないと正しく動作しません。よって、デバッグ以外では推奨されません。

*  <code>-O1</code>: これは最も基本的な最適化レベルです。コンパイラは時間をたくさんかけることなく、高速でサイズの小さなバイナリを生成しようと試みるでしょう。これは基本的な最適化しかおこないませんが、その代わり、いつでもうまくいくはずです。

*  <code>-O2</code>: <code>-O1</code>から更に踏み込みます。これは特別な理由がない限り"推奨される"最適化レベルです。<code>-O2</code>は<code>-O1</code>で有効になるものに加え、さらにいくつかのフラグを有効にします。<code>-O2</code>を使うと、コンパイラはサイズとコンパイル時間に妥協せずにコードのパフォーマンスを改善しようと試みます。

*  <code>-O3</code>: これは取りうる最も高い最適化レベルです。コンパイル時間とメモリ使用量を犠牲にして最適化を実施します。ただし<code>-O3</code>は性能を改善する保証がありません。実際多くのケースで、バイナリサイズが大きくなり、メモリ使用量が増えることで逆にシステムが遅くなります。<code>-O3</code>はいくつかのパッケージを壊すことがわかっています。これらの理由により<code>-O3</code>は推奨されません。

*  <code>-Os</code>: このレベルはバイナリのサイズを重視して最適化するでしょう。これは<code>-O2</code>フラグの中で、生成されるバイナリのサイズが増えないものを全て有効にします。CPUのキャッシュが小さかったり、ディスクの空き容量が極端に限られている場合などに非常に有効でしょう。

*  <code>-Og</code>: GCC 4.8では新しい汎用的な最適化レベル<code>-Og</code>が導入されました。このレベルはコンパイル時間の短縮とデバッグエクスペリエンスを向上させる一方、妥当なランタイム性能を確保することを目的としています。結果的に開発全体で得られるものはデフォルトの最適化レベル<code>-O0</code>より向上するはずです。<code>-Og</code>と<code>-g</code>は同じでないことだけ理解しておいてください。<code>-g</code>はデバッガとやりとりするために単純に最適化をオフにするだけです。

*  <code>-Ofast</code>: GCC 4.7では、<code>-O3</code>に加えて<code>-ffast-math</code>、<code>-fno-protect-parens</code>、<code>-fstack-arrays</code>が利用できます。このオプションは規格への厳密な適合を犠牲にするため推奨されません。

前述の通り、<code>-O2</code>が推奨される最適化レベルです。もし<code>-O2</code>以外を使用してパッケージのコンパイルが失敗する場合は、<code>-O2</code>で再コンパイルしてみましょう。うまくいかなかった場合は、<var>CFLAGS</var>と<var>CXXFLAGS</var>を(エラー報告や問題の調査向けに)<code>-O1</code>や<code>-O0 -g2 -ggdb</code>のように、最適化レベルを低く設定してみてください。

=== -pipe ===

よく使うフラグに<code>-pipe</code>があります。このフラグは、生成されるバイナリ自体には何の影響もありませんが、コンパイル時間が短縮されます。これはコンパイルにおける各処理の間で一時ファイルを使う代わりにパイプを使うように指示します。これにより多くのメモリを使うことになります。メモリに余裕のないシステムの場合、GCCが強制終了するかもしれません。そのような場合はこのフラグを使わないでください。 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but it may need to be activated. In that case add it to the flags. Though the GCC manual does not specify all architectures, it is turned on by using the <code>-O</code> option. It's still necessary to explicitly enable the <code>-fomit-frame-pointer</code> option, to activate it on x86-32 with GCC up to version 4.6, or when using <code>-Os</code> on x86-32 with any version of GCC. However, using <code>-fomit-frame-pointer</code> will make debugging hard or impossible. 

特に、Javaで書かれたアプリケーションの問題解決をとても難しくします。もっとも、Javaだけがこのフラグの影響を受けるわけではありませんが。このように、このフラグは役立つ一方でデバッグを難しくしているのです。特にバックトレースは役に立たなくなります。しかしながら、それほどソフトウェアのデバッグを行う予定がなく、他に<code>-ggdb</code>のようなデバッグ関連の<var>CFLAGS</var>を追加していないのであれば、<code>-fomit-frame-pointer</code>を使ってみてもいいでしょう。 

{{Important/ja|<code>-fomit-frame-pointer</code>とそれに似た<code>-momit-leaf-frame-pointer</code>フラグを組み合わせて'''使わないでください'''。後者のフラグを使うのはやめてください。<code>-fomit-frame-pointer</code>のみで十分です。そのうえ、<code>-momit-leaf-frame-pointer</code>はコードの性能に悪影響を及ぼすことがわかっています。}}

=== -msse、-msse2、-msse3、-mmmx、-m3dnow ===

These flags enable the [https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extentions] (SSE), [https://en.wikipedia.org/wiki/SSE2 SSE2], [https://en.wikipedia.org/wiki/SSSE3 SSE3], [https://en.wikipedia.org/wiki/MMX_(instruction_set) MMX], and [https://en.wikipedia.org/wiki/3DNow! 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important/ja|CPUがこれらをサポートしているかどうかは<kbd>cat /proc/cpuinfo</kbd>を実行して確認してください。サポートされている命令セットが表示されます。'''pni'''が実際はSSE3の別名であることに注意してください。}}

通常、正しい<code>-march</code>を使っている限り、これらのどのフラグも{{Path|/etc/portage/make.conf}}に加える必要はありません(例えば<code>-march=nocona</code>は<code>-msse3</code>を有効にします)。いくつかの注意すべき例外は、比較的新しいVIAとAMD64のCPUです。VIAとAMD64はこれらの命令をサポートしますが、(SSE3のように)<code>-march</code>では有効になりません。これらのCPUについては{{Path|/proc/cpuinfo}}の出力を確認して、ふさわしいフラグを追加する必要があるでしょう。 

{{Note|Check the [https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags] to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then it does not need to be separately specified; it will be turned on by using the proper <code>-march</code> setting.}}

== 最適化FAQ ==

=== -funroll-loopsや-fomg-optimizeを使ったら速くなったんだけど！ ===

No, people only ''think'' they do because someone has convinced them that more flags are better. Aggressive flags will only hurt applications when used system-wide. Even the GCC [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> will make code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

ここで本当に問題なのは、これらのフラグは危険なほどに挑戦的なフラグということです。それらのフラグが何をやらかしているのか[https://forums.gentoo.org/ Gentoo Forums]と[https://bugs.gentoo.org/ Bugzilla]あたりをよく見てください。ろくなことないですよ！ 

These flags are not needed globally in <var>CFLAGS</var> or <var>CXXFLAGS</var>. They will only hurt performance. They might bring on the idea of having a high-performance system running on the bleeding edge, but they don't do anything but bloat the code and get bugs marked INVALID or WONTFIX. 

Dangerous flags like these are not needed. '''Don't use them'''. Stick to the basics: <code>-march</code>, <code>-O</code>, and <code>-pipe</code>.

=== 3より高い-Oレベルはどう？ ===

何人かのユーザーが、<code>-O4</code>や<code>-O9</code>などを使うことによってもっといいパフォーマンスを得たと誇張していますが、3より高い<code>-O</code>レベルは何の効果もありません。コンパイラは<code>-O4</code>のような<var>CFLAGS</var>も許容するでしょうが、それらは実質何もしないのです。<code>-O3</code>の最適化を行うだけで、それ以上の最適化はしません。 

さらに証拠が必要ですか？[https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup ソースコード]を試してみてください。 

{{CodeBox|title=-O ソースコード|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

見てのとおり、3より高いレベルであっても、結局<code>-O3</code>として扱われます。

=== 実際のマシンと別のマシンでコンパイルするのはどう？ ===

何人かの読者は、あきらかに劣ったCPUやGCCサブアーキテクチャでコンパイルすることを避けるために他のマシンでコンパイルすることは、（ネイティブな環境でのコンパイルと比較して）劣った最適化になるのか知りたくなるでしょう。答えは単純で'''いいえ'''です。コンパイルが走る実際のマシンに関係なく、またGCCをビルドしたときのCHOSTに関係なく、同じ引数が使用されている限り<small>(<code>-march=native</code>は除く)</small>、そしてGCCのバージョンが同じである限り<small>(マイナーバージョンが違うかもしれません)</small>、最適化の結果は厳密に同じです。

例を一つあげます。GCCのCHOSTが''i686-pc-linux-gnu''となっているマシンにGentooをインストールして、CHOSTが''i486-linux-gnu''となっている別のPCに[[Distcc]]サーバーをインストールします。リモートサーバーのコンパイラのサブアーキテクチャもしくはハードウェアが明らかに劣っている場合、最適化が十分なされないのではと心配する必要はありません。結果は、両方のコンパイラに同じ引数が与えられている限り（かつ<code>-march</code>に<code>native</code>が与えられていない限り）、ネイティブにビルドしたときと同じ最適化がかかります。ただしこの特殊なケースでは[[Distcc#-march.3Dnative|Distcc and -march=native]]で説明されている通り、ターゲットのアーキテクチャが明示的に指定されなければなりません。

異なるサブアーキテクチャに向けてビルドされた２つのGCCの動作には一つしか違いがありません。それは暗に与えられるデフォルトの<code>-march</code>です。コマンドラインで<code>-march</code>を明示的に指定しなかった場合、GCCのCHOSTに設定された値が使用されます。

=== 冗長なフラグ指定はどう？ ===

しばしば、{{Path|/etc/portage/make.conf}}の中で、個々の<code>-O</code>レベルを指定すれば有効になるフラグを重複して<var>CFLAGS</var>や<var>CXXFLAGS</var>に設定していることがあります。これは時々知らずにやってしまうのですが、一方で(ebuildが行う)フラグの除去や置換を回避するために意図的に行われることがあります。 

フラグの除去や置換はPortageツリーの中にある多くのebuildで行われます。大抵は、特定の<code>-O</code>レベルでパッケージをコンパイルすると失敗するために、もしくはフラグを追加するとそのソースコードでは問題が出るためです。ebuildはどちらの場合も、全部/一部の<var>CFLAGS</var>と<var>CXXFLAGS</var>を除外するか、もしくは異なる<code>-O</code>レベルに置換するでしょう。 

The [https://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] outlines where and how flag filtering/replacing works. 

特定のレベルに対して重複してフラグを設定することによって、<code>-O</code>に対するフラグ除去をある程度回避することができます。例えば、<code>-O3</code>であれば次のようにします。 

{{CodeBox|title=重複してCFLAGSを設定|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

However, '''this is not a smart thing to do'''. <var>CFLAGS</var> are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile the whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, don't try to "outsmart" the developers who maintain those packages. ''Trust the developers''. Flag filtering and replacing is done to ensure stability of the system and application! If an ebuild specifies alternative flags, then don't try to get around it. 

Building packages with unacceptable flags will most likely lead to problems. When reporting problems on Bugzilla, the flags that are used in {{Path|/etc/portage/make.conf}} will be readily visible and developers will ask to recompile without those flags. Save the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume to be more knowledgeable than the developers.

=== LDFLAGSはどう？ ===

Gentoo開発者がすでに基本的で安全な<var>LDFLAGS</var>を基本プロファイルにセットしているので、それらを変更する必要はありません。

=== パッケージごとにフラグを変更出来るの？ ===

{{Warning|Using per-package flags complicates debugging and support. Make sure to mention the use of this feature in the bug reports together with the changes made.}}

パッケージごとに(<var>CFLAGS</var>を含む)環境変数を変更する方法は、[[Handbook:AMD64/Portage/Advanced/ja#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]]で説明しています。

== 資料 ==

以下、最適化について理解を深めるための資料を紹介します。 

* The [https://gcc.gnu.org/onlinedocs/ GCC online documentation] 

* Gentoo ハンドブック - [[Handbook:AMD64/Installation/Stage#コンパイルオプションを設定する|コンパイルオプションを設定する]]

* <kbd>man make.conf</kbd>

* [https://ja.wikipedia.org/wiki/ ウィキペディア]

* [https://forums.gentoo.org/ Gentooフォーラム]

{{Migrated|originalauthors=nightmorph}}
