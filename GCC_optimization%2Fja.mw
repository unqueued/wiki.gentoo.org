<languages />

{{Metadata|abstract=このガイドは、コンパイル済みコードを安全で分別のあるCFLAGSとCXXFLAGSを使って最適化する手法を紹介します。また一般的な最適化の背景にある理論についても述べます。}}

このガイドは、[[Article description::コンパイル済みコードを安全で分別のある<var>CFLAGS</var>と<var>CXXFLAGS</var>を使って最適化する手法を紹介します。]]また、一般的な最適化の背景にある理論について述べます。

== はじめに ==

=== CFLAGSとCXXFLAGSとは？ ===

<var>CFLAGS</var>と<var>CXXFLAGS</var>は、CやC++のソースコードをコンパイルするときに使われるオプションを、コンパイラに指示するために慣例的に使われる環境変数の一種です。これらの環境変数は標準化されているわけではありませんがそれに近い状況で用いられており、コンパイラを使う際に追加のオプションを指定したいなら理解しておく必要があります。[https://www.gnu.org/software/make/manual/make.html#Implicit-Variables GNU make]では一般的によく使われている環境変数のリストが記されています。

Gentooシステムでは大多数のパッケージがCまたはC++で書かれているため、これらの環境変数はシステムがどのように構成されるかに多大な影響を及ぼします。そのため管理者にはこれらを正しく設定することが求められます。

これらはプログラムのデバッグメッセージの量を減らすために使われたり、エラーや警告のレベルを増加させたり、また、もちろん生成されるコードの最適化にも使われます。[https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCCのマニュアル]に利用可能なフラグとその効果の完全なリストが記載されています。

=== どのように使われているのでしょうか？ ===

普通<var>CFLAGS</var>と<var>CXXFLAGS</var>は、configureスクリプトを走らせるか、プログラム毎に{{c|automake}}により生成されたMakefileによってセットされます。Gentooシステムでは、<var>CFLAGS</var>と<var>CXXFLAGS</var>は{{Path|/etc/portage/make.conf}}で設定します。このファイルに定義された変数はportageが呼び出したプログラムに適用され、その設定に基づいてプログラムがコンパイルされます。

{{CodeBox|title=/etc/portage/make.confのCFLAGS設定|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important/ja|'''USE'''フラグは複数の行で構成できますが、<var>CFLAGS</var>を複数の行で構成すると{{c|cmake}}のようなプログラムで問題が発生します。問題を避けるために、<var>CFLAGS</var>の宣言は極力スペースで区切られた単一行で構成するようにしてください。{{Bug|500034}}が参考になります。}}

見てわかるとおり、<var>CXXFLAGS</var>は<var>CFLAGS</var>の中にある全てのフラグが設定されています。大部分のシステムはこのように設定されるべきです。通常のケースでは、<var>CXXFLAGS</var>だけに追加のオプションを指定するようなことはほとんどありませんし、大体そういったオプションはグローバルに適用すべきではありません。

{{Tip|[[Safe_CFLAGS|安全なCFLAGS]] 初心者向けにシステム最適化の方法が書かれています。}}

=== よくある誤解 ===

<var>CFLAGS</var>でコンパイラの最適化をするのはより小さく高速なバイナリを生成するには効果的な方法ですが、一方で正しく動作しない、サイズの巨大化や動作速度の低下を引き起こしたり、そもそもコンパイルできないなどの問題を起こす可能性があります。<var>CFLAGS</var>を弄っているとこうしたことはあっさりと発生します。適当に設定してはいけません。

{{Path|/etc/portage/make.conf}}にて設定した<var>CFLAGS</var>はシステム上の全てのパッケージに適用されます。そのため管理者は至極一般的で広く適用しても問題ないオプションのみを設定するのが普通です。これに加えて各々のパッケージがebuildやコンパイル中にさらに必要なオプションを自動で追加しています。

=== 準備はできましたか？ ===

リスクを伴うことを理解したところで、良識的、かつ安全な最適化の方法を見ていきましょう。そうすれば、この先[https://bugs.gentoo.org/ Bugzilla]で開発者に歓迎され、役立つ報告をすることができます。（開発者は、大抵、問題が再現するか確かめるために、最小限の<var>CFLAGS</var>でパッケージを再コンパイルすることを要求します。挑戦的なフラグはコードを破壊しうることを覚えておいてください!） 

== 最適化について ==

=== 基本 ===

<var>CFLAGS</var>と<var>CXXGLAGS</var>の使用目的は、システム向けにあつらえた、可能な限り早くて小さな、かつ完全に動作するコードを生成することです。時には、これらの条件は相互に排他的ですので、うまく動作すると分かっている組み合わせをここでは扱うことにします。原則、それぞれのCPUアーキテクチャ向けに利用可能なよい最適化が用意されています。参考情報として、さらにアグレッシブなフラグを後述します。このガイドではGCCのマニュアルに記載されているすべてのオプションを商会する訳ではありません。基本的な、そして最も標準的なオプションについてのみ解説します。 

{{Note/ja|フラグがどういう働きをするのか不明なときは、[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual]の関連する章を参照してください。もしそれでもわからない場合は、ウェブ検索をするか、[https://gcc.gnu.org/lists.html GCC mailing lists]をチェックしましょう}}

=== -march ===

最初の、そしてもっとも重要なオプションは<code>-march</code>です。このオプションはコンパイラに対してどのシステム[https://en.wikipedia.org/wiki/Microarchitecture プロセッサアーキテクチャ] (もしくは"arch")のためのコードを生成するのかを指示します。つまり、特定のCPU向けのコードを生成すべきであるといっているのです。CPUが違えば、性能が異なり、異なる命令セットをサポートし、コードの実行方法も違います。<code>-march</code>フラグは、あなたのCPUの全ての性能、機能、命令セット、癖などに合わせて特化したコードを生成するようにコンパイラに伝えます。例えばAVX命令の恩恵を受けたいなら、ソースコードがそれに対応しておく必要があります。

<code>-march=</code>はISA（訳註：命令セットアーキテクチャ）指定のオプションで、コンパイラにどんな命令が利用可能かを伝えます。Intel/AMD64プラットフォームで <code>-march=native</code <code>-O2</code>を使用すると、AVX命令はサポートされますがSSEのXMMレジスタがサポートされない場合があります。AVXのYMMレジスタを最大限利用したい場合、<code>-ftree-vectorize</code> <code>-O3</code>または<code>-Ofast</code> も指定する必要があります。<ref>GNU GCC Bugzilla, [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57952#c8 AVX/AVX2で単純約分のときにXMMレジスタが使われない問題。] 2017/07/18取得。</ref>

<code>-ftree-vectorize</code>は最適化オプション(<code>-O3</code>と<code>-Ofast</code>においてはデフォルト)で、可能であれば選択されたISAを使用してループのベクトル化を試みます。<code>-O2</code>で有効化されていないのは、常にコードを改善するわけではなく、またコードを遅くしてしまう可能性があり、そしてたいていはコードを大きくしてしまうためです; 実際、これはループなどの状況次第です。 

たとえ{{Path|/etc/portage/make.conf}}に書いてある<var>CHOST</var>変数を一般的なアーキテクチャに設定していても、<code>-march</code>を設定すれば、プログラムは指定したプロセッサ向けに最適化されるでしょう。x86とx86-64のCPUは(とりわけ)<code>-march</code>フラグを使うべきです。 

どんな種類のCPUを使っていますか？以下のコマンドを実行すれば、それが分かります。 

{{Cmd|cat /proc/cpuinfo}}

あるいは、{{Package|app-portage/cpuid2cpuflags}}をインストールし、ツールが[[CPU FLAGS X86|CPU_FLAGS_X86]]などの変数を通じて表示した利用可能なCPU特有のオプションを{{Path|make.conf}}ファイルに追加することもできます:

{{Cmd|cpuid2cpuflags|output=<pre>
CPU_FLAGS_X86: aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3</pre>}}

{{RootCmd|echo "CPU_FLAGS_X86{{=}}'aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3'" >> /etc/portage/make.conf}}

さらに<code>march</code>と<code>mtune</code>の値を含む詳細な情報を得たい場合は、以下の2つのコマンドが使えます。

* 最初のコマンドはコンパイラにリンクを行わないようにさせ(<code>-c</code>)、また、<code>--help</code>をコマンドラインオプションを明らかにせよとではなく、あるオプションが有効か無効かを示せという意味に解釈させます(<code>-Q</code>)。ここでは、選択されたターゲットで有効なオプションが出力されます:
:{{Cmd|gcc -c -Q -march{{=}}native --help{{=}}target}}

* 二つ目のコマンドはヘッダーファイルをビルドしますが、実際には処理は行わずそれらを画面に表示する(<code>-###</code>)ことでコンパイラーディレクティブを表示します。出力の最終行がすべての最適化オプションと選択されたアーキテクチャーを含むコマンドです:
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

では実際に<code>-march</code>を見てみましょう。この例は古いPentium IIIチップ向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium IIIの例|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

こちらはAMD64向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64の例|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

CPUのタイプが決められない場合、またはどの設定を使えばいいかわからない場合、<code>-march=native</code>を使うことができます。このフラグを使った場合、GCCはプロセッサを判別して、自動的にふさわしいフラグを設定するでしょう。'''しかしながら、このフラグは異なるCPU向けにパッケージをコンパイルする目的では使用すべきではありません！''' 

{{Warning/ja|{{c|[[Distcc#-march.3Dnative|distcc]]}}を使ってコンパイルする場合、{{Path|make.conf}}の<var>CFLAGS</var>もしくは<var>CXXFLAGS</var>に<code>-march{{=}}native</code>や<code>-mtune{{=}}native</code>を使用しては'''いけません'''。}}

例えば、あるコンピュータでパッケージをコンパイルして、しかしそれらを別のコンピュータで実行しようとしている場合 (処理の早いコンピュータで、古くて遅いマシンのためにビルドしているときなど)、<code>-march=native</code>を''使わない''でください。"native"というのはコンパイルしているマシンのCPUタイプ''のみ''に特化して、アプリケーションのコードを生成することを意味しています。AMD Athlon 64上で<code>-march=native</code>と共にビルドされたアプリケーションは、古いVIA C3では実行することができ'''ない'''でしょう。 

また、<code>-mtune</code>と<code>-mcpu</code>フラグも利用可能です。これらのフラグはたいてい<code>-march</code>フラグが利用できない場合にのみ使われます。例えば特定のプロセッサアーキテクチャは<code>-mtune</code>や<code>-mcpu</code>が必要になるかもしれません。残念ながら、GCCの挙動はそれぞれのフラグの振る舞いが、あるアーキテクチャから近いアーキテクチャであってもあまり一貫性はありません。 

x86とx86-64のCPUにおいて、<code>-march</code>は利用可能な命令セットと正しいABIを使い、そのCPUに特化したコードを生成するでしょう。そのため古かったり種類の異なるCPUとの後方互換性は持っていません。i386やi486のような古いCPU向けにコードを生成する必要があるときのみ、<code>-mtune</code>の使用を考慮するべきでしょう。<code>-mtune</code>は<code>-march</code>よりも一般的なコードを生成します。特定のCPUコードにチューニングしますが、利用可能な命令セットやABIを考慮しないのです。<code>-mcpu</code>はx86やx86-64のシステム上では非推奨となっているので、使わないでください。 

x86/x86-64でない(SPARCやAlpha、PowerPCのような)CPUでのみ、<code>-march</code>の代わりに<code>-mtune</code>や<code>-mcpu</code>が必要になるでしょう。これらのアーキテクチャ上では、<code>-mtune</code>/<code>-mcpu</code>は(x86/x86-64上での)<code>-march</code>と同じように振る舞うでしょう･･･しかしフラグの名前は違うのです。繰り返しますが、GCCの振る舞いとフラグ名はアーキテクチャを超えて一貫していないので、システムでどのフラグを使うべきなのかをGCCの[https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options マニュアル]で必ず確認してください。 

{{Note/ja|更なる<code>-march</code>/<code>-mtune</code>/<code>-mcpu</code>の設定についての情報は、あなたのアーキテクチャに適した[[HandBook:Main_Page/ja|Gentooハンドブック]]の５章を読んでみてください。また、GCCマニュアルの[https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options]のリストに、<code>-march</code>と<code>-mcpu</code>と<code>-mtune</code>の違いについてもっと詳しい説明があります。}}

=== -O ===
{{warning/ja|<code>-O3</code>や<code>-Ofast</code>を使用するといくつかのパッケージがコンパイル中に壊れることがあります。}}

{{note|特定の<var>CFLAGS</var>/<var>CXXFLAGS</var>でビルドされたすべてのパッケージを表示したい場合、以下のコマンドが使えます: <code>grep Ofast /var/db/pkg/*/*/CFLAGS</code>}}

次は<code>-O</code>フラグについてです。これは全体の最適化レベルをコントロールしますが、特にこの最適化レベルを上げることによって、ソースコードのコンパイルの時間がいくらか増えたり、よりたくさんのメモリを使用するようになります。 

７つの<code>-O</code>設定があります。<code>-O0</code>、<code>-O1</code>、<code>-O2</code>、<code>-O3</code>、<code>-Os</code>、<code>-Og</code>、<code>-Ofast</code>です。{{Path|/etc/portage/make.conf}}で指定できるのはこのうちの一つだけです。

<code>-O0</code>を除いて、<code>-O</code>の設定はいずれもいくつかの追加フラグを有効にします。なので、どの<code>-O</code>レベルで、どのフラグが有効になり、そのフラグにどんな効果があるのかを学ぶために、GCCマニュアルの[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimization options]
の章を読んで確認しましょう。 

では、それぞれの最適化レベルを見てみましょう。 

*  <code>-O0</code>: このレベル("O"のあとにゼロが続いてます)は、完全に最適化をオフにします。<var>CFLAGS</var>や<var>CXXFLAGS</var>の中に<code>-O</code>が定義されていない場合のデフォルトです。このレベルはコンパイル時間を短縮して、生成するデバッグ情報を改善しますが、いくつかのアプリケーションは最適化がないと正しく動作しません。よって、デバッグ以外では推奨されません。

*  <code>-O1</code>: これは最も基本的な最適化レベルです。コンパイラは時間をたくさんかけることなく、高速でサイズの小さなバイナリを生成しようと試みるでしょう。これは基本的な最適化しかおこないませんが、その代わり、いつでもうまくいくはずです。

* <code>-O2</code>: <code>-O1</code>から更に踏み込みます。これは特別な理由がない限り"推奨される"最適化レベルです。<code>-O2</code>は<code>-O1</code>で有効になるものに加え、さらにいくつかのフラグを有効にします。<code>-O2</code>を使うと、コンパイラはサイズとコンパイル時間に妥協せずにコードのパフォーマンスを改善しようと試みます。このレベルではSSEやAVXは利用されますが、YMMレジスタは<code>-ftree-vectorize</code>も有効にしない限り使われません。

*  <code>-O3</code>: これは取りうる最も高い最適化レベルです。コンパイル時間とメモリ使用量を犠牲にして最適化を実施します。ただし<code>-O3</code>は性能を改善する保証がありません。実際多くのケースで、バイナリサイズが大きくなり、メモリ使用量が増えることで逆にシステムが遅くなります。<code>-O3</code>はいくつかのパッケージを壊すことがわかっています。これらの理由により<code>-O3</code>は推奨されません。一方、このレベルはコード内のループをベクトル化する<code>-ftree-vectorize</code>を有効化し、AVX YMMレジスタも利用されます。

*  <code>-Os</code>: このレベルはバイナリのサイズを重視して最適化するでしょう。これは<code>-O2</code>フラグの中で、生成されるバイナリのサイズが増えないものを全て有効にします。CPUのキャッシュが小さかったり、ディスクの空き容量が極端に限られている場合などに非常に有効でしょう。

*  <code>-Og</code>: GCC 4.8では新しい汎用的な最適化レベル<code>-Og</code>が導入されました。このレベルはコンパイル時間の短縮とデバッグエクスペリエンスを向上させる一方、妥当なランタイム性能を確保することを目的としています。結果的に開発全体で得られるものはデフォルトの最適化レベル<code>-O0</code>より向上するはずです。<code>-Og</code>と<code>-g</code>は同じでないことだけ理解しておいてください。<code>-g</code>はデバッガとやりとりするために単純に最適化をオフにするだけです。

*  <code>-Ofast</code>: GCC 4.7では、<code>-O3</code>に加えて<code>-ffast-math</code>、<code>-fno-protect-parens</code>、<code>-fstack-arrays</code>が利用できます。このオプションは規格への厳密な適合を犠牲にするため推奨されません。

前述の通り、<code>-O2</code>が推奨される最適化レベルです。もし<code>-O2</code>以外を使用してパッケージのコンパイルが失敗する場合は、<code>-O2</code>で再コンパイルしてみましょう。うまくいかなかった場合は、<var>CFLAGS</var>と<var>CXXFLAGS</var>を(エラー報告や問題の調査向けに)<code>-O1</code>や<code>-O0 -g2 -ggdb</code>のように、最適化レベルを低く設定してみてください。

=== -pipe ===

よく使うフラグに<code>-pipe</code>があります。このフラグは、生成されるバイナリ自体には何の影響もありませんが、コンパイル時間が短縮されます。これはコンパイルにおける各処理の間で一時ファイルを使う代わりにパイプを使うように指示します。これにより多くのメモリを使うことになります。メモリに余裕のないシステムの場合、GCCが強制終了するかもしれません。そのような場合はこのフラグを使わないでください。 

=== -fomit-frame-pointer ===

これは生成されるバイナリのサイズを減少させるために設計されているフラグで、よく利用されています。このフラグは、(x86-64のように)有効化してもデバッグ作業の阻害をしないアーキテクチャにおいては(<code>-O0</code>を除く)全ての<code>-O</code>のレベルに対して有効になりますが、有効化する必要がある場合もあります。そのような場合にはこれをフラグに加えてください。GCCマニュアルによれば、全てのアーキテクチャにおいて、<code>-O</code>を使えば<code>-fomit-frame-pointer</code>が有効になる訳ではありません。GCC 4.6までは、もしくは<code>-Os</code>を使っているときは、x86-32で有効化するためには明示的に<code>-fomit-frame-pointer</code>オプションを使わなければなりません。ただし、<code>-fomit-frame-pointer</code>を使うとデバックは困難もしくは不可能になります。 

特に、Javaで書かれgcjでコンパイルされたアプリケーションの問題解決をとても難しくします。もっとも、Javaだけがこのフラグの影響を受けるわけではありませんが。このように、このフラグは役立つ一方でデバッグを難しくしているのです。特にバックトレースは役に立たなくなります。しかしながら、それほどソフトウェアのデバッグを行う予定がなく、他に<code>-ggdb</code>のようなデバッグ関連の<var>CFLAGS</var>を追加していないのであれば、<code>-fomit-frame-pointer</code>を使ってみてもいいでしょう。 

{{Important/ja|<code>-fomit-frame-pointer</code>とそれに似た<code>-momit-leaf-frame-pointer</code>フラグを組み合わせて'''使わないでください'''。後者のフラグを使うのはやめてください。<code>-fomit-frame-pointer</code>のみで十分です。そのうえ、<code>-momit-leaf-frame-pointer</code>はコードの性能に悪影響を及ぼすことがわかっています。}}

=== -msse、-msse2、-msse3、-mmmx、-m3dnow ===

これらのフラグは[https://ja.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extentions] (SSE)、[https://en.wikipedia.org/wiki/SSE2 SSE2]、[https://en.wikipedia.org/wiki/SSSE3 SSE3]、[https://ja.wikipedia.org/wiki/MMX MMX]、[https://ja.wikipedia.org/wiki/3DNow! 3DNow!]の命令セットをx86とx86-64アーキテクチャで有効にします。これらは主にマルチメディアやゲーム、その他の浮動小数点を多用する計算処理に向いています。その他にも有用な数学用機能の向上をいくつか含んでいます。比較的新しいCPUならば、これらの命令セットに対応しています。 

{{Important/ja|CPUがこれらをサポートしているかどうかは{{c|cat /proc/cpuinfo}}を実行して確認してください。サポートされている命令セットが表示されます。'''pni'''が実際はSSE3の別名であることに注意してください。}}

通常、正しい<code>-march</code>を使っている限り、これらのどのフラグも{{Path|/etc/portage/make.conf}}に加える必要はありません(例えば<code>-march=nocona</code>は<code>-msse3</code>を有効にします)。いくつかの注意すべき例外は、比較的新しいVIAとAMD64のCPUです。VIAとAMD64はこれらの命令をサポートしますが、(SSE3のように)<code>-march</code>では有効になりません。これらのCPUについては{{Path|/proc/cpuinfo}}の出力を確認して、ふさわしいフラグを追加する必要があるでしょう。 

{{Note/ja|x86とx86-64特有のフラグについて[https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags]を確認しましょう。適切にCPUを指定することによって、どの命令セットが有効になるのか確認することができます。もし命令セットがリストの中にあったら、改めて指定する必要はありません。なぜならそれらは正しい<code>-march</code>を使えば有効になるでしょうから。}}

== 最適化FAQ ==

=== -funroll-loopsや-fomg-optimizeを使ったら速くなったんだけど！ ===

いいえ違います。フラグを付け加えれば付け加えるほど最適化されると言う誰かに騙されているだけです。システム全体で挑戦的なフラグを使うことはあなたのアプリケーションを傷つけるでしょう。GCC [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options マニュアル]では<code>-funroll-loops</code>と<code>-funroll-all-loops</code>を使うとバイナリは大きくなり、実行も遅くなると述べています。またいくつかの理由から、これらの二つのフラグと同時に、<code>-ffast-math</code>や<code>-fforce-mem</code>や<code>-fforce-addr</code>などの似たようなフラグが、速度を最大限誇示したい人たちの間で、とても人気を博しています。 

ここで本当に問題なのは、これらのフラグは危険なほどに挑戦的なフラグということです。それらのフラグが何をやらかしているのか[https://forums.gentoo.org/ Gentoo Forums]と[https://bugs.gentoo.org/ Bugzilla]あたりをよく見てください。ろくなことないですよ！ 

それらのフラグを<var>CFLAGS</var>や<var>CXXFLAGS</var>に設定し、システム全体で使う必要はありません。それらはパフォーマンスに悪影響を及ぼすだけでしょう。それらのフラグが、最先端でハイパフォーマンスなシステムを使っているかのように見せるかもしれませんが、しかしそれらは何の効果もないどころか、バイナリのサイズが膨れ上がり、無効(INVALID)や修正の必要無し(WONTFIX)と結論づけられたバグを踏むことになります。 

そのような危険なフラグを使う必要はありません。いえ、'''使わないでください。'''<code>-march</code>、<code>-O</code>、<code>-pipe</code>という基本を守り通してください。

=== 3より高い-Oレベルはどう？ ===

何人かのユーザーが、<code>-O4</code>や<code>-O9</code>などを使うことによってもっといいパフォーマンスを得たと誇張していますが、3より高い<code>-O</code>レベルは何の効果もありません。コンパイラは<code>-O4</code>のような<var>CFLAGS</var>も許容するでしょうが、それらは実質何もしないのです。<code>-O3</code>の最適化を行うだけで、それ以上の最適化はしません。 

さらに証拠が必要ですか？[https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup ソースコード]を試してみてください。 

{{CodeBox|title=-O ソースコード|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

見てのとおり、3より高いレベルであっても、結局<code>-O3</code>として扱われます。

=== 実際のマシンと別のマシンでコンパイルするのはどう？ ===

何人かの読者は、あきらかに劣ったCPUやGCCサブアーキテクチャでコンパイルすることを避けるために他のマシンでコンパイルすることは、（ネイティブな環境でのコンパイルと比較して）劣った最適化になるのか知りたくなるでしょう。答えは単純で'''いいえ'''です。コンパイルが走る実際のマシンに関係なく、またGCCをビルドしたときのCHOSTに関係なく、同じ引数が使用されている限り<small>(<code>-march=native</code>は除く)</small>、そしてGCCのバージョンが同じである限り<small>(マイナーバージョンが違うかもしれません)</small>、最適化の結果は厳密に同じです。

例を一つあげます。GCCのCHOSTが''i686-pc-linux-gnu''となっているマシンにGentooをインストールして、CHOSTが''i486-linux-gnu''となっている別のPCに[[Distcc]]サーバーをインストールします。リモートサーバーのコンパイラのサブアーキテクチャもしくはハードウェアが明らかに劣っている場合、最適化が十分なされないのではと心配する必要はありません。結果は、両方のコンパイラに同じ引数が与えられている限り（かつ<code>-march</code>に<code>native</code>が与えられていない限り）、ネイティブにビルドしたときと同じ最適化がかかります。ただしこの特殊なケースでは[[Distcc#-march.3Dnative|Distcc and -march=native]]で説明されている通り、ターゲットのアーキテクチャが明示的に指定されなければなりません。

異なるサブアーキテクチャに向けてビルドされた２つのGCCの動作には一つしか違いがありません。それは暗に与えられるデフォルトの<code>-march</code>です。コマンドラインで<code>-march</code>を明示的に指定しなかった場合、GCCのCHOSTに設定された値が使用されます。

=== 冗長なフラグ指定はどう？ ===

しばしば、{{Path|/etc/portage/make.conf}}の中で、個々の<code>-O</code>レベルを指定すれば有効になるフラグを重複して<var>CFLAGS</var>や<var>CXXFLAGS</var>に設定していることがあります。これは時々知らずにやってしまうのですが、一方で(ebuildが行う)フラグの除去や置換を回避するために意図的に行われることがあります。 

フラグの除去や置換はPortageツリーの中にある多くのebuildで行われます。大抵は、特定の<code>-O</code>レベルでパッケージをコンパイルすると失敗するために、もしくはフラグを追加するとそのソースコードでは問題が出るためです。ebuildはどちらの場合も、全部/一部の<var>CFLAGS</var>と<var>CXXFLAGS</var>を除外するか、もしくは異なる<code>-O</code>レベルに置換するでしょう。 

[https://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual]にフラグの除去と置換がどのような場合に、どのように使われているのか概要が記載されています。 

特定のレベルに対して重複してフラグを設定することによって、<code>-O</code>に対するフラグ除去をある程度回避することができます。例えば、<code>-O3</code>であれば次のようにします。 

{{CodeBox|title=重複してCFLAGSを設定|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

しかしながら、'''これは賢いやり方ではありません'''。<var>CFLAGS</var>は理由があって除去されるのです！ フラグが除去されるとき、それらのフラグでパッケージをビルドすると安全でないことを意味します。明らかに分かっているのは、<code>-O3</code>でシステム全体をコンパイルすることは"安全ではない"という事です。そうすると、<code>-O3</code>の最適化で有効になるいくつかのフラグによって問題となるパッケージが出てくるでしょう。そのため、それらのパッケージをメンテナンスしている開発者の"裏をかく"ことを試みないでください。
''開発者を信用してください。''フラグの除去と置換はシステムやアプリケーションの安定性を確保するために行われているのです！ もしebuildに代替のフラグが指定されているなら、それを回避しようとしないでください。 

開発者が許可していないフラグでパッケージをビルドすれば、大概は数々の問題に繋がるでしょう。Bugzillaに不具合を報告する際には、{{Path|/etc/portage/make.conf}}で使っているフラグは容易く見抜かれてしまうので、余計なフラグを除いて再コンパイルする様に開発者に指示されるでしょう。初めから冗長なフラグを指定しないことで、再コンパイルする手間を省いてください！ あなたが開発者よりよく知っていると根拠なく無意識に決めつけないでください。

=== LDFLAGSはどう？ ===

Gentoo開発者がすでに基本的で安全な<var>LDFLAGS</var>を基本プロファイルにセットしているので、それらを変更する必要はありません。

=== パッケージごとにフラグを変更出来るの？ ===

{{Warning/ja|パッケージごとにフラグを変更するとデバッグやサポートが込み入ってきます。もしこの機能を使っている場合には、どのような変更をしたのか、バグレポートで言及してください。}}

パッケージごとに(<var>CFLAGS</var>を含む)環境変数を変更する方法は、[[Handbook:AMD64/Portage/Advanced/ja#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]]で説明しています。

== 参考 ==

* [[Handbook:AMD64/Installation/Stage/ja#コンパイルオプションを設定する|コンパイルオプションを設定する]] (AMD64 ハンドブック)

== 外部資料 ==

以下、最適化について理解を深めるための資料を紹介します。 

* [https://gcc.gnu.org/onlinedocs/ GCC online documentation] 

* {{c|man make.conf}}

* [https://ja.wikipedia.org/wiki/ ウィキペディア]

* [https://forums.gentoo.org/ Gentooフォーラム]

== 参照 ==

{{reflist}}

{{Migrated|originalauthors={{Dev|nightmorph}}}}


[[Category:Compilation]]
