<languages />

{{Metadata|abstract=このガイドは、安全で分別のあるCFLAGSとCXXFLAGSを使ったコンパイル済みコードの最適化の導入を提供します。また、一般的な最適化の裏側にある理論について述べます。}}

このガイドは、安全で分別のあるCFLAGSとCXXFLAGSを使ったコンパイル済みコードの最適化の導入を提供します。また、一般的な最適化の裏側にある理論について述べます。

== はじめに ==

=== CFLAGSとCXXFLAGSとは？ ===

CFLAGSとCXXFLAGSは、ソースコードをコンパイルするときに使われるオプションをGNUコンパイラコレクションであるgccに伝えるために使われる環境変数です。CFLAGSはCで書かれたソースコード、CXXFLAGSはC++で書かれたソースコード用になります。 

これらはプログラムのデバッグメッセージの量を減らすのに使われたり、エラーや警告のレベルを増加させたり、また、もちろん生成されるコードの最適化にも使われたりします。[http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC manual]に利用可能なフラグとその働きの完全なリストが記載されています。

=== どのように使われているのでしょうか？ ===

CFLAGSとCXXFLAGSは二通り使われ方があります。一つ目は、プログラム毎にautomakeにより生成されたMakefileと共に使う方法です。 

しかしながら、この方法はPortageツリーの中にあるパッケージをインストールする際に使うべきではありません。その代わりに、Gentooベースのシステムでは{{Path|/etc/portage/make.conf}}の<code>CFLAGS</code>と<code>CXXFLAGS</code>を設定します。この方法を使えば、全てのパッケージはあなたが{{Path|make.conf}}に設定したフラグでコンパイルされるでしょう。

{{CodeBox|title=/etc/portage/make.confのCFLAGS設定|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important/ja|'''USE'''フラグは複数の行で構成できますが、<code>CFLAGS</code>を複数の行で構成すると<tt>cmake</tt>のようなプログラムで問題が発生します。問題を避けるために、CFLAGSの宣言は極力スペースで区切られた単一行で構成するようにしてください。{{Bug|500034}}が参考になります。}}

見てわかるとおり、CXXFLAGSはCFLAGSの中にある全てのフラグが設定されています。大部分のシステムはこのように設定されるべきです。通常のユースケースでは、<code>CXXFLAGS</code>だけに追加のオプションを指定するようなことはほとんどありません。

=== よくある誤解 ===

CFLAGSとCXXFLAGSは、ソースコードから小さくて早いバイナリを得るにはとても効果的な方法である一方で、ソースコード中の機能を損なったり、バイナリのサイズが膨れ上がったり、実行速度を低下させたり、コンパイルの失敗さえも引き起こす場合もあります！ 

CFLAGSは特効薬ではありません。これらは自動的にあなたのシステムを早くしたり、ディスク上のスペースが少なくなるようバイナリを縮めてはくれないでしょう。たくさんのフラグを、システムを最適化する目的で追加することは、確実に失敗します。払った労力に見合う実入りを得るにも限度と言うものがあります。 

インターネットでは挑戦的なCFLAGSやCXXFLAGSの自慢も見受けられますが、それらはいい影響を与えるよりも、コンパイルされたバイナリに悪影響を及ぼす可能性の方がはるかに高いです。そもそもフラグは特定の場所、特定の目的のために設計されていることを忘れてはいけません。グローバルに適用することを目的としたフラグはほとんどありません。

=== 準備はできましたか？ ===

リスクが伴うことを理解したところで、良識的、かつ安全な最適化の方法を見ていきましょう。そうすれば、この先、[https://bugs.gentoo.org/ Bugzilla]で開発者に歓迎される役立つ報告をすることができます。（開発者は、大抵、問題が再現するか確かめるために、最小限のCFLAGSでパッケージを再コンパイルすることを要求します。挑戦的なフラグはコードを破壊しうることを覚えておいてください!） 

== 最適化について ==

=== 基本 ===

CFLAGSとCXXGLAGSの使用目的は、あなたのシステム向けにあつらえた、可能な限り早くて小さな、かつ完全に動作するコードを生成することです。時には、これらの条件は相互に排他的ですので、うまく動作すると分かっている組み合わせをここでは使うことにします。原則的には、お手持ちのCPUアーキテクチャ向けに利用可能な良い最適化が用意されています。参考情報として、さらにアグレッシブなフラグを後述します。このガイドではGCCのマニュアルに記載されているすべてのオプションを議論する訳ではありません。基本的な、そしてもっとも標準的なオプションについて解説します。 

{{Note/ja|フラグがどういう働きをするのか不明なときは、[http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual]の関連する章を参照してください。もしそれでもわからない場合は、ウェブ検索をするか、[http://gcc.gnu.org/lists.html GCC mailing lists]をチェックしましょう}}

=== -march ===

最初の、そしてもっとも重要なオプションは<code>-march</code>です。このオプションはコンパイラに対してどのシステム[https://en.wikipedia.org/wiki/Microarchitecture プロセッサアーキテクチャ] (もしくは"arch")のためのコードを生成するのかを指示します。つまり、特定のCPU向けのコードを生成すべきであるといっているのです。CPUが違えば、性能が異なり、異なる命令セットをサポートし、コードの実行方法も違います。<code>-march</code>フラグは、あなたのCPUの全ての性能、特徴、命令セット、癖などに合わせて特化したコードを生成するようにコンパイラに伝えます。 

たとえ{{Path|/etc/portage/make.conf}}に書いてある<code>CHOST</code>変数を一般的なアーキテクチャに設定していても、<code>-march</code>を設定すれば、プログラムは指定したプロセッサ向けに最適化されるでしょう。x86とx86-64のCPUは(とりわけ)<code>-march</code>フラグを使うべきです。 

どんな種類のCPUを使っていますか？以下のコマンドを実行すれば、それが分かります。 

{{Cmd|cat /proc/cpuinfo}}

さらに<code>march</code>と<code>mtune</code>の値を含む詳細な情報を得たい場合は、以下を実行してください。

{{Cmd|<nowiki>gcc -c -Q -march=native --help=target</nowiki>}}

では実際に<code>-march</code>を見てみましょう。この例は古いPentium IIIチップ向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium IIIの例|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

こちらはAMD64向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64の例|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

CPUのタイプが決められない場合、またはどの設定を使えばいいかわからない場合、<code>-march=native</code>を使うことができます。このフラグを使った場合、GCCはプロセッサを判別して、自動的にふさわしいフラグを設定するでしょう。'''しかしながら、このフラグは異なるCPU向けにパッケージをコンパイルする目的では使用すべきではありません！''' 

{{Warning/ja|<tt>[[Distcc#-march.3Dnative|distcc]]</tt>を使ってコンパイルする場合、{{Path|make.conf}}の<code>CFLAGS</code>もしくは<code>CXXFLAGS</code>に<code>-march{{=}}native</code>や<code>-mtune{{=}}native</code>を使用しては'''いけません'''。}}

例えば、あるコンピュータでパッケージをコンパイルして、しかしそれらを別のコンピュータで実行しようとしている場合 (処理の早いコンピュータで、古くて遅いマシンのためにビルドしているときなど)、<code>-march=native</code>を'''使わない'''でください。"native"というのはコンパイルしているマシンのCPUタイプ'''のみ'''に特化して、アプリケーションのコードを生成することを意味しています。AMD Athlon 64上で<code>-march=native</code>と共にビルドされたアプリケーションは、古いVIA C3では実行することができないでしょう。 

また、<code>-mtune</code>と<code>-mcpu</code>フラグも利用可能です。これらのフラグはたいてい<code>-march</code>フラグが利用できない場合にのみ使われます。例えば特定のプロセッサアーキテクチャは<code>-mtune</code>や<code>-mcpu</code>が必要になるかもしれません。残念ながら、GCCの挙動はそれぞれのフラグの振る舞いが、あるアーキテクチャから近いアーキテクチャであってもあまり一貫性はありません。 

x86とx86-64のCPUにおいて、<code>-march</code>は利用可能な命令セットと正しいABIを使い、そのCPUに特化したコードを生成するでしょう。そのため古かったり種類の異なるCPUとの後方互換性は持っていません。i386やi486のような古いCPU向けにコードを生成する必要があるときのみ、<code>-mtune</code>の使用を考慮するべきでしょう。<code>-mtune</code>は<code>-march</code>よりも一般的なコードを生成します。特定のCPUコードにチューニングしますが、利用可能な命令セットやABIを考慮しないのです。<code>-mcpu</code>はx86やx86-64のシステム上では非推奨となっているので、使わないでください。 

x86/x86-64でない(SparcやAlpha、PowerPCのような)CPUでのみ、<code>-march</code>の代わりに<code>-mtune</code>や<code>-mcpu</code>が必要になるでしょう。これらのアーキテクチャ上では、<code>-mtune</code>/<code>-mcpu</code>は(x86/x86-64上での)<code>-march</code>と同じように振る舞うでしょう･･･しかしフラグの名前は違うのです。繰り返しますが、GCCの振る舞いとフラグ名はアーキテクチャを超えて一貫していないので、システムでどのフラグを使うべきなのかをGCCの[http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options マニュアル]で必ず確認してください。 

{{Note/ja|更なる<code>-march</code>/<code>-mtune</code>/<code>-mcpu</code>の設定についての情報は、あなたのアーキテクチャに適した[[HandBook:Main_Page/ja|Gentooハンドブック]]の５章を読んでみてください。また、GCCマニュアルの[http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options]のリストに、<code>-march</code>と<code>-mcpu</code>と<code>-mtune</code>の違いについてもっと詳しい説明が書いてあります。}}

=== -O ===

次は<code>-O</code>フラグについてです。これは全体の最適化レベルをコントロールしますが、特にこの最適化レベルを上げることによって、ソースコードのコンパイルの時間がいくらか増えたり、よりたくさんのメモリを使用するようになります。 

７つの<code>-O</code>設定があります。<code>-O0</code>、<code>-O1</code>、<code>-O2</code>、<code>-O3</code>、<code>-Os</code>、<code>-Og</code>、<code>-Ofast</code>です。{{Path|/etc/portage/make.conf}}で指定できるのはこのうちの一つだけです。

<code>-O0</code>を除いて、<code>-O</code>の設定はいずれもいくつかの追加フラグを有効にします。なので、どの<code>-O</code>レベルで、どのフラグが有効になり、そのフラグにどんな効果があるのかを学ぶために、GCCマニュアルの[http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimization options]
の章を読んで確認しましょう。 

私たちはそれぞれの最適化レベルを調べてみましょう: 

*  <code>-O0</code>: このレベル("O"のあとにゼロが続いてます)は、完全に最適化をオフにします。<code>CFLAGS</code>や<code>CXXFLAGS</code>の中に<code>-O</code>が定義されていない場合のデフォルトです。このレベルはコンパイル時間を短縮して、生成するデバッグ情報を改善しますが、いくつかのアプリケーションは最適化がないと正しく動作しません。よって、デバッグ以外では推奨されません。

*  <code>-O1</code>: これは最も基本的な最適化レベルです。コンパイラはコンパイル時間をたくさんかけることなく、高速でサイズの小さなバイナリを生成しようと試みるでしょう。これは基本的な最適化しかおこないませんが、その代わり、いつでもうまくいくはずです。

*  <code>-O2</code>: <code>-O1</code>から更に踏み込みます。これは特別な理由がない限り"推奨される"最適化レベルです。<code>-O2</code>は<code>-O1</code>により有効になるものに加え、さらにいくつかのフラグを有効にします。<code>-O2</code>を使うと、コンパイラは、サイズが大きくなったり、たくさんの時間がかかったりしないように、コードのパフォーマンスを増加させようと試みます。

*  <code>-O3</code>: これは取りうる最高の最適化レベルです。コンパイル時間とメモリ使用量を犠牲にして最適化を実施します。<code>-O3</code>は性能を改善する保証がありません。実際多くのケースで、バイナリサイズが大きくなり、メモリ使用量が増えることでシステムが遅くなります。<code>-O3</code>はいくつかのパッケージを壊すことがわかっています。これらの理由により<code>-O3</code>は推奨されません。

*  <code>-Os</code>: このレベルはバイナリのサイズを重視して最適化するでしょう。これは<c>-O2</c>フラグの中で、生成されるバイナリのサイズが増えないものを全て有効にします。CPUのキャッシュが小さかったり、ディスクストレージスペースが極端に限られている場合などに非常に有効でしょう。

*  <code>-Og</code>: GCC 4.8では新しい汎用的な最適化レベル<code>-Og</code>が導入されました。このレベルはコンパイル時間の短縮とデバッグエクスペリエンスを向上させる一方、妥当なランタイム性能を確保することを目的としています。結果的に開発全体で得られるものはデフォルトの最適化レベル<code>-O0</code>より向上するはずです。<code>-Og</code>は<code>-g</code>を意味しないことだけ理解しておいてください。<code>-g</code>はデバッガとやりとりするために単純に最適化をオフにするだけです。

*  <code>-Ofast</code>: GCC 4.7では、<code>-O3</code>に加えて、<code>-ffast-math</code>、<code>-fno-protect-parens</code>、<code>-fstack-arrays</code>が利用できます。このオプションは規格への厳密な適合を犠牲にするため推奨されません。

前述の通り、<code>-O2</code>が推奨される最適化レベルです。もし<code>-O2</code>を使用してパッケージのコンパイルが失敗する場合は、<code>-O2</code>で再コンパイルしてみましょう。うまくいかなかった場合は、<code>CFLAGS</code>と<code>CXXFLAGS</code>を(エラー報告や問題の調査向けに)<c>-O1</c>や<c>-O0 -g2 -ggdb</c>のように、最適化レベルを低く設定してみてください。

=== -pipe ===

よく使うフラグに<c>-pipe</c>があります。このフラグは、生成されるバイナリ自体には何の影響もありませんが、コンパイル処理が早くなります。これはコンパイルにおける各処理間で一時ファイルを使う代わりに、より多くのメモリを使うことになりますが、パイプを使うように指示します。メモリに余裕のないシステムの場合、GCCがもしかすると強制終了するかもしれません。そのような場合はこのフラグを使わないでください。 

=== -fomit-frame-pointer ===

これは生成されるバイナリのサイズを減少させるために設計されているフラグで、よく利用されています。(<code>-O0</code>を除く)全ての<code>-O</code>のレベルで、このフラグを有効にしても(x86-64のように)デバッグ作業の阻害をしないアーキテクチャでは有効になります。GCCマニュアルによれば、全てのアーキテクチャにおいて、<code>-O</code>を使えば<code>-fomit-frame-pointer</code>が有効になる訳ではありません。GCC 4.6までは、もしくは<code>-Os</code>を使っているときは、x86で明示的に有効にするために<code>-O</code>を使わなければなりません。 

特に、Javaで書かれたアプリケーションの不具合修正をとても難しくします。もっとも、Javaだけがこのフラグの影響を受けるわけではありませんが。このように、このフラグは役立つ一方でデバッグを難しくしているのです。特にバックトレースは役に立たなくなります。しかしながら、そんなにソフトウェアのデバッグを行う予定がなく、他に<code>-ggdb</code>のようなデバッグ関連のCFLAGSを追加していないのであれば、<code>-fomit-frame-pointer</code>を試しに使ってみてもいいでしょう。 

{{Important/ja|<code>-fomit-frame-pointer</code>と似ている<c>-momit-leaf-frame-pointer</c>フラグを組み合わせて'''使わないでください'''。後者のフラグを使うのはやめてください。<code>-fomit-frame-pointer</code>のみで十分です。そのうえ、<code>-momit-leaf-frame-pointer</code>はコードの性能に悪影響を及ぼすことがわかっています。}}

=== -msse、-msse2、-msse3、-mmmx、-m3dnow ===

これらのフラグは[https://ja.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extentions] (SSE)、[https://en.wikipedia.org/wiki/SSE2 SSE2]、[https://en.wikipedia.org/wiki/SSSE3 SSE3]、[https://ja.wikipedia.org/wiki/MMX MMX]、[https://ja.wikipedia.org/wiki/3DNow! 3DNow!]の命令セットをx86とx86-64アーキテクチャで有効にします。これらは主にマルチメディアやゲーム、その他の浮動小数点を多用する計算処理に有用です。その他にも有用な数学用機能の向上をいくつか含んでいます。比較的新しいCPUならば、これらの命令セットに対応しています。 

{{Important/ja|CPUがこれらをサポートしているかどうかは<kbd>cat /proc/cpuinfo</kbd>を実行して確認してください。その出力にサポートされているこれらの命令セットが表示されます。'''pni'''が実際はSSE3の別名であることに注意してください。}}

通常、正しい<code>-march</code>を使っている限り、これらのどのフラグも{{Path|/etc/portage/make.conf}}に加える必要はありません(例えば<code>-march=nocona</code>は<code>-msse3</code>を有効にします)。いくつかの注意すべき例外は、比較的新しいVIAとAMD64のCPUです。VIAとAMD64はこれらの命令をサポートしますが、(SSE3のように)<code>-march</code>では有効になりません。これらのCPUについては{{Path|/proc/cpuinfo}}の出力を確認して、ふさわしいフラグを追加する必要があるでしょう。 

{{Note/ja|x86とx86-64特有のフラグの[http://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags]を確認しましょう。適切にCPUを指定することによって、どの命令セットが有効になるのか確認することができます。もし命令セットがリストの中にあったら、改めて指定する必要はありません。なぜならそれらは正しい<code>-march</code>を使えば有効になるでしょうから。}}

== 最適化FAQ ==

=== -funroll-loopsや-fomg-optimizeを使ったら速くなったんだけど！ ===

いいえ違います。フラグを付け加えれば付け加えるほど最適化されると言う誰かに騙されて、してやったと勘違いしているだけです。システム全体で挑戦的なフラグを使うことはあなたのアプリケーションを傷つけるでしょう。GCC [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options マニュアル]では<code>-funroll-loops</code>と<code>-funroll-all-loops</code>を使うとバイナリは大きくなり、実行も遅くなると述べています。またいくつかの理由から、これらの二つのフラグと同時に、<code>-ffast-math</code>や<code>-fforce-mem</code>や<code>-fforce-addr</code>などの似たようなフラグが、速度を最大限誇示したい人たちの間で、とても人気を博しています。 

ここで本当に問題なのは、これらのフラグは危険なほどに挑戦的なフラグということです。それらのフラグが何をやらかしているのか[https://forums.gentoo.org/ Gentoo Forums]と[https://bugs.gentoo.org/ Bugzilla]あたりをよく見てください。ろくなことないですよ！ 

それらのフラグを<code>CFLAGS</code>や<code>CXXFLAGS</code>に設定し、システム全体で使う必要はありません。それらはパフォーマンスに悪影響を及ぼすだけでしょう。それらのフラグが、最先端でハイパフォーマンスなシステムを使っているかのように見せるかもしれませんが、しかしそれらは何の効果もないどころか、バイナリのサイズが膨れ上がり、無効(INVALID)や修正の必要無し(WONTFIX)と結論づけられたバグを踏むことになります。 

あなたはそのような危険なフラグを使う必要はありません。'''使わないでください。'''<code>-march</code>、<code>-O</code>、<code>-pipe</code>という基本を守り通してください。

=== 3より高い-Oレベルはどう？ ===

何人かのユーザーが、<code>-O4</code>や<code>-O9</code>などを使うことによってもっといいパフォーマンスを得たと誇張していますが、3より高い<code>-O</code>レベルは何の効果もありません。コンパイラは<code>-O4</code>のようなCFLAGSも許容するでしょうが、それらは実質何もしないのです。<code>-O3</code>の最適化を行うだけで、それ以上の最適化はしません。 

さらに証拠が必要ですか？[https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup ソースコード]を試してみてください。 

{{CodeBox|title=-O ソースコード|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

見てのとおり、3より高いレベルであっても、結局<code>-O3</code>として扱われます。

=== 実際のマシンと別のマシンでコンパイルするのはどう？ ===

何人かの読者は、あきらかに劣ったCPUやGCCサブアーキテクチャでコンパイルすることを避けて、他のマシンでコンパイルすることは（ネイティブな環境でのコンパイルと比較して）、劣った最適化になるのか知りたくなるでしょう。

To exemplify, if Gentoo is installed on a machine whose GCC's CHOST is ''i686-pc-linux-gnu'', and a [[Distcc]] server is setup on another computer whose GCC's CHOST is ''i486-linux-gnu'', then there is no need to be afraid that the results would be less optimal because of the strictly inferior sub-architecture of the remote compiler and/or hardware. The result would be as optimized as a native build, as long as the same options are passed to both compilers (and the <code>-march</code> parameter doesn't get a <code>native</code> argument).  In this particular case the target architecture needs to be specified explicitly as explained in [[Distcc#-march.3Dnative|Distcc and -march=native]].

The only difference in behavior between two GCC versions built targeting different sub-architectures is the implicit default argument for the <code>-march</code> parameter, which is derived from the GCC's CHOST when not explicitly provided in the command line.

=== 冗長なフラグ指定はどう？ ===

しばしば、{{Path|/etc/portage/make.conf}}の中で、個々の<code>-O</code>レベルを指定すれば有効になるフラグを重複してCFLAGSやCXXFLAGSに設定していることがあります。これは時々よく知らずにやってしまうのですが、一方で(ebuildが行う)フラグの除去や置換を回避する為に行われることがあります。 

フラグの除去や置換はPortageツリーの中にある多くのebuildで行われています。大抵は、特定の<code>-O</code>レベルでパッケージをコンパイルすると失敗するため、もしくは、フラグを追加すると、そのソースコードでは問題が出るからです。ebuildはどちらの場合も、全部/一部のCFLAGSとCXXFLAGSを除外するか、もしくは異なる<code>-O</code>レベルに置換するでしょう。 

[http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual]にフラグの除去と置換がどんな場合にどうやって使われているのか、あらましがあります。 

特定のレベルに対して重複してフラグを設定することによって、ある程度は<code>-O</code>に対するフラグ除去を回避することができます。例えば、<code>-O3</code>であれば、次のようにします。 

{{CodeBox|title=重複してCFLAGSを設定|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

しかしながら、'''これは賢いやり方ではありません'''。CFLAGSは理由があって除去されるのです！ フラグが除去されるとき、それらのフラグでパッケージをビルドすると安全でないことを意味します。明らかに分かっているのは、<code>-O3</code>でシステム全体をコンパイルすることは"安全ではない"という事です。そうすると、<c>-O3</c>の最適化で有効になるいくつかのフラグによって問題となるパッケージが出てくるでしょう。そのため、それらのパッケージをメンテナンスしている開発者の"裏をかく"ことを試みるべきではありません。
"開発者を信用してください。"フラグの除去と置換はあなたの利益になるから行われているのです！ もしebuildに代替のフラグが指定されているなら、それを回避しようとしないでください。 

開発者が許可していないフラグでパッケージをビルドすれば、大概は数々の問題に陥り続けることでしょう。Bugzillaに不具合を報告する際には、{{Path|/etc/portage/make.conf}}で使っているフラグは容易く見抜かれてしまうので、余計なフラグを除いて再コンパイルする様に開発者に指示されるでしょう。初めから冗長なフラグを指定しないことで、再コンパイルする手間を省いてください！ あなたが開発者よりよく知っていると根拠なく無意識に決めつけないでください。

=== LDFLAGSはどう？ ===

Gentoo開発者がすでに基本的で安全なLDFLAGSを基本プロファイルにセットしているので、それらを変更する必要はありません。

=== パッケージごとにフラグを変更出来るの？ ===

{{Warning/ja|パッケージごとにフラグを変更するとデバッグやサポートが込み入ってきます。もしこの機能を使っている場合には、どんな変更をしたのか、バグレポートで言及してください。}}

パッケージごとに(CFLAGSを含む)環境変数を変更する方法は、[[Handbook:AMD64/Portage/Advanced/ja#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]]で説明しています。

== 資料 ==

以下のいくつかの資料が更に最適化について理解する助けになるでしょう。 

* [http://gcc.gnu.org/onlinedocs/ GCC online documentation] 

* [[Handbook:Main_Page|Gentoo インストールハンドブック]]の第5章

* <kbd>man make.conf</kbd>

* [https://ja.wikipedia.org/wiki/ ウィキペディア]

* [https://forums.gentoo.org/ Gentooフォーラム]

{{Migrated|originalauthors=nightmorph}}
