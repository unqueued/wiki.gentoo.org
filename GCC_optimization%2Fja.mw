<languages />

{{Metadata|abstract=このガイドは、コンパイル済みコードを安全で分別のあるCFLAGSとCXXFLAGSを使って最適化する手法を紹介します。また一般的な最適化の背景にある理論についても述べます。}}

このガイドは、[[Article description::コンパイル済みコードを安全で分別のある<var>CFLAGS</var>と<var>CXXFLAGS</var>を使って最適化する手法を紹介します。]]また、一般的な最適化の背景にある理論について述べます。

== はじめに ==

=== CFLAGSとCXXFLAGSとは？ ===

<var>CFLAGS</var>と<var>CXXFLAGS</var>は、CやC++のソースコードをコンパイルするときに使われるオプションを、コンパイラに指示するために慣例的に使われる環境変数の一種です。これらの環境変数は標準化されているわけではありませんがそれに近い状況で用いられており、コンパイラを使う際に追加のオプションを指定したいなら理解しておく必要があります。[https://www.gnu.org/software/make/manual/make.html#Implicit-Variables GNU make]では一般的によく使われている環境変数のリストが記されています。

Gentooシステムでは大多数のパッケージがCまたはC++で書かれているため、これらの環境変数はシステムがどのように構成されるかに多大な影響を及ぼします。そのため管理者にはこれらを正しく設定することが求められます。

これらはプログラムのデバッグメッセージの量を減らすために使われたり、エラーや警告のレベルを増加させたり、また、もちろん生成されるコードの最適化にも使われます。[https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCCのマニュアル]に利用可能なフラグとその効果の完全なリストが記載されています。

=== どのように使われているのでしょうか？ ===

普通<var>CFLAGS</var>と<var>CXXFLAGS</var>は、configureスクリプトを走らせるか、プログラム毎に{{c|automake}}により生成されたMakefileによってセットされます。Gentooシステムでは、<var>CFLAGS</var>と<var>CXXFLAGS</var>は{{Path|/etc/portage/make.conf}}で設定します。このファイルに定義された変数はportageが呼び出したプログラムに適用され、その設定に基づいてプログラムがコンパイルされます。

{{CodeBox|title=/etc/portage/make.confのCFLAGS設定|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important/ja|'''USE'''フラグは複数の行で構成できますが、<var>CFLAGS</var>を複数の行で構成すると{{c|cmake}}のようなプログラムで問題が発生します。問題を避けるために、<var>CFLAGS</var>の宣言は極力スペースで区切られた単一行で構成するようにしてください。{{Bug|500034}}が参考になります。}}

見てわかるとおり、<var>CXXFLAGS</var>は<var>CFLAGS</var>の中にある全てのフラグが設定されています。大部分のシステムはこのように設定されるべきです。通常のケースでは、<var>CXXFLAGS</var>だけに追加のオプションを指定するようなことはほとんどありませんし、大体そういったオプションはグローバルに適用すべきではありません。

{{Tip|[[Safe_CFLAGS|安全なCFLAGS]] 初心者向けにシステム最適化の方法が書かれています。}}

=== よくある誤解 ===

<var>CFLAGS</var>でコンパイラの最適化をするのはより小さく高速なバイナリを生成するには効果的な方法ですが、一方で正しく動作しない、サイズの巨大化や動作速度の低下を引き起こしたり、そもそもコンパイルできないなどの問題を起こす可能性があります。<var>CFLAGS</var>を弄っているとこうしたことはあっさりと発生します。適当に設定してはいけません。

{{Path|/etc/portage/make.conf}}にて設定した<var>CFLAGS</var>はシステム上の全てのパッケージに適用されます。そのため管理者は至極一般的で広く適用しても問題ないオプションのみを設定するのが普通です。これに加えて各々のパッケージがebuildやコンパイル中にさらに必要なオプションを自動で追加しています。

=== 準備はできましたか？ ===

リスクを伴うことを理解したところで、良識的、かつ安全な最適化の方法を見ていきましょう。そうすれば、この先[https://bugs.gentoo.org/ Bugzilla]で開発者に歓迎され、役立つ報告をすることができます。（開発者は、大抵、問題が再現するか確かめるために、最小限の<var>CFLAGS</var>でパッケージを再コンパイルすることを要求します。挑戦的なフラグはコードを破壊しうることを覚えておいてください!） 

== 最適化について ==

=== 基本 ===

<var>CFLAGS</var>と<var>CXXGLAGS</var>の使用目的は、システム向けにあつらえた、可能な限り早くて小さな、かつ完全に動作するコードを生成することです。時には、これらの条件は相互に排他的ですので、うまく動作すると分かっている組み合わせをここでは扱うことにします。原則、それぞれのCPUアーキテクチャ向けに利用可能なよい最適化が用意されています。参考情報として、さらにアグレッシブなフラグを後述します。このガイドではGCCのマニュアルに記載されているすべてのオプションを商会する訳ではありません。基本的な、そして最も標準的なオプションについてのみ解説します。 

{{Note/ja|フラグがどういう働きをするのか不明なときは、[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual]の関連する章を参照してください。もしそれでもわからない場合は、ウェブ検索をするか、[https://gcc.gnu.org/lists.html GCC mailing lists]をチェックしましょう}}

=== -march ===

最初の、そしてもっとも重要なオプションは<code>-march</code>です。このオプションはコンパイラに対してどのシステム[https://en.wikipedia.org/wiki/Microarchitecture プロセッサアーキテクチャ] (もしくは"arch")のためのコードを生成するのかを指示します。つまり、特定のCPU向けのコードを生成すべきであるといっているのです。CPUが違えば、性能が異なり、異なる命令セットをサポートし、コードの実行方法も違います。<code>-march</code>フラグは、あなたのCPUの全ての性能、機能、命令セット、癖などに合わせて特化したコードを生成するようにコンパイラに伝えます。例えばAVX命令の恩恵を受けたいなら、ソースコードがそれに対応しておく必要があります。

<code>-march=</code>はISA（訳註：命令セットアーキテクチャ）指定のオプションで、コンパイラにどんな命令が利用可能かを伝えます。Intel/AMD64プラットフォームで <code>-march=native</code <code>-O2</code>を使用すると、AVX命令はサポートされますがSSEのXMMレジスタがサポートされない場合があります。AVXのYMMレジスタを最大限利用したい場合、<code>-ftree-vectorize</code> <code>-O3</code>または<code>-Ofast</code> も指定する必要があります。<ref>GNU GCC Bugzilla, [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57952#c8 AVX/AVX2で単純約分のときにXMMレジスタが使われない問題。] 2017/07/18取得。</ref>

<code>-ftree-vectorize</code>は最適化オプション(<code>-O3</code>と<code>-Ofast</code>においてはデフォルト)で、可能であれば選択されたISAを使用してループのベクトル化を試みます。<code>-O2</code>で有効化されていないのは、常にコードを改善するわけではなく、またコードを遅くしてしまう可能性があり、そしてたいていはコードを大きくしてしまうためです; 実際、これはループなどの状況次第です。 

たとえ{{Path|/etc/portage/make.conf}}に書いてある<var>CHOST</var>変数を一般的なアーキテクチャに設定していても、<code>-march</code>を設定すれば、プログラムは指定したプロセッサ向けに最適化されるでしょう。x86とx86-64のCPUは(とりわけ)<code>-march</code>フラグを使うべきです。 

どんな種類のCPUを使っていますか？以下のコマンドを実行すれば、それが分かります。 

{{Cmd|cat /proc/cpuinfo}}

or even install {{Package|app-portage/cpuid2cpuflags}} and add the available CPU-specific options to the {{Path|make.conf}} file, which the tool does through e.g. the [[CPU FLAGS X86|CPU_FLAGS_X86]] variable:

{{Cmd|cpuid2cpuflags|output=<pre>
CPU_FLAGS_X86: aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3</pre>}}

{{RootCmd|echo "CPU_FLAGS_X86{{=}}'aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3'" >> /etc/portage/make.conf}}

さらに<code>march</code>と<code>mtune</code>の値を含む詳細な情報を得たい場合は、以下の2つのコマンドが使えます。

* 最初のコマンドはコンパイラにリンクを行わないようにさせ(<code>-c</code>)、また、<code>--help</code>をコマンドラインオプションを明らかにせよとではなく、あるオプションが有効か無効かを示せという意味に解釈させます(<code>-Q</code>)。ここでは、選択されたターゲットで有効なオプションが出力されます:
:{{Cmd|gcc -c -Q -march{{=}}native --help{{=}}target}}

* The second command will show the compiler directives for building the header file, but without actually performing the steps and instead showing them on the screen (<code>-###</code>). The final output line is the command that holds all the optimization options and architecture selection:
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

では実際に<code>-march</code>を見てみましょう。この例は古いPentium IIIチップ向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium IIIの例|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

こちらはAMD64向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64の例|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

CPUのタイプが決められない場合、またはどの設定を使えばいいかわからない場合、<code>-march=native</code>を使うことができます。このフラグを使った場合、GCCはプロセッサを判別して、自動的にふさわしいフラグを設定するでしょう。'''しかしながら、このフラグは異なるCPU向けにパッケージをコンパイルする目的では使用すべきではありません！''' 

{{Warning/ja|{{c|[[Distcc#-march.3Dnative|distcc]]}}を使ってコンパイルする場合、{{Path|make.conf}}の<var>CFLAGS</var>もしくは<var>CXXFLAGS</var>に<code>-march{{=}}native</code>や<code>-mtune{{=}}native</code>を使用しては'''いけません'''。}}

If compiling packages on one computer in order to run them on a different computer (such as when using a fast computer to build for an older, slower machine), then ''do not'' use <code>-march=native</code>. "Native" means that the code produced will run ''only'' on that type of CPU. The applications built with <code>-march=native</code> on an AMD Athlon 64 CPU will '''not''' be able to run on an old VIA C3 CPU. 

また、<code>-mtune</code>と<code>-mcpu</code>フラグも利用可能です。これらのフラグはたいてい<code>-march</code>フラグが利用できない場合にのみ使われます。例えば特定のプロセッサアーキテクチャは<code>-mtune</code>や<code>-mcpu</code>が必要になるかもしれません。残念ながら、GCCの挙動はそれぞれのフラグの振る舞いが、あるアーキテクチャから近いアーキテクチャであってもあまり一貫性はありません。 

x86とx86-64のCPUにおいて、<code>-march</code>は利用可能な命令セットと正しいABIを使い、そのCPUに特化したコードを生成するでしょう。そのため古かったり種類の異なるCPUとの後方互換性は持っていません。i386やi486のような古いCPU向けにコードを生成する必要があるときのみ、<code>-mtune</code>の使用を考慮するべきでしょう。<code>-mtune</code>は<code>-march</code>よりも一般的なコードを生成します。特定のCPUコードにチューニングしますが、利用可能な命令セットやABIを考慮しないのです。<code>-mcpu</code>はx86やx86-64のシステム上では非推奨となっているので、使わないでください。 

Only non-x86/x86-64 CPUs (such as SPARC, Alpha, and PowerPC) may require <code>-mtune</code> or <code>-mcpu</code> instead of <code>-march</code>. On these architectures, <code>-mtune</code> / <code>-mcpu</code> will sometimes behave just like <code>-march</code> (on x86/x86-64) but with a different flag name. Again, GCC's behavior and flag naming is not consistent across architectures, so be sure to check the GCC [https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] to determine which one should be used. 

{{Note/ja|更なる<code>-march</code>/<code>-mtune</code>/<code>-mcpu</code>の設定についての情報は、あなたのアーキテクチャに適した[[HandBook:Main_Page/ja|Gentooハンドブック]]の５章を読んでみてください。また、GCCマニュアルの[https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options]のリストに、<code>-march</code>と<code>-mcpu</code>と<code>-mtune</code>の違いについてもっと詳しい説明があります。}}

=== -O ===
{{warning|Using <code>-O3</code> or <code>-Ofast</code> may cause some packages to break during the compilation.}}

{{note|To print all packages that were built with specified <var>CFLAGS</var>/<var>CXXFLAGS</var> it's possible to use the following command: <code>grep Ofast /var/db/pkg/*/*/CFLAGS</code>}}

次は<code>-O</code>フラグについてです。これは全体の最適化レベルをコントロールしますが、特にこの最適化レベルを上げることによって、ソースコードのコンパイルの時間がいくらか増えたり、よりたくさんのメモリを使用するようになります。 

７つの<code>-O</code>設定があります。<code>-O0</code>、<code>-O1</code>、<code>-O2</code>、<code>-O3</code>、<code>-Os</code>、<code>-Og</code>、<code>-Ofast</code>です。{{Path|/etc/portage/make.conf}}で指定できるのはこのうちの一つだけです。

<code>-O0</code>を除いて、<code>-O</code>の設定はいずれもいくつかの追加フラグを有効にします。なので、どの<code>-O</code>レベルで、どのフラグが有効になり、そのフラグにどんな効果があるのかを学ぶために、GCCマニュアルの[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimization options]
の章を読んで確認しましょう。 

では、それぞれの最適化レベルを見てみましょう。 

*  <code>-O0</code>: このレベル("O"のあとにゼロが続いてます)は、完全に最適化をオフにします。<var>CFLAGS</var>や<var>CXXFLAGS</var>の中に<code>-O</code>が定義されていない場合のデフォルトです。このレベルはコンパイル時間を短縮して、生成するデバッグ情報を改善しますが、いくつかのアプリケーションは最適化がないと正しく動作しません。よって、デバッグ以外では推奨されません。

*  <code>-O1</code>: これは最も基本的な最適化レベルです。コンパイラは時間をたくさんかけることなく、高速でサイズの小さなバイナリを生成しようと試みるでしょう。これは基本的な最適化しかおこないませんが、その代わり、いつでもうまくいくはずです。

*  <code>-O2</code>: A step up from <code>-O1</code>. The ''recommended'' level of optimization unless the system has special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code>. With <code>-O2</code>, the compiler will attempt to increase code performance without compromising on size, and without taking too much compilation time. SSE or AVX may be be utilized at this level but no YMM registers will be used unless <code>-ftree-vectorize</code> is also enabled.

*  <code>-O3</code>: the highest level of optimization possible. It enables optimizations that are expensive in terms of compile time and memory usage.  Compiling with <code>-O3</code> is not a guaranteed way to improve performance, and in fact, in many cases, can slow down a system due to larger binaries and increased memory usage. <code>-O3</code> is also known to break several packages. Using <code>-O3</code> is not recommended. However, it also enables <code>-ftree-vectorize</code> so that loops in the code get vectorized and will use AVX YMM registers.

*  <code>-Os</code>: このレベルはバイナリのサイズを重視して最適化するでしょう。これは<code>-O2</code>フラグの中で、生成されるバイナリのサイズが増えないものを全て有効にします。CPUのキャッシュが小さかったり、ディスクの空き容量が極端に限られている場合などに非常に有効でしょう。

*  <code>-Og</code>: GCC 4.8では新しい汎用的な最適化レベル<code>-Og</code>が導入されました。このレベルはコンパイル時間の短縮とデバッグエクスペリエンスを向上させる一方、妥当なランタイム性能を確保することを目的としています。結果的に開発全体で得られるものはデフォルトの最適化レベル<code>-O0</code>より向上するはずです。<code>-Og</code>と<code>-g</code>は同じでないことだけ理解しておいてください。<code>-g</code>はデバッガとやりとりするために単純に最適化をオフにするだけです。

*  <code>-Ofast</code>: GCC 4.7では、<code>-O3</code>に加えて<code>-ffast-math</code>、<code>-fno-protect-parens</code>、<code>-fstack-arrays</code>が利用できます。このオプションは規格への厳密な適合を犠牲にするため推奨されません。

前述の通り、<code>-O2</code>が推奨される最適化レベルです。もし<code>-O2</code>以外を使用してパッケージのコンパイルが失敗する場合は、<code>-O2</code>で再コンパイルしてみましょう。うまくいかなかった場合は、<var>CFLAGS</var>と<var>CXXFLAGS</var>を(エラー報告や問題の調査向けに)<code>-O1</code>や<code>-O0 -g2 -ggdb</code>のように、最適化レベルを低く設定してみてください。

=== -pipe ===

よく使うフラグに<code>-pipe</code>があります。このフラグは、生成されるバイナリ自体には何の影響もありませんが、コンパイル時間が短縮されます。これはコンパイルにおける各処理の間で一時ファイルを使う代わりにパイプを使うように指示します。これにより多くのメモリを使うことになります。メモリに余裕のないシステムの場合、GCCが強制終了するかもしれません。そのような場合はこのフラグを使わないでください。 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but it may need to be activated. In that case add it to the flags. Though the GCC manual does not specify all architectures, it is turned on by using the <code>-O</code> option. It's still necessary to explicitly enable the <code>-fomit-frame-pointer</code> option, to activate it on x86-32 with GCC up to version 4.6, or when using <code>-Os</code> on x86-32 with any version of GCC. However, using <code>-fomit-frame-pointer</code> will make debugging hard or impossible. 

In particular, it makes troubleshooting applications written in Java and compiled by gcj much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. When not doing software debugging and no other debugging-related <var>CFLAGS</var> such as <code>-ggdb</code> have been used, then try using <code>-fomit-frame-pointer</code>. 

{{Important/ja|<code>-fomit-frame-pointer</code>とそれに似た<code>-momit-leaf-frame-pointer</code>フラグを組み合わせて'''使わないでください'''。後者のフラグを使うのはやめてください。<code>-fomit-frame-pointer</code>のみで十分です。そのうえ、<code>-momit-leaf-frame-pointer</code>はコードの性能に悪影響を及ぼすことがわかっています。}}

=== -msse、-msse2、-msse3、-mmmx、-m3dnow ===

これらのフラグは[https://ja.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extentions] (SSE)、[https://en.wikipedia.org/wiki/SSE2 SSE2]、[https://en.wikipedia.org/wiki/SSSE3 SSE3]、[https://ja.wikipedia.org/wiki/MMX MMX]、[https://ja.wikipedia.org/wiki/3DNow! 3DNow!]の命令セットをx86とx86-64アーキテクチャで有効にします。これらは主にマルチメディアやゲーム、その他の浮動小数点を多用する計算処理に向いています。その他にも有用な数学用機能の向上をいくつか含んでいます。比較的新しいCPUならば、これらの命令セットに対応しています。 

{{Important|Be sure to see if the CPU supports these instruction sets by running {{c|cat /proc/cpuinfo}}. The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

通常、正しい<code>-march</code>を使っている限り、これらのどのフラグも{{Path|/etc/portage/make.conf}}に加える必要はありません(例えば<code>-march=nocona</code>は<code>-msse3</code>を有効にします)。いくつかの注意すべき例外は、比較的新しいVIAとAMD64のCPUです。VIAとAMD64はこれらの命令をサポートしますが、(SSE3のように)<code>-march</code>では有効になりません。これらのCPUについては{{Path|/proc/cpuinfo}}の出力を確認して、ふさわしいフラグを追加する必要があるでしょう。 

{{Note/ja|x86とx86-64特有のフラグについて[https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags]を確認しましょう。適切にCPUを指定することによって、どの命令セットが有効になるのか確認することができます。もし命令セットがリストの中にあったら、改めて指定する必要はありません。なぜならそれらは正しい<code>-march</code>を使えば有効になるでしょうから。}}

== 最適化FAQ ==

=== -funroll-loopsや-fomg-optimizeを使ったら速くなったんだけど！ ===

No, people only ''think'' they do because someone has convinced them that more flags are better. Aggressive flags will only hurt applications when used system-wide. Even the GCC [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> will make code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

ここで本当に問題なのは、これらのフラグは危険なほどに挑戦的なフラグということです。それらのフラグが何をやらかしているのか[https://forums.gentoo.org/ Gentoo Forums]と[https://bugs.gentoo.org/ Bugzilla]あたりをよく見てください。ろくなことないですよ！ 

それらのフラグを<var>CFLAGS</var>や<var>CXXFLAGS</var>に設定し、システム全体で使う必要はありません。それらはパフォーマンスに悪影響を及ぼすだけでしょう。それらのフラグが、最先端でハイパフォーマンスなシステムを使っているかのように見せるかもしれませんが、しかしそれらは何の効果もないどころか、バイナリのサイズが膨れ上がり、無効(INVALID)や修正の必要無し(WONTFIX)と結論づけられたバグを踏むことになります。 

Dangerous flags like these are not needed. '''Don't use them'''. Stick to the basics: <code>-march</code>, <code>-O</code>, and <code>-pipe</code>.

=== 3より高い-Oレベルはどう？ ===

何人かのユーザーが、<code>-O4</code>や<code>-O9</code>などを使うことによってもっといいパフォーマンスを得たと誇張していますが、3より高い<code>-O</code>レベルは何の効果もありません。コンパイラは<code>-O4</code>のような<var>CFLAGS</var>も許容するでしょうが、それらは実質何もしないのです。<code>-O3</code>の最適化を行うだけで、それ以上の最適化はしません。 

さらに証拠が必要ですか？[https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup ソースコード]を試してみてください。 

{{CodeBox|title=-O ソースコード|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

見てのとおり、3より高いレベルであっても、結局<code>-O3</code>として扱われます。

=== 実際のマシンと別のマシンでコンパイルするのはどう？ ===

何人かの読者は、あきらかに劣ったCPUやGCCサブアーキテクチャでコンパイルすることを避けるために他のマシンでコンパイルすることは、（ネイティブな環境でのコンパイルと比較して）劣った最適化になるのか知りたくなるでしょう。答えは単純で'''いいえ'''です。コンパイルが走る実際のマシンに関係なく、またGCCをビルドしたときのCHOSTに関係なく、同じ引数が使用されている限り<small>(<code>-march=native</code>は除く)</small>、そしてGCCのバージョンが同じである限り<small>(マイナーバージョンが違うかもしれません)</small>、最適化の結果は厳密に同じです。

例を一つあげます。GCCのCHOSTが''i686-pc-linux-gnu''となっているマシンにGentooをインストールして、CHOSTが''i486-linux-gnu''となっている別のPCに[[Distcc]]サーバーをインストールします。リモートサーバーのコンパイラのサブアーキテクチャもしくはハードウェアが明らかに劣っている場合、最適化が十分なされないのではと心配する必要はありません。結果は、両方のコンパイラに同じ引数が与えられている限り（かつ<code>-march</code>に<code>native</code>が与えられていない限り）、ネイティブにビルドしたときと同じ最適化がかかります。ただしこの特殊なケースでは[[Distcc#-march.3Dnative|Distcc and -march=native]]で説明されている通り、ターゲットのアーキテクチャが明示的に指定されなければなりません。

異なるサブアーキテクチャに向けてビルドされた２つのGCCの動作には一つしか違いがありません。それは暗に与えられるデフォルトの<code>-march</code>です。コマンドラインで<code>-march</code>を明示的に指定しなかった場合、GCCのCHOSTに設定された値が使用されます。

=== 冗長なフラグ指定はどう？ ===

しばしば、{{Path|/etc/portage/make.conf}}の中で、個々の<code>-O</code>レベルを指定すれば有効になるフラグを重複して<var>CFLAGS</var>や<var>CXXFLAGS</var>に設定していることがあります。これは時々知らずにやってしまうのですが、一方で(ebuildが行う)フラグの除去や置換を回避するために意図的に行われることがあります。 

フラグの除去や置換はPortageツリーの中にある多くのebuildで行われます。大抵は、特定の<code>-O</code>レベルでパッケージをコンパイルすると失敗するために、もしくはフラグを追加するとそのソースコードでは問題が出るためです。ebuildはどちらの場合も、全部/一部の<var>CFLAGS</var>と<var>CXXFLAGS</var>を除外するか、もしくは異なる<code>-O</code>レベルに置換するでしょう。 

[https://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual]にフラグの除去と置換がどのような場合に、どのように使われているのか概要が記載されています。 

特定のレベルに対して重複してフラグを設定することによって、<code>-O</code>に対するフラグ除去をある程度回避することができます。例えば、<code>-O3</code>であれば次のようにします。 

{{CodeBox|title=重複してCFLAGSを設定|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

However, '''this is not a smart thing to do'''. <var>CFLAGS</var> are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile the whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, don't try to "outsmart" the developers who maintain those packages. ''Trust the developers''. Flag filtering and replacing is done to ensure stability of the system and application! If an ebuild specifies alternative flags, then don't try to get around it. 

Building packages with unacceptable flags will most likely lead to problems. When reporting problems on Bugzilla, the flags that are used in {{Path|/etc/portage/make.conf}} will be readily visible and developers will ask to recompile without those flags. Save the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume to be more knowledgeable than the developers.

=== LDFLAGSはどう？ ===

Gentoo開発者がすでに基本的で安全な<var>LDFLAGS</var>を基本プロファイルにセットしているので、それらを変更する必要はありません。

=== パッケージごとにフラグを変更出来るの？ ===

{{Warning|Using per-package flags complicates debugging and support. Make sure to mention the use of this feature in the bug reports together with the changes made.}}

パッケージごとに(<var>CFLAGS</var>を含む)環境変数を変更する方法は、[[Handbook:AMD64/Portage/Advanced/ja#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]]で説明しています。

== See also ==

* [[Handbook:AMD64/Installation/Stage#Configuring_compile_options|Configuring compile options]] (AMD64 Handbook)

== External resources ==

以下、最適化について理解を深めるための資料を紹介します。 

* [https://gcc.gnu.org/onlinedocs/ GCC online documentation] 

* {{c|man make.conf}}

* [https://ja.wikipedia.org/wiki/ ウィキペディア]

* [https://forums.gentoo.org/ Gentooフォーラム]

== References ==

{{reflist}}

{{Migrated|originalauthors={{Dev|nightmorph}}}}


[[Category:Compilation]]
