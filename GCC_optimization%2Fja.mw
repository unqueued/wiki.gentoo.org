<languages />

{{Metadata|abstract=このガイドは、コンパイル済みコードを安全で分別のあるCFLAGSとCXXFLAGSを使って最適化する手法を紹介します。また、一般的な最適化の背景にある理論について述べます。}}

このガイドは、コンパイル済みコードを安全で分別のある<var>CFLAGS</var>と<var>CXXFLAGS</var>を使って最適化する手法を紹介します。また、一般的な最適化の背景にある理論について述べます。

== はじめに ==

=== CFLAGSとCXXFLAGSとは？ ===

<var>CFLAGS</var>と<var>CXXFLAGS</var>は、ソースコードをコンパイルするときに使われるオプションをGNUコンパイラコレクションであるGCCに伝えるための環境変数です。<var>CFLAGS</var>はCで書かれたソースコード、<var>CXXFLAGS</var>はC++で書かれたソースコード用になります。 

これらはプログラムのデバッグメッセージの量を減らすために使われたり、エラーや警告のレベルを増加させたり、また、もちろん生成されるコードの最適化にも使われます。[http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC manual]に利用可能なフラグとその効果の完全なリストが記載されています。

=== どのように使われているのでしょうか？ ===

<var>CFLAGS</var>と<var>CXXFLAGS</var>には二通りの使用方法があります。一つ目は、プログラム毎に{{c|automake}}により生成されたMakefileと共に使う方法です。 

しかしながら、この方法はPortageツリーの中にあるパッケージをインストールする際に使うべきではありません。その代わりに、Gentooベースのシステムでは{{Path|/etc/portage/make.conf}}の<var>CFLAGS</var>と<var>CXXFLAGS</var>を設定します。この方法を使えば、全てのパッケージはあなたが{{Path|make.conf}}に設定したフラグでコンパイルされるでしょう。

{{CodeBox|title=/etc/portage/make.confのCFLAGS設定|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important/ja|'''USE'''フラグは複数の行で構成できますが、<var>CFLAGS</var>を複数の行で構成すると{{c|cmake}}のようなプログラムで問題が発生します。問題を避けるために、CFLAGSの宣言は極力スペースで区切られた単一行で構成するようにしてください。{{Bug|500034}}が参考になります。}}

見てわかるとおり、<var>CXXFLAGS</var>は<var>CFLAGS</var>の中にある全てのフラグが設定されています。大部分のシステムはこのように設定されるべきです。通常のユースケースでは、<var>CXXFLAGS</var>だけに追加のオプションを指定するようなことはほとんどありません。

=== よくある誤解 ===

<var>CFLAGS</var>と<var>CXXFLAGS</var>は、ソースコードから小さくて早いバイナリを得るにはとても効果的な方法である一方で、ソースコード中の機能を損なったり、バイナリのサイズが膨れ上がったり、実行速度を低下させたり、コンパイルエラーを引き起こす場合もあります！ 

<var>CFLAGS</var> are not a magic bullet; they will not automatically make the system run faster or reduce the size of binaries on the disk. Adding too many flags in an attempt to optimize (or "rice") the system is a sure recipe for failure. The point of diminishing returns is reached rather quickly when dealing with <var>CFLAGS</var>. 

インターネットでは挑戦的な<var>CFLAGS</var>や<var>CXXFLAGS</var>の自慢も見受けられますが、それらはいい影響を与えるよりも、コンパイルされたバイナリに悪影響を及ぼす可能性の方がはるかに高いです。そもそもフラグは特定の場所、特定の目的のために設計されていることを忘れてはいけません。グローバルに適用することを目的としたフラグはほとんどありません。

=== 準備はできましたか？ ===

Being aware of the risks involved, take a look at some sane, safe optimizations. These will hold in good stead and will be endearing to developers the next time a problem  is reported on [https://bugs.gentoo.org/ Bugzilla]. (Developers will usually request the user to recompile a package with minimal <var>CFLAGS</var> to see if the problem persists. Remember: aggressive flags can ruin code!) 

== 最適化について ==

=== 基本 ===

The goal behind <var>CFLAGS</var> and <var>CXXFLAGS</var> is to create code tailor-made to your system; it should function perfectly while being lean and fast, if possible. Sometimes these conditions are mutually exclusive, so this guide will stick to combinations known to work well. Ideally, they are the best available for any CPU architecture. For informational purposes, aggressive flag use will be covered later. Not every option listed on the GCC manual (there are hundreds) will be discussed, but basic, most common flags will be reviewed. 

{{Note/ja|フラグがどういう働きをするのか不明なときは、[http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual]の関連する章を参照してください。もしそれでもわからない場合は、ウェブ検索をするか、[http://gcc.gnu.org/lists.html GCC mailing lists]をチェックしましょう}}

=== -march ===

最初の、そしてもっとも重要なオプションは<code>-march</code>です。このオプションはコンパイラに対してどのシステム[https://en.wikipedia.org/wiki/Microarchitecture プロセッサアーキテクチャ] (もしくは"arch")のためのコードを生成するのかを指示します。つまり、特定のCPU向けのコードを生成すべきであるといっているのです。CPUが違えば、性能が異なり、異なる命令セットをサポートし、コードの実行方法も違います。<code>-march</code>フラグは、あなたのCPUの全ての性能、特徴、命令セット、癖などに合わせて特化したコードを生成するようにコンパイラに伝えます。 

たとえ{{Path|/etc/portage/make.conf}}に書いてある<code>CHOST</code>変数を一般的なアーキテクチャに設定していても、<code>-march</code>を設定すれば、プログラムは指定したプロセッサ向けに最適化されるでしょう。x86とx86-64のCPUは(とりわけ)<code>-march</code>フラグを使うべきです。 

どんな種類のCPUを使っていますか？以下のコマンドを実行すれば、それが分かります。 

{{Cmd|cat /proc/cpuinfo}}

To get more details, including <code>march</code> and <code>mtune</code> values, two commands can be used.

* The first command tells the compiler not to do any linking (<code>-c</code>), and instead of interpreting the <code>--help</code> option for clarifying command line options, it now shows if certain options are enabled or disabled (<code>-Q</code>). In this case, the options shown are those enabled for the selected target:
: {{Cmd|gcc -c -Q -march{{=}}native --help{{=}}target}}

* The second command will show the compiler directives for building the header file, but without actually performing the steps and instead showing them on the screen (<code>-###</code>). The final output line is the command that holds all the optimization options and architecture selection:
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

では実際に<code>-march</code>を見てみましょう。この例は古いPentium IIIチップ向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium IIIの例|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

こちらはAMD64向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64の例|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

CPUのタイプが決められない場合、またはどの設定を使えばいいかわからない場合、<code>-march=native</code>を使うことができます。このフラグを使った場合、GCCはプロセッサを判別して、自動的にふさわしいフラグを設定するでしょう。'''しかしながら、このフラグは異なるCPU向けにパッケージをコンパイルする目的では使用すべきではありません！''' 

{{Warning|Do '''not''' use <code>-march{{=}}native</code> or <code>-mtune{{=}}native</code> in the <var>CFLAGS</var> or <var>CXXFLAGS</var> variables of {{Path|make.conf}} when compiling with {{c|[[Distcc#-march.3Dnative|distcc]]}}.}}

例えば、あるコンピュータでパッケージをコンパイルして、しかしそれらを別のコンピュータで実行しようとしている場合 (処理の早いコンピュータで、古くて遅いマシンのためにビルドしているときなど)、<code>-march=native</code>を'''使わない'''でください。"native"というのはコンパイルしているマシンのCPUタイプ'''のみ'''に特化して、アプリケーションのコードを生成することを意味しています。AMD Athlon 64上で<code>-march=native</code>と共にビルドされたアプリケーションは、古いVIA C3では実行することができないでしょう。 

また、<code>-mtune</code>と<code>-mcpu</code>フラグも利用可能です。これらのフラグはたいてい<code>-march</code>フラグが利用できない場合にのみ使われます。例えば特定のプロセッサアーキテクチャは<code>-mtune</code>や<code>-mcpu</code>が必要になるかもしれません。残念ながら、GCCの挙動はそれぞれのフラグの振る舞いが、あるアーキテクチャから近いアーキテクチャであってもあまり一貫性はありません。 

x86とx86-64のCPUにおいて、<code>-march</code>は利用可能な命令セットと正しいABIを使い、そのCPUに特化したコードを生成するでしょう。そのため古かったり種類の異なるCPUとの後方互換性は持っていません。i386やi486のような古いCPU向けにコードを生成する必要があるときのみ、<code>-mtune</code>の使用を考慮するべきでしょう。<code>-mtune</code>は<code>-march</code>よりも一般的なコードを生成します。特定のCPUコードにチューニングしますが、利用可能な命令セットやABIを考慮しないのです。<code>-mcpu</code>はx86やx86-64のシステム上では非推奨となっているので、使わないでください。 

x86/x86-64でない(SparcやAlpha、PowerPCのような)CPUでのみ、<code>-march</code>の代わりに<code>-mtune</code>や<code>-mcpu</code>が必要になるでしょう。これらのアーキテクチャ上では、<code>-mtune</code>/<code>-mcpu</code>は(x86/x86-64上での)<code>-march</code>と同じように振る舞うでしょう･･･しかしフラグの名前は違うのです。繰り返しますが、GCCの振る舞いとフラグ名はアーキテクチャを超えて一貫していないので、システムでどのフラグを使うべきなのかをGCCの[http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options マニュアル]で必ず確認してください。 

{{Note/ja|更なる<code>-march</code>/<code>-mtune</code>/<code>-mcpu</code>の設定についての情報は、あなたのアーキテクチャに適した[[HandBook:Main_Page/ja|Gentooハンドブック]]の５章を読んでみてください。また、GCCマニュアルの[http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options]のリストに、<code>-march</code>と<code>-mcpu</code>と<code>-mtune</code>の違いについてもっと詳しい説明があります。}}

=== -O ===

次は<code>-O</code>フラグについてです。これは全体の最適化レベルをコントロールしますが、特にこの最適化レベルを上げることによって、ソースコードのコンパイルの時間がいくらか増えたり、よりたくさんのメモリを使用するようになります。 

７つの<code>-O</code>設定があります。<code>-O0</code>、<code>-O1</code>、<code>-O2</code>、<code>-O3</code>、<code>-Os</code>、<code>-Og</code>、<code>-Ofast</code>です。{{Path|/etc/portage/make.conf}}で指定できるのはこのうちの一つだけです。

<code>-O0</code>を除いて、<code>-O</code>の設定はいずれもいくつかの追加フラグを有効にします。なので、どの<code>-O</code>レベルで、どのフラグが有効になり、そのフラグにどんな効果があるのかを学ぶために、GCCマニュアルの[http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimization options]
の章を読んで確認しましょう。 

では、それぞれの最適化レベルを見てみましょう。 

*  <code>-O0</code>: This level (that is the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in <var>CFLAGS</var> or <var>CXXFLAGS</var>. This reduces compilation time and can improve debugging info, but some applications will not work properly without optimization enabled. This option is not recommended except for debugging purposes.

*  <code>-O1</code>: これは最も基本的な最適化レベルです。コンパイラは時間をたくさんかけることなく、高速でサイズの小さなバイナリを生成しようと試みるでしょう。これは基本的な最適化しかおこないませんが、その代わり、いつでもうまくいくはずです。

*  <code>-O2</code>: <code>-O1</code>から更に踏み込みます。これは特別な理由がない限り"推奨される"最適化レベルです。<code>-O2</code>は<code>-O1</code>で有効になるものに加え、さらにいくつかのフラグを有効にします。<code>-O2</code>を使うと、コンパイラはサイズとコンパイル時間に妥協せずにコードのパフォーマンスを改善しようと試みます。

*  <code>-O3</code>: これは取りうる最も高い最適化レベルです。コンパイル時間とメモリ使用量を犠牲にして最適化を実施します。ただし<code>-O3</code>は性能を改善する保証がありません。実際多くのケースで、バイナリサイズが大きくなり、メモリ使用量が増えることで逆にシステムが遅くなります。<code>-O3</code>はいくつかのパッケージを壊すことがわかっています。これらの理由により<code>-O3</code>は推奨されません。

*  <code>-Os</code>: このレベルはバイナリのサイズを重視して最適化するでしょう。これは<code>-O2</code>フラグの中で、生成されるバイナリのサイズが増えないものを全て有効にします。CPUのキャッシュが小さかったり、ディスクの空き容量が極端に限られている場合などに非常に有効でしょう。

*  <code>-Og</code>: GCC 4.8では新しい汎用的な最適化レベル<code>-Og</code>が導入されました。このレベルはコンパイル時間の短縮とデバッグエクスペリエンスを向上させる一方、妥当なランタイム性能を確保することを目的としています。結果的に開発全体で得られるものはデフォルトの最適化レベル<code>-O0</code>より向上するはずです。<code>-Og</code>と<code>-g</code>は同じでないことだけ理解しておいてください。<code>-g</code>はデバッガとやりとりするために単純に最適化をオフにするだけです。

*  <code>-Ofast</code>: GCC 4.7では、<code>-O3</code>に加えて<code>-ffast-math</code>、<code>-fno-protect-parens</code>、<code>-fstack-arrays</code>が利用できます。このオプションは規格への厳密な適合を犠牲にするため推奨されません。

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and while not using <code>-O2</code>, try rebuilding with that option. As a fallback option, try setting the <var>CFLAGS</var> and <var>CXXFLAGS</var> to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).

=== -pipe ===

よく使うフラグに<code>-pipe</code>があります。このフラグは、生成されるバイナリ自体には何の影響もありませんが、コンパイル時間が短縮されます。これはコンパイルにおける各処理の間で一時ファイルを使う代わりにパイプを使うように指示します。これにより多くのメモリを使うことになります。メモリに余裕のないシステムの場合、GCCが強制終了するかもしれません。そのような場合はこのフラグを使わないでください。 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but it may need to be activated. In that case add it to the flags. Though the GCC manual does not specify all architectures, it is turned on by using the <code>-O</code> option. It's still necessary to explicitly enable the <code>-fomit-frame-pointer</code> option, to activate it on x86-32 with GCC up to version 4.6, or when using <code>-Os</code> on x86-32 with any version of GCC. However, using <code>-fomit-frame-pointer</code> will make debugging hard or impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. When not doing software debugging and no other debugging-related <var>CFLAGS</var> such as <code>-ggdb</code> have been used, then try using <code>-fomit-frame-pointer</code>. 

{{Important/ja|<code>-fomit-frame-pointer</code>とそれに似た<code>-momit-leaf-frame-pointer</code>フラグを組み合わせて'''使わないでください'''。後者のフラグを使うのはやめてください。<code>-fomit-frame-pointer</code>のみで十分です。そのうえ、<code>-momit-leaf-frame-pointer</code>はコードの性能に悪影響を及ぼすことがわかっています。}}

=== -msse、-msse2、-msse3、-mmmx、-m3dnow ===

これらのフラグは[https://ja.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extentions] (SSE)、[https://en.wikipedia.org/wiki/SSE2 SSE2]、[https://en.wikipedia.org/wiki/SSSE3 SSE3]、[https://ja.wikipedia.org/wiki/MMX MMX]、[https://ja.wikipedia.org/wiki/3DNow! 3DNow!]の命令セットをx86とx86-64アーキテクチャで有効にします。これらは主にマルチメディアやゲーム、その他の浮動小数点を多用する計算処理に向いています。その他にも有用な数学用機能の向上をいくつか含んでいます。比較的新しいCPUならば、これらの命令セットに対応しています。 

{{Important/ja|CPUがこれらをサポートしているかどうかは<kbd>cat /proc/cpuinfo</kbd>を実行して確認してください。サポートされている命令セットが表示されます。'''pni'''が実際はSSE3の別名であることに注意してください。}}

通常、正しい<code>-march</code>を使っている限り、これらのどのフラグも{{Path|/etc/portage/make.conf}}に加える必要はありません(例えば<code>-march=nocona</code>は<code>-msse3</code>を有効にします)。いくつかの注意すべき例外は、比較的新しいVIAとAMD64のCPUです。VIAとAMD64はこれらの命令をサポートしますが、(SSE3のように)<code>-march</code>では有効になりません。これらのCPUについては{{Path|/proc/cpuinfo}}の出力を確認して、ふさわしいフラグを追加する必要があるでしょう。 

{{Note/ja|x86とx86-64特有のフラグについて[http://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags]を確認しましょう。適切にCPUを指定することによって、どの命令セットが有効になるのか確認することができます。もし命令セットがリストの中にあったら、改めて指定する必要はありません。なぜならそれらは正しい<code>-march</code>を使えば有効になるでしょうから。}}

== 最適化FAQ ==

=== -funroll-loopsや-fomg-optimizeを使ったら速くなったんだけど！ ===

いいえ違います。フラグを付け加えれば付け加えるほど最適化されると言う誰かに騙されているだけです。システム全体で挑戦的なフラグを使うことはあなたのアプリケーションを傷つけるでしょう。GCC [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options マニュアル]では<code>-funroll-loops</code>と<code>-funroll-all-loops</code>を使うとバイナリは大きくなり、実行も遅くなると述べています。またいくつかの理由から、これらの二つのフラグと同時に、<code>-ffast-math</code>や<code>-fforce-mem</code>や<code>-fforce-addr</code>などの似たようなフラグが、速度を最大限誇示したい人たちの間で、とても人気を博しています。 

ここで本当に問題なのは、これらのフラグは危険なほどに挑戦的なフラグということです。それらのフラグが何をやらかしているのか[https://forums.gentoo.org/ Gentoo Forums]と[https://bugs.gentoo.org/ Bugzilla]あたりをよく見てください。ろくなことないですよ！ 

You do not need to use those flags globally in <var>CFLAGS</var> or <var>CXXFLAGS</var>. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat the code and get your bugs marked INVALID or WONTFIX. 

あなたはそのような危険なフラグを使う必要はありません。いえ、'''使わないでください。'''<code>-march</code>、<code>-O</code>、<code>-pipe</code>という基本を守り通してください。

=== 3より高い-Oレベルはどう？ ===

Some users boast about even better performance obtained by using <code>-O4</code>, <code>-O9</code>, and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept <var>CFLAGS</var> like <code>-O4</code>, but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code>, nothing more. 

さらに証拠が必要ですか？[https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup ソースコード]を試してみてください。 

{{CodeBox|title=-O ソースコード|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

見てのとおり、3より高いレベルであっても、結局<code>-O3</code>として扱われます。

=== 実際のマシンと別のマシンでコンパイルするのはどう？ ===

何人かの読者は、あきらかに劣ったCPUやGCCサブアーキテクチャでコンパイルすることを避けるために他のマシンでコンパイルすることは、（ネイティブな環境でのコンパイルと比較して）劣った最適化になるのか知りたくなるでしょう。答えは単純で'''いいえ'''です。コンパイルが走る実際のマシンに関係なく、またGCCをビルドしたときのCHOSTに関係なく、同じ引数が使用されている限り<small>(<code>-march=native</code>は除く)</small>、そしてGCCのバージョンが同じである限り<small>(マイナーバージョンが違うかもしれません)</small>、最適化の結果は厳密に同じです。

例を一つあげます。GCCのCHOSTが''i686-pc-linux-gnu''となっているマシンにGentooをインストールして、CHOSTが''i486-linux-gnu''となっている別のPCに[[Distcc]]サーバーをインストールします。リモートサーバーのコンパイラのサブアーキテクチャもしくはハードウェアが明らかに劣っている場合、最適化が十分なされないのではと心配する必要はありません。結果は、両方のコンパイラに同じ引数が与えられている限り（かつ<code>-march</code>に<code>native</code>が与えられていない限り）、ネイティブにビルドしたときと同じ最適化がかかります。ただしこの特殊なケースでは[[Distcc#-march.3Dnative|Distcc and -march=native]]で説明されている通り、ターゲットのアーキテクチャが明示的に指定されなければなりません。

異なるサブアーキテクチャに向けてビルドされた２つのGCCの動作には一つしか違いがありません。それは暗に与えられるデフォルトの<code>-march</code>です。コマンドラインで<code>-march</code>を明示的に指定しなかった場合、GCCのCHOSTに設定された値が使用されます。

=== 冗長なフラグ指定はどう？ ===

Oftentimes <var>CFLAGS</var> and <var>CXXFLAGS</var> that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}}. Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all <var>CFLAGS</var> and <var>CXXFLAGS</var>, or it may replace <code>-O</code> with a different level. 

[http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual]にフラグの除去と置換がどのような場合に、どのように使われているのか概要が記載されています。 

特定のレベルに対して重複してフラグを設定することによって、<code>-O</code>に対するフラグ除去をある程度回避することができます。例えば、<code>-O3</code>であれば次のようにします。 

{{CodeBox|title=重複してCFLAGSを設定|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

However, '''this is not a smart thing to do'''. <var>CFLAGS</var> are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers''. Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

開発者が許可していないフラグでパッケージをビルドすれば、大概は数々の問題に陥り続けることでしょう。Bugzillaに不具合を報告する際には、{{Path|/etc/portage/make.conf}}で使っているフラグは容易く見抜かれてしまうので、余計なフラグを除いて再コンパイルする様に開発者に指示されるでしょう。初めから冗長なフラグを指定しないことで、再コンパイルする手間を省いてください！ あなたが開発者よりよく知っていると根拠なく無意識に決めつけないでください。

=== LDFLAGSはどう？ ===

The Gentoo developers have already set basic, safe <var>LDFLAGS</var> in the base profiles, so they do not need to be changed.

=== パッケージごとにフラグを変更出来るの？ ===

{{Warning/ja|パッケージごとにフラグを変更するとデバッグやサポートが込み入ってきます。もしこの機能を使っている場合には、どのような変更をしたのか、バグレポートで言及してください。}}

Information on how to use per-package environment variables (including <var>CFLAGS</var>) is described in the [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]].

== 資料 ==

以下、最適化について理解を深めるための資料を紹介します。 

* [http://gcc.gnu.org/onlinedocs/ GCC online documentation] 

* Gentoo Handbook - [[Handbook:AMD64/Installation/Stage#Configuring_compile_options|Configuring compile options]]

* <kbd>man make.conf</kbd>

* [https://ja.wikipedia.org/wiki/ ウィキペディア]

* [https://forums.gentoo.org/ Gentooフォーラム]

{{Migrated|originalauthors=nightmorph}}
