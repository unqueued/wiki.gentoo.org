<languages />

{{Metadata|abstract=このガイドは、安全で分別のあるCFLAGSとCXXFLAGSを使ったコンパイル済みコードの最適化の導入を提供します。また、一般的な最適化の裏側にある理論について述べます。}}

このガイドは、安全で分別のあるCFLAGSとCXXFLAGSを使ったコンパイル済みコードの最適化の導入を提供します。また、一般的な最適化の裏側にある理論について述べます。

== はじめに ==

=== CFLAGSとCXXFLAGSとは？ ===

CFLAGSとCXXFLAGSは、ソースコードをコンパイルするときに使われるオプションをGNUコンパイラコレクションであるgccに伝えるために使われる環境変数です。CFLAGSはCで書かれたソースコード、CXXFLAGSはC++で書かれたソースコード用になります。 

これらはプログラムのデバッグメッセージの量を減らすのに使われたり、エラーや警告のレベルを増加させたり、また、もちろん生成されるコードの最適化にも使われたりします。[http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC manual]に利用可能なフラグとその働きの完全なリストが記載されています。

=== どのように使われているのでしょうか？ ===

CFLAGSとCXXFLAGSは二通り使われ方があります。一つ目は、プログラム毎にautomakeにより生成されたMakefileと共に使う方法です。 

しかしながら、この方法はPortageツリーの中にあるパッケージをインストールする際に使うべきではありません。その代わりに、Gentooベースのシステムでは{{Path|/etc/portage/make.conf}}の<code>CFLAGS</code>と<code>CXXFLAGS</code>を設定します。この方法を使えば、全てのパッケージはあなたが{{Path|make.conf}}に設定したフラグでコンパイルされるでしょう。

{{CodeBox|title=/etc/portage/make.confのCFLAGS設定|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important/ja|'''USE'''フラグは複数の行で構成できますが、<code>CFLAGS</code>を複数の行で構成すると<tt>cmake</tt>のようなプログラムで問題が発生します。問題を避けるために、CFLAGSの宣言は極力スペースで区切られた単一行で構成するようにしてください。{{Bug|500034}}が参考になります。}}

見てわかるとおり、CXXFLAGSはCFLAGSの中にある全てのフラグが設定されています。大部分のシステムはこのように設定されるべきです。通常のユースケースでは、<code>CXXFLAGS</code>だけに追加のオプションを指定するようなことはほとんどありません。

=== よくある誤解 ===

CFLAGSとCXXFLAGSは、ソースコードから小さくて早いバイナリを得るにはとても効果的な方法である一方で、ソースコード中の機能を損なったり、バイナリのサイズが膨れ上がったり、実行速度を低下させたり、コンパイルの失敗さえも引き起こす場合もあります！ 

CFLAGSは特効薬ではありません。これらは自動的にあなたのシステムを早くしたり、ディスク上のスペースが少なくなるようバイナリを縮めてはくれないでしょう。たくさんのフラグを、システムを最適化する目的で追加することは、確実に失敗します。払った労力に見合う実入りを得るにも限度と言うものがあります。 

インターネットでは挑戦的なCFLAGSやCXXFLAGSの自慢も見受けられますが、それらはいい影響を与えるよりも、コンパイルされたバイナリに悪影響を及ぼす可能性の方がはるかに高いです。そもそもフラグは特定の場所、特定の目的のために設計されていることを忘れてはいけません。グローバルに適用することを目的としたフラグはほとんどありません。

=== 準備はできましたか？ ===

リスクが伴うことを理解したところで、良識的、かつ安全な最適化の方法を見ていきましょう。そうすれば、この先、[https://bugs.gentoo.org/ Bugzilla]で開発者に歓迎される役立つ報告をすることができます。（開発者は、大抵、問題が再現するか確かめるために、最小限のCFLAGSでパッケージを再コンパイルすることを要求します。挑戦的なフラグはコードを破壊しうることを覚えておいてください!） 

== 最適化について ==

=== 基本 ===

CFLAGSとCXXGLAGSの使用目的は、あなたのシステム向けにあつらえた、可能な限り早くて小さな、かつ完全に動作するコードを生成することです。時には、これらの条件は相互に排他的ですので、うまく動作すると分かっている組み合わせをここでは使うことにします。原則的には、お手持ちのCPUアーキテクチャ向けに利用可能な良い最適化が用意されています。参考情報として、さらにアグレッシブなフラグを後述します。このガイドではGCCのマニュアルに記載されているすべてのオプションを議論する訳ではありません。基本的な、そしてもっとも標準的なオプションについて解説します。 

{{Note/ja|フラグがどういう働きをするのか不明なときは、[http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual]の関連する章を参照してください。もしそれでもわからない場合は、ウェブ検索をするか、[http://gcc.gnu.org/lists.html GCC mailing lists]をチェックしましょう}}

=== -march ===

最初の、そしてもっとも重要なオプションは<code>-march</code>です。このオプションはコンパイラに対してどのシステム[https://en.wikipedia.org/wiki/Microarchitecture プロセッサアーキテクチャ] (もしくは"arch")のためのコードを生成するのかを指示します。つまり、特定のCPU向けのコードを生成すべきであるといっているのです。CPUが違えば、性能が異なり、異なる命令セットをサポートし、コードの実行方法も違います。<code>-march</code>フラグは、あなたのCPUの全ての性能、特徴、命令セット、癖などに合わせて特化したコードを生成するようにコンパイラに伝えます。 

たとえ{{Path|/etc/portage/make.conf}}に書いてある<code>CHOST</code>変数を一般的なアーキテクチャに設定していても、<code>-march</code>を設定すれば、プログラムは指定したプロセッサ向けに最適化されるでしょう。x86とx86-64のCPUは(とりわけ)<code>-march</code>フラグを使うべきです。 

どんな種類のCPUを使っていますか？以下のコマンドを実行すれば、それが分かります。 

{{Cmd|cat /proc/cpuinfo}}

さらに<code>march</code>と<code>mtune</code>の値を含む詳細な情報を得たい場合は、以下を実行してください。

{{Cmd|<nowiki>gcc -c -Q -march=native --help=target</nowiki>}}

では実際に<code>-march</code>を見てみましょう。この例は古いPentium IIIチップ向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium IIIの例|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

こちらはAMD64向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64の例|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

CPUのタイプが決められない場合、またはどの設定を使えばいいかわからない場合、<code>-march=native</code>を使うことができます。このフラグを使った場合、GCCはプロセッサを判別して、自動的にふさわしいフラグを設定するでしょう。'''しかしながら、このフラグは異なるCPU向けにパッケージをコンパイルする目的では使用すべきではありません！''' 

{{Warning/ja|<tt>[[Distcc#-march.3Dnative|distcc]]</tt>を使ってコンパイルする場合、{{Path|make.conf}}の<code>CFLAGS</code>もしくは<code>CXXFLAGS</code>に<code>-march{{=}}native</code>や<code>-mtune{{=}}native</code>を使用しては'''いけません'''。}}

例えば、あるコンピュータでパッケージをコンパイルして、しかしそれらを別のコンピュータで実行しようとしている場合 (処理の早いコンピュータで、古くて遅いマシンのためにビルドしているときなど)、<code>-march=native</code>を'''使わない'''でください。"native"というのはコンパイルしているマシンのCPUタイプ'''のみ'''に特化して、アプリケーションのコードを生成することを意味しています。AMD Athlon 64上で<code>-march=native</code>と共にビルドされたアプリケーションは、古いVIA C3では実行することができないでしょう。 

また、<code>-mtune</code>と<code>-mcpu</code>フラグも利用可能です。これらのフラグはたいてい<code>-march</code>フラグが利用できない場合にのみ使われます。例えば特定のプロセッサアーキテクチャは<code>-mtune</code>や<code>-mcpu</code>が必要になるかもしれません。残念ながら、GCCの挙動はそれぞれのフラグの振る舞いが、あるアーキテクチャから近いアーキテクチャであってもあまり一貫性はありません。 

x86とx86-64のCPUにおいて、<code>-march</code>は利用可能な命令セットと正しいABIを使い、そのCPUに特化したコードを生成するでしょう。そのため古かったり種類の異なるCPUとの後方互換性は持っていません。i386やi486のような古いCPU向けにコードを生成する必要があるときのみ、<code>-mtune</code>の使用を考慮するべきでしょう。<code>-mtune</code>は<code>-march</code>よりも一般的なコードを生成します。特定のCPUコードにチューニングしますが、利用可能な命令セットやABIを考慮しないのです。<code>-mcpu</code>はx86やx86-64のシステム上では非推奨となっているので、使わないでください。 

x86/x86-64でない(SparcやAlpha、PowerPCのような)CPUでのみ、<code>-march</code>の代わりに<code>-mtune</code>や<code>-mcpu</code>が必要になるでしょう。これらのアーキテクチャ上では、<code>-mtune</code>/<code>-mcpu</code>は(x86/x86-64上での)<code>-march</code>と同じように振る舞うでしょう･･･しかしフラグの名前は違うのです。繰り返しますが、GCCの振る舞いとフラグ名はアーキテクチャを超えて一貫していないので、システムでどのフラグを使うべきなのかをGCCの[http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options マニュアル]で必ず確認してください。 

{{Note/ja|更なる<code>-march</code>/<code>-mtune</code>/<code>-mcpu</code>の設定についての情報は、あなたのアーキテクチャに適した[[HandBook:Main_Page/ja|Gentooハンドブック]]の５章を読んでみてください。また、GCCマニュアルの[http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options]のリストに、<code>-march</code>と<code>-mcpu</code>と<code>-mtune</code>の違いについてもっと詳しい説明が書いてあります。}}

=== -O ===

次は<code>-O</code>フラグについてです。これは全体の最適化レベルをコントロールしますが、特にこの最適化レベルを上げることによって、ソースコードのコンパイルの時間がいくらか増えたり、よりたくさんのメモリを使用するようになります。 

７つの<code>-O</code>設定があります。<code>-O0</code>、<code>-O1</code>、<code>-O2</code>、<code>-O3</code>、<code>-Os</code>、<code>-Og</code>、<code>-Ofast</code>です。{{Path|/etc/portage/make.conf}}で指定できるのはこのうちの一つだけです。

<code>-O0</code>を除いて、<code>-O</code>の設定はいずれもいくつかの追加フラグを有効にします。なので、どの<code>-O</code>レベルで、どのフラグが有効になり、そのフラグにどんな効果があるのかを学ぶために、GCCマニュアルの[http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimization options]
の章を読んで確認しましょう。 

私たちはそれぞれの最適化レベルを調べてみましょう: 

*  <code>-O0</code>: このレベル("O"のあとにゼロが続いてます)は、完全に最適化をオフにします。<code>CFLAGS</code>や<code>CXXFLAGS</code>の中に<code>-O</code>が定義されていない場合のデフォルトです。このレベルはコンパイル時間を短縮して、生成するデバッグ情報を改善しますが、いくつかのアプリケーションは最適化がないと正しく動作しません。よって、デバッグ以外では推奨されません。

*  <code>-O1</code>: これは最も基本的な最適化レベルです。コンパイラはコンパイル時間をたくさんかけることなく、高速でサイズの小さなバイナリを生成しようと試みるでしょう。これは基本的な最適化しかおこないませんが、その代わり、いつでもうまくいくはずです。

<code>-O2</code>: <code>-O1</code>から更に踏み込みます。これは特別な理由がない限り"推奨される"最適化レベルです。<code>-O2</code>は<code>-O1</code>により有効になるものに加え、さらにいくつかのフラグを有効にします。<code>-O2</code>を使うと、コンパイラは、サイズが大きくなったり、たくさんの時間がかかったりしないように、コードのパフォーマンスを増加させようと試みます。

<code>-O3</code>: これは取りうる最高の最適化レベルです。コンパイル時間とメモリ使用量を犠牲にして最適化を実施します。<code>-O3</code>は性能を改善する保証がありません。実際多くのケースで、バイナリサイズが大きくなり、メモリ使用量が増えることでシステムが遅くなります。<code>-O3</code>はいくつかのパッケージを壊すことがわかっています。これらの理由により<code>-O3</code>は推奨されません。

<code>-Os</code>: このレベルはバイナリのサイズを重視して最適化するでしょう。これは<c>-O2</c>フラグの中で、生成されるバイナリのサイズが増えないものを全て有効にします。CPUのキャッシュが小さかったり、ディスクストレージスペースが極端に限られている場合などに非常に有効でしょう。

*  <code>-Og</code>: In GCC 4.8, a new general optimization level, <code>-Og</code>, has been introduced. It addresses the need for fast compilation and a superior debugging experience while providing a reasonable level of runtime performance. Overall experience for development should be better than the default optimization level <code>-O0</code>.  Note that <code>-Og</code> does not imply <code>-g</code>, it simply disables optimizations that may interfere with debugging.

*  <code>-Ofast</code>: New in GCC 4.7, consists of <code>-O3</code> plus <code>-ffast-math</code>, <code>-fno-protect-parens</code>, and <code>-fstack-arrays</code>. This option breaks strict standards compliance, and is not recommended for use.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and while not using <code>-O2</code>, try rebuilding with that option. As a fallback option, try setting the <code>CFLAGS</code> and <code>CXXFLAGS</code> to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).

=== -pipe ===

A common flag is <code>-pipe</code>. This flag has no effect on the generated code, but it makes the compilation process ''faster''. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, GCC might get killed. In those cases do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but it may need to activated. In that case add it to the flags. Though the GCC manual does not specify all architectures, it is turned on by using the <code>-O</code> option. Use the <code>-O</code> option to explicitly activate it on x86, with GCC up to version 4.6 or when using <code>-Os</code>. However, using this flag will make debugging hard or impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. When not doing software debugging and no other debugging-related CFLAGS such as <code>-ggdb</code> have been used, then try using <code>-fomit-frame-pointer</code>. 

{{Important|Do ''not'' combine <code>-fomit-frame-pointer</code> with the similar flag <code>-momit-leaf-frame-pointer</code>. Using the latter flag is discouraged, as <code>-fomit-frame-pointer</code> already does the job properly. Furthermore, <code>-momit-leaf-frame-pointer</code> has been shown to negatively impact code performance.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extentions] (SSE), [http://en.wikipedia.org/wiki/SSE2 SSE2], [http://en.wikipedia.org/wiki/SSSE3 SSE3], [http://en.wikipedia.org/wiki/MMX_(instruction_set) MMX], and [http://en.wikipedia.org/wiki/3dnow 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to see if the CPU supports these instruction sets by running <kbd>cat /proc/cpuinfo</kbd>. The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

Normally none of these flags need to be added to {{Path|/etc/portage/make.conf}}, as long as the system is using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code>). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these additional flags will need to be enabled where appropriate after checking {{Path|/proc/cpuinfo}}. 

{{Note|Check the [http://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags] to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then it does not need to be separately specified; it will be turned on by using the proper <code>-march</code> setting.}}

== Optimization FAQs ==

=== But I get better performance with -funroll-loops -fomg-optimize! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt applications when used system-wide. Even the GCC [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> will make code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

The truth of the matter is that they are dangerously aggressive flags. Take a good look around the [https://forums.gentoo.org/ Gentoo Forums] and [https://bugs.gentoo.org/ Bugzilla] to see what those flags do: nothing good! 

You do not need to use those flags globally in <code>CFLAGS</code> or <code>CXXFLAGS</code>. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat the code and get your bugs marked INVALID or WONTFIX. 

You don't need dangerous flags like these. '''Don't use them'''. Stick to the basics: <code>-march</code>, <code>-O</code>, and <code>-pipe</code>.

=== What about -O levels higher than 3? ===

Some users boast about even better performance obtained by using <code>-O4</code>, <code>-O9</code>, and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept CFLAGS like <code>-O4</code>, but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code>, nothing more. 

Need more proof? Examine the [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup source code]: 

{{CodeBox|title=-O source code|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

As you can see, any value higher than 3 is treated as just <code>-O3</code>.

=== What about compiling outside the target machine? ===

Some readers might wonder if compiling outside the target machine with a strictly inferior CPU or GCC sub-architecture will result in inferior optimization results (compared to a native compilation). The answer is simple: '''No'''.  Regardless of the actual hardware on which the compilation takes place and the CHOST for which GCC was built, as long as the same arguments are used <small>(except for <code>-march=native</code>)</small> and the same version of GCC is used <small>(although minor version might be different)</small>, the resulting optimizations are strictly the same.

To exemplify, if Gentoo is installed on a machine whose GCC's CHOST is ''i686-pc-linux-gnu'', and a [[Distcc]] server is setup on another computer whose GCC's CHOST is ''i486-linux-gnu'', then there is no need to be afraid that the results would be less optimal because of the strictly inferior sub-architecture of the remote compiler and/or hardware. The result would be as optimized as a native build, as long as the same options are passed to both compilers (and the <code>-march</code> parameter doesn't get a <code>native</code> argument).  In this particular case the target architecture needs to be specified explicitly as explained in [[Distcc#-march.3Dnative|Distcc and -march=native]].

The only difference in behavior between two GCC versions built targeting different sub-architectures is the implicit default argument for the <code>-march</code> parameter, which is derived from the GCC's CHOST when not explicitly provided in the command line.

=== What about redundant flags? ===

Oftentimes CFLAGS and CXXFLAGS that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}}. Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all CFLAGS and CXXFLAGS, or it may replace <code>-O</code> with a different level. 

The [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] outlines where and how flag filtering/replacing works. 

It's possible to circumvent <code>-O</code> filtering by redundantly listing the flags for a certain level, such as <code>-O3</code>, by doing things like: 

{{CodeBox|title=Specifying redundant CFLAGS|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

However, '''this is not a smart thing to do'''. CFLAGS are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers''. Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

You will most likely continue to run into problems when you build a package with unacceptable flags. When you report your troubles on Bugzilla, the flags you use in {{Path|/etc/portage/make.conf}} will be readily visible and you will be told to recompile without those flags. Save yourself the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume that you know better than the developers.

=== What about LDFLAGS? ===

The Gentoo developers have already set basic, safe LDFLAGS in the base profiles, so they do not need to be changed.

=== Can I use per-package flags? ===

{{Warning|Using per-package flags complicates debugging and support. Make sure you mention in your bug reports if you make use of this feature and what the changes are you made.}}

Information on how to use per-package environment variables (including CFLAGS) is described in the [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]].

== Resources ==

The following resources are of some help in further understanding optimization: 

* [http://gcc.gnu.org/onlinedocs/ GCC online documentation] 

* [[Handbook:Main_Page|Gentoo インストールハンドブック]]の第5章

* <kbd>man make.conf</kbd>

* [https://en.wikipedia.org/ Wikipedia]

* [https://forums.gentoo.org/ Gentoo Forums]

{{Migrated|originalauthors=nightmorph}}
