<languages />

{{Metadata|abstract=This guide provides an introduction to optimizing compiled code using safe, sane CFLAGS and CXXFLAGS. It also describes the theory behind optimization in general.}}

This guide provides [[Article description::an introduction to optimizing compiled code using safe, sane <var>CFLAGS</var> and <var>CXXFLAGS</var>.]] It also as describes the theory behind optimizing in general.

== はじめに ==

=== CFLAGSとCXXFLAGSとは？ ===

<var>CFLAGS</var> and <var>CXXFLAGS</var> are among the environment variables conventionally used to specify compiler options to a build system when compiling C and C++ code. While these variables are not standardized, their use is essentially ubiquitous and any correctly written build should understand these for passing extra or custom options when it invokes the compiler. See the [https://www.gnu.org/software/make/manual/make.html#Implicit-Variables GNU make] info page for a list of some of the commonly used variables in this category.

Because such a large proportion of the packages that make up most Gentoo systems are written in C and C++, these are two variables administrators will definitely want to set correctly as they will greatly influence the way much of the system is built.

これらはプログラムのデバッグメッセージの量を減らすために使われたり、エラーや警告のレベルを増加させたり、また、もちろん生成されるコードの最適化にも使われます。[https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC manual]に利用可能なフラグとその効果の完全なリストが記載されています。

=== どのように使われているのでしょうか？ ===

Normally, <var>CFLAGS</var> and <var>CXXFLAGS</var> would be set in the environment when invoking a configure script or with makefiles generated by the {{c|automake}} program. In Gentoo-based systems, set the <var>CFLAGS</var> and <var>CXXFLAGS</var> variables in {{Path|/etc/portage/make.conf}}. Variables set in this file will be exported to the environment of programs invoked by portage such that all packages will be compiled using these options as a base.

{{CodeBox|title=/etc/portage/make.confのCFLAGS設定|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important/ja|'''USE'''フラグは複数の行で構成できますが、<var>CFLAGS</var>を複数の行で構成すると{{c|cmake}}のようなプログラムで問題が発生します。問題を避けるために、<var>CFLAGS</var>の宣言は極力スペースで区切られた単一行で構成するようにしてください。{{Bug|500034}}が参考になります。}}

As seen in the example above the <var>CXXFLAGS</var> variable is set to use all the options present in <var>CFLAGS</var>. Almost every system should be configured in this manner. Additional options for <var>CXXFLAGS</var> are less common and don't usually apply generally enough to deserve setting them globally.

{{Tip|[[Safe_CFLAGS|Safe CFLAGS]] article might help beginners start optimizing their systems.}}

=== よくある誤解 ===

While compiler optimizations enabled by various <var>CFLAGS</var> can be an effective means of producing smaller and/or faster binaries, they can also impair the function of the code, bloat its size, slow down its execution time, or simply cause a build failure. The point of diminishing performance returns is reached rather quickly when dealing with <var>CFLAGS</var>. Don't set them arbitrarily.

Remember, the global <var>CFLAGS</var> configured in {{Path|/etc/portage/make.conf}} will be applied to every package on the system so administrators typically only set general, widely-applicable options. Individual packages further modify these options either in the ebuild or the build system itself to generate the final set of flags used when invoking the compiler.

=== 準備はできましたか？ ===

リスクを伴うことを理解したところで、良識的、かつ安全な最適化の方法を見ていきましょう。そうすれば、この先[https://bugs.gentoo.org/ Bugzilla]で開発者に歓迎され、役立つ報告をすることができます。（開発者は、大抵、問題が再現するか確かめるために、最小限の<var>CFLAGS</var>でパッケージを再コンパイルすることを要求します。挑戦的なフラグはコードを破壊しうることを覚えておいてください!） 

== 最適化について ==

=== 基本 ===

The goal behind <var>CFLAGS</var> and <var>CXXFLAGS</var> is to create code tailor-made to the system; it should function perfectly while being lean and fast, if possible. Sometimes these conditions are mutually exclusive, so this guide will stick to combinations known to work well. Ideally, they are the best available for any CPU architecture. For informational purposes, aggressive flag use will be covered later. Not every option listed on the GCC manual (there are hundreds) will be discussed, but basic, most common flags will be reviewed. 

{{Note/ja|フラグがどういう働きをするのか不明なときは、[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual]の関連する章を参照してください。もしそれでもわからない場合は、ウェブ検索をするか、[https://gcc.gnu.org/lists.html GCC mailing lists]をチェックしましょう}}

=== -march ===

The first and most important option is <code>-march</code>. This tells the compiler what code it should produce for the system's [https://en.wikipedia.org/wiki/Microarchitecture processor architecture] (or ''arch''); it tells GCC that it should produce code for a certain kind of CPU. Different CPUs have different capabilities, support different instruction sets, and have different ways of executing code. The <code>-march</code> flag will instruct the compiler to produce specific code for the system's CPU, with all its capabilities, features, instruction sets, quirks, and so on provided the source code is prepared to use them. For instance, to take benefit from AVX instructions, the source code needs to be adapted to support it.

<code>-march=</code> is an ISA selection option; it tells the compiler that it may use the instructions from the ISA. On an Intel/AMD64 platform with <code>-march=native -O2</code> or lower OPT level, the code will likely end up with AVX instructions used but using shorter SSE XMM registers. To take full advantage of AVX YMM registers, the <code>-ftree-vectorize</code>, <code>-O3</code> or <code>-Ofast</code> options should be used as well<ref>GNU GCC Bugzilla, [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57952#c8 AVX/AVX2 no ymm registers used in a trivial reduction]. Retrieved on 2017/07/18.</ref>.

<code>-ftree-vectorize</code> is an optimization option (default at <code>-O3</code> and <code>-Ofast</code>), which attempts to vectorize loops using the selected ISA if possible.  The reason it isn't enabled at <code>-O2</code> is that it doesn't always improve code, it can make code slower as well, and usually makes the code larger; it really depends on the loop etc. 

Even though the <var>CHOST</var> variable in {{Path|/etc/portage/make.conf}} specifies the general architecture used, <code>-march</code> should still be used so that programs can be optimized for the system specific processor. x86 and x86-64 CPUs (among others) should make use of the <code>-march</code> flag. 

どんな種類のCPUを使っていますか？以下のコマンドを実行すれば、それが分かります。 

{{Cmd|cat /proc/cpuinfo}}

or even install {{Package|app-portage/cpuid2cpuflags}} and add the available CPU-specific options to the {{Path|make.conf}} file, which the tool does through e.g. the [[CPU FLAGS X86|CPU_FLAGS_X86]] variable:

{{RootCmd|cpuinfo2cpuflags-x86|output=<pre>
CPU_FLAGS_X86: aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3</pre>}}

{{RootCmd|echo "CPU_FLAGS_X86{{=}}'aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3'" >> /etc/portage/make.conf}}

さらに<code>march</code>と<code>mtune</code>の値を含む詳細な情報を得たい場合は、以下の2つのコマンドが使えます。

* 最初のコマンドはコンパイラにリンクを行わないようにさせ(<code>-c</code>)、また、<code>--help</code>をコマンドラインオプションを明らかにせよとではなく、あるオプションが有効か無効かを示せという意味に解釈させます(<code>-Q</code>)。ここでは、選択されたターゲットで有効なオプションが出力されます:
:{{Cmd|gcc -c -Q -march{{=}}native --help{{=}}target}}

* The second command will show the compiler directives for building the header file, but without actually performing the steps and instead showing them on the screen (<code>-###</code>). The final output line is the command that holds all the optimization options and architecture selection:
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

では実際に<code>-march</code>を見てみましょう。この例は古いPentium IIIチップ向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium IIIの例|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

こちらはAMD64向けです。 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64の例|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

CPUのタイプが決められない場合、またはどの設定を使えばいいかわからない場合、<code>-march=native</code>を使うことができます。このフラグを使った場合、GCCはプロセッサを判別して、自動的にふさわしいフラグを設定するでしょう。'''しかしながら、このフラグは異なるCPU向けにパッケージをコンパイルする目的では使用すべきではありません！''' 

{{Warning/ja|{{c|[[Distcc#-march.3Dnative|distcc]]}}を使ってコンパイルする場合、{{Path|make.conf}}の<var>CFLAGS</var>もしくは<var>CXXFLAGS</var>に<code>-march{{=}}native</code>や<code>-mtune{{=}}native</code>を使用しては'''いけません'''。}}

If compiling packages on one computer in order to run them on a different computer (such as when using a fast computer to build for an older, slower machine), then ''do not'' use <code>-march=native</code>. "Native" means that the code produced will run ''only'' on that type of CPU. The applications built with <code>-march=native</code> on an AMD Athlon 64 CPU will '''not''' be able to run on an old VIA C3 CPU. 

また、<code>-mtune</code>と<code>-mcpu</code>フラグも利用可能です。これらのフラグはたいてい<code>-march</code>フラグが利用できない場合にのみ使われます。例えば特定のプロセッサアーキテクチャは<code>-mtune</code>や<code>-mcpu</code>が必要になるかもしれません。残念ながら、GCCの挙動はそれぞれのフラグの振る舞いが、あるアーキテクチャから近いアーキテクチャであってもあまり一貫性はありません。 

x86とx86-64のCPUにおいて、<code>-march</code>は利用可能な命令セットと正しいABIを使い、そのCPUに特化したコードを生成するでしょう。そのため古かったり種類の異なるCPUとの後方互換性は持っていません。i386やi486のような古いCPU向けにコードを生成する必要があるときのみ、<code>-mtune</code>の使用を考慮するべきでしょう。<code>-mtune</code>は<code>-march</code>よりも一般的なコードを生成します。特定のCPUコードにチューニングしますが、利用可能な命令セットやABIを考慮しないのです。<code>-mcpu</code>はx86やx86-64のシステム上では非推奨となっているので、使わないでください。 

Only non-x86/x86-64 CPUs (such as SPARC, Alpha, and PowerPC) may require <code>-mtune</code> or <code>-mcpu</code> instead of <code>-march</code>. On these architectures, <code>-mtune</code> / <code>-mcpu</code> will sometimes behave just like <code>-march</code> (on x86/x86-64) but with a different flag name. Again, GCC's behavior and flag naming is not consistent across architectures, so be sure to check the GCC [https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] to determine which one should be used. 

{{Note/ja|更なる<code>-march</code>/<code>-mtune</code>/<code>-mcpu</code>の設定についての情報は、あなたのアーキテクチャに適した[[HandBook:Main_Page/ja|Gentooハンドブック]]の５章を読んでみてください。また、GCCマニュアルの[https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options]のリストに、<code>-march</code>と<code>-mcpu</code>と<code>-mtune</code>の違いについてもっと詳しい説明があります。}}

=== -O ===

次は<code>-O</code>フラグについてです。これは全体の最適化レベルをコントロールしますが、特にこの最適化レベルを上げることによって、ソースコードのコンパイルの時間がいくらか増えたり、よりたくさんのメモリを使用するようになります。 

There are seven <code>-O</code> settings: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code>, and <code>-Ofast</code>. Only use one of them in {{Path|/etc/portage/make.conf}}.

<code>-O0</code>を除いて、<code>-O</code>の設定はいずれもいくつかの追加フラグを有効にします。なので、どの<code>-O</code>レベルで、どのフラグが有効になり、そのフラグにどんな効果があるのかを学ぶために、GCCマニュアルの[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimization options]
の章を読んで確認しましょう。 

では、それぞれの最適化レベルを見てみましょう。 

*  <code>-O0</code>: このレベル("O"のあとにゼロが続いてます)は、完全に最適化をオフにします。<var>CFLAGS</var>や<var>CXXFLAGS</var>の中に<code>-O</code>が定義されていない場合のデフォルトです。このレベルはコンパイル時間を短縮して、生成するデバッグ情報を改善しますが、いくつかのアプリケーションは最適化がないと正しく動作しません。よって、デバッグ以外では推奨されません。

*  <code>-O1</code>: これは最も基本的な最適化レベルです。コンパイラは時間をたくさんかけることなく、高速でサイズの小さなバイナリを生成しようと試みるでしょう。これは基本的な最適化しかおこないませんが、その代わり、いつでもうまくいくはずです。

*  <code>-O2</code>: A step up from <code>-O1</code>. The ''recommended'' level of optimization unless the system has special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code>. With <code>-O2</code>, the compiler will attempt to increase code performance without compromising on size, and without taking too much compilation time. SSE or AVX may be be utilized at this level but no YMM registers will be used unless <code>-ftree-vectorize</code> is also enabled.

*  <code>-O3</code>: the highest level of optimization possible. It enables optimizations that are expensive in terms of compile time and memory usage.  Compiling with <code>-O3</code> is not a guaranteed way to improve performance, and in fact, in many cases, can slow down a system due to larger binaries and increased memory usage. <code>-O3</code> is also known to break several packages. Using <code>-O3</code> is not recommended. However, it also enables <code>-ftree-vectorize</code> so that loops in the code get vectorized and will use AVX YMM registers.

*  <code>-Os</code>: このレベルはバイナリのサイズを重視して最適化するでしょう。これは<code>-O2</code>フラグの中で、生成されるバイナリのサイズが増えないものを全て有効にします。CPUのキャッシュが小さかったり、ディスクの空き容量が極端に限られている場合などに非常に有効でしょう。

*  <code>-Og</code>: GCC 4.8では新しい汎用的な最適化レベル<code>-Og</code>が導入されました。このレベルはコンパイル時間の短縮とデバッグエクスペリエンスを向上させる一方、妥当なランタイム性能を確保することを目的としています。結果的に開発全体で得られるものはデフォルトの最適化レベル<code>-O0</code>より向上するはずです。<code>-Og</code>と<code>-g</code>は同じでないことだけ理解しておいてください。<code>-g</code>はデバッガとやりとりするために単純に最適化をオフにするだけです。

*  <code>-Ofast</code>: GCC 4.7では、<code>-O3</code>に加えて<code>-ffast-math</code>、<code>-fno-protect-parens</code>、<code>-fstack-arrays</code>が利用できます。このオプションは規格への厳密な適合を犠牲にするため推奨されません。

前述の通り、<code>-O2</code>が推奨される最適化レベルです。もし<code>-O2</code>以外を使用してパッケージのコンパイルが失敗する場合は、<code>-O2</code>で再コンパイルしてみましょう。うまくいかなかった場合は、<var>CFLAGS</var>と<var>CXXFLAGS</var>を(エラー報告や問題の調査向けに)<code>-O1</code>や<code>-O0 -g2 -ggdb</code>のように、最適化レベルを低く設定してみてください。

=== -pipe ===

よく使うフラグに<code>-pipe</code>があります。このフラグは、生成されるバイナリ自体には何の影響もありませんが、コンパイル時間が短縮されます。これはコンパイルにおける各処理の間で一時ファイルを使う代わりにパイプを使うように指示します。これにより多くのメモリを使うことになります。メモリに余裕のないシステムの場合、GCCが強制終了するかもしれません。そのような場合はこのフラグを使わないでください。 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but it may need to be activated. In that case add it to the flags. Though the GCC manual does not specify all architectures, it is turned on by using the <code>-O</code> option. It's still necessary to explicitly enable the <code>-fomit-frame-pointer</code> option, to activate it on x86-32 with GCC up to version 4.6, or when using <code>-Os</code> on x86-32 with any version of GCC. However, using <code>-fomit-frame-pointer</code> will make debugging hard or impossible. 

特に、Javaで書かれたアプリケーションの問題解決をとても難しくします。もっとも、Javaだけがこのフラグの影響を受けるわけではありませんが。このように、このフラグは役立つ一方でデバッグを難しくしているのです。特にバックトレースは役に立たなくなります。しかしながら、それほどソフトウェアのデバッグを行う予定がなく、他に<code>-ggdb</code>のようなデバッグ関連の<var>CFLAGS</var>を追加していないのであれば、<code>-fomit-frame-pointer</code>を使ってみてもいいでしょう。 

{{Important/ja|<code>-fomit-frame-pointer</code>とそれに似た<code>-momit-leaf-frame-pointer</code>フラグを組み合わせて'''使わないでください'''。後者のフラグを使うのはやめてください。<code>-fomit-frame-pointer</code>のみで十分です。そのうえ、<code>-momit-leaf-frame-pointer</code>はコードの性能に悪影響を及ぼすことがわかっています。}}

=== -msse、-msse2、-msse3、-mmmx、-m3dnow ===

These flags enable the [https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extensions] (SSE), [https://en.wikipedia.org/wiki/SSE2 SSE2], [https://en.wikipedia.org/wiki/SSSE3 SSE3], [https://en.wikipedia.org/wiki/MMX_(instruction_set) MMX], and [https://en.wikipedia.org/wiki/3DNow! 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to see if the CPU supports these instruction sets by running {{c|cat /proc/cpuinfo}}. The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

通常、正しい<code>-march</code>を使っている限り、これらのどのフラグも{{Path|/etc/portage/make.conf}}に加える必要はありません(例えば<code>-march=nocona</code>は<code>-msse3</code>を有効にします)。いくつかの注意すべき例外は、比較的新しいVIAとAMD64のCPUです。VIAとAMD64はこれらの命令をサポートしますが、(SSE3のように)<code>-march</code>では有効になりません。これらのCPUについては{{Path|/proc/cpuinfo}}の出力を確認して、ふさわしいフラグを追加する必要があるでしょう。 

{{Note/ja|x86とx86-64特有のフラグについて[https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags]を確認しましょう。適切にCPUを指定することによって、どの命令セットが有効になるのか確認することができます。もし命令セットがリストの中にあったら、改めて指定する必要はありません。なぜならそれらは正しい<code>-march</code>を使えば有効になるでしょうから。}}

== 最適化FAQ ==

=== -funroll-loopsや-fomg-optimizeを使ったら速くなったんだけど！ ===

No, people only ''think'' they do because someone has convinced them that more flags are better. Aggressive flags will only hurt applications when used system-wide. Even the GCC [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> will make code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

ここで本当に問題なのは、これらのフラグは危険なほどに挑戦的なフラグということです。それらのフラグが何をやらかしているのか[https://forums.gentoo.org/ Gentoo Forums]と[https://bugs.gentoo.org/ Bugzilla]あたりをよく見てください。ろくなことないですよ！ 

These flags are not needed globally in <var>CFLAGS</var> or <var>CXXFLAGS</var>. They will only hurt performance. They might bring on the idea of having a high-performance system running on the bleeding edge, but they don't do anything but bloat the code and get bugs marked INVALID or WONTFIX. 

Dangerous flags like these are not needed. '''Don't use them'''. Stick to the basics: <code>-march</code>, <code>-O</code>, and <code>-pipe</code>.

=== 3より高い-Oレベルはどう？ ===

何人かのユーザーが、<code>-O4</code>や<code>-O9</code>などを使うことによってもっといいパフォーマンスを得たと誇張していますが、3より高い<code>-O</code>レベルは何の効果もありません。コンパイラは<code>-O4</code>のような<var>CFLAGS</var>も許容するでしょうが、それらは実質何もしないのです。<code>-O3</code>の最適化を行うだけで、それ以上の最適化はしません。 

さらに証拠が必要ですか？[https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup ソースコード]を試してみてください。 

{{CodeBox|title=-O ソースコード|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

見てのとおり、3より高いレベルであっても、結局<code>-O3</code>として扱われます。

=== 実際のマシンと別のマシンでコンパイルするのはどう？ ===

何人かの読者は、あきらかに劣ったCPUやGCCサブアーキテクチャでコンパイルすることを避けるために他のマシンでコンパイルすることは、（ネイティブな環境でのコンパイルと比較して）劣った最適化になるのか知りたくなるでしょう。答えは単純で'''いいえ'''です。コンパイルが走る実際のマシンに関係なく、またGCCをビルドしたときのCHOSTに関係なく、同じ引数が使用されている限り<small>(<code>-march=native</code>は除く)</small>、そしてGCCのバージョンが同じである限り<small>(マイナーバージョンが違うかもしれません)</small>、最適化の結果は厳密に同じです。

例を一つあげます。GCCのCHOSTが''i686-pc-linux-gnu''となっているマシンにGentooをインストールして、CHOSTが''i486-linux-gnu''となっている別のPCに[[Distcc]]サーバーをインストールします。リモートサーバーのコンパイラのサブアーキテクチャもしくはハードウェアが明らかに劣っている場合、最適化が十分なされないのではと心配する必要はありません。結果は、両方のコンパイラに同じ引数が与えられている限り（かつ<code>-march</code>に<code>native</code>が与えられていない限り）、ネイティブにビルドしたときと同じ最適化がかかります。ただしこの特殊なケースでは[[Distcc#-march.3Dnative|Distcc and -march=native]]で説明されている通り、ターゲットのアーキテクチャが明示的に指定されなければなりません。

異なるサブアーキテクチャに向けてビルドされた２つのGCCの動作には一つしか違いがありません。それは暗に与えられるデフォルトの<code>-march</code>です。コマンドラインで<code>-march</code>を明示的に指定しなかった場合、GCCのCHOSTに設定された値が使用されます。

=== 冗長なフラグ指定はどう？ ===

しばしば、{{Path|/etc/portage/make.conf}}の中で、個々の<code>-O</code>レベルを指定すれば有効になるフラグを重複して<var>CFLAGS</var>や<var>CXXFLAGS</var>に設定していることがあります。これは時々知らずにやってしまうのですが、一方で(ebuildが行う)フラグの除去や置換を回避するために意図的に行われることがあります。 

フラグの除去や置換はPortageツリーの中にある多くのebuildで行われます。大抵は、特定の<code>-O</code>レベルでパッケージをコンパイルすると失敗するために、もしくはフラグを追加するとそのソースコードでは問題が出るためです。ebuildはどちらの場合も、全部/一部の<var>CFLAGS</var>と<var>CXXFLAGS</var>を除外するか、もしくは異なる<code>-O</code>レベルに置換するでしょう。 

[https://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual]にフラグの除去と置換がどのような場合に、どのように使われているのか概要が記載されています。 

特定のレベルに対して重複してフラグを設定することによって、<code>-O</code>に対するフラグ除去をある程度回避することができます。例えば、<code>-O3</code>であれば次のようにします。 

{{CodeBox|title=重複してCFLAGSを設定|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

However, '''this is not a smart thing to do'''. <var>CFLAGS</var> are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile the whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, don't try to "outsmart" the developers who maintain those packages. ''Trust the developers''. Flag filtering and replacing is done to ensure stability of the system and application! If an ebuild specifies alternative flags, then don't try to get around it. 

Building packages with unacceptable flags will most likely lead to problems. When reporting problems on Bugzilla, the flags that are used in {{Path|/etc/portage/make.conf}} will be readily visible and developers will ask to recompile without those flags. Save the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume to be more knowledgeable than the developers.

=== LDFLAGSはどう？ ===

Gentoo開発者がすでに基本的で安全な<var>LDFLAGS</var>を基本プロファイルにセットしているので、それらを変更する必要はありません。

=== パッケージごとにフラグを変更出来るの？ ===

{{Warning|Using per-package flags complicates debugging and support. Make sure to mention the use of this feature in the bug reports together with the changes made.}}

パッケージごとに(<var>CFLAGS</var>を含む)環境変数を変更する方法は、[[Handbook:AMD64/Portage/Advanced/ja#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]]で説明しています。

== See also ==

* [[Handbook:AMD64/Installation/Stage#Configuring_compile_options|Configuring compile options]] (AMD64 Handbook)

== External resources ==

以下、最適化について理解を深めるための資料を紹介します。 

* [https://gcc.gnu.org/onlinedocs/ GCC online documentation] 

* {{c|man make.conf}}

* [https://ja.wikipedia.org/wiki/ ウィキペディア]

* [https://forums.gentoo.org/ Gentooフォーラム]

== References ==

{{reflist}}

{{Migrated|originalauthors={{Dev|nightmorph}}}}


[[Category:Compilation]]
