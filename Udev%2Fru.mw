<languages />


{{Metadata|abstract=udev это менеджер устройств для ядра Linux. Он обрабатывает файлы устройств в каталоге /dev и обрабатывает все действия пользователя при добавлении/удалении устройств.}}

{{Lowercase title}}
{{InfoBox stack
|{{InfoBox wikipedia|header=true}}
}}

'''udev''' это менеджер устройств для ядра Linux. Он обрабатывает файлы устройств в каталоге /dev и обрабатывает все действия пользователя при добавлении/удалении устройств. Также посмотрите на  [http://www.gentoo.org/proj/en/eudev eudev], это страница программы, выполняющей ту же функцию, что и udev.

== Что такое udev? ==

=== Каталог /dev ===

Когда пользователи Linux разговаривают о начинке своих систем среди людей, полагающих, что Linux — это какой-то вид вируса или марка кофе, пользуясь оборотами вроде «слэш дев слэш что—нибудь» (/dev/foo), на них наверняка смотрят косо. Но для счастливчиков (естественно, включая вас), {{Path|/dev/sda1}} — просто быстрый способ упоминания первого раздела ведущего диска SATA на первичном канале. Разве нет? 

Все мы знаем, что такое файл устройства. Некоторые даже знают, почему рядом с ними видны специальные числа, если посмотреть на результат <code>ls -l</code>, запущенной в каталоге {{Path|/dev}}. Но мы принимаем за данность, что первичный ведущий диск IDE называется {{Path|/dev/sda}}. У вас может быть и не так, но это всего лишь пример. 

Представим себе устройства «горячей замены» вроде USB, IEEE1394, заменямой PCI и т.д. Какое из них является первым по счету? Надолго ли? Как изменятся названия других устройств, если первое отключить? Как это повлияет на текущие операции? Было бы забавно, если бы задание печати вдруг переключалось с вашего супернавороченного лазерного принтера на старый полудохлый матричный из-за того, что ваша мама решила выдернуть разъем лазерного принтера, а тот оказался первым в списке, не так ли? 

Перейдем к ''udev''. Цели проекта udev как занимательны, так и актуальны:

* работа в режиме пользователя
* динамическое создание и удаление файлов устройств
* согласованное назначение имен устройств
* предоставление интерфейса программирования (API) для режима пользователя

Каждая раз, когда в структуре устройств появляется изменение, ядро генерирует ''uevent'', который ловится udev. Затем udev следует правилам, определенным в каталогах {{Path|/etc/udev/rules.d}}, {{Path|/run/udev/rules.d}} и {{Path|/lib/udev/rules.d}} directories. На основании информации в uevent, он находит правило или правила, которые он должен выполнить, и выполняет необходимые действия. Эти действия могут заключаться в создании или удалении файлов устройств, но могут и загружать нужные файлы прошивки в память ядра.

== Установка ==

{{Note/ru|Если вы обновляетесь, проверьте[[/upgrade|часть для обновлений]].}}

=== Ядро ===

Вам нужно включить следующие параметры ядра:

<!-- Смотри http://git.kernel.org/?p=linux/hotplug/udev.git;a=blob_plain;f=README -->
{{Kernel||<pre>
General setup  --->
    [*] Configure standard kernel features (expert users)  --->
        [ ] Enable deprecated sysfs features to support old userspace tools
        [*] Enable signalfd() system call
Enable the block layer  --->
    [*] Block layer SG support v4
Networking support  --->
    Networking options  --->
        <*> Unix domain sockets
Device Drivers  --->
    Generic Driver Options  --->
        ()  path to uevent helper
        [*] Maintain a devtmpfs filesystem to mount at /dev
    < > ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
File systems  --->
    [*] Inotify support for userspace
    Pseudo filesystems --->
        [*] /proc file system support
        [*] sysfs file system support
</pre>}}

=== Программное обеспечение ===

Portage знает о глобальном USE флаге ''udev'' для включения поддержки udev в остальных пакетах. Включение этого USE флага (он включен по умолчанию по всех [[profile|профилях]] ''linux'') приведет к тому, что {{Package|sys-fs/udev}} автоматически установится:

{{File|/etc/portage/make.conf||<pre>
USE="... udev ..."
</pre>}}

USE флаги программы udev следующие:

{{USEflag|package=sys-fs/udev
|acl+yes
|doc
|firmware-loader+yes
|gudev+yes
|introspection+yes
|kmod+yes
|openrc+yes
|selinux++no
|static-libs++no
}}

После установки этого флага потребуется обновить систему, чтобы изменения вступили в силу:

{{Emerge|params+=--changed-use --deep|@world}}

== Конфигурация ==

=== Запуск как сервис ===

Чтобы запустить udev при загрузке, добавьте его к уровню запуска sysinit:
{{RootCmd|rc-update add udev sysinit}}

== Расширенная конфигурация ==

=== Правила ===

udev дает возможность создавать правила, которые проверяют uevents (события, посланные ядром) и задают свойства найденного устройства. Совпадающее правило, возможно, даст устройству имя, создаст файл устройства, и запустит программу конфигурации, чтобы настроить устройство.

Определения правил сохраняются в  {{Path|/lib/udev/rules.d}} (устанавливаются пакетами) и {{Path|/etc/udev/rules.d}} (для правил, определенных конечными пользователями). В этих каталогах, обрабатываются файлы правил (с суффиксом {{Path|.rules}}) в буквенноцифровом порядке имен, по возрастению. Внутри файлов правил, udev ищет выражения, которые могут совпасть с uevent, вместе с состоянием для проверки (добавляется устройство или удаляется), и с командами для выполнения.

Выражения проверяются на совпадение на основании следующей информации:
* Поле ''SUBSYSTEM'' uevent (для какого типа устройства был uevent)
* Действие (поле ''ACTION''), которое было предпринято (добавление, удаление, либо изменение устройства)
* Один или более атрибутов (через поля ''ATTR'' or ''ATTRS''), например, класс устройства, производитель, либо другая информация об устройстве
* Имя, данное ядром (через поле ''KERNEL''), например, sd* (для дисков SCSI/SATA), либо input* (для устройств ввода, таких, как мыши и клавиатуры)
* Одна или более настройка окружения (через поле ''ENV''), используемая для информации, которая может использоваться несколькими правилами сразу.

На основании этой информации, правило может сделать следующее:
* определить информацию, которую необходимо будет передать более поздним событиям (через переменные окружения)
* создать ссылки в {{Path|/dev}}
* выполнить команды

Udev делает эти действия для каждого правила, для которого находит соответствие (он не останавливается после первого совпадения), позволяя организовать гибкий подход к управлению устройствами.

=== Постоянные имена устройств ===

The kernel detects devices asynchronous, udev mirrors the kernel's [[sysfs]] filesystem and so the device are named and numbered in order of detection. So by default udev provides no persistent device names. However there are mechanismen for some device classes to provide these:

* udev creates for storage devices additional symlinks based on the device's id, label, uuid and path. See the {{Path|/dev/disk/by-*}} directory. So instead of using e.g. the device file {{Path|/dev/sda}} use the file {{Path|/dev/disk/by-label/SOME_LABEL}}.

* The same for input devices in the {{Path|/dev/input}} directory.

* Using custom rules you can create your own device files.

== Использование ==

Некоторые полезные команды следующие:

* Показать все сообщения о заданном файле устройства:
: {{RootCmd|udevadm info --query{{=}}all --name{{=}}/dev/DEVICE_FILE}}

* Мониторинг активности udev:
: {{RootCmd|udevadm monitor}}

Смотри [[man page|man страницу]] ''udevadm'' для более детальной информации.

== Устранение проблем ==

* {{Bug|udev|search=package}}

=== Log monitor messages ===

Log all message you see, when you run '''udevadm monitor''':

{{File|/etc/conf.d/udev||<pre>
udev_monitor="YES"
</pre>}}

It will create the new log file {{Path|/run/udev/udevmonitor.log}}.

=== Debug mode ===

Enable debug mode to get more log messages:

{{File|/etc/conf.d/udev||<pre>
udev_debug="YES"
</pre>}}

It will create the new log file {{Path|/run/udev/udevdebug.log}}.

=== Missing device files {{Path|/dev/null}} and {{Path|/dev/console}} ===

Some udev versions need these files and can't create them on their own. So you have to create them:

{{RootCmd
|mkdir test
|mount --bind / test
|cd test/dev
|mknod -m 660 console c 5 1
|mknod -m 660 null c 1 3
|cd ../..
|umount test
|rmdir test
}}

=== Сетевая карта определена как eth0, но изменилась на eth1 ===

Те, у кого две сетевых карты на материнской плате, могут попасть в ситуацию, когда ifconfig не покажет eth0 или eth1. Dmesg может показать, что сетевая карта определена как eth0, а затем переименована в eth1. При выполнении "ifconfig -a" также будет показана сетевая карта как eth1. Это из-за того, что имена, определенные ядром используются в первую очередь. Вы должны написать свои собственные правила, например, в файле {{Path|/etc/udev/rules.d/70-my-network.rules}}, и задать свои имена, вроде lan0 или wireless0, либо использовать предсказуемые имена интерфейсов, которые включены по умолчанию с версии 197.

Также, помните, что нужно удалить старые файлы, оставшиеся от старых версий udev:

{{RootCmd|rm /etc/udev/rules.d/70-persistent-net.rules}}


[[Category:Core system]]
[[Category:Daemons]]
