<languages />

{{Metadata|abstract=LVM permite a los administradores crear metadispositivos que ofrecen una capa de abstracción entre un sistema de ficheros y el almacenamiento físico que se utiliza por debajo.}}

{{InfoBox stack
|{{InfoBox wikipedia|LVM|header=true}}
}}

'''LVM''' ('''L'''ogical '''V'''olume '''M'''anager) permite a los administradores crear metadispositivos que ofrecen una capa de abstracción entre un sistema de ficheros y el almacenamiento físico que se utiliza por debajo. Los metadispositivos (en los cuales se alojan los sistemas de ficheros) son ''volúmenes lógicos'' que utilizan almacenamiento que se obtiene de espacios de almacenamiento  llamados ''grupos de volumen''. Un grupo de volumen se abastece con uno o más ''volúmenes físicos'' que son los auténticos dispositivos en los que se almacenan los datos.

Los volúmenes físicos pueden ser particiones, discos SATA completos agrupados como JBOD ('''J'''ust a '''B'''unch '''O'''f '''D'''isks o '''Simplemente un puñado de discos'''), sistemas RAID, iSCSI, Fibre Channel, eSATA etc.

== Instalación ==

LVM se gestiona por los controladores al nivel de núcleo y por aplicaciones en el espacio de usuario que permiten gestionar la configuración de LVM.

=== Núcleo ===

Activar las siguientes opciones del núcleo:

{{Kernel||<pre>
Device Drivers --->
 Multiple devices driver support (RAID and LVM) --->
  <*> Device mapper support
    <*> Crypt target support
    <*> Snapshot target
    <*> Mirror target
  <*> Multipath target
    <*> I/O Path Selector based on the number of in-flight I/Os
    <*> I/O Path Selector based on the service time </pre>}}

{{Note/es|No se necesita activar todo lo de arriba, algunas opciones son necesarias únicamente para [[#LVM2_Snapshots_and_LVM2_Thin_Snapshots|LVM2 Snapshots and LVM2 Thin Snapshots]], [[#LVM2_Mirrors|LVM2 Mirrors]], [[#LVM2_RAID_0.2FStripeset|LVM2 RAID 0/Stripeset]] y el cifrado.}}

=== Software ===

Instalar {{Package|sys-fs/lvm2}}:

{{USEflag|package=sys-fs/lvm2
|clvm
|cman
|lvm1+yes
|readline+yes
|selinux++no
|static
|static-libs
|thin+yes
|udev+yes
}}

{{Emerge|lvm2}}

== Configuración ==

La configuración de LVM se realiza en diferentes niveles:
# La gestión de LV, PV y VG a través de las utilidades de gestión
# El ajuste fino del subsistema LVM a través del fichero de configuración
# La gestión del servicio al nivel de distribución
# La configuración a través de un sistema de ficheros RAM inicial

La gestión de los volúmenes físicos y lógicos así como de los grupos de volumen se gestiona en el capítulo [[#Utilización|Utilización]].

=== Fichero de configuración de LVM ===

LVM posee un fichero de configuración muy extenso en {{Path|/etc/lvm/lvm.conf}}. La mayoría de usuarios no necesitan modificar ningún aspecto de este fichero para comenzar a usar LVM.

=== Gestión de servicios ===

Gentoo ofrece el servicio LVM para detectar automáticamente los grupos de volumen y los volúmenes lógicos.

Se puede gestionar este servicio a través del sistema de inico.

==== openrc ====

Para iniciar LVM manualmente:

{{RootCmd|/etc/init.d/lvm start}}

Para iniciar LVM cuando arranque el sistema:

{{RootCmd|rc-update add lvm boot}}

==== systemd ====

Para iniciar LVM manualmente:

{{RootCmd|systemctl start lvm2-monitor.service}}

Para iniciar LVM cuando arranque el sistema:

{{RootCmd|systemctl enable lvm2-monitor.service}}

=== Usar LVM en un initramfs ===

La mayoría de los cargadores de arranque no pueden iniciar directamente desde LVM. Ni GRUB Legacy ni LILO pueden hacerlo. Grub 2 PUEDE iniciar desde un volumen lógico LVM lineal, desde un volumen lógico en espejo y probablemente desde algunos tipos de volúmenes lógicos RAID. Ningún cargador de arranque ofrece soporte actualmente para volúmenes lógicos delgados (thin). 

Debido a esto, se recomienda utilizar una partición de arranque que no sea LVM y montar la partición raíz LVM desde un initramfs. Se puede generar este initramfs de forma automática mediante [[Genkernel/es|genkernel]], {{Package|sys-kernel/genkernel-next}} y [[dracut]]:

* '''genkernel''' puede iniciar desde cualquier tipo excepto volúmenes delgados (ya que ni construye ni copia los binarios de {{Package|thin-provisioning-tools}} del equipo de construcción) y quizá desde RAID10 (El soporte de RAID10 requiere LVM2 2.02.98, pero genkernel construye la versión 2.02.89. Sin embargo, si se dispone de binarios estáticos, éstos se puede copiar)
* '''genkernel-next''' puede iniciar desde todos los tipos de volúmenes, pero necesita un nuevo {{Package|app-misc/pax-utils}} o, de lo contrario, los binarios para volúmenes delgados estarán rotos (Mirar la incidencia {{Bug|482504}})
* '''dracut''' debería poder iniciar desde todos los tipos, pero únicamente incluye soporte para volúmenes delgados en el initramfs si el equipo en el que corre tiene un volumen raíz delgado.

==== Genkernel/Genkernel-next ====

Haga emerge de {{Package|sys-kernel/genkernel}} o de {{Package|sys-kernel/genkernel-next}}. El ajuste USE static también se puede activar en el paquete {{Package|sys-fs/lvm2}} de modo que genkernel utilice los binarios del sistema (de lo contrario construirá su propia copia privada). El siguiente ejemplo construirá únicamente un initramfs (no el núcleo completo) y habilitará el soporte para LVM.

{{RootCmd|genkernel --lvm initramfs}}

La página del manual de genkernel describe otras opciones que dependen de los requisitos del sistema.

El initrd requerirá parámetros para indicarle cómo iniciar LVM. Éstos se pasan igual que el resto de parámetros del núcleo. Por ejemplo:

{{File|/etc/default/grub|Añadir dolvm como parámetro de inicio del núcleo|<pre>
GRUB_CMDLINE_LINUX="dolvm"
</pre>}}

==== Dracut ====

El paquete {{Package|sys-kernel/dracut}} se portó desde el proyecto RedHat y es una herramienta similar para generar un initramfs. Ya que actualmente  Since it is currently se encuentra en pruebas (~arch), los usuarios necesitarán [[Knowledge_Base:Accepting_a_keyword_for_a_single_package|aceptar este hecho]] (a través de {{Path|/etc/portage/package.accept_keywords}}) para poder hacer emerge. Antes de hacerlo, se debería añadir la variable <code>DRACUT_MODULES="lvm"</code> a {{Path|/etc/portage/make.conf}}. Puede que se quieran instalar otros módulos, por favor, eche un vistazo a [[Dracut]]. Normalmente la siguiente orden genera un initramfs funcional por defecto.

{{RootCmd|dracut -a lvm}}

El initrd requerirá parámetros para indicarle cómo iniciar lvm. Éstos se pasan igual que el resto de parámetros del núcleo. Por ejemplo:

{{File|/etc/default/grub|Añadir soporte para LVM a los parámetros de inicio del núcleo|<pre>
GRUB_CMDLINE_LINUX="rd.lvm.vg=vol00"
</pre>}}

Para obtener una lista completa de opciones LVM dentro de dracut, por favor, lea la sección en el [https://www.kernel.org/pub/linux/utils/boot/dracut/dracut.html#_lvm Manual de Dracut].

== Utilización ==

LVM organiza el almacenamiento en tres niveles diferentes como se muestra a continuación:
* Los discos duros, particiones, sistemas RAID y otros modos de almacenamiento se inicializan como volúmenes físicos (PVs)
* Los Volúmenes Físicos (PV) se agrupan en Grupos de Volumen (VG)
* Los Volúmenes Lógicos (LV) se gestionan en los Grupos de Volumen (VG)

=== PV (Volumen Físico) ===
Los Volúmenes Físicos son el hardware o el sistema de almacenamiento sobre el que se construye LVM.

==== Particionamiento ====

{{Note/es|Solo se necesita usar particiones separadas para proveer de almacenamiento a los grupos de volumen en el caso de que no se quiera utilizar todo el disco para un solo grupo de volúmenes LVM. Si se puede utilizar todo el disco, entonces ignore esto e inicialice el disco duro completo como un volumen físico.}}

El tipo de partición para ''LVM'' es ''8e'' (Linux LVM).

Por ejemplo, para definir el tipo usando <code>fdisk</code> para una partición en {{Path|/dev/sda}}:

{{RootCmd|fdisk /dev/sda}}

En <code>fdisk</code>, cree particiones usando la tecla {{Key|n}} y a continuación cambie el tipo de partición con la tecla {{Key|t}} a ''8e''.

==== Crear PV ====

Puede crear o inicializar los volúmenes físico con la orden <code>pvcreate</code>.

Por ejemplo, la siguiente orden crea un volumen físico en la primera partición primar de los discos {{Path|/dev/sda}} y {{Path|/dev/sdb}}:

{{RootCmd|pvcreate /dev/sd[ab]1}}

==== Listar PV ====

Con la orden <code>pvdisplay</code> se puede obtener información de todos los volúmenes físicos activos del sistema.

{{RootCmd|pvdisplay|output=<pre>
--- Physical volume ---
PV Name /dev/sda1
VG Name volgrp
PV Size 160.01 GiB / not usable 2.31 MiB
Allocatable yes
PE Size 4.00 MiB
Total PE 40962
Free PE 4098
Allocated PE 36864
PV UUID 3WHAz3-dh4r-RJ0E-5o6T-9Dbs-4xLe-inVwcV

--- Physical volume ---
PV Name /dev/sdb1
VG Name volgrp
PV Size 160.01 GiB / not usable 2.31 MiB
Allocatable yes
PE Size 4.00 MiB
Total PE 40962
Free PE 40962
Allocated PE 0
PV UUID b031x0-6rej-BcBu-bE2C-eCXG-jObu-0Boo0x
</pre>}}

Si se necesitan mostrar más volúmenes físicos, <code>pvscan</code> puede detectar volúmenes físicos inactivos y activarlos.

{{RootCmd|pvscan|output=<pre>
PV /dev/sda1 VG volgrp lvm2 [160.01 GiB / 16.01 GiB free]
PV /dev/sdb1 VG volgrp lvm2 [160.01 GiB / 160.01 GiB free]
Total: 2 [320.02 GB] / in use: 2 [320.02 GiB] / in no VG: 0 [0]
</pre>}}

==== Eliminar PV ====

LVM distribuye los datos automáticamente entre todos los volúmenes físicos disponibles (a menos que se le indique lo contrario) usando un enfoque lineal. Si un volumen lógico (dentro de un grupo de volumen) es menor que la cantidad total de espacio libre en un volumen físico, entonces todo el espacio se reclama de ese (único) volumen físico de una forma continua. Esto se hace así por cuestiones de rendimiento.

Si se necesita eliminar un volumen físico de un grupo de volumen, se necesita en primer lugar mover los datos de ese volumen físico. Con la orden <code>pvmove</code>, todos los datos de un volumen físico se mueven a otros volúmenes físicos dentro del mismo grupo de volumen.

{{RootCmd|pvmove -v /dev/sda1}}

Esta operación puede llevar tiempo dependiendo de la cantidad de datos que se van a mover. Una vez haya terminado, no debería haber datos en el dispositivo. Puede comprobar con <code>pvdisplay</code> que ningún volumen lógico utiliza ese volumen físico.

El siguiente paso es eliminar el volumen físico del grupo de volumen mediante <code>vgreduce</code> después de lo cual el dispositivo se puede "deseleccionar" como un volumen físico usando <code>pvremove</code>:

{{RootCmd|vgreduce vg0 /dev/sda1 && pvremove /dev/sda1}}

=== VG (Grupo de Volumen) ===

Un grupo de volumen (VG) agrupa varios volúmenes físicos y se muestra como {{Path|/dev/NOMBRE_DEL_VG}} el el sistema de ficheros de los dispositivos. El administrador es el que elige el nombre del grupo de volumen.

==== Crear VG ====

La siguiente orden crea un grupo de volumen llamado ''vg0'' con dos volúmenes físicos asignados: {{Path|/dev/sda1}} y {{Path|/dev/sdb1}}.

{{RootCmd|vgcreate vg0 /dev/sd[ab]1}}

==== Listar VG ====

Para listar todos los grupos de volumen activos, utilice la orden <code>vgdisplay</code>:

{{RootCmd|vgdisplay|output=<pre>
--- Volume group ---
VG Name vg0
System ID
Format lvm2
Metadata Areas 1
Metadata Sequence No 8
VG Access read/write
VG Status resizable
MAX LV 0
Cur LV 6
Open LV 6
Max PV 0
Cur PV 1
Act PV 1
VG Size 320.02 GiB
PE Size 4.00 MiB
Total PE 81924
Alloc PE / Size 36864 / 144.00 GiB
Free PE / Size 45056 /176.01 GiB
VG UUID mFPXj3-DdPi-7YJ5-9WKy-KA5Y-Vd4S-Lycxq3
</pre>}}

Si falta algún grupo de volumen, utilice la orden <code>vgscan</code> para localizarlo:

{{RootCmd|vgscan|output=<pre>
 Reading all physical volumes. This may take a while...
 Found volume group "vg0" using metadata type lvm2
</pre>}}

==== Extender VG ====

Los grupos de volumen agrupan volúmenes físicos, permitiendo a los administradores utilizar una reserva de recursos de almacenamiento para crear sistemas de ficheros. Cuando un grupo de volumen no tiene los suficientes recursos de almacenamiento, es necesario extenderlo con volúmenes físicos adicionales.

El siguiente ejemplo extiende el grupo de volumen ''vg0'' con un volumen físico en {{Path|/dev/sdc1}}:

{{RootCmd|vgextend vg0 /dev/sdc1}}

¡Recuerde antes necesita inicializar el volumen físico!

==== Reducir VG ====

Si se necesita eliminar volúmenes físicos de un grupo de volumen, todos los datos que todavía se utilizan en ese volumen físicos se deben mover a otros dentro del mismo grupo de volumen. Como hemos visto antes, esto se gestiona con la orden <code>pvmove</code> después de la cual el volumen físico se puede eliminar del grupo de volumen usando <code>vgreduce</code>:

{{RootCmd|pvmove -v /dev/sdc1 |vgreduce vg0 /dev/sdc1}}

==== Eliminar VG ====

Si ya no se necesita un grupo de volumen (o en otras palabras la reserva de recursos de almacenamiento que éste representa ya no se necesita y se necesita liberar los volúmenes físicos dentro de él para otras cuestiones) entonces se puede eliminar el grupo de volumen con <code>vgremove</code>. Esto solo funciona si no no se han definido volúmenes lógicos dentro del grupo de volumen y se han eliminado todos los volúmenes físicos de la reserva salvo uno.

{{RootCmd|vgremove vg0}}

=== LV (Volumen Lógico) ===

Los volúmenes lógicos son los metadispositivos finales que se ofrecen al sistema normalmente para crear sistemas de ficheros en ellos. Se crean y se gestionan dentro de grupos de volumen y se muestran como {{Path|/dev/NOMBRE_DEL_VG/NOMBRE_DEL_LV}}. Al igual que con los grupos de volumen el nombre lo decide el administrador.

==== Crear LV ====

Para crear un volumen lógico se utiliza la orden <code>lvcreate</code>. Los parámetros de esta orden son: el tamaño deseado para el volumen lógico (que no puede ser mayor que la cantidad disponible en el grupo de volumen), el grupo de volumen del cual se obtendrá el espacio y el nombre del volumen lógico que se va a crear.

En el ejemplo de abajo, se crea un volumen lógico llamado ''lvol1'' en el grupo de volumen llamado ''vg0'' con un tamaño de 150MB:

{{RootCmd|lvcreate -L 150M -n lvol1 vg0}}

Es posible indicarle a <code>lvcreate</code> que use todo el espacio disponible en el grupo de volumen. Esto se realiza mediante el parámetro ''-l'' el cual selecciona el número de ''extents'' (extensiones) en lugar de un tamaño (legible por los humanos). Los volúmenes lógicos se dividen en ''extensiones lógicas'' que son trozos de datos dentro de un grupo de volumen. Todas la extensiones dentro de un grupo de volumen tienen el mismo tamaño. Con el párametro ''-l'' se puede pedir a <code>lvcreate</code> que use todas las extensiones disponibles:

{{RootCmd|lvcreate -l 100%FREE -n lvol1 vg0}}

A continuación de ''FREE'' se puede utilizar la clave ''VG'' para indicar el tamaño total de un grupo de volumen.

==== Listar LV ====

Para listar todos los volúmenes lógicos, utilice la orden <code>lvdisplay</code>:

{{RootCmd|lvdisplay}}

Si echa de menos algún volumen lógico, entonces la orden <code>lvscan</code> se puede utiliza para escanear los grupos de volumen en busca de otros volúmenes lógicos.

{{RootCmd|lvscan}}

==== Extender LV ====

Cuando se necesita expandir un volumen lógico, entonces se puede utilizar la orden <code>lvextend</code> para ampliar el espacio asociado al volumen lógico.

Por ejemplo, para extender el volumen lógico ''lvol1'' a un total de 500 MB:

{{RootCmd|lvextend -L500M /dev/vg0/lvol1}}

También es posible utilizar el tamaño que se necesita añadir en lugar del tamaño total:

{{RootCmd|lvextend -L+350MB /dev/vg0/lvol1}}

Un grupo de volumen extendido no ofrece de forma inmediata el espacio de almacenamiento adicional a los usuarios finales. Para ello, se necesita igualmente incrementar el sistema de ficheros creado en el grupo de volumen. No todos los sistemas de ficheros admiten el cambio de tamaño cuando se están utilizando, por tanto compruebe la documentación del sistema de ficheros en cuestión para obtener más información.

Por ejemplo, para cambiar el tamaño de un sistema de ficheros ext4 a 500MB:

{{RootCmd|resize2fs /mnt/data 500M}}

==== Reducir LV ====

Si se necesita reducir el tamaño de un volumen lógico, en primer lugar se debe reducir el propio sistema de ficheros. No todos los sistemas de ficheros lo permiten cuando se están utilizando.

Por ejemplo, ext4 no permite reducir el tamaño cuando se está utilizando por lo que se debe desmontar en primer lugar. También se recomienda realizar una comprobación del sistema de ficheros para asegurarse de que no hay inconsistencias:

{{RootCmd|umount /mnt/data
|e2fsck -f /dev/vg0/lvol1
|resize2fs /dev/vg0/lvol1 150M}}

Con un sistema de ficheros reducido ya es posible reducir también el volumen lógico:

{{RootCmd|lvreduce -L150M /dev/vg0/lvol1}}

==== Permisos LV ====

LVM ofrece soporte para estados de permisos en los volúmenes lógicos.

Por ejemplo, se puede definir un volumen lógico a ''solo lectura'' mediante la orden <code>lvchange</code>:

{{RootCmd|lvchange -p r /dev/vg0/lvol1
|mount -o remount /dev/vg0/lvol1}}

La opción para remontar el sistema de fichero se necesita ya que el cambio no se fuerza de forma inmediata.

Para marcar el volumen lógico como escribible, utilice el bit de permisos ''rw'':

{{RootCmd|lvchange -p rw /dev/vg0/lvol1 && mount -o remount /dev/vg0/lvol1}}

==== Eliminar LV ====

Antes de eliminar un volumen lógico, asegúrese de que no está montado:

{{RootCmd|umount /dev/vg0/lvol1}}

Desactive el volumen lógico de modo que no se pueda realizar ninguna actividad de escritura:

{{RootCmd|lvchange -a n /dev/vg0/lvol1}}

Una vez que el volumen está desmontado y desactivado, se puede eliminar, liberando las extensiones asignadas a éste para que otros volúmenes lógicos del grupo de volumen las puedan utilizar:

{{RootCmd|lvremove /dev/vg0/lvol1}}

== Características ==

LVM ofrece algunas características interesantes para los administradores del almacenamiento, incluyendo (pero no limitadas a):
* Provisión delgada (almacenamiento "over-commiting")
* Soporte a instantáneas
* Tipos de volumen con distintos métodos de asignación de espacio de almacenamiento

=== Provisión delgada ===

Las versiones recientes de LVM2  (2.02.89) ofrecen soporte a volúmenes "delgados" (thin). Los volúmenes delgados son a los dispositivos de bloque lo que los ficheros desperdigados son a los sistemas de ficheros. Así, un volumen lógico delgado dentro de una reserva se puede sobreasignar (over-committed): el tamaño que muestra puede ser mayor que el presente en al propia reserva. Al igual que un fichero, las extensiones se asignan mientras el dispositivo se va llenando. Si el sistema de ficheros tiene soporte para ''descartes'', las extensiones se liberan de nuevo cuando los ficheros se eliminan, reduciendo el uso del espacio en la reserva.

Dentro de LVM, esta reserva delgada es un tipo especial de volumen lógico que puede contener a su vez otros volúmenes lógicos.

==== Crear una reserva delgada ====

{{Warning/es|Si ocurre un desbordamiento (overflow) dentro de los metadatos de la reserva delgada, entonces la reserva se corromperá. '''LVM no puede recuperarse de esto'''.}} 

{{Note/es|Si se acaba el espacio de almacenamiento de la reserva delgada, cualquier proceso que pudiera causar que esta reserva intentará asignar más extensiones (que no están disponibles) pasaría al estado "dormido y terminable" ("killable sleep") hasta que se extienda la reserva delgada o el proceso reciba la señal SIGKILL.}}

Cada reserva delgada tiene unos metadatos asociados que se añaden al tamaño de la reserva. LVM calculará el tamaño de los metadatos basándose en el tamaño de la reserva y como mínimo asignará <tt>pool_chunks * 64 bytes</tt> o 2MiB, el que sea mayor. El administrador puede seleccionar también un tamaño diferente para los metadatos.

Para crear una reserva delgada, añada los parámetros ''--type thin-pool --thinpool thin_pool'' a la orden <code>lvcreate</code>:

{{RootCmd|lvcreate -L 150M --type thin-pool --thinpool thin_pool vg0}}

El ejemplo de arriba crea una reserva delgada llamado ''thin_pool'' con un tamaño total de 150 MB. Este es el tamaño real asignado a la reserva delgada (y de este modo la cantidad total de espacio de almacenamiento se puede utilizar).

Para asignar explícitamente un tamaño para los metadatos, utilice el parámetro ''--metadatasize''.

{{RootCmd|lvcreate -L 150M --metadatasize 2M --type thin-pool --thinpool thin_pool vg0}}

Debido a los metadatos añadidos a la reserva delgada, la forma intuitiva de utilizar todo el espacio disponible en un grupo de volumen para un volumen lógico no funciona (vea la incidencia sobre LVM [https://bugzilla.redhat.com/show_bug.cgi?id=812726|812726]):

{{RootCmd|lvcreate -l 100%FREE --type thin-pool --thinpool thin_pool vg0|output=<pre>
Insufficient suitable allocatable extents for logical volume thin_pool: 549 more required
</pre>}}

Observe que la reserva delgada no tiene un nodo de dispositivo asociado como otros volúmenes lógicos.

==== Crear un volumen lógico delgado ====

Un ''volumen lógico delgado'' es un volumen lógico dentro de una reserva delgada (que a su vez es otro volumen lógico). Debido a que los volúmenes lógicos delgados están ''desperdigados'', se especifica un tamaño virtual en lugar de uno físico usando el parámetro ''-V'':

{{RootCmd|lvcreate -T vg0/thin_pool -V 300M -n lvol1}}

En este ejemplo, el volumen lógico (delgado) ''lvol1'' se muestra como un dispositivo de 300MB de tamaño aunque la reserva que lo sustenta solo dispone de 150MB de espacio de almacenamiento real.

También es posible crear la reserva delgada y el volumen lógico dentro de la reserva en una sola orden:

{{RootCmd|lvcreate -T vg0/thin_pool -V 300M -L150M -n lvol1}}

==== Listar las reservas delgadas y los volúmenes lógicos delgados ====

Las reservas delgadas y los volúmenes lógicos delgados son tipos espaciales de volúmenes lógicos y así se muestran con la orden <code>lvdisplay</code>. La orden <code>lvscan</code> también detecta este tipo de volúmenes lógicos.

==== Extender una reserva delgada ====

{{Warning/es|A partir de la versión  2.02.89 de LVM2, el tamaño de los metadatos de la reserva delgada no se puede ampliar, se fija en el momento de su creación.}}

La reserva delgada se expande igual que un volumen lógico que no es delgado, esto es, mediante <code>lvextend</code>. Por ejemplo:

{{RootCmd|lvextend -L500M vg0/thin_pool}}

==== Extender un volumen lógico delgado ====

Los volúmenes lógicos delgados se expanden igual que los normales:

{{RootCmd|lvextend -L1G vg0/lvol1}}

Observe que la orden <code>lvextend</code> utiliza la opción ''-L'' (o ''-l'' si se indica un número de extensiones) y no una opción que indique un "tamaño virtual" tal y como se utilizó en el momento de su creación. 

==== Reducir una reserva delgada ====

Actualmente LVM no puede reducir el tamaño de la reserva delgada. Mire la incidencia LVM [https://bugzilla.redhat.com/show_bug.cgi?id=812731|812731].

==== Reducir un volumen lógico delgado ====

Los volúmenes lógicos delgados se reducen de forma similar a los volúmenes lógicos normales:

Por ejemplo:
{{RootCmd|lvreduce -L300M vg0/lvol1l}}

Observe que la orden <code>lvextend</code> utiliza la opción ''-L'' (o ''-l'' si se indica un número de extensiones) y no una opción que indique un "tamaño virtual" tal y como se utilizó en el momento de su creación.

==== Eliminar reservas delgadas ====

Las reservas delgadas no se pueden eliminar hasta que todos los volúmenes lógicos delgados contenidos en ellas se eliminen.

Cuando una reserva delgada ya no ofrece servicio a ningún volumen lógico delgado, ésta se puede eliminar mediante la orden <code>lvremove</code>:

{{RootCmd|lvremove vg0/thin_pool}}

=== Instantáneas LVM2 e instantáneas delgadas ===

Una instantánea es un volumen lógico que actúa como una copia de otro volumen lógico. Muestra el estado del volumen lógico original en el momento de creación de la instantánea.

==== Crear un volumen lógico tipo instantánea ====

Un volumen lógico tipo instantánea se crea utilizando la opción ''-s'' de <code>lvcreate</code>. A los volúmenes lógicos tipo instantánea se les asigna espacio de almacenamiento para que LVM "registre" todos los cambios realizados en el volumen lógico original y almacene estos cambios en el espacio de almacenamiento reservado para la instantánea. Cuando se consulta el estado de la instantánea,  LVM comenzará en el volumen lógico original y comprobará todos los cambios registrados "deshaciendo" lso cambios antes de mostrar el resultado al usuario.

Por lo tanto un volumen lógico tipo instantánea "crece" al mismo ritmo que se realizan cambios en el volumen lógico original. Cuando se utiliza completamente el espacio de almacenamiento reservado a la instantánea, entonces ésta se elimina automáticamente del sistema.

{{RootCmd|lvcreate -l 10%VG -s -n 20140412_lvol1 /dev/vg0/lvol1}}

El ejemplo de arriba crea un volumen lógico tipo instantánea llamado ''20140412_lvol1'' y basado en el volumen lógico ''lvol1'' en el grupo de volumen ''vg0''. Utiliza un 10% del espacio (de hecho son extensiones) asignado al grupo de volumen.

==== Acceder un volumen lógico tipo instantánea ====

Los volúmenes lógicos tipo instantánea se pueden montar de forma similar a los volúmenes lógicos normales. Incluso no están restringidos a operaciones de solo lectura. Es posible modificar instantáneas y de este modo usarlas para probar cambios antes de hacerlos en sistemas de ficheros de "producción".

Mientras existan volúmenes lógicos tipo instantánea, los volúmenes lógicos originales y normales no se pueden reducir en tamaño ni eliminar.

==== Instantáneas delgadas LVM ====

{{Note/es|Una instantánea delgada solo se puede tomar de una reserva delgada y para un volumen lógico delgado. El destino del mapeador de dispositivos delgado ofrece soporte para instantáneas delgadas de volúmenes lógicos solo lectura y que no sean delgados. Sin embargo, las herramientas de LVM2 no ofrecen soporte para esto. Es posible crear un volumen lógico tipo instantánea normal (no delgado) de un volumen lógico delgado.}}

Para crear una instantánea delgada, se utiliza la orden <code>lvcreate</code> con la opción <code>-s</code>. No se necesita pasar declaraciones de tamaño:

{{RootCmd|lvcreate -s -n 20140413_lvol1 /dev/vg0/lvol1}}

Las instantáneas de volúmenes lógicos delgados tienen el mismo tamaño que sus volúmenes lógicos originales y utilizan una asignación física de cero al igual que otros volúmenes lógicos delgados. 

{{Important/es|Se se especifica ''-l'' o ''-L'' se creará igualmente una instantánea pero el resultado será una instantánea normal no una instantánea delgada.}}

También es posible tomar instantáneas de instantáneas:

{{RootCmd|lvcreate -s -n 1_20140413_lvol1 /dev/vg0/20140413_lvol1}}

Las instantáneas delgadas tiene varias ventajas sobre las instantáneas normales. En primer lugar, las instantáneas delgadas son independientes de su volumen lógico original una vez se han creado. Se puede eliminar o reducir el tamaño del volumen lógico original sin que esto afecte a la instantánea. En segundo lugar, se pueden crear instantáneas delgadas de forma recursiva eficientemente (instantáneas de instantáneas) sin "encadenar" sobrecarga de instantáneas normales recursivas de LVM.

==== Deshacer cambios a un estado de instantánea ====

Para deshacer los cambios de un volumen lógico a la versión de la instantánea, lance la siguiente orden:

{{RootCmd|lvconvert --merge /dev/vg0/20140413_lvol1}}

Esto puede tomar un par de minutos dependiendo del tamaño del volumen.

{{Important/es|La instantánea desaparecerá y este cambio no es reversible}}

==== Deshacer cambios en instantáneas delgadas ====

Para instantáneas delgadas, <code>lvconvert --merge</code> no funciona. En su lugar, elimine el volumen lógico original y renombre la instantánea:

{{RootCmd|umount /dev/vg0/lvol1
|lvremove /dev/vg0/lvol1
|lvrename vg0/20140413_lvol1 lvol1}}

=== Diferentes métodos de asignación de espacio de almacenamiento ===

LVM ofrece soporte para varios métodos de asignación de espacio de almacenamiento:
* Volúmenes lineales (que es el que se aplica por defecto)
* Volúmenes en espejo (en una configuración más o menos activa/en línea)
* Volúmenes seccionados (RAID0)
* Volúmenes en espejo (RAID1, que es más una configuración activa/activa)
* Volúmenes seccionados con paridad (RAID4 y RAID5)
* Volúmenes seccionados con doble paridada (RAID6)
* Volúmenes seccionados y en espejo (RAID10)

==== Volúmenes lineales ====

Los volúmenes lineales son los más comunes de los volúmenes LVM. LVM intentará asignar el espacio para el volumen lógico para que físicamente sea lo más contiguo posible. Si hay un volumen lógico lo suficientemente grande para contener todo el volumen físico, entonces LVM lo asignará a ese espacio, de lo contrario lo troceará en el menor número de partes posible.

Las órdenes descritas anteriormente para crear grupos de volúmenes y volúmenes lógicos crean volúmenes lineales.

Debido a que los volúmenes lineales no precisan requisitos espaciales, son los más fáciles de manipular y se les puede cambiar el tamaño y relocalizarlos según se desee. SI un volumen lógico se asigna en varios volúmenes físicos y alguno de estos volúmenes físicos falla y no está disponible, entonces el volumen lógico no se podrá arrancar y no será utilizable.

==== Volúmenes en espejo ====

LVM ofrece soporte para volúmenes  ''en espejo'', los cuales ofrecen tolerancia ante fallos en caso de que un disco deje de funcionar. Al contrario que RAID1, no se obtiene ningún beneficio en el rendimiento. Todas las lecturas y escrituras se envían a un solo lado del espejo.

Para supervisar el estado del espejo, LVM necesita guardar un ''registro''. Se recomienda (y en algunos casos es obligatorio) colocar este registro en un volumen físico que no contenga a ninguno de los volúmenes lógicos en espejo. Hay tres tipos de registros que se pueden utilizar para los espejos:

# '''Disk''' es el tipo de registro por defecto. Todos los cambios se registran en unas extensiones de metadatos extra que gestiona LVM. Si falla un dispositivo entondes los cambios se guardan en el registro hasta que se pueda restaurar el espejo.
# '''Mirror''' son registro '''disk''' que se mantienen en espejo.
# '''Core''' espejo registra el estado del espejo únicamente en memoria. LVM tendrá que reconstruir el espejo cada vez que se active. Este tipo es muy útil para espejos temporales.

Para crear un volumen lógico con un espejo sencillo, pase el argumento  ''-m 1'' (para seleccionar un espejo estándar) y opicionalmente  ''--mirrorlog'' para seleccionar una tipo particular de registro:

{{RootCmd|lvcreate -m 1 --mirrorlog mirror -l 40%VG --nosync -n lvol1 vg0}}

La opción <tt>-m 1</tt> le indica a LVM que cree un espejo (adicional) por lo que se requieren dos volúmenes físicos. La opción <tt>--nosync</tt> es una optimización, sin ella LVM intentará sincronizar el espejo copiando sectores vacíos de un volumen lógico al otro.

Es posible crear un espejo de un volumen lógico ya existente:

{{RootCmd|lvconvert -m 1 -b vg0/lvol1}}

La opción ''-b'' hace la conversión en segundo plano por lo que esto puede llevar cierto tiempo.

Para eliminar un espejo, defina el número de espejos (de nuevo) a cero:

{{RootCmd|lvconvert -m0 vg0/lvol1}}

Si alguna parte del espejo no está disponible (normalmente debido a que ha fallado el disco que contiene el volumen físico), el grupo de volumen tendrá que ser activado en modo degradado:

{{RootCmd|vgchange -ay --partial vg0}}

En la primera escritura, LVM detectará que el espejo está roto. La directriz por defecto ("eliminar") es reducir o romper automáticamente el espejo en el número de partes disponibles. Un espejo de tres vías con un volumen físico no disponible se reducirá a un volumen lineal normal. Si el fallo es transitorio y el volumen físico vuelve a estar disponible después de que LVM haya roto el espejo, el volumen lógico en espejo tendrá que ser creado de nuevo sobre éste. 

Para recuperar el espejo, se debe eliminar el volumen físico del grupo de volumen y se necesita añadir un volumen físico de reemplazo (o si el grupo de volumen tiene un volumen físico disponible, se puede crear en él). A continuación se puede recrear el espejo con <tt>lvconvert</tt> y en este punto se puede eliminar el volumen físico antiguo del grupo de volumen:

{{RootCmd|vgextend vg0 /dev/sdc1
|lvconvert -b -m 1 --mirrorlog disk vg0/lvol1
|vgreduce --removemissing vg0}}

Es posible hacer que LVM recree el espejo con extensiones disponibles en un volumen físico diferente si un lado falla. Para hacer esto, defina <code>mirror_image_fault_policy</code> a ''allocate'' en {{Path|lvm.conf}}.

==== Espejos delgados ====

No es posible (aún) crear una reserva delgada o un volumen delgado en espejo. Es posible si se crea en primer lugar un volumen lógico en espejo normal y a continuación convertir el volumen lógico en una reserva delgada con <code>lvconvert</code>. Se necesitan dos volúmenes lógicos: uno para la reserva delgada y otro para los metadatos delgados. El proceso de conversión los mezclará en un único volumen lógico.

{{Warning/es|Se necesita la versión de LVM 2.02.98 o posterior para que esto funcione correctamente. Las versiones anteriores no pueden hacerlo o causarán un fallo de segmente y corromperán el grupo de volumen. Además, la conversión de un espejo en una reserva delgada ¡'''Destruye''' todos los datos existentes en el espejo!}}

{{RootCmd|lvcreate -m 1 --mirrorlog mirrored -l40%VG -n thin_pool vg0
|lvcreate -m 1 --mirrorlog mirrored -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg0/thin_meta}}

==== Seccionado (RAID0) ====

En lugar de un volumen lineal en el que múltiples volúmenes físicos contiguos se añaden, es posible crear un volumen ''seccionado'' o ''RAID0'' para mejorar el rendimiento. Esto causará que las asignaciones de espacio de almacenamiento se alternen entre los volúmenes físicos disponibles.

Para crear un volumen seccionado sobre tres volúmenes físicos:

{{RootCmd|lvcreate -i 3 -l 20%VG -n lvol1_stripe vg0|output=<pre>
Using default stripesize 64.00 KiB
</pre>}}

La opción -i indica sobre cuántos volúmenes físicos se realizará el seccionado.

Es posible reflejar un conjunto seccionado. Las opciones -i y -m se pueden combinar para crear un espejo seccionado:

{{RootCmd|lvcreate -i 2 -m 1 -l 10%VG vg0}}

Esto crea un conjunto seccionado de dos volúmenes lógicos y hace el espejo en dos volúmenes físicos diferentes obteniendo así un total de cuatro volúmenes físicos. Un conjunto seccionado ya existente se puede reflejar con la orden <code>lvconvert</code>.

Una reserva delgada se puede seccionar como cualquier otro volumen lógico. Todos los volúmenes lógicos creados en la reserva heredan esos ajustes. No los especifique manualmente cuando cree un volumen delgado.

No es posible seccionar un volumen ya existente ni redimensionar las secciones entre más o menos volúmenes físico ni convertirlo a un volumen lineal o de otro nivel RAID. Un conjunto seccionado se puede reflejar. Es posible extender un conjunto seccionado sobre volúmenes físicos adicionales pero se deben añadir en múltiplos del tamaño original del conjunto seccionado (el cual añadirá de forma efectiva y lineal un nuevo conjunto seccionado).

==== Espejos (RAID1) ====

Al contrario que RAID0 que consiste en volúmenes seccionados, RAID1 los refleja, sin embargo se implementa de forma diferente a los espejos LVM originales. Bajo RAID1 las lecturas se reparten a través de los volúmenes físicos mejorando el rendimiento. Los fallos en los espejos RAID1 no causan bloqueo de E/S ya que LVM no necesita romperlo a la hora de la escritura.

Cualquier lugar en el que se pueda utilizar un espejo LVM, se puede utilizar un espejo RAID1 en su lugar. Es posible hacer que LVM cree espejos RAID1 en lugar de espejos normales definiendo ''mirror_segtype_default'' a ''raid1'' en {{Path|lvm.conf}}.

Para crear un volumen lógico con un solo espejo:

{{RootCmd|lvcreate -m 1 --type raid1 -l 40%VG --nosync -n lvm_raid1 vg0}}

Observe la diferencia a la hora de crear un espejo: No se especifica ''mirrorlog'' debido a que los volúmenes lógicos RAID1 no tienen un registro espejo explícito, se incluyen en el volumen lógico.

Es posible convertir un volumen lógico existente a RAID1:

{{RootCmd|lvconvert -m 1 --type raid1 -b vg0/lvol1}}

Para eliminar un espejo RAID 1, defina el número de espejos a cero:

{{RootCmd|lvconvert -m0 vg0/lvm_raid1}}

Si alguna parte del RAID1 no está disponible (normalmente debido a que ha fallado el disco que contiene el volumen físico), el grupo de volumen tendrá que ser activado en modo degradado:

{{RootCmd|vgchange -ay --partial vg0}}

Al contrario que en los espejos LVM, la escritura NO rompe el espejo. Si el fallo es solo transitorio y el volumen físico que falla vuelve a entrar en funcionamiento, LVM sincronizará de nuevo el espejo copiando los segmentos que están desactualizados en lugar del volumen lógico completo. Si el fallo es permanente, entonces se necesita eliminar del grupo de volumen el volumen físico que ha fallado y añadir un volumen físico de reemplazo (o si el grupo de volumen dispone de algún volumen físico libre, se puede crear en un volumen físico distinto). El espejo se puede reparar con <code>lvconvert</code>, y el antiguo volumen físico se puede eliminar del grupo de volumen:

{{RootCmd|vgextend vg0 /dev/sdc1
|lvconvert --repair -b vg0/lvm_raid1
|vgreduce --removemissing vg0}}

==== RAID1 delgado ====

No es posible (aún) crear una reserva delgada o un volumen delgado RAID 1. Es posible crear una reserva delgada RAID 1 creando en primer lugar un volumen lógico en espejo y a continuación convertirlo en una reserva delgada con <tt>lvconvert</tt>. Se necesitan dos volúmenes lógicos: una para la reserva delgada y otro para los metadatos delgados. El proceso de conversión los mezclará en un único volumen lógico.

{{Warning/es|Se necesita una versión de LVM igual o posterior a la 2.02.98 para que esto funcione. Las versiones anteriores no podrán funcionar o causarán un fallo de segmento y corromperán el grupo de volumen. Además, la conversión de RAID1 a una reserva delgada ¡'''Destruirá'' todos los datos del espejo!}}

{{RootCmd|lvcreate -m 1 --type raid1 -l40%VG -n thin_pool vg0
|lvcreate -m 1 --type raid1 -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg00/thin_meta}}

==== Seccionado con paridad (RAID4 y RAID5) ====

{{Note/es|El seccionado con paridad requiere al menos tres volúmenes físicos.}}

RAID0 no es tolerante a fallos. Si cualquiera de los volúmenes físicos falla, entonces el volumen lógico es inutilizable. Al añadir una sección de paridad a RAID0 el volumen lógico puede seguir funcionando si algún volumen físico falta. Se puede añadir un nuevo volumen físico para restaurar la tolerancia a fallos.

Los conjuntos seccionados con paridad se pueden implementar de dos formas: RAID4 y RAID5. En RAID4, todas las secciones que contienen la información de paridad se almacenan en lel mismo volumen físico. Esto puede dar lugar a un cuello de botella ya que todas las escrituras afectan también a ese volumen físico. Con RAID5 los datos de paridad se distribuyen homogéneamente por todos los volúmenes físicos de modo que ninguno de ellos es un cuello de botella. Debido a esto, RAID4 no es una implementación común y se considera obsoleta y anticuada. En la práctica todos los conjuntos seccionados con paridad son RAID5.

{{RootCmd|lvcreate --type raid5 -l 20%VG -i 2 -n lvm_raid5 vg0}}

Únicamente los volúmenes físicos de datos se especifican con la opción -i, LVM añade uno de forma automática para la paridad. Por lo tanto para un volumen RAID5 de tres volúmenes físicos, se pasa ''-i 2'' y no ''-i 3''.

Cuando un volumen físico falla, entonces se necesita levantar el grupo de volumen en modo degradado:

{{RootCmd|vgchange -ay --partial vg0}}

El volumen funcionará correctamente en este momento. Sin embargo esto degrada el array a RAID0 hasta que se añada un volumen físico de reemplazo. Normalmente el rendimiento no se ve afectado mientras el array está degradado aunque se necesita recalcular los datos perdidos partiendo de la paridad. Esto requiere únicamente simples operaciones XOR entre los bloques de paridad y los datos restantes. La sobrecarga no es representativa comparada con la E/S del disco.

Para reparar el RAID5:

{{RootCmd|lvconvert --repair vg0/lvm_raid5 |vgreduce --removemissing vg0}}

En RAID5 también es posible reemplazar un volumen físico en funcionamiento:

{{RootCmd|lvconvert --replace /dev/sdb1 vg0/lvm_raid5
|vgreduce vg0 /dev/sdb1}}

Las mismas restricciones de los conjuntos seccionados se aplican a los conjuntos seccionados con paridad. No es posible habilitar seccionado con paridad en un volumen ya existente ni redimensionar las secciones con paridad a lo largo de más (o menos) volúmenes físicos, tampoco convertirlo a otro nivel RAID o volumen lineal. Se puede crear un espejo de un conjunto seccionado con paridad. Es posible extender un conjunto seccionado con paridad a lo largo de volúmenes físicos adicionales pero se deben añadir en múltiplos del conjunto seccionado con paridad original (lo cual añadirá de forma efectiva una nueva sección lineal con paridad).

==== Volúmenes lógicos RAID5 delgados ====

No es posible (aún) crear reservas delgadas o volúmenes delgados que sean conjuntos con paridad (RAID5). Es posible crear una reserva delgada RAID5 creando en primer lugar un volumen lógico RAID5 normal y a continuación convertirlo en una reserva delgada con <code>lvconvert</code>. Se necesitan dos volúmenes lógicos: una para la reserva delgada y otro para los metadatos delgados. El proceso de conversión los mezclará en un único volumen lógico.

{{Warning/es|Se necesita una versión de LVM igual o posterior a la 2.02.98 para que esto funcione. Las versiones anteriores no podrán funcionar o causarán un fallo de segmento y corromperán el grupo de volumen. Además, la conversión de RAID5 a una reserva delgada ¡'''Destruirá'' todos los datos del volumen lógico!}}

{{RootCmd|lvcreate --type raid5 -i 2 -l20%VG -n thin_pool vg0
|lvcreate --type raid5 -i 2 -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg00/thin_meta}}

==== Seccionado con doble paridad (RAID6) ====

{{Note/es|RAID6 requiere al menos cinco volúmenes físicos.}}

RAID6 es similar a RAID5, sin embargo RAID6 puede sobrevivir '''dos''' fallos en volúmenes físicos ofreciendo así mayor tolerancia a los fallos que RAID5 a costa de volúmenes físicos extra. 

{{RootCmd|lvcreate --type raid6 -l 20%VG -i 3 -n lvm_raid6 vg00}}

Al igual que raid5, la opción -i se utiliza para especificar el número de volúmenes físicos para seccionar excluyendo los dos volúmenes físicos para la paridad. Por tanto para un volumen RAID6 con cinco volúmenes físicos se debe pasar ''-i 3'' y no ''-i 5''.

La recuperación en RAID6 es la misma que en RAID5.

{{Note/es|Al contrario que en RAID5 en el que el recálculo del bloque de paridad es bajo comparado con la E/S del disco, en RAID6 esto no es del todo cierto. RAID6 utiliza dos secciones para la paridad: Una sección se calcula de la misma forma que en RAID5 (un simple XOR). La segunda sección de paridad es más difícil de calcular, lea [https://www.kernel.org/pub/linux/kernel/people/hpa/raid6.pdf|raid6 (pdf)] para obtener más información.}}

==== Volúmenes lógicos RAID6 delgados ====

No es posible (aún) crear una reserva delgada o un volumen delgado RAID6. Es posible crear una reserva delgada RAID6 creando en primer lugar un volumen lógico RAID6 y a continuación convertirlo en una reserva delgada con <code>lvconvert</code>. Se necesitan dos volúmenes lógicos: una para la reserva delgada y otro para los metadatos delgados. El proceso de conversión los mezclará en un único volumen lógico.

{{Warning/es|Se necesita una versión de LVM igual o posterior a la 2.02.98 para que esto funcione. Las versiones anteriores no podrán funcionar o causarán un fallo de segmento y corromperán el grupo de volumen. Además, la conversión de RAID6 a una reserva delgada ¡'''Destruirá'' todos los datos del volumen lógico!}}

{{RootCmd|lvcreate --type raid6 -i 2 -l20%VG -n thin_pool vg0
|lvcreate --type raid6 -i 2 -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg0/thin_meta}}

==== RAID10 LVM ====

{{Note/es|RAID10 necesita al menos cuatro volúmenes físicos. También, la sintaxis LVM necesita que el número de volúmenes físicos sea múltiplo del número de secciones y espejos, incluso aunque el formato de RAID10 no lo necesite}}

RAID10 is a combination of RAID0 and RAID1. It is more powerful than RAID0+RAID1 as the mirroring is done at the stripe level instead of the logical volume level, and therefore the layout doesn't need to be symmetric. A RAID10 volume can tolerate at least a single missing physical volume, and possibly more.

{{Note|LVM currently limits RAID10 to a single mirror.}}

{{RootCmd|lvcreate --type raid10 -l 1020 -i 2 -m 1 --nosync -n lvm_raid10 vg0}}

Both the ''-i and -m'' options are specified: ''-i'' is the number of stripes and ''-m'' is the number of mirrors. Two stripes and 1 mirror requires 4 physical volumes.

==== Thin RAID10 ====

No es posible (aún) crear una reserva delgada o un volumen delgado RAID10. Es posible crear una reserva delgada RAID10 creando en primer lugar un volumen lógico RAID10 normal y a continuación convertirlo en una reserva delgada con <code>lvconvert</code>. Se necesitan dos volúmenes lógicos: una para la reserva delgada y otro para los metadatos delgados. El proceso de conversión los mezclará en un único volumen lógico.

{{Warning/es|La conversión de un RAID10 a una reserva delgada ¡'''Destruye'' todos los datos del volumen lógico!}}

{{RootCmd|lvcreate -i 2 -m 1 --type raid10 -l 1012 -n thin_pool vg0
|lvcreate -i 2 -m 1 --type raid10 -l 6 -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg0/thin_meta}}

== Experimenting with LVM ==

It is possible to experiment with LVM without using real storage devices. To accomplish this, loopback devices are created.

First make sure to have the loopback module loaded. 

{{RootCmd|modprobe -r loop && modprobe loop max_part{{=}}63}}

{{Note|If loopback support is built into the kernel, then use <code>loop.max_part{{=}}63</code> as boot option.}}

Next configure LVM to not use [[udev]] to scan for devices:

{{File|/etc/lvm/lvm.conf|Disabling udev in LVM config|<pre>
obtain_device_list_from_udev = 0
</pre>}}

{{Important|This is for testing only, make sure to change the setting back when dealing with real devices since it is much faster to use udev!}}

Create some image files which will become the storage devices. The next example uses five files for a total of about ~10GB of real hard drive space:

{{RootCmd|mkdir /var/lib/lvm_img
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm0.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm1.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm2.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm3.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm4.img bs{{=}}1024 seek{{=}}2097152}}

Compruebe qué dispositivos de bucle están disponibles:

{{RootCmd|losetup -a}}

Asumiendo que todos los dispositivos de bucle están disponibles, cree a continuación los dispositivos:

{{RootCmd|losetup /dev/loop0 /var/lib/lvm_img/lvm0.img
|losetup /dev/loop1 /var/lib/lvm_img/lvm1.img
|losetup /dev/loop2 /var/lib/lvm_img/lvm2.img
|losetup /dev/loop3 /var/lib/lvm_img/lvm3.img
|losetup /dev/loop4 /var/lib/lvm_img/lvm4.img}}

Los dispositivos {{Path|/dev/loop[0-4]}} están disponibles ahora para su uso como cualquier otro disco duro del sistema (y así es perfecto para volúmenes físicos).

{{Note/es|En el siguiente reinicio, todos los dispositivos de bucle se liberarán y se puede eliminar el directorio {{Path|/var/lib/lvm_img}}.}}

== Troubleshooting ==

LVM has a few features that already provide some level of redundancy. However, there are situations where it is possible to restore lost physical volumes or logical volumes.

=== vgcfgrestore utility ===

By default, on any change to a LVM physical volume, volume group, or logical volume, LVM2 create a backup file of the metadata in {{Path|/etc/lvm/archive}}. These files can be used to recover from an accidental change (like deleting the wrong logical volume). LVM also keeps a backup copy of the most recent metadata in {{Path|/etc/lvm/backup}}. These can be used to restore metadata to a replacement disk, or repair corrupted metadata.

To see what states of the volume group are available to be restored (partial output to improve readability):

{{RootCmd|vgcfgrestore --list vg00|output=<pre>
 File:         /etc/lvm/archive/vg0_00042-302371184.vg
 VG name:      vg0
 Description:  Created *before* executing 'lvremove vg0/lvm_raid1'
 Backup Time:  Sat Jul 13 01:41:32 201
</pre>}}

==== Recuperar un volumen lógico eliminado por accidente ====

Asumiendo que el volumen lógico ''lvm_raid1'' se eliminó accidentalmente del grupo de volumen ''vg0'', es posible recuperarlo del siguiente modo:

{{RootCmd|vgcfgrestore -f /etc/lvm/archive/vg0_00042-302371184.vg vg0}}

{{Important/es|<tt>vgcfgrestore</tt> restaura únicamente los metadatos LVM metadata ''no'' los datos dentro del volumen lógico. Sin embargo, <code>pvremove</code>, <code>vgremove</code> y <code>lvremove</code> únicamente destruyen los metadatos, dejando los datos intactos. si se define <code>issue_discards</code> en {{Path|/etc/lvm/lvm.conf}}, entonces estos comandos ''destruyen'' los datos.}}

==== Replacing a failed physical volume ====

Es posible realizar un "reemplazo" real y recrear los metadatos en el nuevo volumen físico para que sea el mismo que el volumen físico antiguo.

{{RootCmd|vgdisplay --partial --verbose|output=<pre>
 --- Physical volumes ---
 PV Name               /dev/loop0
 PV UUID               iLdp2U-GX3X-W2PY-aSlX-AVE9-7zVC-Cjr5VU
 PV Status             allocatable
 Total PE / Free PE    511 / 102

 PV Name               unknown device
 PV UUID               T7bUjc-PYoO-bMqI-53vh-uxOV-xHYv-0VejBY
 PV Status             allocatable
 Total PE / Free PE    511 / 102
</pre>}}

La línea importante aquí es el UUID "unknown device" (dispositivo desconocido). 

{{RootCmd|pvcreate --uuid T7bUjc-PYoO-bMqI-53vh-uxOV-xHYv-0VejBY --restorefile /etc/lvm/backup/vg0 /dev/loop1|output=<pre>
 Couldn't find device with uuid T7bUjc-PYoO-bMqI-53vh-uxOV-xHYv-0VejBY.
 Physical volume "/dev/loop1" successfully created</pre>}}

This recreates the physical volume metadata, but not the missing logical volume or volume group data on the physical volume.

{{RootCmd|vgcfgrestore -f /etc/lvm/backup/vg0 vg0|output=<pre>
 Restored volume group vg0
</pre>}}

This now reconstructs all the missing metadata on the physical volume, including the logical volume and volume group data. However it doesn't restore the data, so the mirror is out of sync.

{{RootCmd|vgchange -ay vg0|output=<pre>
 device-mapper: reload ioctl on failed: Invalid argument
 1 logical volume(s) in volume group "vg0" now active
</pre>}}

{{RootCmd|lvchange --resync vg0/lvm_raid1|output=<pre>
Do you really want to deactivate logical volume lvm_raid1 to resync it? [y/n]: y
</pre>}}

This will resync the mirror. This works with RAID 4,5 and 6 as well. 

=== Deactivating a logical volume ===

It is possible to deactivate a logical volume with the following command:

{{RootCmd|umount /dev/vg0/lvol1 |lvchange -a n /dev/vg0/lvol1}}

It is not possible to mount the logical volume anywhere before it gets reactivated:

{{RootCmd|lvchange -a y /dev/vg0/lvol1}}

== Recursos externos ==

* [http://sourceware.org/lvm2/ LVM2 sourceware.org]
* [http://tldp.org/HOWTO/LVM-HOWTO/ LVM tldp.org]
* [http://sources.redhat.com/lvm2/wiki/ LVM2 Wiki redhat.com]


[[Category:Core system]]
