{{Lowercase title}}

An '''initramfs''' is a filesystem loaded in memory during the early boot process. Therefore, some utilities, kernel modules, scripts, ..., may be used during the boot process. The initramfs usually takes care of mounting important file systems (by loading the proper kernel modules and drivers) such as {{Path|/usr}} or {{Path|/var}}, preparing the {{Path|/dev}} file structure, etc. Users who use an encrypted file system will also have the initramfs ask them for the passphrase before it can mount the file systems. When the file systems are mounted, control is passed on to '''init''' which then takes care of further starting all necessary services and booting up the remainder of the system.

{{InfoBox stack
|{{InfoBox wikipedia|Initrd|header=true}}
}}



== Initramfs concepts ==

<!--T:4-->
For many users, an initramfs system is of no concern. Their system uses a simple partitioning schema with no exotic drivers or setups (like encrypted file systems), so the Linux kernel is entirely capable to hand over control to the {{c|init}} binary on their system. But for many systems, an initramfs is mandatory. 

<!--T:5-->
The key concept to understanding what an initramfs is (or is needed for) is to understand how the Linux boot process works, even in a high-level approach. 

=== Linux boot process === <!--T:6-->

<!--T:7-->
Once the Linux kernel has control over the system (which it gets after being loaded by the boot loader), it prepares its memory structures and drivers. It then hands over control to an application (usually {{c|init}}) whose task it is to further prepare the system and make sure that, at the end of the boot process, all necessary services are running and the user is able to log on. The {{c|init}} application does that by launching, among other services, the {{c|udev}} daemon who will further load up and prepare the system based on the detected devices. When {{c|udev}} is launched, all remaining file systems that have not been mounted are mounted, and the remainder of services is started. 

<!--T:8-->
For systems where all necessary files and tools reside on the same file system, the {{c|init}} application can perfectly control the further boot process. But when multiple file systems are defined (or more exotic installations are done), this might become a bit more tricky: 

<!--T:9-->
* When the {{Path|/usr}} partition is on a separate file system, tools and drivers that have files stored within {{Path|/usr}} cannot be used unless {{Path|/usr}} is available. If those tools are needed to make {{Path|/usr}} available, then we cannot boot up the system.

<!--T:10-->
* If the root file system is encrypted, then the Linux kernel will not be able to find the {{c|init}} application, resulting in an unbootable system.

<!--T:11-->
The solution for this problem has since long been to use an ''initrd'' (initial root device). 

=== The initial root disk === <!--T:12-->

<!--T:13-->
The '''initrd''' is an in-memory disk structure (ramdisk) that contains the necessary tools and scripts to mount the needed file systems ''before'' control is handed over to the {{c|init}} application on the root file system. The Linux kernel triggers the setup script (usually called {{Path|linuxrc}} but that name is not mandatory) on this root disk, which prepares the system, switches to the real root file system and then calls {{c|init}}. 

<!--T:14-->
Although the initrd method is all that is needed, it had a few drawbacks: 

<!--T:15-->
* It is a full-fledged block device, requiring the overhead of an entire file system; it has a fixed size. Choosing an initrd that is too small and all needed scripts cannot fit. Make it too big and memory will be wasted.

<!--T:16-->
* Because it is a real, static device it consumes cache memory in the Linux kernel and is prone to the memory and file management methods in use (such as paging), this makes initrd greater in memory consumption.

<!--T:17-->
To resolve these issues the initramfs was created.

=== The initial ram file system === <!--T:18-->

<!--T:19-->
An '''initramfs''' is an initial ram file system based on ''tmpfs'' (a size-flexible, in-memory lightweight file system), which also did not use a separate block device (so no caching was done and all overhead mentioned earlier disappears). Just like the initrd, it contains the tools and scripts needed to mount the file systems before the {{c|init}} binary on the real root file system is called. These tools can be decryption abstraction layers (for encrypted file systems), logical volume managers, software raid, bluetooth driver based file system loaders, etc. 

<!--T:20-->
The content of the initramfs is made by creating a cpio archive. {{c|cpio}} is an old (but proven) file archiver solution (and its resulting archive files are called cpio files). cpio is definitely comparable to the {{c|tar}} archiver. The choice of {{c|cpio}} here was because it was easier to implement (code-wise) and supported (back then) device files which {{c|tar}} could not. 

<!--T:21-->
All files, tools, libraries, configuration settings (if applicable), etc. are put into the cpio archive. This archive is then compressed using the {{c|gzip}} utility and stored alongside the Linux kernel. The boot loader will then offer it to the Linux kernel at boot time so the kernel knows an initramfs is needed. 

<!--T:22-->
Once detected, the Linux kernel will create a tmpfs file system, extract the contents of the archive on it, and then launch the {{Path|init}} script located in the root of the tmpfs file system. This script then mounts the real root file system (after making sure it can mount it, for instance by loading additional modules, preparing an encryption abstraction layer, etc.) as well as vital other file systems (such as {{Path|/usr}} and {{Path|/var}} ). 

<!--T:23-->
Once the root file system and the other vital file systems are mounted, the {{Path|init}} script from the initramfs will switch the root towards the real root file system and finally call the {{Path|/sbin/init}} binary on that system to continue the boot process.

== Building an initramfs ==

Several ways :
* [[Early Userspace Mounting]]
* [[Dracut]]
* [[Genkernel]]
* [[Mkinitcpio]]
* [https://github.com/tokiclover/mkinitramfs-ll mkinitramfs-ll], [https://github.com/tokiclover/bar-overlay sys-kernel/mkinitramfs-ll]
* [[Custom Initramfs]]

== See also ==

* [[Handbook:Parts/Installation/Kernel#Optional: Building an initramfs]]

[[Category:Initramfs]]
