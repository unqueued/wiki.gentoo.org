{{lowercase title}}
{{InfoBox stack
|{{InfoBox homepage|https://untroubled.org/daemontools-encore|header=true}}
|{{InfoBox github|bruceg/daemontools-encore}}
|{{InfoBox package|sys-process/daemontools-encore}}
|{{InfoBox ohloh}}
}}

Daemontools-encore is [[Article description::a backwards compatible, enhanced version of [[Daemontools|Daniel J. Bernstein's daemontools package]], written by Bruce Guenter.]] A summary of the features that have been added to daemontools-encore is available [https://untroubled.org/daemontools-encore/CHANGES here].

__TOC__

== Installation ==

=== USE flags ===

{{USEflag|package=sys-process/daemontools-encore}}

=== Emerge ===

{{Emerge|sys-process/daemontools-encore}}

{{Important|Daemontools-encore is currently on the testing branch. Users with systems on the stable branch will need to add the package to {{Path|/etc/portage/package.accept_keywords}} (if using Portage) to be able to install it. While it is generally not advised to mix packages of stable and testing branches, this package only depends on the [[libc]], so in this case it should be safe}}

== Configuration ==

=== Environment variables ===

* <var>SUPERVISEDIR</var> - Name of the directory used by {{C|supervise}} for its control files. If it is an absolute pathname, it will be suffixed by all programs that use it with the path to the corresponding service directory, with all slashes ('/') replaced with colons (':'). Otherwise, it is taken relative to the corresponding service directory. For example, if <var>SUPERVISEDIR</var> is set to {{Path|/run/supervise}}, a {{C|supervise}} process running for service directory {{Path|/service/foo}} will place its control files in directory {{Path|/run/supervise/service:foo}}.
* <var>SOFTLIMIT_ALLBYTES</var> - Alternative to {{C|softlimit}}'s <code>-a</code> option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_COREBYTES</var> - Alternative to {{C|softlimit}}'s <code>-c</code> option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_DATABYTES</var> - Alternative to {{C|softlimit}}'s <code>-d</code> option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_FILEBYTES</var> - Alternative to {{C|softlimit}}'s <code>-f</code> option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_LOCKEDBYTES</var> - Alternative to {{C|softlimit}}'s <code>-l</code> option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_MEMBYTES</var> - Alternative to {{C|softlimit}}'s <code>-m</code> option for specifying the corresponding soft limits.
* <var>SOFTLIMIT_OPENFILES</var> - Alternative to {{C|softlimit}}'s <code>-o</code> option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_PROCS</var> - Alternative to {{C|softlimit}}'s <code>-p</code> option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_RSSBYTES</var> - Alternative to {{C|softlimit}}'s <code>-r</code> option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_STACKBYTES</var> - Alternative to {{C|softlimit}}'s <code>-s</code> option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_CPUSECS</var> - Alternative to {{C|softlimit}}'s <code>-t</code> option for specifying the corresponding soft limit.

=== Files ===

* {{Path|/service}} - Location of the scan directory when using [[OpenRC]], [[#svscanboot|{{C|svscanboot}}]] or [[#supervise-scripts|{{C|svscan-add-to-inittab}}]].

=== Service ===

==== OpenRC ====

See [[#openrclaunch|here]]

== Usage ==

[[Daemontools|Bernstein daemontools]] and daemontools-encore implement ''process supervision'': programs that run as long-lived processes, such as a server program, can be supervised by being run as a child process of a ''supervisor''. The supervisor can detect if the process, also called ''the service'' or ''the daemon'' in this context, has unexpectedly terminated, e.g. because it exited with an error status or was killed by a signal, and automatically restart it. The supervisor also provides a reliable interface for controlling both the supervised process and itself, to send signals to the process, and to query status information about it.

All this is based on standard POSIX features: a process reliably knows its child's process ID (PID), because it is the return value of the <code>fork()</code> call that creates it, knows when its child terminates, because it is notified with a <code>SIGCHLD</code> signal, and can obtain exit status information when it happens using the <code>wait()</code> or <code>waitpid()</code> calls.

For more information information about process supervision see <ref>D. J. Bernstein, [https://cr.yp.to/daemontools/faq/create.html#why daemontools FAQ], which includes one about the benefits of process supervision. Retrieved on April 23rd, 2017.</ref> <ref>Gerrit Pape, [http://smarden.org/runit/benefits.html runit benefits], which includes a short description of process supervision in general. Retrieved on April 23rd, 2017.</ref> <ref>Laurent Bercot, [https://www.skarnet.org/software/s6/overview.html s6 overview], which contains an introduction to process supervision. Retrieved on April 23rd, 2017.</ref>.

=== Service directories ===

The program that implements the supervisor features in Bernstein daemontools and daemontools-encore is {{C|supervise}}. Supervision for a single process is configured  using a ''service directory'' (or ''servicedir''). A servicedir is an ordinary directory containing at least one executable file named {{Path|run}}. It can also contain an optional, regular file named {{Path|down}}. The (absolute or relative to the working directory) pathname of this directory is then passed as an argument to {{C|supervise}}. This however is not supposed to be done directly by the user, but to happen indirectly as a consequence of running {{C|svscan}}.

When {{C|supervise}} is invoked, it changes its working directory to the specifed servicedir, and executes the contained {{Path|run}} file as a child process, unless there is also a {{Path|down}} file, or, for daemontools-encore only, a {{Path|start}} file (see [[#startstopnotify|the start, stop and notify files, and the daemontools-encore extended service state]]). Daemontools-encore's {{C|supervise}} also makes the child process the leader of a new session using the POSIX <code>setsid()</code> call, unless the servicedir contains a regular file named {{Path|no-setsid}}. In that case, the child process will run in {{C|supervise}}'s session instead. Making the child process a session leader with Bernstein daemontools requires using the {{C|pgrphack}} program inside {{Path|run}} (see [[#changingstate|supervised process execution state changes]]). If {{C|supervise}} is invoked with a servicedir that contains a {{Path|down}} file, the {{Path|run}} file won't be executed, but the service can be started later with the {{C|svc}} program (see [[#controlling|controlling supervised processes]]). The contents of the {{Path|down}} and {{Path|no-setsid}} files are ignored, so they are usually empty.

{{Path|run}} can have any file format that the kernel knows how to execute, but is usually a shell script that performs some sort of initialization, and then calls the real program intended to be supervised, using the shell's {{C|exec}} builtin utility. This allows the program to run without creating a new process, so it will have the same PID as the {{Path|run}} script, and from there on become the supervised process. {{C|supervise}} waits for 1 second between two child process spawns, so that it does not loop too quickly if the process exits immediately. The daemontools-encore version of {{C|supervise}} also has special behaviour when it receives a signal: if it receives a <code>SIGTERM</code> signal, it behaves as if an {{C|svc -dx}} command naming the corresponding servicedir had been used (see [[#controlling|controlling supervised processes]]), if it receives a <code>SIGTSTP</code> signal, it sends a <code>SIGSTOP</code> signal to the supervised process, as if an {{C|svc -p}} command naming the corresponding servicedir had been used, and if it receives a <code>SIGCONT</code> signal, it sends a <code>SIGCONT</code> signal to the supervised process, as if an {{C|svc -c}} command naming the corresponding servicedir had been used.

Programs that fail to adhere to certain design criteria, including those that use <code>fork()</code> in order to "put the daemon into the background" <ref>Jonathan de Boyne Pollard, [https://jdebp.eu/FGA/unix-daemon-design-mistakes-to-avoid.html Mistakes to avoid when designing Unix d√¶mon programs]. Retrieved on May 5th, 2017.</ref>, might not be able to be supervised. Sometimes programs can meet those criteria if passed certain options (e.g. a 'run in the foreground' option) on invocation.

An example of a minimal (and simplistic) service directory for a hypothetical {{C|test-daemon}} program:
{{Cmd|ls -l|
output=<pre>total 4
-rwxr-xr-x 1 user user 27 May  5 12:00 run</pre>}}

{{FileBox|lang=bash|filename=run|1=#!/bin/sh
exec test-daemon}}

The {{C|supervise}} program keeps control files in a subdirectory of the servicedir, also named {{Path|supervise}}. If this subdirectory doesn't exist when supervise is invoked, it will be created, as well as any of its missing files. If the servicedir contains a {{Path|supervise}} symbolic link to directory instead of a subdirectory, {{C|supervise}} will follow it and use the linked-to directory for its control files. Daemontools-encore also allows setting the name of this control directory via the <var>SUPERVISEDIR</var> environment variable, see [[#Environment_variables|environment variables]].

{{Important|The service directory can be in a read-only filesystem, but files contained in the {{Path|supervise}} directory must writable by the effective user of the corresponding {{C|supervise}} process. For Bernstein daemontools, and for daemontools-encore when some of the control files are missing, the directory itself must also be writable. So in this case a symbolic link to an existing directory in a read-write filesystem must be used.}}

Service directories can also optionally contain a subdirectory or symbolic link to directory named {{Path|log}}, which can be used for setting up a dedicated logger (see [[#logging|logging]]).

For further details about the {{C|supervise}} program and service directories, please consult the {{C|supervise}} man page.

Service directory with a {{Path|supervise}} subdirectory:
{{Cmd|ls -l|
output=<pre>total 8
-rwxr-xr-x 1 user user   27 May  5 12:00 run
drwx------ 2 user user 4096 May  5 12:00 supervise</pre>}}

{{Path|supervise}} subdirectory contents:
{{Cmd|ls -l supervise|
output=<pre>total 4
prw------- 1 user user  0 May  5 12:00 control
-rw------- 1 user user  0 May  5 12:00 lock
prw------- 1 user user  0 May  5 12:00 ok
-rw-r--r-- 1 user user 18 May  5 12:00 status</pre>}}

=== The scan directory and supervision tree ===

Bernstein daemontools and daemontools-encore allow supervising a set of processes running in parallel using the {{C|svscan}} program and a ''scan directory'' (or ''scandir''). A scan directory is a directory that contains service directories and/or symbolic links to services directories. Invoking {{C|svscan}} with the (absolute or relative to the working directory) path of the scandir as its first argument (and only argument for Bernstein daemontools' {{C|svscan}}) launches one child {{C|supervise}} process for each contained service directory with a name that does not start with a dot ('.'). If {{C|svscan}} is called with no arguments, it assumes the working directory is the scandir, otherwise it changes its working directory to the specified scandir.

Every 5 seconds, {{C|svscan}} rereads the scan directory (i. e. performs a ''scan''), launching {{C|supervise}} processes for each new servicedir it finds, or old servicedir for which it finds its {{C|supervise}} process has exited. {{C|svscan}} acts as a supervisor for every {{C|supervise}} child, just like {{C|supervise}} does for its child process. This arrangement of processes is called the ''supervision tree''. The root of the supervision tree is {{C|svscan}}, so it is designed to be robust and to cope with {{C|supervise}} processes exiting unexpectedly, being killed, or being unable to start. The leaves of the supervision tree are the processes that correspond to the service directories in the scandir.

Example scan directory containing three service directories:
{{Cmd|ls -l|
output=<pre>total 12
drwxr-xr-x 3 user user 4096 May  5 12:00 test-service1
drwxr-xr-x 3 user user 4096 May  5 12:00 test-service2
drwxr-xr-x 3 user user 4096 May  5 12:00 test-service3</pre>}}

{{FileBox|lang=bash|filename=test-service1/run|1=#!/bin/sh
exec test-daemon1}}

{{FileBox|lang=bash|filename=test-service2/run|1=#!/bin/sh
exec test-daemon2}}

{{FileBox|lang=bash|filename=test-service3/run|1=#!/bin/sh
exec test-daemon3}}

Resulting supervision tree when {{C|svscan}} is run on this scandir as a background process in an interactive shell, assuming it is the working directory (i.e. launched with <kbd>svscan &</kbd>):
{{Cmd|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre>  PID  PPID  PGRP EUSER    COMMAND
...
 1777  1764  1777 user -bash
 2047  1777  2047 user  \_ svscan
 2048  2047  2047 user      \_ supervise test-service3
 2053  2048  2047 user      |   \_ test-daemon3
 2049  2047  2047 user      \_ supervise test-service1
 2052  2049  2047 user      |   \_ test-daemon1
 2050  2047  2047 user      \_ supervise test-service2
 2051  2050  2047 user          \_ test-daemon2
...</pre>}}

{{Important|Since processes in a supervision tree are created using the POSIX <code>fork()</code> call, all of them will inherit {{C|svscan}}'s enviroment, which, in the context of this example, is the user's login shell environment. If {{C|svscan}} is launched in some other way (see later), the environment will likely be completely different. This must be taken into account when trying to debug a supervision tree with an interactive shell.}}
{{anchor|startstopnotify}}
=== The start, stop and notify files, and the daemontools-encore extended service state ===

Daemontools-encore service directories can contain executable files named {{Path|start}}, {{Path|stop}} and {{Path|notify}}. The {{Path|run}} file is optional for daemontools-encore, but either {{Path|start}} or {{Path|run}} must exist in the servicedir. If there is a {{Path|start}} file and it is executable, it will be executed as a child process instead of {{Path|run}} when {{C|supervise}} is invoked, and also when an {{C|svc -u}} or {{C|svc -o}} command is used to manually start the service (see [[#controlling|controlling supervised processes]]). If the {{Path|start}} process exits with a an exit code of 0, {{C|supervise}} will then execute the {{Path|run}} file just like Bernstein daemontools' {{C|supervise}}. {{Path|start}} can be used to perform some kind of first time-only initialization for the program intended to be supervised.

If the supervised process exits with an exit code of '''100''', or if the {{Path|start}} process is killed by a signal or exits with a nonzero exit code, {{C|supervise}} enters the ''failed'' extended state (see later) and does not restart the service. If the service is manually stopped with an {{C|svc -d}} command or, after an {{C|svc -o}} command is used, the supervised or {{Path|start}} process terminated and the conditions for entering the failed state are not met, {{C|supervise}} enters the ''stopped'' extended state. In stopped state, if there is a {{Path|stop}} file in the servicedir and it is executable, {{C|supervise}} will execute it as a child process. {{Path|stop}} can be used to perform some kind of last time-only cleanup for the program intended to be supervised, or for the {{Path|start}} process. If the {{Path|stop}} process exits with an exit code of '''100''', {{C|supervise}} will also enter the failed state, otherwise it will remain in stopped state.

If there is a {{Path|notify}} file, {{C|supervise}} will execute it as a child process each time a {{Path|start}}, {{Path|run}} or {{Path|stop}} process is spawned or terminates for whatever reason, so it can be used to perfom some action after one or more of those events. {{C|supervise}} invokes {{Path|notify}} with four arguments: the first one is either '''start''', '''run''' or '''stop''', indicating which process caused {{Path|notify}} to be invoked (or '''log''' [[#logging|in certain cases]]), the second one is either '''start''', '''exit''' or '''killed''', indicating that the corresponding process was spawned, exited or was killed by a signal, respectively, the third one is the process ID of the corresponding process, and the fourth one is the exit code or signal number, as determined by POSIX <code>waitpid()</code>, or '''0''' if the second argument is '''start'''. So, for example, {{Path|notify}} could be used to perfom cleanup actions each time the supervised process terminates, possibly depending on its exit status information, by checking that its first argument is '''run''' and its second argument is other than '''start''', behaving like a [[runit]] or [[s6]] {{Path|finish}} file.

The effect of the {{Path|no-setsid}} file applies to all {{Path|start}}, {{Path|stop}}, {{Path|run}} and {{Path|notify}} processes.

Because Bernstein daemontools' {{C|supervise}} only executes a {{Path|run}} file, the corresponding service can only be in two states: '''up''' if {{C|supervise}} has a child process, or '''down''' if it doesn't. Daemontools-encore's {{C|supervise}}, on the other hand, can have at any given time either a {{Path|start}}, {{Path|run}}, {{Path|stop}} or {{Path|notify}} child process, so for compatibility with Bernstein daemontools, when the service state is queried with the {{C|svstat}} program (see [[#controlling|controlling supervised processes]]), an up or down state will still be displayed, but also an additional ''extended'' state: '''starting''', '''started''', '''running''', '''stopping''', '''stopped''' or '''failed'''.

* Extended state ''starting'' will be displayed after {{C|supervise}} launches a {{Path|start}} process.
* Extended state ''started'' will be displayed after the {{Path|start}} process exits successfully, if there is no {{Path|run}} file. In started state, {{C|supervise}} does nothing but wait for commands sent with the {{C|svc}} program.
* Extended state ''running'' will be displayed after {{C|supervise}} launches a {{Path|run}} process.
* Extended state ''stopping'' will be displayed after {{C|supervise}} sends its child process a <code>SIGTERM</code> signal followed by a <code>SIGCONT</code> signal to make it stop, until the process dies.
* Otherwise, either extended state ''stopped'' or extended state ''failed'' will be displayed. In failed state, or in stopped state after the {{Path|stop}} process has exited, {{C|supervise}} does nothing but wait for commands sent with the {{C|svc}} program.

Whether a {{Path|notify}} process is currently running or not does not modify the service state, it will be whatever it was immediatly before {{Path|notify}} was executed.

Service directories using {{Path|down}}, {{Path|start}}, {{Path|stop}} and {{Path|notify}} files:
{{Cmd|ls -l|
output=<pre>total 8
drwxr-xr-x 3 user user 4096 May  6 12:00 test-service1
drwxr-xr-x 3 user user 4096 May  6 12:00 test-service2</pre>}}

{{Cmd|ls -l *|
output=<pre>test-service1:
total 4
-rw-r--r-- 1 user user  0 May  6 12:00 down
-rwxr-xr-x 1 user user 28 May  6 12:00 run

test-service2:
total 16
-rwxr-xr-x 1 user user 163 May  6 12:00 notify
-rwxr-xr-x 1 user user  24 May  6 12:00 run
-rwxr-xr-x 1 user user  24 May  6 12:00 start
-rwxr-xr-x 1 user user  24 May  6 12:00 stop</pre>}}

{{FileBox|lang=bash|filename=test-service1/run|1=#!/bin/sh
exec test-daemon1}}

{{FileBox|lang=bash|filename=test-service2/run|1=#!/bin/sh
exec sleep 20}}

{{FileBox|lang=bash|filename=test-service2/start|1=#!/bin/sh
exec sleep 10}}

{{FileBox|lang=bash|filename=test-service2/stop|1=#!/bin/sh
exec sleep 10}}

{{FileBox|lang=bash|filename=test-service2/notify|1=#!/bin/sh
case $2 in
start) echo "'$1' started (PID $3)";;
exit) echo "'$1' (PID $3) exited with $4";;
killed) echo "'$1' (PID $3) was killed by signal $4";;
esac}}

Resulting supervision tree:
{{Cmd|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre>  PID  PPID  PGRP EUSER    COMMAND
...
 1777  1764  1777 user -bash
 2114  1777  2114 user  \_ svscan
 2115  2114  2114 user      \_ supervise test-service1
 2116  2114  2114 user      \_ supervise test-service2
 2146  2116  2146 user          \_ sleep 20
...</pre>}}

Note that since {{Path|test-service1}} has a {{Path|down}} file, the corresponding {{C|supervise}} process has no children.

Messages printed to {{C|svscan}}'s standard output (stdout) by the {{Path|notify}} script:
{{Cmd|svscan scan &|
output=<pre>'start' started (PID 2253)
'start' (PID 2253) exited with 0
'run' started (PID 2258)
'run' (PID 2258) exited with 0
'run' started (PID 2287)</pre>}}

Sending a <code>SIGTERM</code> signal to the {{Path|run}} process (PID 2287):
{{Cmd|kill 2287|
output=<pre>'run' (PID 2287) was killed by signal 15
'run' started (PID 2295)</pre>}}

Manually stopping service ''test-service2'':
{{Cmd|svc -d scan/test-service2|
output=<pre>'run' (PID 2295) was killed by signal 15
'stop' started (PID 2300)
'stop' (PID 2300) exited with 0</pre>}}
{{anchor|logging}}
=== Logging ===

==== The multilog program ====

If a servicedir '''S''' in the scan directory contains a subdirectory or symbolic link to directory named {{Path|log}}, {{C|svscan}} will launch two {{C|supervise}} processes in parallel, one executing '''S'''{{Path|/run}} as a child process, and the other executing '''S'''{{Path|/log/run}} with its standard input (stdin) connected to '''S'''{{Path|/run}}'s standard output (stdout) by a pipe. If any of the two processes or their {{C|supervise}} parents terminates and is restarted, the same pipe is reused so that no data is lost. This allows per-service logging by having '''S'''{{Path|/log/run}} execute a ''logger program''.  Bernstein daemontools and daemontools-encore provide such a logger: the {{C|multilog}} program. This type of logging works for programs that send messages to their standard error (stderr).

Daemontools-encore's {{C|supervise}} allows {{Path|log}} to be an ''executable file'' instead of subdirectory or symlink to directory. In this case, the same {{C|supervise}} process will supervise both the 'main' service and the logger, and maintain the pipe between then. This is similar to having a subdirectory with a {{Path|run}} file equivalent to the {{Path|log}} file, and no {{Path|start}} or {{Path|stop}} files. The {{Path|notify}} file of the 'main' service will be invoked with '''log''' as its first argument when the {{Path|log}} process starts, exits or gets killed by a signal. The {{Path|down}} and {{Path|no-setsid}} files of the 'main' service also apply to the {{Path|log}} process in this case.

{{C|multilog}} is invoked as <kbd>multilog arg1 arg2 arg3 ...</kbd>, and expects to read a sequence of newline-terminated lines of text from its standard input. The arguments ''arg1'', ''arg2'', ''arg3'', ... make up a ''logging script'' that tells {{C|multilog}} what to do. Each argument specifies an ''action'', actions are carried out sequentially in argument order.

The simplest form of {{C|multilog}} invocation is <kbd>multilog dir</kbd>, where ''dir'' starts with a dot ('.') or a slash ('/'): it is interpreted as a pathname specifying an automatically rotated ''logging directory'' (or ''logdir''). The logdir contains control files used by {{C|multilog}}, a ''current log file'' named {{Path|current}}, and may also contain a set of old log files. The current log file contains a selection of the lines read by {{C|multilog}}, possibly modified by other actions specified in the logging script, and old log files are produced by ''rotations'': when {{Path|current}} approaches a certain maximum size, its contents are copied to a another file, after some optional processing, and {{Path|current}} is emptied. Old log file have names beginning with '@', continuing with a timestamp in [https://cr.yp.to/libtai/tai64.html external TAI64N format] showing when the file was finished, and ending with either '''.s''' or '''.u'''. The .s files are files that have been completely processed and safely written, i.e. files produced by a complete rotation. The .u files, if any, are files created by an incomplete rotation, they are not completely processed and may be truncated. Rotations respect line boundaries, i.e. old log files will always contain whole lines. Also, to avoid indefinite accumulation of old log files, if, after completing a rotation, their number exceeds a certain value, {{C|multilog}} deletes the oldest log file (the file with the smallest TAI64N timestamp). The default maximum size of a {{Path|current}} file is 99999 bytes, and the default maximum number of old log files is 10. A rotation can be forced by sending {{C|multilog}} a <code>SIGALRM</code> signal. If it is running as a supervised process, the {{C|svc}} program can be used to do that (see [[#controlling|controlling supervised processes]]).

Some other actions recognized by {{C|multilog}} in a logging script are:

* '''+''' (plus sign) and '''-''' (minus sign) followed by a ''pattern'': By default, {{C|multilog}} logs all the lines read from its standard input without modifications; these actions allow selection and deselection of lines, respectively, based on the specified pattern. Because all lines are initially selected, '''+''' actions are only effective after a '''-''' action that deselects some lines first. The pattern uses the shell's notation for matching strings, and must match whole lines (i.e. partial matching doesn't count), with the following restrictions:
** Berstein daemontools' {{C|multilog}} only treats asterisks ('*') as special characters in the pattern: they match any string, including the null string, that does not include the next character in pattern instead of the POSIX behaviour of matching the greatest possible number of characters that still allows the remainder of the pattern to match the line, and cannot be escaped with a backslash ('\').
** Daemontools-encore's {{C|multilog}} can switch between Bernstein daemontools behaviour and using the full range of patterns allowed by POSIX <code>fnmatch()</code>, including backslash escaping. The latter is more flexible at the expense of being less efficient. At the start of logging script action processing, Bernstein daemontools match mode is selected.
*** An '''F''' action selects <code>fnmatch()</code> match mode for all subsequent '''+''' and '''-''' actions until the next mode-changing action in the logging script.
*** An '''S''' action selects Bernstein daemontools match mode for all subsequent '''+''' and '''-''' actions until the next mode-changing action in the logging script.
* '''t''': prepends each logged line with '@', followed by a timestamp in [https://cr.yp.to/libtai/tai64.html external TAI64N format] (printed as 24 lowercase hexadecimal characters), and a space. It must be specified as the first action, and any subsequent '''+''' and '''-''' actions match against lines '''with''' the prepended timesptamp. Daemontools-encore also supports a '''T''' action, which must also be the first one, that prepends an accustamp-style timestamp and a space instead ({{C|accustamp}} was a program shipped with Bernstein daemontools that was eventually dropped).
* '''s''' followed by an integer: sets the maximum size of the {{Path|current}} file to the specified value (in bytes), for all subsequent actions in the logging script that specify a logdir, until the next '''s''' action.
* '''n''' followed by an integer: sets the maximum number of old log files to the specified value, for all subsequent actions in the logging script that specify a logdir, until the next '''n''' action.
* '''!''' (exclamation mark) followed by a string ''args'': sets a ''processor'' for all subsequent actions in the logging script that specify a logdir, until the next '''!''' action. A processor allows performing some processing of the contents of {{Path|current}} log files during a rotation; {{C|multilog}} performs the equivalent of an <kbd>sh -c 'args'</kbd> command for every logdir, and feeds the resulting processes the contents of their corresponding {{Path|current}} file on its standard input, so ''args'' should specify a program and its arguments, if any. The .s or .u file produced as a result will contain that program's output. For example, a <kbd>multilog '!processor-script arg1 arg2' ./dirname</kbd> command makes {{C|multilog}} launch a processor with the equivalent of a <kbd>sh -c 'processor-script arg1 arg2'</kbd> command during a rotation on logdir {{Path|dirname}} in {{C|multilog}}'s working directory. If an executable file named {{C|processor-script}} is found via <var>PATH</var> search, this will invoke it with arguments <code>arg1 arg2</code> and feed it the contents of {{Path|dirname/current}} on its standard input.

For details about all actions supported {{C|multilog}}, and about the protocol used for communication between {{C|multilog}} and the processor specified in an '''!''' action, please consult the {{C|multilog}} man page.

{{FileBox|filename=input|title=Sample input for the {{C|multilog}} program|1=info: Message 1
warning: Message 2
error: Message 3
error: Message 4
warning: Message 5
info: Message 6}}

{{Cmd|cat input {{!}} multilog '-*' '+warning: *' ./log1 '+error: *' ./log2|ls -l|
output=<pre>drwx------ 2 user user 4096 May  6 12:00 log1
drwx------ 2 user user 4096 May  6 12:00 log2</pre>}}

{{Cmd|ls -l log*|
output=<pre>log1:
total 4
-rwxr--r-- 1 user user 38 May  6 12:00 current
-rw------- 1 user user  0 May  6 12:00 lock
-rw-r--r-- 1 user user  0 May  6 12:00 state

log2:
total 4
-rwxr--r-- 1 user user 72 May  6 12:00 current
-rw------- 1 user user  0 May  6 12:00 lock
-rw-r--r-- 1 user user  0 May  6 12:00 state</pre>}}

When there's no {{C|multilog}} process running on a logdir, the {{Path|current}} file has the executable by user flag set.

{{FileBox|filename=log1/current|1=warning: Message 2
warning: Message 5}}

{{FileBox|filename=log2/current|1=warning: Message 2
error: Message 3
error: Message 4
warning: Message 5}}

Note that the {{Path|log2/current}} file also contains the warning messages. This shows that actions that aren't '''+''' or '''-''' do not affect the currently selected lines, so warning messages selected by action '+warning: *' stay selected after processing action './log1'. To only have the error messages in {{Path|log2/current}}, a '-*' action should have immediatly preceded the '+error: *' action.

Service directory {{Path|test-service}} containing a logger:
{{Cmd|ls -l|
output=<pre>total 8
drwxr-xr-x 2 user user 4096 May  6 12:00 log
-rwxr-xr-x 1 user user  110 May  6 12:00 run</pre>}}

{{Cmd|ls -l log|
output=<pre>total 4
-rwxr-xr-x 1 user user 40 May  6 12:00 run</pre>}}

{{FileBox|lang=python|filename=/home/user/test-daemon|title=Python script generating messages on its stderr|1=#!/usr/bin/python3
from time import sleep
from sys import stderr
for i in range(1,30):
   print("Message", i, file=stderr, flush=True)
   sleep(2)}}

{{FileBox|lang=bash|filename=test-service/run|1=#!/bin/sh
exec /home/user/test-daemon 2>&1}}

{{FileBox|lang=bash|filename=test-service/log/run|1=#!/bin/sh
exec multilog t ../../../logs}}

Note that since {{C|supervise}} makes the service directory its working directory, the relative pathname in {{C|multilog}}'s invocation results in the logging directory being placed wherever the scan directory is.

Resulting supervision tree:
{{Cmd|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre>  PID  PPID  PGRP EUSER    COMMAND
...
 1777  1764  1777 user -bash
 2702  1777  2702 user  \_ svscan
 2703  2702  2702 user      \_ supervise test-service
 2706  2703  2702 user      |   \_ /usr/lib/python-exec/python3.6/python3 /home/user/test-daemon
 2704  2702  2702 user      \_ supervise log
 2705  2704  2702 user          \_ multilog t ../../../logs
...</pre>}}

Contents of the {{Path|logs}} logging directory:
{{Cmd|ls -l ../logs|
output=<pre>total 20
-rwxr--r-- 1 user user  361 May  6 17:20 @40000000590e2ffe0bf16944.s
-rwxr--r-- 1 user user 2202 May  6 17:22 @40000000590e30941e642c9c.s
-rw-r--r-- 1 user user 1101 May  6 17:23 current
-rw------- 1 user user    0 May  6 17:19 lock
-rw-r--r-- 1 user user    0 May  6 17:19 state</pre>}}

This logdir contains two old log files and, since {{C|multilog}} is running, the {{Path|current}} file has its executable by user flag cleared.

{{Cmd|cat ../logs/current|
output=<pre>@40000000590e30983973bda4 Message 1
@40000000590e309a39b02a64 Message 2
@40000000590e309c3a353ccc Message 3
@40000000590e309e3a93b84c Message 4
@40000000590e30a03aec8a94 Message 5
@40000000590e30a23b3bbc04 Message 6
@40000000590e30a5003a28ac Message 7
@40000000590e30a70097255c Message 8
@40000000590e30a900bc221c Message 9
@40000000590e30ab0100ff04 Message 10</pre>}}

The TAI64N timestamps can be shown in human-readable form with {{C|tai64nlocal}}, for further details please consult the respective man page.

{{Cmd|cat ../logs/current {{!}} tai64nlocal|
output=<pre>2017-05-06 17:22:38.963886500 Message 1
2017-05-06 17:22:40.967846500 Message 2
2017-05-06 17:22:42.976567500 Message 3
2017-05-06 17:22:44.982759500 Message 4
2017-05-06 17:22:46.988580500 Message 5
2017-05-06 17:22:48.993770500 Message 6
2017-05-06 17:22:51.003811500 Message 7
2017-05-06 17:22:53.009905500 Message 8
2017-05-06 17:22:55.012329500 Message 9
2017-05-06 17:22:57.016842500 Message 10</pre>}}

==== The readproctitle program ====

The {{C|readproctitle}} program expects to read a sequence of newline-terminated lines of text from its standard input, and saves them to an automatically rotated log it keeps in ''memory''. The log can be seen in the output of the {{C|ps}} utility. The number of characters displayed is specified by {{C|readproctitle}}'s arguments.

{{C|readproctitle}} is invoked as <kbd>readproctitle arg1 arg2 ... argn dots</kbd>. The arguments ''arg1'', ''arg2'', ..., ''argn'' can be anything, they are shown as-is in the output of {{C|ps}}, and can used for displaying some kind of heading that introduces the log. The last argument, ''dots'', must be at least five dots ('.'), and its length specifies the number of characters the log kept in memory will have. In the output of {{C|ps}}, {{C|readproctitle}}'s last shown argument will be the contents of the log up to that time instead of ''dots''. Characters shift to the left as {{C|readproctitle}} reads new lines of text, and older characters are discarded to keep the log of constant size. Therefore, the {{C|ps}} utility will show each time the most recent data. For further details, please consult the {{C|readproctitle}} man page.

{{FileBox|lang=bash|filename=doit|title=Shell script generating output|1=#!/bin/sh
echo Print this message!
sleep 10
echo Second message
sleep 10}}

{{Cmd|./doit {{!}} readproctitle Log header: ........................ &|
ps x -o pid,args|
output=<pre>  PID COMMAND
...
 2860 readproctitle Log header: ....Print this message!
...</pre>}}

After enough seconds have elapsed:
{{Cmd|ps x -o pid,args|
output=<pre>  PID COMMAND
...
 2860 readproctitle Log header: ...sage! Second message
...</pre>}}

The best known use of {{C|readproctitle}} is in the {{C|svscanboot}} script included in Bernstein daemontools and daemontools-encore.

{{anchor|loggingchain}}
==== The logging chain ====

A supervision tree where all leaf processes have a logger can be arranged into what the author of [[s6]] calls ''the logging chain'' <ref>Laurent Bercot, [https://www.skarnet.org/software/s6/s6-log.html#loggingchain the logging chain], Retrieved on May 1st, 2017.</ref>, which he considers to be technically superior to the traditional syslog-based centralized approach <ref>Laurent Bercot, [https://www.skarnet.org/software/s6/s6-log.html#diesyslogdiedie on the syslog design], Retrieved on May 1st, 2017.</ref>.

Since processes in a supervision tree are created using the POSIX <code>fork()</code> call, each of them will inherit {{C|svscan}}'s standard input, output and error. A logging chain arrangement using Bernstein daemontools and daemontools-encore is as follows:

* Leaf processes should normally have a logger, so their standard output and error connect to their logger's standard input. Therefore, all their messages are collected and stored in dedicated, per-service logs by their logger. Some programs might need to be invoked with special options to make them send messages to their standard error, and redirection of standard error to standard output (i.e. '''2>&1''' in a shell script) must be performed in the servicedir's {{Path|run}} file.
* Leaf processes with a controlling terminal are an exception: their standard input, output and error connect to the terminal.
* {{C|supervise}}, the loggers, and leaf processes that exceptionally don't have logger for some reason, inherit their standard input, output and error from {{C|svscan}}, so their messages are sent wherever the ones from {{C|svscan}} are.
* Leaf processes that still unavoidably report their messages using <code>syslog()</code> have them collected and logged by a (possibly supervised) syslog server.

==== Specifying a logger for {{C|svscan}} ====

Daemontools-encore's {{C|svscan}} allows the pathname of a service directory to be passed as a second argument after the scan directory's pathname. If this argument is present, {{C|svscan}} will launch one {{C|supervise}} process for the specified directory, and connect its standard output and error to the corresponding supervised process' standard input by a pipe. This makes it possible to set up a logger for {{C|svscan}} in the same way a logger can be set up for the leaf processes of the supervision tree.

{{Note|If the service directory of {{C|svscan}}'s logger is specified as a relative pathname, it is interpreted as relative to the scan directory}}

{{anchor|changingstate}}
=== Supervised process execution state changes ===

Bernstein's daemontools and daemontools-encore provide a set of tools for modifying a supervised process' execution state. These tools employ a technique called ''chain loading'' by some people, and  ''Bernstein chaining'' by others. A program ''prog1'' designed to use chain loading is invoked as <kbd>prog1 arg11 ... arg1n prog2 arg21 ... arg2n</kbd>, where ''prog2'' is the name of another program. When ''prog1'' is invoked, it performs some action based on arguments ''arg11'', ..., ''arg1n'', and then executes ''prog2'' without creating a new process, using one of the POSIX <code>exec...()</code> calls. Arguments ''arg21'', ..., ''arg2n'' are not interpreted by ''prog1'' and are passed along to ''prog2''.

If ''prog2'' is also designed to use chain loading, some of those arguments might in turn be the name of a third program ''prog3'' and its corresponding arguments, which will be executed after ''prog2'' completes its task. As a consequence, it is possible to build a chain of programs that will run one after the other as a single process, therefore preserving the process ID (PID), which makes the technique suitable for the {{Path|run}} script of a service directory. The final one in such a chain of programs would be the real program intended to be supervised.

The tools provided by Bernstein's daemontools and daemontools-encore to change a process' execution state are:

* {{C|envdir}}: runs another program with environment modified according to files in a specified directory.
* {{C|envuidgid}}: runs another program with environment variables indicating a specified account's user ID and group ID
* {{C|pgrphack}}: runs a program in a new session (using POSIX <code>setsid()</code>).
* {{C|setlock}}: runs another program with a file locked (using Linux <code>flock()</code> on Gentoo).
* {{C|setuidgid}}: runs another program under a specified account's user ID and group ID. Requires root privileges.
* {{C|softlimit}}: runs another program with new soft resource limits (using POSIX <code>setrlimit()</code>). These limits are set via options specified as {{C|softlimit}}'s arguments. Daemontools-encore also allows setting those limits via <var>SOFTLIMIT_*</var> environment variables, applied at {{C|softlimit}} invocation; see [[#Environment_variables|environment variables]].

For further details on these tools please consult their respective man page.

The directory supplied to the {{C|envdir}} program is called an ''environment directory'' (or ''envdir''). Each file in the envdir controls a single environment variable. If the file is empty, and a variable with the same name as the file exists in the process' environment, it is removed from it. If the file is nonempty, the contents of its first line become the value of a new environment variable with the same name as the file. If the variable existed before {{C|envdir}}'s invocation, it is first removed from the environment, and then readded with the new value. Enviroment variables not referred to by a file in the envdir remain unchanged.

{{FileBox|lang=bash|filename=run|title=Example ''run'' script with process state change|1=#!/bin/sh
exec \
softlimit -o 5 \
setuidgid daemon \
test-daemon 2>&1}}

This script executes program {{C|test-daemon}} with effective user ''daemon'' and the maximum number of open file descriptors set to 5. This is the same as if {{C|test-daemon}} performed a <code>setrlimit(RLIMIT_NOFILE, &rl)</code> call itself with <code>rl.rlim_cur</code> set to 5, provided that value does not exceed the corresponding hard limit. As in previous examples, the redirection of stderr to stdout allows setting up a dedicated logger for {{C|test-daemon}}.

Example service directory with an enviroment directory {{Path|env}}:
{{Cmd|ls -l|
output=<pre>total 8
drwxr-xr-x 2 root root 4096 May  7 12:00 env
-rwxr-xr-x 1 root root  125 May  7 12:00 run</pre>}}

{{Cmd|ls -l env|
output=<pre>total 4
-rw-r--r-- 1 root root 2 May  7 12:00 SOFTLIMIT_OPENFILES</pre>}}

{{FileBox|lang=bash|filename=run|1=#!/bin/sh
exec \
envdir env \
envuidgid daemon \
softlimit \
test-daemon 2>&1}}

{{FileBox|filename=env/SOFTLIMIT_OPENFILES|1=5}}

This script adds variables <var>UID</var>, <var>GID</var> and <var>SOFTLIMIT_OPENFILES</var> to {{Ctest-daemon}}'s environment, the first two set to the user ID and group ID of account ''daemon'' via {{C|envuidgid}}, and the last one via the enviroment directory {{Path|env}}, which is used by the {{C|softlimit}} invocation to set the maximum number of open file descriptors to 5, provided it is the daemontools-encore version of that program. Environment variables <var>UID</var> and <var>GID</var> could be used by {{C|test-daemon}} to drop privileges.

{{anchor|controlling}}
=== Controlling supervised processes ===

Bernstein daemontools and daemontools-encore provide two programs for controlling a supervised process and to query status information about it: {{C|svc}} and {{C|svstat}}, respectively.

The {{C|svc}} program accepts a set of service directory pathnames and options that specify what to do. Some of these options are:

* <code>-d</code> (''down''): If the supervised process is running, send it a <code>SIGTERM</code> signal followed by a <code>SIGCONT</code> signal. The {{Path|run}} file won't be reexecuted after that, and, for daemontools-encore, the {{Path|stop}} file will be executed, if present. This is the standard way to manually stop a supervised process. If the process is not running (e.g. because it has a {{Path|down}} file or after a previous {{C|svc -d}} command) this is a no operation.
* <code>-u</code> (''up''): If the supervised process is not running, start it by executing its {{Path|run}} file, or, for daemontools-encore, its {{Path|start}} file, if present. If the process is running, this is mostly a no operation, except that it cancels the effect of a previous {{C|svc -o}} command. This is the standard way to manually start a supervised process that has a {{Path|down}} file, or that has been previously stopped with an {{C|svc -d}} command.
* <code>-o</code> (''once''): If the supervised process is not running, start it by executing its {{Path|run}} file, or, for daemontools-encore, its {{Path|start}} file, if present, but don't restart it if terminates. This still allows the process to be monitored and to be reliably sent signals, but it won't actually be supervised. If the process is running, just ask {{C|supervise}} to not restart it if it terminates. The effect of this option can be cancelled by a subsequent {{C|svc -u}} command, and restored by another {{C|svc -o}} command.
* <code>-x</code> (''exit''): Asks {{C|supervise}} to exit if the supervised process terminates. This is mostly useful for tearing down a supervision tree: after sending {{C|svscan}} a <code>SIGTERM</code>, an <kbd>svc -dx ${scandir}/*</kbd> command can terminate all supervised processes, because of the <code>-d</code> option, and make their {{C|supervise}} parents exit afterwards, because of the <code>-x</code> option. If an {{C|svc -dx}} command is used when {{C|svscan}} is still running, after the servicedir's {{C|supervise}} process exits, it will just be restarted on {{C|svscan}}'s next periodic scan.

Other {{C|svc}} options allow reliably sending signals to a supervised process. For further details, please consult the {{C|svc}} man page. In particular, {{C|svc -a}} be used to send a <code>SIGALRM</code> signal to a supervised {{C|multilog}} process to force it to perform a rotation.

The {{C|svstat}} program accepts a set of service directory pathnames. Its output is intended to be displayed on a user interface or logged, not to be fed as input to a program for parsing. It displays whether the supervised process is running ('up') or not ('down'), its process ID (PID) if it is up, how long it has been in the current state, whether its current up or down status matches the presence or absence of a {{Path|down}} file in the servicedir ('normally up' or 'normally down'), and whether it is transitioning to the desired state or already there ('want up' or 'want down'). The daemontools-encore version also displays the service's extended state (see [[#startstopnotify|the start, stop and notify files, and the daemontools-encore extended service state]]), and if there is a {{Path|log}} executable file, it will print a second line of output with information about the logger process. If an <code>-l</code> option is passed {{C|svstat}}, the information about the logger process will be suppressed from the output, and if an <code>-L</code> option is passed to {{C|svstat}}, ''only'' information about the logger process will be displayed, or the message 'no log service' if the servicedir has no {{Path|log}} executable file. For further details, please consult the {{C|svstat}} man page.

Bernstein daemontools and daemontools-encore also provide the {{C|svok}} program, that accepts a service directory pathname, and exits with an exit code of 0 if there is a {{C|supervise}} process successfully running for that directory, and an exit code of '''100''' if there isn't. It produces no output if no error was encountered, otherwise it displays an error message and exits with an exit code of '''111'''. Finally, daemontools-encore provides the {{C|svup}} program, that accepts a service directory pathname, and exits with an exit code of 0 if there is a {{C|supervise}} process successfully running for that directory and the service's extended state is either '''started''' or '''running''', and an exit code of '''100''' if the service is in any other state, or if there is no {{C|supervise}} process. It produces no output if no error was encountered, otherwise it displays an error message and exits with an exit code of '''111'''. If there is a {{Path|log}} executable file, {{C|svup}} exits with an exit code of 0 only if ''both'' the 'main' service and the logger are in started or running state. If an <code>-l</code> option is passed to {{C|svup}}, only the 'main' service will be checked, and if an <code>-L</code> option is passed to {{C|svup}}, only the logger will be checked (and the exit code will be '''100''' if the servicedir has no {{Path|log}} executable file). For further details about {{C|svok}} and {{C|svup}}, please consult their respective man page.

{{Important|For the operation performed by {{C|svc}} to be allowed, its effective user must have write access to the {{Path|supervise/control}} FIFO in the service directory, otherwise, it will fail with an "access denied" error. For the operation performed by {{C|svstat}} and {{C|svup}} to be allowed, its effective user must have write access to the {{Path|supervise/ok}} FIFO and read access to the {{Path|supervise/status}} file in the service directory, otherwise, it will fail with an "access denied" error. Using {{C|svc}} or {{C|svstat}} on a service directory for which no {{C|supervise}} process is running will result in a "supervise not running" error.}}

Service directories with a {{Path|log}} subdirectory and a {{Path|log}} executable file:
{{Cmd|ls -l|
output=<pre>total 8
drwxr-xr-x 3 user user 4096 Jan 28 12:00 test-service1
drwxr-xr-x 2 user user 4096 Jan 28 12:00 test-service2</pre>}}

{{Cmd|ls -l * test-service1/log|
output=<pre>test-service1:
total 8
drwxr-xr-x 2 user user 4096 Jan 28 12:00 log
-rwxr-xr-x 1 user user   32 Jan 28 12:00 run

test-service1/log:
total 4
-rwxr-xr-x 1 user user 41 Jan 28 12:00 run

test-service2:
total 8
-rwxr-xr-x 1 user user 38 Jan 28 12:00 log
-rwxr-xr-x 1 user user 32 Jan 28 12:00 run</pre>}}

{{FileBox|lang=bash|filename=test-service1/run|1=#!/bin/sh
exec test-daemon 2>&1}}

{{FileBox|lang=bash|filename=test-service1/log/run|1=#!/bin/sh
exec multilog ../../../logdir1}}

{{FileBox|lang=bash|filename=test-service2/run|1=#!/bin/sh
exec test-daemon 2>&1}}

{{FileBox|lang=bash|filename=test-service2/log|1=#!/bin/sh
exec multilog ../../logdir2}}

Resulting supervision tree:
{{Cmd|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre> PID  PPID  PGRP EUSER    COMMAND
...
2284  2122  2284 user     -bash
2353  2284  2353 user      \_ svscan
2354  2353  2353 user          \_ supervise test-service1
2357  2354  2357 user          |   \_ test-daemon
2355  2353  2353 user          \_ supervise log
2359  2355  2359 user          |   \_ multilog ../../../logdir1
2356  2353  2353 user          \_ supervise test-service2
2358  2356  2358 user              \_ multilog ../../logdir2
2360  2356  2360 user              \_ test-daemon
...</pre>}}

Note that there are separate {{C|supervise}} processes (with PIDs 2354 and 2355) for ''test-service1'' and its logger, but a single {{C|supervise}} process (with PID 2356) supervising both ''test-service2'' and its logger.

{{Cmd|svstat *|
output=<pre>test-service1: up (pid 2357) 157 seconds, running
test-service2: up (pid 2360) 156 seconds, running
test-service2 log: up (pid 2358) 157 seconds, running</pre>}}

{{Cmd|svstat -l *|
output=<pre>test-service1: up (pid 2357) 170 seconds, running
test-service2: up (pid 2360) 169 seconds, running</pre>}}

{{Cmd|svstat -L *|
output=<pre>test-service1: no log service
test-service2 log: up (pid 2358) 182 seconds, running</pre>}}

To get the status of the {{Path|test-service1}}'s logger, the pathname of the corresponding {{Path|log}} subdirectory must be specified to {{C|svstat}}:
{{Cmd|svstat test-service1/log|
output=<pre>test-service1/log: up (pid 2359) 241 seconds, running</pre>}}

=== Starting the supervision tree ===

In a supervision tree arrangement each process supervises its children, therefore the robustness of the supervision tree ultimately relies on the {{C|svscan}} process. So the problem of how to supervise {{C|svscan}} itself arises, as well as what to do with {{C|svscan}}'s messages in a [[#loggingchain|logging chain]].

{{anchor|openrclaunch}}
==== From OpenRC ====

Gentoo's packaging of Bernstein daemontools and daemontools-encore provides an [[OpenRC]] service script for running {{C|svscan}}, also named {{Path|svscan}}. If this service script is used, the scan directory will be {{Path|/service}}. Thus, {{C|svscan}} can be started when the machine boots by adding it to an OpenRC runlevel using {{C|rc-update}}:
{{RootCmd|rc-update add svscan default}}

Or it can also be started manually:
{{RootCmd|rc-service svscan start}}

{{Warning|The service script launches {{C|svscan}} using OpenRC's {{C|start-stop-daemon}} program, so it will run unsupervised, and with its standard output and error redirected to {{Path|/dev/null}} by default, so supervision tree messages other than those from leaf processes that have a dedicated logger will be lost.}}

{{anchor|svscanboot}}
==== The svscanboot script ====

Bernstein daemontools and daemontools-encore provide a script called {{C|scvscanboot}}, that can be spawned and supervised by [[sysvinit]] ({{Package|sys-apps/sysvinit}}) by adding a <code>respawn</code> line for it in {{Path|/etc/inittab}}. {{C|scvscanboot}} is a shell script that launches an {{C|svscan}} process and a {{C|readproctitle}} process, with the former's standard output connected to the latter's standard input by a pipe, and every other standard descriptor redirected to {{Path|/dev/null}}. The enviroment will be empty, except for the <var>PATH</var> variable, set to a known value in the script. The scan directory will be {{Path|/service}}.

Used in this way, the supervision tree becomes rooted in process 1, which cannot die without crashing the machine. Also, {{C|svscan}}'s messages will go to {{C|readproctitle}}, so they can be seen using the {{C|ps}} utility.

Gentoo users wanting to use {{C|svscanboot}} will need to manually edit {{Path|/etc/inittab}}, and then call {{C|telinit}}

{{FileBox|filename=/etc/inittab|1=SV:12345:respawn:/usr/bin/svscanboot}}

{{RootCmd|telinit q}}

This will run {{C|svscanboot}} when entering [[sysvinit#runlevels|runlevels]] 1 to 5. Because {{C|svscanboot}} calls {{C|svc}} using absolute path {{Path|/command/svc}}, a symlink to the correct path for Gentoo must be created:
{{RootCmd|mkdir -p /command|ln -s /usr/bin/svc /command/svc}}

{{anchor|supervise-scripts}}
==== The supervise-scripts package ====

Bruce Guenter's supervise-scripts package ({{Package|sys-process/supervise-scripts}}) provides an {{C|svscan-add-to-inittab}} script that also allows sysvinit to launch and supervise {{C|svscan}}. The script will make a backup of {{Path|/etc/inittab}} (with a name of the form {{Path|/etc/inittab-YYYY-MM-DD}}) and then modify it so that another script, {{C|svscan-start}} is run when entering runlevels 1 to 5.
{{RootCmd|svscan-add-to-inittab|telinit q}}

The {{C|svscan-start}} script is a wrapper around {{C|svscan}}. After some initialization it will replace itself with {{C|svscan}} using the shell's {{C|exec}} builtin utility, with its standard input, output and error redirected to {{Path|/dev/console}}. Therefore, {{C|svscan}}'s messages will be shown on the console. The enviroment will be empty, except for the <var>PATH</var> variable, set to a known value in the script.  The scan directory will be {{Path|/service}}.

The package also includes an {{C|svscan-stopall}} script, that will be called when entering sysvinit's [[sysvinit#singleuser|single user mode]] or runlevels 0, 1 and 6, to perform cleanup. It will stop all lingering {{C|supervise}} processes and their children using an {{C|svc -dx}} command.

== Removal ==

=== Unmerge ===

{{Unmerge|sys-process/daemontools-encore}}

All scan directories, service directories, the {{Path|/command/svc}} symlink, etc. must be manually deleted if no longer wanted after removing the package. Also, all modifications to {{Path|/etc/inittab}} must be manually reverted, even when using the supervise-scripts package, because {{C|svscan-add-to-inittab}} does not have an 'undo' option. Lines for {{C|svscanboot}}, {{C|svscan-start}} and {{C|svscan-stopall}} must be deleted, and a <kbd>telinit q</kbd> command must be used afterwards. If no further changes to {{Path|/etc/inittab}} have been made after invoking {{C|svscan-add-to-inittab}}, the backup copy created by that script before the changes are applied can be used to revert them by just replacing {{Path|/etc/inittab}} with that file.

== See also ==

* {{See also|Daemontools}}
* {{See also|Runit}}
* {{See also|S6}}
* {{See also|Process-Supervision}}

== External Resources ==

* [https://github.com/tokiclover/supervision Tokiclover's supervision framework (OpenRC friendly)]
* [https://bitbucket.org/avery_payne/supervision-scripts/ Avery Payne's supervision-scripts project]

== References ==

{{reflist}}

[[Category:Monitoring]]
[[Category:Process_Supervision]]
[[Category:Daemons]]
