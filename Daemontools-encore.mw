{{InfoBox stack
|{{InfoBox homepage|https://untroubled.org/daemontools-encore|header=true}}
|{{InfoBox github|bruceg/daemontools-encore}}
|{{InfoBox ohloh}}
}}

Daemontools-encore is [[Article description::a backwards compatible, enhanced version of [[Daemontools|Daniel J. Bernstein's daemontools package]], written by Bruce Guenter]]. A summary of the features that have been added to daemontools-encore is available [https://untroubled.org/daemontools-encore/CHANGES here].

__TOC__

== Installation ==

=== USE flags ===

{{USEflag|package=sys-process/daemontools-encore}}

=== Emerge ===

{{Emerge|sys-process/daemontools-encore}}

{{Important|Daemontools-encore is currently on the testing branch. Users with systems on the stable branch will need to add the package to {{Path|/etc/portage/package.accept_keywords}} (if using Portage) to be able to install it. While it is generally not advised to mix packages of stable and testing branches, this package only depends on the libc, so in this case it should be safe}}

== Configuration ==

=== Environment variables ===

* <var>SUPERVISEDIR</var> - Name of the the subdirectory used for {{C|supervise}}'s control files in a service directory.
* <var>SOFTLIMIT_ALLBYTES</var> - Alternative to {{C|softlimit}}'s '''-a''' option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_COREBYTES</var> - Alternative to {{C|softlimit}}'s '''-c''' option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_DATABYTES</var> - Alternative to {{C|softlimit}}'s '''-d''' option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_FILEBYTES</var> - Alternative to {{C|softlimit}}'s '''-f''' option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_LOCKEDBYTES</var> - Alternative to {{C|softlimit}}'s '''-l''' option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_MEMBYTES</var> - Alternative to {{C|softlimit}}'s '''-m''' option for specifying the corresponding soft limits.
* <var>SOFTLIMIT_OPENFILES</var> - Alternative to {{C|softlimit}}'s '''-o''' option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_PROCS</var> - Alternative to {{C|softlimit}}'s '''-p''' option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_RSSBYTES</var> - Alternative to {{C|softlimit}}'s '''-r''' option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_STACKBYTES</var> - Alternative to {{C|softlimit}}'s '''-s''' option for specifying the corresponding soft limit.
* <var>SOFTLIMIT_CPUSECS</var> - Alternative to {{C|softlimit}}'s '''-t''' option for specifying the corresponding soft limit.

=== Files ===

* {{Path|/service}} - Location of the scan directory when using [[OpenRC]], {{C|svscanboot}} or {{C|svscan-add-to-inittab}}.

=== Service ===

==== OpenRC ====

See [[#openrclaunch|here]]

== Usage ==

[[Daemontools|Bernstein daemontools]] and daemontools-encore implement ''process supervision'': programs that run as long-lived processes, such as a server program, can be supervised by being run as a child process of a ''supervisor''. The supervisor can detect if the process, also called ''the service'' or ''the daemon'' in this context, has unexpectedly stopped running, e.g. because it exited with an error status or was killed by a signal, and automatically restart it. The supervisor also provides a reliable interface for controlling both the supervised process and itself, to send signals to the process, and to query status information about it.

All this is based on standard POSIX features: a process' parent reliably knows its child's process ID (PID), because it is the return value of the {{C|fork()}} call that creates it, knows when the child stops running, because it is notified with a <code>SIGCHLD</code> signal, and can obtain exit status information when it happens using the {{C|wait()}} or {{C|waitpid()}} calls.

For more information information about process supervision see <ref>D. J. Bernstein, [https://cr.yp.to/daemontools/faq/create.html#why daemontools FAQ], which includes one about the benefits of process supervision. Retrieved on April 23rd, 2017.</ref> <ref>Gerrit Pape, [http://smarden.org/runit/benefits.html runit benefits], which includes a short description of process supervision in general. Retrieved on April 23rd, 2017.</ref> <ref>Laurent Bercot, [https://www.skarnet.org/software/s6/overview.html s6 overview], which contains an introduction to process supervision. Retrieved on April 23rd, 2017.</ref>.

=== Service directories ===

The program implementing the supervisor features in Bernstein daemontools and daemontools-encore is {{C|supervise}}. Supervision for a single process is configured  using a ''service directory'' (or ''servicedir''). A servicedir is an ordinary directory containing at least one executable file named {{Path|run}}. It can also contain an optional, regular file named {{Path|down}}. The (absolute or relative to the working directory) pathname of this servicedir is then passed as an argument to {{C|supervise}}. This however is not supposed to be done directly by the user, but to happen indirectly as a consequence of running {{C|svscan}}.

When {{C|supervise}} is invoked, it changes its working directory to the specifed servicedir, and executes the contained {{Path|run}} file as a child process, unless there is also a {{Path|down}} file. Daemontools-encore's {{C|supervise}} also makes the child process the leader of a new session using the POSIX {{C|setsid()}} call, unless the servicedir contains a regular file named {{Path|no-setsid}}. In that case, the child process will run in {{C|supervise}}'s session instead. Making the child process a session leader with Bernstein daemontools requires using the {{C|pgrphack}} program inside {{Path|run}} (see [[#changingstate|supervised process state changes]]). If {{C|supervise}} is invoked with a servicedir that contains a {{Path|down}} file, the {{Path|run}} file won't be executed, but the service can be started later with the {{C|svc}} program (see [[#controlling|controlling supervised processes]]). The contents of the {{Path|down}} and {{Path|no-setsid}} files are ignored, so they are usually empty.

{{Path|run}} can have any file format that the kernel knows how to execute, but is usually a shell script that performs some sort of initialization, and then calls the real program intended to be supervised, using the shell's {{C|exec}} builtin utility. This allows the program to run without creating a new process, so it will have the same PID as the {{Path|run}} script, and from there on become the supervised process. If the supervised process exits, {{C|supervise}} will wait 1 second before restarting it, so that it does not loop too quickly.

Programs that fail to adhere to certain design criteria, including those that use {{C|fork()}} in order to "put the daemon into the background" <ref>Jonathan de Boyne Pollard, [https://jdebp.eu/FGA/unix-daemon-design-mistakes-to-avoid.html Mistakes to avoid when designing Unix d√¶mon programs]. Retrieved on May 5th, 2017.</ref>, might not be able to be supervised. Sometimes programs can meet those criteria if passed certain options (e.g. a 'run in the foreground' option) as arguments on invocation.

A minimal (and simplistic) service directory for a hypothetical {{C|test-daemon}} program:
{{Cmd|ls -l|
output=<pre>total 4
-rwxr-xr-x 1 user user 27 May  5 12:00 run</pre>}}

{{FileBox|lang=bash|filename=run|1=#!/bin/sh
exec test-daemon}}

The {{C|supervise}} program keeps control files in a subdirectory of the servicedir, also named {{Path|supervise}}. If this subdirectory or any of its files doesn't exist when {{C|supervise}}  is invoked, they will be created. If the servicedir contains a {{Path|supervise}} symbolic link to directory instead of a subdirectory, {{C|supervise}} will follow it and use the linked-to directory for its control files.

{{Warning|The service directory can be in a read-only filesystem, but the {{Path|supervise}} directory and its contained files must writable by the effective user of the corresponding {{C|supervise}} process, so a symbolic link to an existing directory in a read-write filesystem must be used in that case.}}

Service directories can also optionally contain a subdirectory or symbolic link to directory named {{Path|log}}, which must also have the format of a servicedir, and can be used for setting up a dedicated logger (see [[#logging|logging]]).

The daemontools-encore package also allows the service directory to optionally contain executable files named {{Path|start}}, {{Path|stop}}, and {{Path|notify}}. These can be used to perfom initialization and cleanup actions, either first-time only, last-time only, or each time the supervised process starts or stops, and to conditionally perform actions based on its exit status information. It also allows {{Path|run}} to be optional, allows {{Path|log}} to be an executable file instead of a directory, can set a different name for the directory containing {{C|supervise}}'s control files via the <var>SUPERVISEDIR</var> environment variable, and avoids restarting a supervised process if its exit code is 100. For further details, please consult the {{C|supervise}} man page.

Service directory with a {{Path|supervise}} subdirectory:
{{Cmd|ls -l|
output=<pre>total 8
-rwxr-xr-x 1 user user   27 May  5 12:00 run
drwx------ 2 user user 4096 May  5 12:00 supervise</pre>}}

{{Path|supervise}} subdirectory contents:
{{Cmd|ls -l supervise|
output=<pre>total 4
prw------- 1 user user  0 May  5 12:00 control
-rw------- 1 user user  0 May  5 12:00 lock
prw------- 1 user user  0 May  5 12:00 ok
-rw-r--r-- 1 user user 18 May  5 12:00 status</pre>}}

=== The scan directory and supervision tree ===

Bernstein daemontools and daemontools-encore allow supervising a set of processes running in parallel using the {{C|svscan}} program and a ''scan directory'' (or ''scandir''). A scan directory is an ordinary directory containing subdirectories and/or symbolic links to directories, each of them a service directory. Invoking {{C|svscan}} with the (absolute or relative to the working directory) path of the scandir as its first argument (and only argument for Bernstein daemontools' {{C|svscan}}) launches one child{{C|supervise}} process for each subdirectory, unless the name of the directory starts with a dot. If {{C|svscan}} is called with no arguments, it will assume the working directory is the scandir, otherwise it will change its working directory to the specified scandir.

Every 5 seconds, {{C|svscan}} rereads the scan directory (i. e. performs a ''scan''), launching {{C|supervise}} processes for each new servicedir it finds, or old servicedir for which it finds its {{C|supervise}} process has exited. {{C|svscan}} acts as a supervisor for every child {{C|supervise}}, the same way {{C|supervise}} does for its child process. This arrangement of processes is called the ''supervision tree''. The root of the supervision tree is {{C|svscan}}, so it is designed to be robust and to cope with {{C|supervise}} processes exiting unexpectedly, being killed, or being unable to start. The leaves of the supervision tree are the processes that correspond to the service directories in the scandir.

Example scan directory containing three service directories:
{{Cmd|ls -l|
output=<pre>total 12
drwxr-xr-x 3 user user 4096 May  5 12:00 test-service1
drwxr-xr-x 3 user user 4096 May  5 12:00 test-service2
drwxr-xr-x 3 user user 4096 May  5 12:00 test-service3</pre>}}

{{FileBox|lang=bash|filename=test-service1/run|1=#!/bin/sh
exec test-daemon1}}

{{FileBox|lang=bash|filename=test-service2/run|1=#!/bin/sh
exec test-daemon2}}

{{FileBox|lang=bash|filename=test-service3/run|1=#!/bin/sh
exec test-daemon3}}

Resulting supervision tree when {{C|svscan}} is run on this scandir as a background process in an interactive shell, assuming it is a subdirectory named {{Path|scan}} in the working directory (i.e. launched with <kbd>svscan scan &</kbd>):
{{Cmd|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre>  PID  PPID  PGRP EUSER    COMMAND
...
 1777  1764  1777 user -bash
 2047  1777  2047 user  \_ svscan scan
 2048  2047  2047 user      \_ supervise test-service3
 2053  2048  2047 user      |   \_ test-daemon3
 2049  2047  2047 user      \_ supervise test-service1
 2052  2049  2047 user      |   \_ test-daemon1
 2050  2047  2047 user      \_ supervise test-service2
 2051  2050  2047 user          \_ test-daemon2
...</pre>}}

{{Important|Since processes in a supervision tree are created using the POSIX {{C|fork()}} call, all of them will inherit {{C|svscan}}'s enviroment, which, in the context of this example, is the user's login shell environment. If {{C|svscan}} is launched in some other way (see later), the environment will likely be completely different. This must be taken into account when trying to debug a supervision tree with an interactive shell.}}

Services directories using {{Path|down}} and daemontools-encore {{Path|start}}, {{Path|stop}} and {{Path|notify}} files:
{{Cmd|ls -l|
output=<pre>total 8
drwxr-xr-x 3 user user 4096 May  6 12:00 test-service1
drwxr-xr-x 3 user user 4096 May  6 12:00 test-service2</pre>}}

{{Cmd|ls -l test-service*|
output=<pre>test-service1:
total 4
-rw-r--r-- 1 user user  0 May  6 12:00 down
-rwxr-xr-x 1 user user 28 May  6 12:00 run

test-service2:
total 16
-rwxr-xr-x 1 user user 163 May  6 12:00 notify
-rwxr-xr-x 1 user user  24 May  6 12:00 run
-rwxr-xr-x 1 user user  24 May  6 12:00 start
-rwxr-xr-x 1 user user  24 May  6 12:00 stop</pre>}}

{{FileBox|lang=bash|filename=test-service1/run|1=#!/bin/sh
exec test-daemon1}}

{{FileBox|lang=bash|filename=test-service2/run|1=#!/bin/sh
exec sleep 20}}

{{FileBox|lang=bash|filename=test-service2/start|1=#!/bin/sh
exec sleep 10}}

{{FileBox|lang=bash|filename=test-service2/stop|1=#!/bin/sh
exec sleep 10}}

{{FileBox|lang=bash|filename=test-service2/notify|1=#!/bin/sh
case $2 in
start) echo "'$1' started (PID $3)";;
exit) echo "'$1' (PID $3) exited with $4";;
killed) echo "'$1' (PID $3) was killed by signal $4";;
esac}}

Resulting supervision tree:
{{Cmd|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre>  PID  PPID  PGRP EUSER    COMMAND
...
 1777  1764  1777 user -bash
 2114  1777  2114 user  \_ svscan scan
 2115  2114  2114 user      \_ supervise test-service1
 2116  2114  2114 user      \_ supervise test-service2
 2146  2116  2146 user          \_ sleep 20
...</pre>}}

Note that since {{Path|test-service1}} has a {{Path|down}} file, the corresponding {{C|supervise}} process has no children.

Messages printed to svscan's standard output (stdout) by the {{Path|notify}} script:
{{Cmd|svscan scan &|
output=<pre>'start' started (PID 2253)
'start' (PID 2253) exited with 0
'run' started (PID 2258)
'run' (PID 2258) exited with 0
'run' started (PID 2287)</pre>}}

{{Cmd|kill 2287|
output=<pre>'run' (PID 2287) was killed by signal 15
'run' started (PID 2295)</pre>}}

{{Cmd|svc -d scan/test-service2|
output=<pre>'run' (PID 2295) was killed by signal 15
'stop' started (PID 2300)
'stop' (PID 2300) exited with 0</pre>}}

For further details, please consult the {{C|supervise}} man page.

{{anchor|logging}}
=== Logging ===

==== The multilog program ====

If a servicedir '''S''' in the scan directory contains a {{Path|log}} subdirectory or symbolic link to directory, {{C|svscan}} will launch two {{C|supervise}} processes in parallel, one executing {{Path|'''S'''/run}} as a child process, and the other executing {{Path|'''S'''/log/run}} with its standard input (stdin) connected to {{Path|'''S'''/run}}'s standard output (stdout) by a pipe. If any of the two processes or their  {{C|supervise}} parents stops running and is restarted, the same pipe is reused so that no data is lost. This allows per-service logging by having {{Path|'''S'''/log/run}} execute a ''logger program''.  Bernstein daemontools and daemontools-encore packages provide such a logger: the {{C|multilog}} program. This works for programs that send messages to their standard error (stderr).

{{C|multilog}} is invoked as <kbd>multilog arg1 arg2 arg3 ...</kbd>, and expects to read a sequence of newline-terminated lines of text from its standard input. The arguments ''arg1'', ''arg2'', ''arg3'', ... make up a ''logging script'' that tells {{C|multilog}} what to do with them. Each argument specifies an ''action'', actions are carried out sequentially in argument order.

The simplest form of {{C|multilog}} invocation is <kbd>multilog dir</kbd>, where ''dir'' starts with a dot ('.') or a slash ('/'): it is interpreted as a pathname specifying an automatically rotated ''logging directory'' (or ''logdir''). The logdir contains control files used by {{C|multilog}}, a ''current log file'' named {{Path|current}}, and may also contain a set of old log files. The current log file contain a selection of the lines read by {{C|multilog}}, possibly modified by other actions specified in its logging script, and old log files are produced by ''rotations'': when {{Path|current}} approaches a certain maximum size, its contents are copied to a another file, after some optional processing, and {{Path|current}} is emptied. Old log file have names beginning with '@', continuing with a timestamp in [https://cr.yp.to/libtai/tai64.html external TAI64N format] showing when the file was finished, and ending with either '.s' or '.u'. The .s files are files that have been completely processed and safely written, i.e. files produced by a complete rotation. The .u files, if any, are files created by an incomplete rotation, they are not completely processed and may be truncated. Rotations respect line boundaries, i.e. old log files will always contain whole lines. Also, to avoid indefinite accumulation of old log files, if, after completing a rotation, their number exceeds a certain value, {{C|multilog}} deletes the oldest log file (the file with the smallest TAI64N timestamp). The default maximum size of a {{Path|current}} file is 99999 bytes, and the default maximum number of old log files is 10. A rotatin can be forced by sending {{C|multilog}} a <code>SIGALRM</code> signal. If it is running as a supervised process, the {{C|svc}} program can be used to do it (see [[#controlling|controlling supervised processes]]).

Some other actions recognized by {{C|multilog}} in a logging script are:

* '''+''' (plus sign) and '''-''' (minus sign) followed by a pattern: By default, {{C|multilog}} logs all the lines read from its standard input without modifications; these actions allow selection and deselection of lines for logging, respectively, based on the specified pattern. Because all lines are initially selected, '''+''' actions are only effective after a '''-''' action deselecting some lines first. The pattern uses the shell's notation for matching strings, and must match whole lines (i.e. partial matching doesn't count), with the following restrictions:
** Berstein daemontools' {{C|multilog}} only treats asterisks ('*') as special characters in the pattern, they match any string, including the null string, that does not include the next character in pattern (instead of the POSIX behaviour of matching the greatest possible number of characters that still allows the remainder of the pattern to match the line), and doesn't support escaping them with a backslash ('\').
** Daemontools-encore's {{C|multilog}} can switch between Bernstein daemontools behaviour and using the full range of patterns allowed by POSIX {{C|fnmatch()}}, including backslash escaping. The latter is more flexible at the expense of being less efficient. At the start of logging script action processing, Bernstein daemontools match mode is selected.
*** An '''F''' action selects {{C|fnmatch()}} match mode for all subsequent '''+''' and '''-''' actions until the next mode-changing action in the logging script.
*** An '''S''' action selects Bernstein daemontools match mode for all subsequent '''+''' and '''-''' actions until the next mode-changing action in the logging script.
* '''t''': prepends each logged line with '@', followed by a timestamp in [https://cr.yp.to/libtai/tai64.html external TAI64N format] (printed as 24 lowercase hexadecimal characters), and a space. It must be specified as the first action, and any subsequent '''+''' and '''-''' actions match against the line '''with''' the prepended timesptamp. Daemontools-encore also supports a '''T''' action, which must also be the first one, that prepends an accustamp-style timestamp and a space instead ({{C|accustamp}} was a program shipped with Bernstein daemontools that was eventually dropped).
* '''s''' followed by an integer: sets the maximum size of the {{Path|current}} file to the specified value (in bytes), for all subsequent actions in the logging script specifying a logdir, until the next '''s''' action.
* '''u''' followed by an integer: sets the maximum number of old log files to the specified value, for all subsequent actions in the logging script specifying a logdir, until the next '''u''' action.
* '''!''' (exclamation mark) followed by a program name (that {{C|multilog}} must be capable of finding using PATH search): allows {{C|multilog}} to perform some processing of the contents of the {{Path|current}} log file during a rotation. {{C|multilog}} will call the program and feed it the contents of {{Path|current}} on its standard input. The .s or .u file produced as a result will contain that program's output.

For details about all actions supported {{C|multilog}}, and about the protocol used for communication between {{C|multilog}} and the processor specified in an '''!''' action, please consult the {{C|multilog}} man page.

{{FileBox|filename=input|title=Sample input for the {{C|multilog}} program|1=info: Message 1
warning: Message 2
error: Message 3
error: Message 4
warning: Message 5
info: Message 6}}

{{Cmd|cat input {{!}} multilog '-*' '+warning: *' ./log1 '+error: *' ./log2|ls -l|
output=<pre>drwx------ 2 user user 4096 May  6 12:00 log1
drwx------ 2 user user 4096 May  6 12:00 log2</pre>}}

{{Cmd|ls -l log*|
output=<pre>log1:
total 4
-rwxr--r-- 1 user user 38 May  6 12:00 current
-rw------- 1 user user  0 May  6 12:00 lock
-rw-r--r-- 1 user user  0 May  6 12:00 state

log2:
total 4
-rwxr--r-- 1 user user 72 May  6 12:00 current
-rw------- 1 user user  0 May  6 12:00 lock
-rw-r--r-- 1 user user  0 May  6 12:00 state</pre>}}

When there's no {{C|multilog}} process running on a logdir, the {{Path|current}} file has the executable by user flag set.

{{FileBox|filename=log1/current|1=warning: Message 2
warning: Message 5}}

{{FileBox|filename=log2/current|1=warning: Message 2
error: Message 3
error: Message 4
warning: Message 5}}

Note that the second {{Path|current}} log file also contains the warning messages. This shows that actions that aren't '''+''' or '''-''' do not affect the currently selected lines, so warning messages selected by ''+warning: *'' stay selected after processing the ''./log1'' action. To only have the error messages in the {{Path|log2/current}} log file, a ''-*'' action should have immediatly preceded the ''+error: *'' action.

Service directory {{Path|test-service}} containing a logger:
{{Cmd|ls -l|
output=<pre>total 8
drwxr-xr-x 2 user user 4096 May  6 12:00 log
-rwxr-xr-x 1 user user  110 May  6 12:00 run</pre>}}

{{Cmd|ls -l log|
output=<pre>total 4
-rwxr-xr-x 1 user user 40 May  6 12:00 run</pre>}}

{{FileBox|lang=python|filename=/home/user/test-daemon|title=Python script generating messages on its stderr|1=#!/usr/bin/python
from time import sleep
from sys import stderr
for i in range(1,30):
   print("Message", i, file=stderr, flush=True)
   sleep(2)}}

{{FileBox|lang=bash|filename=test-service/run|1=#!/bin/sh
exec /home/user/test-daemon 2>&1}}

{{FileBox|lang=bash|filename=test-service/log/run|1=#!/bin/sh
exec multilog t ../../../logs}}

Note that since {{C|supervise}} makes the service directory its working directory, the relative pathname in {{C|multilog}}'s invocation results in the logging directory being placed wherever the scan directory is.

Resulting supervision tree:
{{Cmd|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre>  PID  PPID  PGRP EUSER    COMMAND
...
 1777  1764  1777 user -bash
 2702  1777  2702 user  \_ svscan scan
 2703  2702  2702 user      \_ supervise test-service
 2706  2703  2702 user      |   \_ /usr/lib/python-exec/python3.4/python /home/user/test-daemon
 2704  2702  2702 user      \_ supervise log
 2705  2704  2702 user          \_ multilog t ../../../logs
...</pre>}}

Contents of the {{Path|logs}} logging directory:
{{Cmd|ls -l|
output=<pre>total 20
-rwxr--r-- 1 user user  361 May  6 17:20 @40000000590e2ffe0bf16944.s
-rwxr--r-- 1 user user 2202 May  6 17:22 @40000000590e30941e642c9c.s
-rw-r--r-- 1 user user 1101 May  6 17:23 current
-rw------- 1 user user    0 May  6 17:19 lock
-rw-r--r-- 1 user user    0 May  6 17:19 state</pre>}}

This logdir contains two old log files and, since {{C|multilog}} is running, the {{Path|current}} file has its executable by user flag cleared.

{{Cmd|cat logs/current|
output=<pre>@40000000590e30983973bda4 Message 1
@40000000590e309a39b02a64 Message 2
@40000000590e309c3a353ccc Message 3
@40000000590e309e3a93b84c Message 4
@40000000590e30a03aec8a94 Message 5
@40000000590e30a23b3bbc04 Message 6
@40000000590e30a5003a28ac Message 7
@40000000590e30a70097255c Message 8
@40000000590e30a900bc221c Message 9
@40000000590e30ab0100ff04 Message 10</pre>}}

The TAI64N timestamps can be shown in human-readable form with {{C|tai64nlocal}}, for further details please consult the respective man page.

{{Cmd|cat logs/current {{!}} tai64nlocal|
output=<pre>2017-05-06 17:22:38.963886500 Message 1
2017-05-06 17:22:40.967846500 Message 2
2017-05-06 17:22:42.976567500 Message 3
2017-05-06 17:22:44.982759500 Message 4
2017-05-06 17:22:46.988580500 Message 5
2017-05-06 17:22:48.993770500 Message 6
2017-05-06 17:22:51.003811500 Message 7
2017-05-06 17:22:53.009905500 Message 8
2017-05-06 17:22:55.012329500 Message 9
2017-05-06 17:22:57.016842500 Message 10</pre>}}

==== The readproctitle program ====

The {{C|readproctitle}} program expects to read a sequence of newline-terminated lines of text from its standard input, and saves them to an automatically rotated log it keeps in ''memory''. The log shows up in the output of the {{C|ps}} utility. The number of characters displayed is specified by {{C|readproctitle}}'s arguments.

{{C|readproctitle}} is invoked as <kbd>readproctitle arg1 arg2 ... argn dots</kbd>. The arguments ''arg1'', ''arg2'', ..., ''argn'' can be anything, they are shown as-is in the output of {{C|ps}}, and can used for displaying some kind of heading that introduces the log. The last argument, ''dots'', must be at least five dots ('.'), and its length specifies the number of characters the log kept in memory will have. In the output of {{C|ps}}, {{C|readproctitle}}'s last shown argument will be the contents of the log up to that time instead. Characters shift to the left as {{C|readproctitle}} reads further lines of text, and older characters are discarded to keep the log of constant size. Therefore, the {{C|ps}} command will show each time the most recent data. For further details, please consult the {{C|readproctitle}} man page.

{{FileBox|lang=bash|filename=doit|title=Shell script generating output|1=#!/bin/sh
echo Print this message!
sleep 10
echo Second message
sleep 10}}

{{Cmd|sh doit {{!}} readproctitle Log header: ........................ &|
ps x -o pid,args|
output=<pre>  PID COMMAND
...
 2860 readproctitle Log header: ....Print this message!
...</pre>}}

After enough seconds have elapsed:
{{Cmd|ps x -o pid,args|
output=<pre>  PID COMMAND
...
 2860 readproctitle Log header: ...sage! Second message
...</pre>}}

The best known use of {{C|readproctitle}} is in the {{C|svscanboot}} script included in Bernstein daemontools and daemontools-encore.

{{anchor|loggingchain}}
==== The logging chain ====

A supervision tree where all leaf processes have a logger can be arranged into what the author of [[s6]] calls ''the logging chain'' <ref>Laurent Bercot, [https://www.skarnet.org/software/s6/s6-log.html#loggingchain the logging chain], Retrieved on May 1st, 2017.</ref>, which he considers to be technically superior to the traditional syslog-based centralized approach <ref>Laurent Bercot, [https://www.skarnet.org/software/s6/s6-log.html#diesyslogdiedie on the syslog design], Retrieved on May 1st, 2017.</ref>.

Since processes in a supervision tree are created using the POSIX {{C|fork()}} call, all of them will inherit {{C|svscan}}'s standard input, output and error. A logging chain arrangement using Bernstein daemontools and daemontools-encore is as follows:

* Leaf processes should normally have a logger, so their standard output and error connect to their logger's standard input. Therefore, all their messages are collected and stored in dedicated, per-service logs by their logger. Some programs might need to be invoked with certain options passed as arguments to make them send messages to their standard error, and redirection of stderr to stdout (i.e. '''2>&1''' in a shell script) must be performed in the servicedir's {{Path|run}} file.
* Leaf processes with a controlling terminal are an exception: their standard input, output and error connect to the terminal.
* {{C|supervise}}, the loggers, and leaf processes that exceptionally don't have logger for some reason, inherit their standard input, output and error from {{C|svscan}}, so their messages are sent wherever the ones from {{C|svscan}} are.
* Leaf processes that still unavoidably report their messages using {{C|syslog()}} have them collected and logged by a (possibly supervised) syslog server.

==== Specifying a logger for {{C|svscan}} ====

Daemontools-encore's {{C|svscan}} allows the pathname of a service directory to be passed as a second argument after the scan directory's pathname. If this argument is present, {{C|svscan}} will launch one {{C|supervise}} process for the specified directory, and connect its standard output and error to the corresponding supervised process' standard input by a pipe. This makes it possible to set up a logger for {{C|svscan}} in the same way a logger can be set up for the leaf processes of the supervision tree.

{{Warning|If the service directory of {{C|svscan}}'s logger is specified as a relative pathname, it is interpreted as relative to the scan directory}}

{{anchor|changingstate}}
=== Supervised process state changes ===

Bernstein's daemontools and daemontools-encore provide a set of tools for modifying a supervised process' execution state. These tools employ a technique called ''chain loading'' by some people, and  ''Bernstein chaining'' by others. A program ''prog1'' designed to use chain loading is invoked as <kbd>prog1 arg11 ... arg1n prog2 arg21 ... arg2n</kbd>, where ''prog2'' is the name of another program. When ''prog1'' is invoked, it performs some action based on arguments ''arg11'', ..., ''arg1n'', and then executes ''prog2'' without creating a new process, using one of the POSIX {{C|exec...()}} calls. Arguments ''arg21'', ..., ''arg2n'' are not interpreted by ''prog1'' and are passed along to ''prog2''.

If ''prog2'' is also designed to use chain loading, some of those arguments might in turn be the name of a third program ''prog3'' and its corresponding arguments, which will be executed after ''prog2'' completes its task. As a consequence, it is possible to build a chain of programs that will all run in the same process, therefore preserving the process ID (PID), which makes the technique suitable for the {{Path|run}} script of a service directory. The final one in such a chain of programs would be the real program intended to be supervised.

The tools provided by Bernstein's daemontools and daemontools-encore to change a process' execution state are:

* {{C|envdir}}: runs another program with environment modified according to files in a specified directory.
* {{C|envuidgid}}: runs another program with environment variables indicating a specified account's user ID and group ID
* {{C|pgrphack}}: runs a program in a new session (using POSIX {{C|setsid()}}).
* {{C|setlock}}: runs another program with a file locked (using Linux {{C|flock()}} on Gentoo).
* {{C|setuidgid}}: runs another program under a specified account's user ID and group ID. Requires root privileges.
* {{C|softlimit}}: runs another program with new soft resource limits (using POSIX {{C|setrlimit()}}). These limits are set via options specified as {{C|softlimit}}'s arguments. Daemontools-encore also allows setting those limits via SOFTLIMIT_* environment variables, applied at {{C|softlimit}} invocation.

For further details on these tools please consult their respective man page.

The directory supplied to the {{C|envdir}} program is called an ''environment directory'' (or ''envdir''). Each file in the envdir controls a single environment variable. If the file is empty, and a variable with the same name as the file exists in the process' environment, it is removed from it. If the file is nonempty, the contents of its first line become the value of a new environment variable with the same name as the file. If the variable existed before {{C|envdir}}'s invocation, it is first removed from the environment, and then readded with the new value. Enviroment variables not referred to by a file in the envdir remain unchanged.

{{FileBox|lang=bash|filename=run|title=Example ''run'' script with process state change|1=#!/bin/sh
exec \
softlimit -o 5 \
setuidgid daemon \
test-daemon 2>&1}}

This script allows executing program {{C|test-daemon}} with effective user ''daemon'' and the maximum number of open file descriptors set to 5. This is the same as if {{C|test-daemon}} performed a <code>setrlimit(RLIMIT_NOFILE, &rl)</code> call itself with <code>rl.rlim_cur</code> set to 5, provided that value does not exceed the corresponding hard limit. As in previous examples, the redirection of stderr to stdout allows setting up a dedicated logger for {{C|test-daemon}}.

Example service directory with an enviroment directory {{Path|env}}:
{{Cmd|ls -l|
output=<pre>total 8
drwxr-xr-x 2 root root 4096 May  7 12:00 env
-rwxr-xr-x 1 root root  125 May  7 12:00 run</pre>}}

{{Cmd|ls -l env|
output=<pre>total 4
-rw-r--r-- 1 root root 2 May  7 12:00 SOFTLIMIT_OPENFILES</pre>}}

{{FileBox|lang=bash|filename=run|1=#!/bin/sh
exec \
envdir env \
envuidgid daemon \
softlimit \
test-daemon 2>&1}}

{{FileBox|filename=env/SOFTLIMIT_OPENFILES|1=5}}

This script adds variables <var>UID</var>, <var>GID</var> and <var>SOFTLIMIT_OPENFILES</var> to the environment, the first two set to the user ID and group ID of user ''daemon'' via {{C|envuidgid}}, and the last one via the enviroment directory {{Path|env}}, which is used by the {{C|softlimit}} invocation to set the maximum number of open file descriptors, provided it is the daemontools-encore version of that program. It is assumed that {{C|test-daemon}} can use environment variables <var>UID</var> and <var>GID</var> to drop privileges.

{{anchor|controlling}}
=== Controlling supervised processes ===

Bernstein daemontools both and daemontools-encore provide two programs for controlling a supervised process and to query status information about it: {{C|svc}} and {{C|svstat}}, respectively. Daemontools-encore provides a third one, {{C|svup}}; for further details please consult its man page.

The {{C|svc}} program accepts a set of service directory pathnames and options that specify what to do. Some of those options are:

* <kbd>svc -d</kbd> (''down''): If the supervised process is running, send it a <code>SIGTERM</code> signal followed by a <code>SIGCONT</code> signal. The {{Path|run}} file won't be reexecuted after that. This is the standard way to manually stop a supervised process. If the process is not running (e.g. because it has a {{Path|down}} file or after a previous <kbd>svc -d</kbd> command) this is a no operation.
* <kbd>svc -u</kbd> (''up''): If the supervised process is not running, start it by executing its {{Path|run}} file. If the process is running, this is mostly a no operation, except that it cancels the effect of a previous <kbd>svc -o</kbd> command. This is the standard way to manually start a supervised process that has a {{Path|down}} file.
* <kbd>svc -o</kbd> (''once''): If the supervised process is not running, start it by executing its {{Path|run}} file, but don't restart it if stops. This still allows the process to be monitored and to be reliably sent signals, but it won't actually be supervised. If the process is running, it just asks {{C|supervise}} to not restart it if it stops. The effect of this option can be cancelled by a subsequent <kbd>svc -u</kbd> command, and restored after that by another <kbd>svc -o</kbd> command.
* <kbd>svc -x</kbd> (''exit''): Asks {{C|supervise}} to exit if the supervised process stops. This is only effective if its {{C|svscan}} parent stopped running without {{C|supervise}} being killed, otherwise a new {{C|supervise}} process will be launched on the next periodic scan.

Other {{C|svc}} options allow reliably sending signals to a supervised process. For further details, please consult the {{C|svc}} man page. In particular, <kbd>svc -a</kbd> can be used to send a <code>SIGALRM</code> signal to a supervised {{C|multilog}} process to force it to perform a rotation.

The {{C|svstat}} program accepts a set of service directory pathnames. Its output is intended to be displayed on a user interface or logged, not to be fed as input to a program for parsing. Bernstein daemontools' {{C|svstat}} displays whether the supervised process is running ('up') or not ('down') and whether it is transitioning to the desired state or already there ('want up' or 'want down'), its process ID (PID) if it is up, how long it has been in the current state, and whether its current up or down status matches the presence or absence of a {{Path|down}} file in the servicedir ('normally up' or 'normally down'). If also shows if the supervised process is paused (because of a <code>SIGSTOP</code> signal). In addition to that, daemontools-encore's {{C|svstat}} displays an extended state, 'started', 'starting', 'running', 'failed', 'stopping' and 'stopped', that depends on which of the {{Path|start}}, {{Path|run}} or {{Path|stop}} files in the servicedir (if present) is being executed, and the reason it stopped running, if it did. It can also display similar information for the logger, depending on options passed as arguments, if there is a {{Path|log}} executable file or directory in the servicedir. For further details, please consult the {{C|svstat}} man page.

{{Note|For the operation performed by {{C|svc}} to be allowed, its effective user must have write access to the {{Path|supervise/control}} FIFO in the service directory, otherwise, it will fail with an 'access denied' error. For the operation performed by {{C|svstat}} and {{C|svup}} to be allowed, its effective user must have write access to the {{Path|supervise/ok}} FIFO and read access to the {{Path|supervise/status}} file in the service directory, otherwise, it will fail with an 'access denied' error. Using {{C|svc}} or {{C|svstat}} on a service directory for which no {{C|supervise}} process is running will result in a 'supervise not running' error.}}

=== Starting the supervision tree ===

In a supervision tree arrangement each process supervises its children, therefore the robustness of the supervision tree ultimately relies on the {{C|svscan}} process. So the problem of how to supervise {{C|svscan}} itself arises, as well as what to do with {{C|svscan}}'s messages in a [[#loggingchain|logging chain]]

{{anchor|openrclaunch}}
==== From OpenRC ====

Gentoo's packaging of Bernstein daemontools and daemontools-encore provides an [[OpenRC]] service script named {{C|svscan}}, to run {{C|svscan}}. The scan directory will be {{Path|/service}}. Thus, is can be started when the machine boots by adding it to an OpenRC runlevel using {{C|rc-update}}:
{{RootCmd|rc-update add svscan default}}

Or it can also be started manually:
{{RootCmd|rc-service svscan start}}

{{Warning|The service script launches {{C|svscan}} using OpenRC's {{C|start-stop-daemon}} program, so it will run unsupervised, and with its standard output and error redirected to {{Path|/dev/null}} by default, so supervision tree messages other than those from leaf processes that have a dedicated logger will be lost.}}

==== The svscanboot script ====

Bernstein daemontools and daemontools-encore provide a script called {{C|scvscanboot}}, that can be launched and supervised by [https://packages.gentoo.org/packages/sys-apps/sysvinit sysvinit] by adding a 'respawn' line for it in {{Path|/etc/inittab}}. {{C|scvscanboot}} is a shell script that launches an {{C|svscan}} process and a {{C|readproctitle}} process, with the former's standard output connected to the latter's standard input by a pipe, and every other standard descriptor redirected to {{Path|/dev/null}}. The enviroment will be empty, except for the <var>PATH</var> variable, set to a known value in the script. The scan directory will be {{Path|/service}}.

Used in this way, the supervision tree becomes rooted in process 1, which cannot die without crashing the machine. Also, {{C|svscan}}'s messages will go to {{C|readproctitle}}, so they can be seen using the {{C|ps}} utility.

Gentoo users wanting to use {{C|svscanboot}} will need to manually edit {{Path|/etc/inittab}}, and then call {{C|telinit}}

{{FileBox|filename=/etc/inittab|1=SV:12345:respawn:/usr/bin/svscanboot}}

{{RootCmd|telinit q}}

This will make sysvinit launch and supervise {{C|svscanboot}} when entering runlevels 1 to 5. Because {{C|svscanboot}} calls {{C|svc}} using absolute path {{Path|/command/svc}}, a symlink to the correct path for Gentoo must be created:
{{RootCmd|mkdir -p /command|ln -s /usr/bin/svc /command/svc}}

==== The supervise-scripts package ====

[https://packages.gentoo.org/packages/sys-process/supervise-scripts Bruce Guenter's supervise-scripts package] provides an {{C|svscan-add-to-inittab}} script that also allows [https://packages.gentoo.org/packages/sys-apps/sysvinit sysvinit] to launch and supervise {{C|svscan}}. The script will make a backup of {{Path|/etc/inittab}} (with a name of the form {{Path|/etc/inittab-YYYY-MM-DD}}) and then modify it so that another script, {{C|svscan-start}} is launched and supervised when entering runlevels 1 to 5. The scan directory will be {{Path|/service}}.

{{RootCmd|svscan-add-to-inittab|telinit q}}

The {{C|svscan-start}} script is a wrapper around {{C|svscan}}. After some initialization it will replace itself with {{C|svscan}} using the shell's {{C|exec}} builtin utility, with its standard input, output and error redirected to {{Path|/dev/console}}. Therefore, {{C|svscan}}'s messages will be shown on the console. The enviroment will be empty, except for the <var>PATH</var> variable, set to a known value in the script.

The package also includes a {{C|svscan-stopall}} script, that will be called when entering sysvinit's single user mode or runlevels 0, 1 and 6, to perform cleanup. It will stop all lingering {{C|supervise}} processes and their children using an <kbd>svc -dx</kbd> command. The script makes use of {{C|svup}}, so it can only be used with daemontools-encore.

== Removal ==

=== Unmerge ===

{{Unmerge|sys-process/daemontools-encore}}

All scan directories, service directories, the {{C|/command/svc}} symlink, etc. must be manually deleted if no longer wanted after unmerging the package. Also, all modifications to {{Path|/etc/inittab}} must be manually reverted, even when using the supervise-scripts package, because {{C|svscan-add-to-inittab}} does not have an 'undo' option. Lines for {{C|svscanboot}}, {{C|svscan-start}} and {{C|svscan-stopall}} must be deleted, and a <kbd>telinit q</kbd> command must be used afterwards. If no further changes to {{Path|/etc/inittab}} have been made after invoking {{C|svscan-add-to-inittab}}, the backup copy created by that script before the changes are applied can be used to revert them by just replacing {{Path|/etc/inittab}} with that file.

== See also ==

* [[Daemontools]]
* [[Runit]]
* [[S6]]
* [[Process-Supervision]]

== External Resources ==

* [https://github.com/tokiclover/supervision Tokiclover's supervision framework (OpenRC friendly)]
* [https://bitbucket.org/avery_payne/supervision-scripts/ Avery Payne's supervision-scripts project]

== References ==

{{reflist}}

[[Category:Monitoring]]
[[Category:Process_Supervision]]
[[Category:Daemons]]
