{{Warning|The syntax used in examples on this page is just an example and is subject to change. Please debate on the concepts, not on the syntax of examples.}}

== Reordering to PACKAGE OP VERSION ==
{{Bug|598627}}

Replace the current:

 [<operator>] <cat/pkg> [-<version>] [:<slot>] ...
 ^^^^^^^^^^^^           ^^^^^^^^^^^^

with:

 <cat/pkg> [:<slot>] [<operator> <version>]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

e.g.:

{|class="wikitable"
! Old syntax
! New syntax
! Notes
|-
| dev-foo/bar || dev-foo/bar || (unchanged)
|-
| dev-foo/bar:4 || dev-foo/bar:4 || (unchanged)
|-
| >=dev-foo/bar-4.1 || dev-foo/bar>=4.1 ||
|-
| >dev-foo/bar-4.1:4 || dev-foo/bar:4>4.1 ||
|-
| =dev-foo/bar-11 || dev-foo/bar==11 || (or =, TBD)
|-
|}

Advantages:
* more readable,
* easier to edit,
* easier to validate,
* easier to split package name from version,
* better ground for version ranges,
* in the future, this will allow us to dump restriction on package names not being confusing with versions.

== Version ranges ==
{{Bug|4315}}

=== Problems to solve ===
==== A. Range dependencies vs slotting ====
Sometimes it is necessary to restrict acceptable versions of a package to a range. This is frequently accomplished using the following syntax:

 <dev-foo/bar-1.5
 >=dev-foo/bar-1.3

If the package is slotted, this dependency can actually cause PM to install two versions of the package in different slots, neither of them matching the intended range, e.g. 1.2 (satisfies <1.5) and 1.6 (satisfies >=1.3). For simple slotting, appending correct slot (e.g. :0) fixes that. For fully slotted packages, any-of dependencies are used instead:

 || (
   dev-foo/bar:1.5
   dev-foo/bar:1.4
   dev-foo/bar:1.3
 )

Problems:
* verbosity, inconvenience,
* any-of dep makes it impossible to use :=.

==== B. Excluding single package versions ====
Sometimes it is necessary to exclude one or a few versions from a wide range, e.g. due to a bug or temporary incompatibility. This is either achieved using:

 || (
   ( <dev-foo/bar-1.5 >=dev-foo/bar-1.3.2 )
   ( <dev-foo/bar-1.3 >=dev-foo/bar-1.1 )
 )

or:

 <dev-foo/bar-1.5
 >=dev-foo/bar-1.1
 !!dev-foo/bar-1.3.0
 !!dev-foo/bar-1.3.1

The former form has the disadvantages of any-of group, the latter of blockers.

=== Slot-binding dependency groups ===
The least-change solution to the problem is to introduce an additional dependency group type that forces all conditions in it to be enforced on the same slot:

 && (
   <dev-foo/bar-1.5
   >=dev-foo/bar-1.3
 )

Advantages:
* minimal syntax change,
* possibility to enforce many different conditions on the matched package without the need to repeat the range (e.g. different sets of USE flags).

Disadvantages:
* still verbose, package name repeated needlessly,
* adding a group requires determining interaction with other groups,
* solves only problem A.

=== Arithmetic version ranges ===
The idea is to use arithmetic notion of ranges:

 =dev-foo/bar-{1.3..1.5>

Problems:
* limited to few operators by design,
* we will probably have to support inclusive and exclusive ranges -- weird syntax,
* solves only problem A.

=== Multiple version operator approach ===
==== Multiple operator conjunction ====
Support specifying multiple version restrictions. All of the restrictions must match (i.e. logical AND).

 dev-foo/bar>=1.3<1.5
 dev-foo/bar{>=1.3,<1.5}
 dev-foo/bar>=1.3<1.5!=1.4.1
 dev-foo/bar{>=1.3,<1.5,!=1.4.1}

Problems:
* solves only problem A.

==== Multiple operator conjunction or disjunction ====
This is the Exherbo approach. The restriction can be either AND-ed or OR-ed (but not both).

 dev-foo/bar[>=1.3&<1.5]
 dev-foo/bar[>=1.3&<1.5&!=1.4.1]
 dev-foo/bar[<1.1|>=1.5]
 dev-foo/bar[=1.1*|=1.3*|>=1.5]

Problems:
* expressing two disjoint ranges requires multiple != exclusions.

==== Full-blown logic ====
Alternatively, we can support AND, OR and nesting.

 dev-foo/bar[(>=1.3&<1.5)|(>=0.9&<1.1)]

Problems:
* added complexity.

== Revision-related operators ==
=== Existing: ~ operator ===
The existing ~ operator can be used to depend on a specific version of package while allowing for Gentoo-specific revisions to differ.

 ~dev-foo/bar-1.4.2

is equivalent to range:

 >=dev-foo/bar-1.4.2
 <dev-foo/bar-1.4.2_p    # smallest next valid version

Problems:
* non-symmetry (~ is modification of =, but no variants for <, <=... are provided),
* inability to further restrict allowed revisions (i.e. v1.4.2, r2+).

=== Missing: end-of-rev-range operators ===
==== Problem ====
Currently we lack a way to express -r9999... that would match all possible revisions of the package. It could be useful with > and < (>= and <= would be equivalent, since the max value is not limited) operators:

 >dev-foo/bar-1.4-r9999...      # matches 1.4_p, 1.4.0, 1.5...
 <=dev-foo/bar-1.4-r9999...     # matches ~1.4 or less

Problems:
* kinda ugly,
* revision value is not limited and some developers already use 8-digit revisions (dates).

==== Using next valid version ====
Alternatively, we can use the next valid version:

 >=dev-foo/bar-1.4_p
 <dev-foo/bar-1.4_p

Advantages:
* no extra syntax necessary,
* always matches all revisions.

Problems:
* still ugly-ish,
* to strictly match any crazy variant possible, we would be always be adding ''_p'' e.g. 1.4_p_p.

==== Range representation ====
The <= variant can be represented using range conjunction.

 dev-foo/bar[<1.4|~1.4]

The > variant would require negation of ~:

 dev-foo/bar[>1.4&!~1.4]

Advantages:
* requires only ~ and !~.

Problems:
* kinda awkward.

==== Additional operators ====
This could be accomplished via adding special >~ and <=~ operators, with ~ indicating ''cover the entire revision range'':

 >~dev-foo/bar-1.4              # version >1.4
 <=~dev-foo/bar-1.4             # version <=1.4

(the >=~ and <~ would logically be equivalent to the other two)

Problems:
* may be a bit confusing: >~1.4 looks like -r0 but matches -r9999...,
* (1.4-r3 <=~ 1.4 <=~ 1.4-r1) is true,
* ruby uses ~> for another purpose,
* non-symmetry: we can add equivalent >=~ and <~ ops, or reduce both to >~ and <~ (in both cases additional confusion possible).

==== Explicit -rMAX ====
Alternatively, a special -r value can be added to indicate a value larger than any valid revision.

 >dev-foo/bar-1.4-rMAX
 <=dev-foo/bar-1.4-rMAX

Advantages:
* clearly readable.

Problems:
* additional magic value that is not valid in versions.

== Component-wide prefix comparison ==
=== Existing: =...* operator ===
The existing = operator can be used with * wildcard on the end of the version to indicate component-wide prefix comparison.

 =dev-foo/bar-1*

is equivalent to range:

 >=dev-foo/bar-1_alpha_alpha_alpha... # this can go on to infinity
 <dev-foo/bar-2         # next valid value of the last version component

Problems:
* non-symmetry (<, <=... do not support * variants),
* often confused with wildcard,
* sometimes confused not to match _pre, _rc... suffixes.
