<languages />


{{Metadata|abstract=De plus en plus de systèmes requièrent un système de fichiers virtuel initial (initramfs) pour démarrer proprement. Dans ce guide, nous abordons le concept de système de fichiers virtuel initial et la manière d'en créer et d'en gérer correctement des instances.}}

De plus en plus de systèmes requièrent un ''système de fichiers virtuel initial'' (initramfs) pour démarrer correctement. Dans ce guide, nous nous abordons le concept de système de fichiers virtuel initial (''initramfs'') et la manière de créer et de gérer des instances d'un tel système.

== Concept du système de fichiers virtuel initial (Initramfs) ==

=== Introduction ===

Beaucoup d'utilisateur ne se soucient pas de ce système de fichiers virtuel. Leur système utilise un schéma de partitionnement simple, sans pilote exotique ou sans configuration particulière (comme un système de chiffré/crypté), et ainsi, le noyau Linux est en mesure de passer le contrôle au binaire {{c|init}} de leur système. Mais, pour beaucoup de système, un système de fichiers virtuel (initramfs system) initial est presque indispensable. 

La clé pour comprendre ce qu'est (ou ce à quoi sert) un système de fichiers virtuel initial (initramfs), c'est de comprendre comment le processus de démarrage de Linux opère, même dans les grandes lignes. 

=== Le processus de démarrage de Linux ===

Dès que le noyau Linux a le contrôle sur le système (qu'il obtient après avoir été chargé par le chargeur de démarrage), il prépare ses structures mémoire et ses pilotes. Il passe ensuite le contrôle à une application (en général {{c|init}}) dont la tâche et de compléter la préparation du système et de s'assurer que, à la fin du processus de démarrage, tous les services nécessaires sont démarrés et que l'utilisateur est en mesure de se connecter.L'application {{c|init}} accomplit cela en lançant, entre autres services, le démon {{c|udev}} qui chargera ensuite et préparera le système en fonction des périphériques détectés. Lorsque  {{c|udev}} est lancé, tous les systèmes de fichiers qui n'ont pas encore été montés le sont, et le reste des services est démarré. 

Pour les systèmes dans lesquels tous les fichiers et outils nécessaires résident sur le même système de fichiers, l'application {{c|init}} peut parfaitement contrôler la suite du processus de démarrage. Mais lorsque des systèmes de fichiers multiples sont définis (ou des installations plus exotiques ont lieu), ceci peut devenir plus problématique : 

* Quand la partition {{Path|/usr}} est sur un système de fichiers séparé, les outils et les pilotes qui ont des fichiers stockés dans {{Path|/usr}} ne peuvent être utilisés sauf si {{Path|/usr}} est accessible. Si ces outils sont nécessaires pour rendre  {{Path|/usr}} accessible, alors il devient impossible de démarrer le système.

* Si le système de fichier root est chiffré/crypté, alors le noyau Linux ne sera incapable de trouver l'application {{c|init}} ce qui conduira à un système non amorçable (unbootable).

La solution à ces problèmes a été pendant longtemps d'utiliser un disque racine initial ''initrd''. 

=== Le disque root initial ===

''initrd'' est une structure de disque en mémoire (ramdisk) qui contient les outils et scripts nécessaires au montage des systèmes de fichiers requis avant que le contrôle ne soit passé à l'application {{c|init}} du système de fichier ''root''. Le noyau Linux déclenche le script de configuration (ordinairement appelé  {{Path|linuxrc}} mais ça n'est pas une obligation) sur ce disque ''root'', lequel prépare le système, commute vers le système de fichiers ''root'' réel et appelle ensuite {{c|init}}. 

Bien que la méthode de l'''initrd'' soit suffisante, elle présente quelques inconvénients : 

* C'est un périphérique de blocs à part entière, qui nécessite le surcoût d'un système de fichiers complet sur lui, et a une taille fixe. Choisissez un ''initrd'' trop petit, et vous ne pourrez y placer tous les scripts nécessaires. Choisissez-le trop grand et vous allez gaspiller la mémoire.

* Comme c'est un périphérique réel statique, il consomme  de la mémoire cache dans le noyau Linux et est sujet aux méthodes de gestion de fichiers utiliser(tel que paging) accroissant la consommation de mémoire de initrd.

C'est pour résoudre ces problèmes, que le système de fichiers virtuel initial (''initramfs'') a été inventé.

=== Le système de fichiers virtuel initial ===

Un système de fichiers virtuel initial (''initramfs'') est un système de fichiers initial en mémoire ram basé sur ''tmpfs'' (un système de fichiers léger de taille flexible, en mémoire), qui n'utilise pas un périphérique de blocs séparé (ainsi aucun cache n'est nécessaire, ce qui élimine les surcoûts mentionnés précédemment). Tout comme le ''initrd'', il contient les outils et les scripts nécessaire au montage des systèmes de fichiers avant que le contrôle e soit passé à l'application {{c|init}} du système de fichiers ''root'' réel.Ces outils peuvent être, des couches d'abstraction du chiffrage (pour les système chiffrés/cryptés), des gestionnaire de volumes logiques, le raid logiciel, des chargeurs de systèmes de fichiers basés sur des pilotes bluetooth, etc. 

Le contenu de l'''initramfs'' est créé en créant une archive ''cpio''. {{c|cpio}} est une ancienne (mais éprouvé) solution d'archivage de fichiers. Les archives produites sont appelées ''fichiers cpio''. cpio est comparable à l'archiveur {{c|tar}}. {{c|cpio}} a été choisi ici parce que le code était plus facile à mettre en œuvre et qu'il prend en charge des fichiers de périphériques, ce que {{c|tar}} ne pouvait pas. 

Tous les fichiers, les outils, les bibliothèques, les fichiers de configuration (si applicables), etc. sont placés dans l'archive cpio. L'archive est ensuite compressée avec l'utilitaire {{c|gzip}} et stockée avec le noyau Linux. Le chargeur d'amorçage (boot loader) le présente ensuite au noyau Linux au moment du démarrage ainsi le noyau sait qu'un système de fichiers virtuel initial (initramfs) est nécessaire. 

Une fois détecté, le noyau Linux crée un système de fichiers ''tmpfs'', extrait le contenu de l'archive dans ce  système de fichiers, et lance le script {{Path|init}} situé à la racine du système de fichiers ''tmpfs''. Ce script monte ensuite la racine (root) du système de fichiers réel (après s'être assuré qu'il peut le faire, par exemple en chargeant des modules additionnels, en préparant un couche d'abstraction du chiffrage, etc.) ainsi que les autres systèmes de fichiers vitaux (comme {{Path|/usr}} and {{Path|/var}}). 

Dès lors que le système de fichier racine (root) et les autres systèmes de fichiers vitaux sont montés, le script {{Path|init}} du ''initramfs'' commute la racine (root) vers le système de fichiers racine réel et, finalement, appelle le binaire {{Path|/sbin/init}} sur ce système pour continuer le processus de démarrage.

== Créer un système de fichiers virtuel initial (initramfs) ==

=== Introduction et configuration du chargeur de démarrage (bootloader) ===

Pour créer un système de fichiers virtuel initial, il est important de connaître quels pilotes, scripts et outils additionnels sont nécessaires au démarrage du système. Par exemple, lors de l'utilisation de LVM, il faut disposer des outils de  prise en charge de LVM dans l'''initramfs''. De la même manière, lors de l'utilisation de ''RAID logiciel'', {{c|mdadm}} est nécessaire, et ainsi de suite. 

Des outils existent pour aider l'utilisateur à créer l'archive compressée du système de fichiers virtuel initial (archives {{c|cpio}} compressées)  pour leurs système. Ceux qui tiennent à conserver un contrôle total, peuvent aussi créer facilement une ''initramfs''. 

Une fois créée, la configuration du chargeur de démarrage  devra être ajustée pour l'informer qu'un ''initramfs'' doit être utilisé. Par exemple, si le fichier ''initramfs'' est stocké dans {{Path|/boot/initramfs-3.2.2-gentoo-r5}}, alors la configuration dans {{Path|/boot/grub/grub.conf}} pourrait ressembler à ceci : 

{{FileBox|filename=grub.conf|title=Exemple d'entrée dans  grub.conf pour démarrer avec un  initramfs|1=
title Gentoo Linux 3.2.2-r5
root (hd0,0)
kernel /boot/kernel-3.2.2-gentoo-r5
initrd /boot/initramfs-3.2.2-gentoo-r5
}}

=== En utilisant genkernel ===

L'utilitaire de compilation du noyau {{c|genkernel}} peut être utilisé pour générer un ''initramfs'', même si {{c|genkernel}} n'a pas été utilisé pour configurer et compiler le noyau. 

Pour créer un ''initramfs'' en utilisant {{c|genkernel}}, il est recommandé que d'inclure tous les pilotes et codes nécessaires au montage des systèmes de fichiers {{Path|/}} et {{Path|/usr}} dans le noyau (pas en tant que modules). Ensuite lancez {{c|genkernel}} comme indiqué ci-dessous : 

{{RootCmd|genkernel --install --no-ramdisk-modules initramfs}}

Selon le système, il peut être nécessaire d'ajouter une, ou plus, des options suivantes : 

{| class="table" style="text-align: left;" 
|- 
! Option
! Description
|- 
| <code>--disklabel</code>
| Ajoute la prise en charge  des <code>LABEL=</code> de disque dans votre {{Path|/etc/fstab}} 
|- 
| <code>--dmraid</code>
| Ajoute la prise en charge du RAID matéril factice
|- 
| <code>--firmware</code>
| Ajoute le micro-code trouvé sur le système. 
|- 
| <code>--gpg</code>
| Ajoute la prise en charge de  GnuPG 
|- 
| <code>--iscsi</code>
| Ajoute la prise en charge de iSCSI
|- 
| <code>--luks</code>
| Ajoute la prise en charge des conteneurs de chiffrage luks 
|- 
| <code>--lvm</code>
| Ajoute la prise en charge de  LVM
|- 
| <code>--mdadm</code>
| Ajoute la prise en charge du RAID logiciel
|- 
| <code>--multipath</code>
| Ajoute la prise en charge pour des accès entrée/sortie multiples vers un   SAN
|- 
| <code>--zfs</code>
| Ajoute la prise en charge de ZFS
|-
|}

Une fois terminé, le fichier ''initramfs'' résultant est stocké dans le répertoire {{Path|/boot}}.

=== En utilisant dracut ===

{{Warning/fs|Au moment de la rédaction de ce document, dracut n'est pas encore marqué ''stable'', il peut être nécessaire de le démasquer avant de continuer.}}

L'utilitaire {{c|dracut}} a été créé dans le seul but de gérer les fichiers ''initramfs''. Il utilise une approche très modulaire à propos des prises en charge qui seront incluse et de celles qui ne le seront pas. 

Lorsque de l'instalation de {{c|dracut}}, faire attention à inclure la prise  en charge des  valeur(s) de la variable <code>DRACUT_MODULES</code> (modules dracut) corrects. C'est une variable que vous pouvez définir dans {{Path|/etc/portage/make.conf}}  pour inclure les prises en charge de configurations spécifiques. 

{{FileBox|filename=make.conf|title=Préparer l'installation de  Dracut|lang=bash|1=<pre>
DRACUT_MODULES="dmraid lvm syslog -biosdevname -btrfs -caps -crypt -crypt-gpg
-dmsquash-live -gensplash -iscsi -livenet -mdraid -multipath -nbd -nfs -plymouth
-ssh-client"
</pre>
}}

Il est recommandé d'activer (ou désactiver) les modules nécessaire. Après avoir configurer les variables <var>DRACUT_MODULES</var> dans {{Path|/etc/portage/make.conf}}, installez ''Dracut'' avec {{c|emerge dracut}} . 

L'étape suivante consiste à configure {{c|dracut}} en éditant {{Path|/etc/dracut.conf}}. Dans le fichier de configuration, qui est très bien commenté, ajouter la prise en charge des modules spécifiques nécessaire.

Une fois configuré, créer un ''initramfs'' en appelant  {{c|dracut}} comme indiqué ci-dessous : 

{{RootCmd|dracut}}

L'image résultante prend en charge les systèmes de démarrage génériques en se basant sur la configuration déclarée dans {{Path|/etc/dracut.conf}}. Il est aussin possible de générer un ''initramfs'' spécifique a ''votre'' système (dans lequel {{c|dracut}} essaie de détecter le outils, pilotes, etc. nécessaires depuis le système existant). Si la prise en charge nécessaire (code et pilote) est incluse dans le noyau (pas en tant que module séparés et référence aux firmware), alors l'option  <code>--no-kernel</code> peut être ajouter: 

{{RootCmd|dracut --host-only --no-kernel}}

Pour plus d'informations, jetez un coup d'œil aux page de manuel de dracut et dracut.cmdline.
{{Cmd
 	+	
|man dracut
 	+	
|man dracut.cmdline
 	+	
}}

== Ressources additionnelles ==

* [[Initramfs]]  official Gentoo Wiki.
* [[Dracut]] official Gentoo Wiki.

== Ressources Externe ==

* Le fichier [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt ramfs-rootfs-initramfs.txt] dans la documentation du noyau linux (Linux kernel).


[[Category:Initramfs]]
