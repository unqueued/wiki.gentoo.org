<languages />


{{Metadata|abstract=De plus en plus de systèmes requièrent un système de fichiers virtuel initial (initramfs) pour démarrer proprement. Dans ce guide, nous abordons le concept de système de fichiers virtuel initial et la manière d'en créer et d'en gérer correctement des instances.}}

De plus en plus de systèmes requièrent un ''système de fichiers virtuel initial'' (initramfs) pour démarrer correctement. Dans ce guide, nous nous abordons le concept de système de fichiers virtuel initial (''initramfs'') et la manière de créer et de gérer des instances d'un tel système.

== Concept du système de fichiers virtuel initial (Initramfs) ==

=== Introduction ===

Beaucoup d'utilisateur ne se soucient pas de ce système de fichiers virtuel. Leur système utilise un schéma de partitionnement simple, sans pilote exotique ou sans configuration particulière (comme un système de chiffré/crypté), et ainsi, le noyau Linux est en mesure de passer le contrôle au binaire {{c|init}} de leur système. Mais, pour beaucoup de système, un système de fichiers virtuel (initramfs system) initial est presque indispensable. 

La clé pour comprendre ce qu'est (ou ce à quoi sert) un système de fichiers virtuel initial (initramfs), c'est de comprendre comment le processus de démarrage de Linux opère, même dans les grandes lignes. 

=== Le processus de démarrage de Linux ===

Dès que le noyau Linux a le contrôle sur le système (qu'il obtient après avoir été chargé par le chargeur de démarrage), il prépare ses structures mémoire et ses pilotes. Il passe ensuite le contrôle à une application (en général {{c|init}}) dont la tâche et de compléter la préparation du système et de s'assurer que, à la fin du processus de démarrage, tous les services nécessaires sont démarrés et que l'utilisateur est en mesure de se connecter.L'application {{c|init}} accomplit cela en lançant, entre autres services, le démon {{c|udev}} qui chargera ensuite et préparera le système en fonction des périphériques détectés. Lorsque  {{c|udev}} est lancé, tous les systèmes de fichiers qui n'ont pas encore été montés le sont, et le reste des services est démarré. 

Pour les systèmes dans lesquels tous les fichiers et outils nécessaires résident sur le même système de fichiers, l'application {{c|init}} peut parfaitement contrôler la suite du processus de démarrage. Mais lorsque des systèmes de fichiers multiples sont définis (ou des installations plus exotiques ont lieu), ceci peut devenir plus problématique : 

* Quand la partition {{Path|/usr}} est sur un système de fichiers séparé, les outils et les pilotes qui ont des fichiers stockés dans {{Path|/usr}} ne peuvent être utilisés sauf si {{Path|/usr}} est accessible. Si ces outils sont nécessaires pour rendre  {{Path|/usr}} accessible, alors il devient impossible de démarrer le système.

* Si le système de fichier root est chiffré/crypté, alors le noyau Linux ne sera incapable de trouver l'application {{c|init}} ce qui conduira à un système non amorçable (unbootable).

La solution à ces problèmes a été pendant longtemps d'utiliser un disque racine initial ''initrd''. 

=== Le disque root initial ===

The '''initrd''' is an in-memory disk structure (ramdisk) that contains the necessary tools and scripts to mount the needed file systems ''before'' control is handed over to the {{c|init}} application on the root file system. The Linux kernel triggers the setup script (usually called {{Path|linuxrc}} but that name is not mandatory) on this root disk, which prepares the system, switches to the real root file system and then calls {{c|init}}. 

Bien que la méthode de l'''initrd'' soit suffisante, elle présente quelques inconvénients : 

* C'est un périphérique de blocs à part entière, qui nécessite le surcoût d'un système de fichiers complet sur lui, et a une taille fixe. Choisissez un ''initrd'' trop petit, et vous ne pourrez y placer tous les scripts nécessaires. Choisissez-le trop grand et vous allez gaspiller la mémoire.

* Comme c'est un périphérique réel, il consomme également de la mémoire cache dans le noyau Linux.

C'est pour résoudre ces problèmes, que le système de fichiers virtuel initial (''initramfs'') a été inventé. 

=== Le système de fichiers virtuel initial ===

An '''initramfs''' is an initial ram file system based on ''tmpfs'' (a size-flexible, in-memory lightweight file system), which also did not use a separate block device (so no caching was done and all overhead mentioned earlier disappears). Just like the initrd, it contains the tools and scripts needed to mount the file systems before the {{c|init}} binary on the real root file system is called. These tools can be decryption abstraction layers (for encrypted file systems), logical volume managers, software raid, bluetooth driver based file system loaders, etc. 

The content of the initramfs is made by creating a cpio archive. {{c|cpio}} is an old (but proven) file archiver solution (and its resulting archive files are called cpio files). cpio is definitely comparable to the {{c|tar}} archiver. The choice of {{c|cpio}} here was because it was easier to implement (code-wise) and supported (back then) device files which {{c|tar}} could not. 

All files, tools, libraries, configuration settings (if applicable), etc. are put into the cpio archive. This archive is then compressed using the {{c|gzip}} utility and stored alongside the Linux kernel. The boot loader will then offer it to the Linux kernel at boot time so the kernel knows an initramfs is needed. 

Une fois détecté, le noyau Linux crée un système de fichiers ''tmpfs'', extrait le contenu de l'archive dans ce  système de fichiers, et lance le script <code>init</code>  situé à la racine du système de fichiers ''tmpfs''. Ce script monte ensuite le système de fichiers réel (après s'être assuré qu'il peut le faire, par exemple en chargeant des modules additionnels, en préparant un couche d'abstraction du chiffrage, etc.) ainsi que les autres systèmes de fichiers vitaux (comme {{Path|/usr}} and {{Path|/var}}). 

Dès lors que le système de fichier ''root'' et les autres systèmes de fichiers vitaux sont montés, le script <code>init</code> depuis le ''initramfs'' commute la racine vers le système de fichiers racine réel et, finalement, appelle <code>/sbin/init</code> sur ce système pour continuer le processus de démarrage.

== Créer un système de fichiers virtuel initial (initramfs) ==

=== Introduction et configuration du chargeur de démarrage ===

To create an initramfs, it is important to know what additional drivers, scripts and tools will be needed to boot the system. For instance, if LVM is used, then LVM tools will be needed in the initramfs. Likewise, if software RAID is used, {{c|mdadm}} utilities will be needed, etc. 

Some tools exist that help users create initramfs (compressed {{c|cpio}} archives) for their system. But for those who want total control can easily create personal, custom initramfs images as well. 

Une fois créée, vous devez ajuster la configuration du chargeur de démarrage pour qu'il sache qu'un ''initramfs'' va être utilisé. Par exemple, si le fichier ''initramfs'' est stocké dans {{Path|/boot/initramfs-3.2.2-gentoo-r5}}, alors la configuration dans {{Path|/boot/grub/grub.conf}} pourrait ressembler à ceci : 

{{File|grub.conf|Exemple d'entrée dans  grub.conf pour démarrer avec un  initramfs|<pre>
title Gentoo Linux 3.2.2-r5
root (hd0,0)
kernel /boot/kernel-3.2.2-gentoo-r5
initrd /boot/initramfs-3.2.2-gentoo-r5
</pre>
}}

=== En utilisant genkernel ===

Gentoo's kernel building utility, {{c|genkernel}}, can be used to generate an initramfs, even if {{c|genkernel}} was not used to configure and build the kernel. 

To use {{c|genkernel}} for generating an initramfs, it is recommended all necessary drivers and code that is needed to mount the {{Path|/}} and {{Path|/usr}} file systems be included in the kernel (not as modules). Then, call {{c|genkernel}} as follows: 

{{RootCmd|genkernel --install --no-ramdisk-modules initramfs}}

Selon votre système, il peut être nécessaire d'ajouter une, ou plus, des options suivantes : 

{| class="table" style="text-align: left;" 
|- 
! Option
! Description
|- 
| <code>--disklabel</code>
| Add support for <code>LABEL=</code> settings in {{Path|/etc/fstab}} 
|- 
| <code>--dmraid</code>
| Add support for fake hardware RAID.
|- 
| <code>--firmware</code>
| Add in firmware code found on the system.
|- 
| <code>--gpg</code>
| Add in GnuPG support.
|- 
| <code>--iscsi</code>
| Add support for iSCSI.
|- 
| <code>--luks</code>
| Add support for LUKS encryption containers.
|- 
| <code>--lvm</code>
| Add support for LVM.
|- 
| <code>--mdadm</code>
| Add support for software RAID.
|- 
| <code>--multipath</code>
| Add support for multiple I/O access towards a SAN.
|- 
| <code>--zfs</code>
| Add support for ZFS.
|-
|}

Une fois terminé, le fichier ''initramfs'' résultant est stocké dans votre répertoire {{Path|/boot}}.

=== En utilisant dracut ===

{{Warning/fs|Au moment de la rédaction de ce document, dracut n'est pas encore marqué ''stable'', c'est pourquoi vous pouvez avoir besoin de le démasquer pour continuer.}}

The {{c|dracut}} utility is created for the sole purpose of managing initramfs files. It uses a highly modular approach on what support is to be included and what is not to be included. 

To install {{c|dracut}}, make special care to include support for the correct value(s) in the <var>DRACUT_MODULES</var> variable. This variable can be set in {{Path|/etc/portage/make.conf}} to include support for system specific setups: 

{{File|make.conf|Préparer l'installation de  dracut|<pre>
DRACUT_MODULES="dmraid lvm syslog -biosdevname -btrfs -caps -crypt -crypt-gpg
-dmsquash-live -gensplash -iscsi -livenet -mdraid -multipath -nbd -nfs -plymouth
-ssh-client"
</pre>
}}

It is advisable to set (or unset) the modules needed. After configuring the <var>DRACUT_MODULES</var> variable in {{Path|/etc/portage/make.conf}}, {{c|emerge dracut}} to install the Dracut utility. 

The next step is to configure {{c|dracut}} by editing {{Path|/etc/dracut.conf}}. In the configuration file, which is well commented, in order to add support for needed modules.

Once configured, create an initramfs by calling {{c|dracut}} as follows: 

{{RootCmd|dracut}}

The resulting image supports generic system boots based on the configuration in {{Path|/etc/dracut.conf}}. It is also possible to generate an initramfs specifically tailored to ''your'' system (which {{c|dracut}} tries to detect the needed tools, drivers, etc. from the existing system). If the modules and drivers are built into the kernel (not as separate modules and references to the firmware), then the <code>--no-kernel</code> option can be added: 

{{RootCmd|dracut --host-only --no-kernel}}

Pour plus d'informations, jetez un coup d'œil aux page de manuel <code>dracut</code> et <code>dracut.cmdline</code>.

== Ressources additionnelles ==

=== Ressources spécifiques à Gentoo ===


* [[Initramfs]] sur le wiki officiel de Gentoo
* [[Dracut]] sur le wiki officiel de Gentoo

* The [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt ramfs-rootfs-initramfs.txt] file within the Linux kernel documentation.


[[Category:Initramfs]]
