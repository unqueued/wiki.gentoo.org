<languages />


De plus en plus de systèmes requièrent un ''système de fichiers virtuel initial'' pour démarrer correctement. Dans ce guide, nous nous abordons le concept de système de fichiers virtuel initial (''initramfs'') et la manière de créer et de gérer des instances d'un tel système.

== Concept du système de fichiers virtuel initial (Initramfs) ==

=== Introduction ===

Beaucoup d'utilisateur ne se soucient pas de ce système de fichiers virtuel. Leur système utilise un schéma de partitionnement simple, sans pilote exotique ou sans configuration particulière (comme un système chiffré), et ainsi, le noyau Linux est en mesure de passer le contrôle au binaire <code>init</code> sur leur système. Mais, pour beaucoup de système, un système de fichiers virtuel initial est presque indispensable. 

La clé pour comprendre ce qu'est (ou ce à quoi sert) un système de fichiers virtuel initial, c'est de comprendre comment le processus de démarrage de Linux travaille, même dans les grandes lignes. 

=== Le processus de démarrage de Linux ===

Dès lors que le noyau Linux a le contrôle sur le système (qu'il obtient après avoir été chargé par le chargeur de démarrage), il prépare ses structures mémoire et ses pilotes comme il le peut. Il passe ensuite le contrôle à une application (en général <code>init</code>) dont la tâche et de compléter la préparation du système et de s'assurer que, à la fin du processus de démarrage, tous les services nécessaires sont démarrés et que l'utilisateur est en mesure de se connecter.L'application <code>init</code> accomplit cela en lançant, entre autres services, le démon  <code>udev</code> qui chargera ensuite et préparera le système en fonction des périphériques détectés. Lorsque  <code>udev</code> est lancé, tous les systèmes de fichiers qui n'ont pas encore été montés le sont, et le reste des services est démarré. 

Pour les systèmes dans lesquels tous les fichiers et outils nécessaires résident sur le même système de fichiers, l'application <code>init</code>  peut parfaitement contrôler la suite du processus de démarrage. Mais lorsque des systèmes de fichiers multiples sont définis (ou des installations plus exotiques ont lieu), ceci peut devenir plus problématique : 

* Quand la partition {{Path|/usr}} est sur un système de fichiers séparé, les outils et les pilotes qui ont des fichiers stockés dans {{Path|/usr}} ne peuvent être utilisés sauf si  {{Path|/usr}} est accessible. Si ces outils sont nécessaires pour rendre  {{Path|/usr}} accessible, alors il devient impossible de démarrer le système.

* Si le système de fichier root est chiffré, alors le noyau Linux ne sera pas capable de trouver l'application  <code>init</code> ce qui conduira à un système non amorçable.

La solution à ces problèmes a été pendant longtemps d'utiliser un disque racine initial ''initrd''. 

=== Le disque root initial ===

''initrd'' est une structure de disque en mémoire (ramdisk) qui contient les outils et scripts nécessaires au montage les systèmes de fichiers requis avant que le contrôle ne soit passé à l'application  <code>init</code> application sur le système de fichier ''root''. Le noyau Linux déclenche le script de configuration (ordinairement appelé  <code>linuxrc</code> mais ça n'est pas une obligation) sur ce disque ''root'', qui prépare le système, commute vers le système de fichiers ''root'' réel et appelle ensuite <code>init</code>. 

Bien que la méthode de l'''initrd'' soit suffisante, elle présente quelques inconvénients : 

* C'est un périphérique de blocs à part entière, qui nécessite le surcoût d'un système de fichiers complet sur lui, et a une taille fixe. Choisissez un ''initrd'' trop petit, et vous ne pourrez y placer tous les scripts nécessaires. Choisissez-le trop grand et vous allez gaspiller la mémoire.

* Comme c'est un périphérique réel, il consomme également de la mémoire cache dans le noyau Linux.

C'est pour résoudre ces problèmes, que le système de fichiers virtuel initial (''initramfs'') a été inventé. 

=== Le système de fichiers virtuel initial ===

Un système de fichiers virtuel initial (''initramfs'') est un système de fichiers initial en mémoire ram basé sur ''tmpfs'' (un système de fichiers léger de taille flexible, en mémoire), qui n'utilise pas un périphérique de blocs séparé (ainsi aucun cache n'est nécessaire, ce qui élimine les surcoûts mentionnés précédemment). Tout comme le ''initrd'', il contient les outils et les scripts nécessaire au montage des systèmes de fichiers avant que le contrôle e soit passé à l'application <code>init</code>  sur le système de fichiers ''root'' réel.Ces outils peuvent être, des couches d'abstraction du chiffrage (pour les système chiffrés), des gestionnaire de volumes logiques, le raid logiciel, des chargeurs de systèmes de fichiers basés sur des pilotes bluetooth, etc. 

Le contenu de l'''initramfs'' est créé en créant une archive ''cpio''. <code>cpio</code>  est une ancienne (mais qui a fait ses preuves) solution d'archivage de fichiers. Les archives produites sont appelées ''fichiers cpio''. Vous pouvez le comparer à <code>tar</code>. Il a été choisi ici parce que le code est plus facile à mettre en œuvre et qu'il prend en charge des fichiers de périphériques que <code>tar</code> ne prend pas en charge. 

Tous les fichiers, les outils, les bibliothèques, les fichiers de configuration (si applicables), etc. sont placés dans l'archive cpio. L'archive est ensuite compressée avec l'utilitaire <code>gzip</code> et stockée avec le noyau Linux. Le chargeur d'amorçage le présente ensuite au noyau Linux au moment du démarrage de manière à ce que le noyau sache qu'un système de fichiers virtuel initial est nécessaire. 

Une fois détecté, le noyau Linux crée un système de fichiers ''tmpfs'', extrait le contenu de l'archive dans ce  système de fichiers, et lance le script <code>init</code>  situé à la racine du système de fichiers ''tmpfs''. Ce script monte ensuite le système de fichiers réel (après s'être assuré qu'il peut le faire, par exemple en chargeant des modules additionnels, en préparant un couche d'abstraction du chiffrage, etc.) ainsi que les autres systèmes de fichiers vitaux (comme {{Path|/usr}} and {{Path|/var}}). 

Once the root file system and the other vital file systems are mounted, the <code>init</code> script from the initramfs will switch the root towards the real root file system and finally call the <code>/sbin/init</code> on that system to continue the boot process. 

== Creating an initramfs ==

=== Introduction and bootloader configuration ===

To create an initramfs, it is important that you know what additional drivers, scripts and tools you need to boot your system. For instance, if you use LVM, then you will need to support LVM tools on the initramfs. Likewise, if you use software RAID, you need <code>mdadm</code>, etc. 

Some tools exist that help you create initramfs' (compressed cpio archives) for your system. But for those that want total control, you can easily create your own initramfs as well. 

Once created, you will need to adjust the bootloader configuration to tell it that an initramfs is to be used. For instance, if the initramfs file is stored as {{Path|/boot/initramfs-3.2.2-gentoo-r5}} , then the configuration in {{Path|/boot/grub/grub.conf}} could look like so: 

{{File|grub.conf|Example entry in grub.conf for booting with an initramfs|<pre>
title Gentoo Linux 3.2.2-r5
root (hd0,0)
kernel /boot/kernel-3.2.2-gentoo-r5
initrd /boot/initramfs-3.2.2-gentoo-r5
</pre>
}}

=== Using genkernel ===

Gentoo's kernel building utility, <code>genkernel</code>, can be used to generate an initramfs, even if you didn't use <code>genkernel</code> to configure and build your kernel. 

To use <code>genkernel</code> for generating an initramfs, it is recommended that you include all necessary drivers and code that is needed to mount your {{Path|/}} and {{Path|/usr}} file systems in the kernel (and not as modules). Then, call <code>genkernel</code> as follows: 

{{RootCmd|genkernel --install --no-ramdisk-modules initramfs}}

Depending on your system, you might want to add one or more of the following options: 

{| class="wikitable" style="text-align: left;" 
|- 
! Option
! Description
|- 
| --disklabel
| Add support for <code>LABEL=</code> settings in your {{Path|/etc/fstab}} 
|- 
| --dmraid
| Add support for fake hardware RAID
|- 
| --firmware
| Add in firmware code found on the system
|- 
| --gpg
| Add in GnuPG support
|- 
| --iscsi
| Add support for iSCSI
|- 
| --luks
| Add support for luks encryption containers
|- 
| --lvm
| Add support for LVM
|- 
| --mdadm
| Add support for software RAID
|- 
| --multipath
| Add support for multiple I/O access towards a SAN
|- 
| --zfs
| Add support for ZFS
|-
|}

When finished, the resulting initramfs file will be stored in your {{Path|/boot}} . 

=== Using dracut ===

{{Warning|At the time of writing, dracut is not marked stable yet, so you might need to unmask it before continuing.}}

The <code>dracut</code> utility is created for the sole purpose of managing initramfs files. It uses a highly modular approach on which support you want to include and which not. 

When you install <code>dracut</code>, you will need to take care to include support for the correct <code>DRACUT_MODULES</code> . This is a variable you can set in {{Path|/etc/portage/make.conf}} to include support for specific setups: 

{{File|make.conf|Preparing to install dracut|<pre>
DRACUT_MODULES="dmraid lvm syslog -biosdevname -btrfs -caps -crypt -crypt-gpg
-dmsquash-live -gensplash -iscsi -livenet -mdraid -multipath -nbd -nfs -plymouth
-ssh-client"
</pre>
}}

It is advisable to set (or unset) those modules you need (and don't need). Afterwards, <code>emerge dracut</code> to install the utility on your system. 

The next step is to configure <code>dracut</code> by editing {{Path|/etc/dracut.conf}}. In the configuration file, which is well commented, you can add in support for specific modules where needed. 

Once configured, create an initramfs by calling <code>dracut</code> as follows: 

{{RootCmd|dracut}}

The resulting image supports generic system boots based on the configuration in {{Path|/etc/dracut.conf}}. You can also opt to generate an initramfs specifically tailored to your system (in which <code>dracut</code> tries to detect the needed tools, drivers, etc. from your existing system). If you know that the needed support (code and drivers) is built in in your kernel (and not as module), then you can even add in <code>--no-kernel</code>: 

{{RootCmd|dracut --host-only --no-kernel}}

For more information, check out the <code>dracut</code> and <code>dracut.cmdline</code> manual pages. 

== Additional resources ==

=== Gentoo-specific ===

* [http://en.gentoo-wiki.com/wiki/Initramfs Initramfs] on Gentoo-wiki.com
* [[Initramfs]] on the official Gentoo Wiki
* [[Dracut]] on the official Gentoo Wiki

=== General resources ===

* [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt ramfs-rootfs-initramfs.txt] within the Linux kernel documentation

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:


* Sven Vermeulen
