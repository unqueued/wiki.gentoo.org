== Introduction ==

=== What is Composer? ===

[https://getcomposer.org/ Composer] is a bundling dependency manager for PHP projects. It's similar to [http://bundler.io/ Bundler] (for Ruby) or [http://www.npmjs.org/ npm] (for Javascript). It automates the process of downloading your project's dependencies. Recently it has become extremely popular and is used by major projects like [https://phpunit.de/ PHPUnit] and [http://www.drush.org/ Drush].

The main repository for Composer packages is [https://packagist.org/ Packagist].

=== How does it work? ===

Each project that can be installed with Composer has a [https://getcomposer.org/doc/01-basic-usage.md#composer-json-project-setup composer.json] file that lists some information about it: the project name, its description, its dependencies, and so on. When you invoke Composer, it goes through that list of dependencies and downloads them all, storing them into your project's <code>vendor</code> directory. Afterwards, it generates a [http://php.net/manual/en/language.oop5.autoload.php PHP class autoloader] <code>vendor/autoload.php</code> that will automatically load any of the classes in your project or its dependencies.

=== Packaging hurdles ===

Most Composer packages use the autoloader (generated by Composer) to find and <code>include()</code> their class files. As a result, the <code>require()</code> statements typically used to include one PHP file into another are often missing. In that case, the package will not work out-of-the-box -- or in fact at all -- until an autoloader is created for it.

Composer's build system is incompatible with the way Gentoo's package managers work, so Composer cannot be used to generate the necessary autoloaders. For a long time, this obstacle prevented us from packaging anything that relied heavily on Composer. Fortunately, thanks to the hard work of other people, we now have decent workarounds for the problem.

== Autoloading ==

The autoloaders that Composer generates support the [http://www.php-fig.org/psr/psr-0/ PSR-0], [http://www.php-fig.org/psr/psr-4/ PSR-4], and [https://getcomposer.org/doc/04-schema.md#autoload classmap] formats. The generation of those autoloaders is the main obstacle to packaging Composer projects, and the creation of [https://github.com/php-fedora/autoloader the Fedora Autoloader] is the breakthrough that makes it possible.

The Fedora autoloader library provides a few functions -- <code>addPsr4</code>, <code>addPsr0</code>, and <code>addClassMap</code> -- that can generate class autoloaders for a directory tree. Moreover, it can build one big autoloader from a bunch of existing ones, allowing you to create an autoloader that works for an application and all of its dependencies (that's how Composer works). For example, the following file creates an autoloader for the {{Package|dev-php/psr-log}} package. The {{Path|psr-log-autoload.php}} file is meant to be locates in the same directory as the library code, so we tell the autoloader to look in the current directory <code>__DIR__</code> and to prefix the class names therein with <code>Psr\Log</code>:

{{FileBox|filename=psr-log-autoload.php|lang=php|1=
<?php
if (!class_exists('Fedora\\Autoloader\\Autoload', false)) {
  require('/usr/share/php/Fedora/Autoloader/autoload.php');
}

\Fedora\Autoloader\Autoload::addPsr4('Psr\\Log\\', __DIR__);
}}

Now, most people won't be using that package directly; instead, it will appear as a dependency of other PHP packages in the tree. In fact, it is used by {{Package|dev-php/composer}} itself. Here's a simplified version of the {{Path|composer-autoload.php}} file that not only generates an autoloader for the <code>Composer</code> namespace, but also pulls in the <code>Psr\Log</code> autoloader as well:

{{FileBox|filename=composer-autoload.php|lang=php|1=
<?php
if (!class_exists('Fedora\\Autoloader\\Autoload', false)) {
    require('/usr/share/php/Fedora/Autoloader/autoload.php');
}

\Fedora\Autoloader\Autoload::addPsr4('Composer\\', __DIR__);

// Dependencies, there are more in the real autoloader.
\Fedora\Autoloader\Dependencies::required(array(
  '/usr/share/php/Psr/Log/autoload.php'
));
}}

== Naming conventions ==

=== Ebuilds ===

[https://devmanual.gentoo.org/ebuild-writing/file-format/ Gentoo's naming conventions] and the [https://packagist.org/about ones for Composer/Packagist] don't quite agree. When choosing a Gentoo name for a Packagist project, you should try to choose the simplest name that is unambiguous and agrees with the Composer/Packagist names. Any slashes in the name must be converted to hyphens, and most packages should wind up in the <code>dev-php</code> category, although that's not required. The idea is best illustrated with some examples.

# The [https://packagist.org/packages/psr/log psr/log] package, once the slash is replaced by a hyphen, becomes {{Package|dev-php/psr-log}}. This closely matches what upstream uses, and what users will expect. A search for "psr" or "log" will turn up the correct package. The name <code>dev-php/log</code> would not be appropriate because it is too general.
# The [https://packagist.org/packages/fedora/autoloader fedora/autoloader] package becomes {{Package|dev-php/fedora-autoloader}}, because <code>dev-php/autoloader</code> is too general.
# The [https://packagist.org/packages/composer/composer composer/composer] package becomes simply {{Package|dev-php/composer}}, because there is no ambiguity in the name, and -- let's face it -- <code>dev-php/composer-composer</code> would be stupid.

=== Namespacing ===

Since we choose where to install everything, the resulting class namespaces are technically at our mercy. However, whenever possible, you should retain the upstream namespaces. As an example, consider the {{Package|dev-php/symfony-process}} package. Symfony is a large framework that contains a number of components, and the Process component is merely one piece of the puzzle. As a result, the upstream namespace used for it is <code>Symfony\Component\Process</code>, which does not quite agree with the "symfony-process" name in the ebuild. Nevertheless, if a user wants to use {{Package|dev-php/symfony-process}} directly, the [https://symfony.com/doc/current/components/process.html upstream documentation] will instruct him to use their namespaces:

{{FileBox|filename=symfony-process-example.php|lang=php|1=
<?php
use Symfony\Component\Process\Process;

$process = new Process('ls -lsa');
$process->run();

// etc.
}}

We don't want to invalidate all of the existing documentation without a very good reason.

== Tests ==

The test suites for Composer packages present another problem. Before a package is installed, it has no autoloader, but both the main class hierarchy and the test class hierarchy usually need autoloaders to be able to run.

Often you can fix this by copying the package's <code>autoload.php</code> file into both the current and test directories. This works because that autoloader is based on "the current directory," i.e. wherever you stick the file. Below you'll find an example from {{Package|dev-php/symfony-yaml}}. (If this doesn't work, you may have to get clever.)

{{FileBox|filename=symfony-yaml-2.1.0.ebuild|lang=bash|<nowiki>
src_prepare() {
    default
    if use test; then
        cp "${FILESDIR}"/autoload.php "${S}"/autoload-test.php || die
    fi
}

src_test() {
    phpunit --bootstrap "${S}"/autoload-test.php || die "test suite failed"
}</nowiki>}}
