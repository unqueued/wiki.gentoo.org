<languages />


{{Metadata|abstract=DM-Crypt는 리눅스 커널 암호화 API 프레임워크와 장치 매퍼 하위 시스템을 활용한 디스크 암호화 시스템입니다.}}

{{InfoBox stack
|{{InfoBox homepage|https://gitlab.com/cryptsetup/cryptsetup|header=true}}
|{{InfoBox wikipedia}}
}}

'''dm-crypt'''는 리눅스 커널 암호화 API 프레임워크와 장치 매퍼 하위 시스템을 활용한 디스크 암호화 시스템입니다. 관리자는 dm-crypt로 전체 디스크, 논리 볼륨 파티션, 단일 파일을 암호화할 수 있습니다.

dm-crypt 하위 시스템은 암호화 데이터 접근에 다중키를 허용하며, 키를 다루기도 하는(키 변경, 암호 추가 등)''리눅스 통합 키 설정(LUKS)'' 구조를 지원합니다. dm-crypt에서 비 LUKS 설정도 지원하지만, 이 글에서는 유연성, 관리성, 커뮤니티 규모의 광범위한 지원을 위한 LUKS 기능에 중점을 두었습니다.

== 설정 ==

dm-crypt를 활용할 수 있기 전 준비해야 할 두가지 사항이 있습니다:

# 커널 설정
# {{Package|sys-fs/cryptsetup}} 꾸러미 설치

=== 커널 설정 ===

dm-crypt를 사용하려면 설정해야 할 몇가지 사항이 있습니다.

먼저 ''device mapper'' 기반 구조 지원과 ''crypt target''을 커널에 포함해야합니다:

{{KernelBox|title=Enabling device mapper and crypt target|1=
[*] Enable loadable module support
Device Drivers --->
    [*] Multiple devices driver support (RAID and LVM) --->
        <*> Device mapper support
        <*>   Crypt target support
}}

다음, 관리자가 암호화 기능을 사용하려면 리눅스 커널에서 암호화 API 모음을 지원해야 합니다. "Cryptographic API" 섹션에서 찾아볼 수 있습니다:

{{KernelBox|title=암호화 API 기능 활성화|1=
[*] Cryptographic API --->
    <*> SHA224 and SHA256 digest algorithm
    <*> XTS support
    <*> AES cipher algorithms
    <*> AES cipher algorithms (x86_64)
}}

마찬가지로 루트 파일 시스템을 암호화 했다면, 루트 파일 시스템을 마운트하기 전 루트 파일 시스템을 해독할 램 파일 시스템을 만들어야 합니다. 따라서, initramfs 지원도 필요합니다:

{{KernelBox|title=initramfs 지원 활성화|1=
General setup  --->
    [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support
}}

=== Cryptsetup 설치 ===

The {{Package|sys-fs/cryptsetup}} package provides the {{c|cryptsetup}} command, which is used to open or close the encrypted storage as well as manage the passphrases or keys associated with it.

{{Emerge|sys-fs/cryptsetup}}

== 암호화 저장소 ==

=== 키 파일 또는 암호문 ===

In order to start with encrypted storage, the administrator will need to decide which method to use for the encryption key. With {{c|cryptsetup}} the choice is either a passphrase or a keyfile. In case of a keyfile, this can be any file, but it is recommended to use a file with random data which is properly protected (considering that access to this keyfile will mean access to the encrypted data).

To create a keyfile, one can use the {{c|dd}} command:

{{RootCmd|dd if{{=}}/dev/urandom of{{=}}/etc/keys/enc.key bs{{=}}1 count{{=}}4096}}

다음 단락에서는 암호문, 키 파일 두 가지 경우에 대해 모든 명령 과정을 보여드리겠습니다. 물론 둘 중 한가지 방식만 필요합니다.

=== 암호화 저장소 플랫폼 만들기 ===

In order to create an encrypted storage platform (which can be a disk, partition, file, ...) use the {{c|cryptsetup}} command with the <code>luksFormat</code> action.

예를 들어, 암호화 데이터가 담긴 {{Path|/dev/vdb2}} 저장소 매체를 취하려면:

{{RootCmd|cryptsetup -s 512 luksFormat /dev/vdb2|output=<pre>
This will overwrite data on /dev/vdb2 irrevocably.
  
Are you sure? (Type uppercase yes): YES
Enter LUKS passphrase: ...
Verify passphrase: ...
</pre>}}

암호문 대신 키 파일을 사용하려면:

{{RootCmd|cryptsetup -s 512 luksFormat /dev/vdb2 /etc/keys/enc.key|output=<pre>
This will overwrite data on /dev/vdb2 irrevocably.
  
Are you sure? (Type uppercase yes): YES
</pre>}}

The <code>-s 512</code> tells {{c|cryptsetup}} which keylength to use for the real encryption key (unlike the passphrase or keyfile, which are used to access this real encryption key).

=== 암호화 저장소 열기 ===

In order to open up the encrypted storage (i.e. make the real data accessible through transparent decryption), use the <code>luksOpen</code> action.

{{RootCmd|cryptsetup luksOpen /dev/vdb2 myname|output=<pre>
Enter passphrase for /dev/vdb2: ...
</pre>}}

키 파일을 사용한다면 명령은 다음과 같습니다:

{{RootCmd|cryptsetup luksOpen -d /etc/keys/enc.key /dev/vdb2 myname}}

When the command finishes successfully, then a new device file called {{Path|/dev/mapper/myname}} will be made available. This device file can then be mounted as a regular storage location:

{{RootCmd|mount /dev/mapper/myname /home}}

=== 암호화 저장소 닫기 ===

In order to close the encrypted storage (i.e. ensure that the real data is no longer accessible through transparent decryption), use the <code>luksClose</code> action:

{{RootCmd|cryptsetup luksClose myname}}

물론 해당 장치를 더 이상 사용하고 있지 않은지 확인하십시오.

== LUKS 키 다루기 ==

LUKS 는 실제 암호화 키에 접근할 때 사용합니다. (암호화) 파티션, 디스크, 파일의 헤더에 저장합니다.

=== 슬롯 감청 ===

With the <code>luksDump</code> action, information about the encrypted partition, disk or file can be shown. This includes the slots:

{{RootCmd|cryptsetup luksDump /dev/vdb2|output=<pre>
LUKS header information for /dev/vdb2
  
Version:        1
Cipher name:    aes
Cipher mode:    xts-plain64
Hash spec:      sha1
Payload offset: 4096
MK bits:        512
MK digest:      34 3b ec ac 10 af 19 e7 e2 d4 c8 90 eb a8 da 3c e4 4f 2e ce
MK salt:        ff 7c 7f 53 db 53 48 02 a4 32 dc e0 22 fc a3 51
                06 ba b3 48 b3 28 13 a8 7a 68 43 d6 46 79 14 fe
MK iterations:  59375
UUID:           2921a7c9-7ccb-4300-92f4-38160804e08c
  
Key Slot 0: ENABLED
        Iterations:             241053
        Salt:                   90 0f 0f db cf 66 ea a9 6c 7c 0c 0d b0 28 05 2f
                                8a 5c 14 54 98 62 1a 29 f3 08 25 0c ec c2 b1 68
        Key material offset:    8
        AF stripes:             4000
Key Slot 1: ENABLED
        Iterations:             273211
        Salt:                   01 4c 26 ed ff 18 75 31 b9 89 5d a6 e0 b5 f4 14
                                48 d0 23 47 a9 85 78 fb 76 c4 a9 d0 cd 63 fb d7
        Key material offset:    512
        AF stripes:             4000
Key Slot 2: DISABLED
Key Slot 3: DISABLED
Key Slot 4: DISABLED
Key Slot 5: DISABLED
Key Slot 6: DISABLED
Key Slot 7: DISABLED
</pre>}}

In the above example, two slots are used. Note that <code>luksDump</code> does not give away anything sensitive - it is merely displaying the LUKS header content. No decryption key has to be provided in order to call <code>luksDump</code>.

=== 키 파일 또는 암호문 추가 ===

In order to add an additional keyfile or passphrase to access the encrypted storage, use the <code>luksAddKey</code> action:

{{RootCmd|cryptsetup luksAddKey /dev/vdb2|output=<pre>
Enter any passphrase: (Enter a valid, previously used passphrase to unlock the key)
Enter new passphrase for key slot: ... 
Verify passphrase: ...
</pre>}}

키 파일로 키 잠금을 해제하려면(그래도 암호문에 추가한다면):

{{RootCmd|cryptsetup luksAddKey -d /etc/keys/enc.key /dev/vdb2|output=<pre>
Enter new passphrase for key slot: ...
Verify passphrase: '''
</pre>}}

키 파일({{Path|/etc/keys/backup.key}}를 말함)을 추가했다면:

{{RootCmd|cryptsetup luksAddKey /dev/vdb2 /etc/keys/backup.key}}

또는 메인키를 잠금 해제할 때 첫번째 키 파일을 사용한다면:

{{RootCmd|cryptsetup luksAddKey -d /etc/keys/enc.key /dev/vdb2 /etc/keys/backup.key}}

=== 키 파일 또는 암호문 제거 ===

With the <code>luksRemoveKey</code> action, a keyfile or passphrase can be removed (so they can no longer be used to decrypt the storage):

{{RootCmd|cryptsetup luksRemoveKey /dev/vdb2|output=<pre>
Enter LUKS passphrase to be deleted: ...
</pre>}}

또는 키 파일을 제거하려면:

{{RootCmd|cryptsetup luksRemoveKey -d /etc/keys/backup.key /dev/vdb2}}

데이터를 접근하는데 있어 최소한 한가지 방식은 두어야합니다. 사용할 암호문 또는 키 파일을 제거하면 다시 복구할 수 없습니다.

=== 슬롯 비우기 ===

암호문 또는 키 파일을 알 수 없는 경우를 가정하면 슬롯을 비워둘 수 있습니다. 물론 어떤 슬롯에 암호문 또는 키 파일을 저장했는지 우선 알고 있어야 합니다.

이를 테면 슬롯 2 번을 비워보겠숩니다(슬롯 번호가 0번부터 시작하므로 세번째 슬롯입니다):

{{RootCmd|cryptsetup luksKillSlot /dev/vdb2 2}}

이 명령은 계속하기 전 유효한 암호문을 요구합니다. 대신 사용할 키 파일을 전달할 수 있습니다:

{{RootCmd|cryptsetup luksKillSlot -d /etc/keys/enc.key /dev/vdb2 2}}

== 추가 자료 ==

* 젠투 위키의  [[DM-Crypt LUKS]] 에서는 젠투 리눅스 설치 과정에서 암호화 파일 시스템에 접근할 때 더욱 정교한 방식의 접근 방법을 설명합니다


[[Category:Core system]]
