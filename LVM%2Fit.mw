<languages />

{{Metadata|abstract=LVM consente agli amministratori di creare meta dispositivi che forniscono un livello di astrazione tra un file system e la memoria fisica che viene utilizzato al di sotto.}}

<noinclude>{{Confused|LLVM}}</noinclude>

{{InfoBox stack
|{{InfoBox wikipedia|Logical Volume Manager (Linux)|header=true}}
}}

'''LVM''' ('''L'''ogical '''V'''olume '''M'''anager) consente agli amministratori di creare meta dispositivi che forniscono un livello di astrazione tra un file system e la memoria fisica che viene utilizzata al di sotto. I meta dispositivi (su cui sono posti i file systems) sono "volumi logici", che utilizzano memoria dai lotti di memoria chiamati "volume groups". Un "volume groups" (gruppo di volumi) viene fornito con uno o più "physical volumes" (volumi fisici), che sono i veri dispositivi su cui sono memorizzati i dati.

I volumi fisici possono essere partizioni, interi hard disk SATA raggruppati come JBOD ('''J'''ust a '''B'''unch '''O'''f '''D'''isks), sistemi RAID, iSCSI, Fibre Channel, eSATA ecc...

== Installazione ==

LVM è gestita da entrambi, drivers kernel-level e applicazioni su spazio utente (user-space), per gestire la configurazione di LVM.

=== Kernel ===

Attivare le seguenti opzioni del kernel:

{{KernelBox|title=Enabling LVM|1=<pre>
Device Drivers  --->
   Multiple devices driver support (RAID and LVM)  --->
       <*> Device mapper support
           <*> Crypt target support
           <*> Snapshot target
           <*> Mirror target
       <*> Multipath target
           <*> I/O Path Selector based on the number of in-flight I/Os
           <*> I/O Path Selector based on the service time
</pre>}}

{{Note|Non tutto deve essere abilitato; alcune opzioni sono richieste solo per [[LVM#LVM2_snapshots_and_thin_snapshots|LVM2 Snapshots and LVM2 Thin Snapshots]], [[LVM#Mirrored_volumes|LVM2 Mirrors]], [[LVM#Striping_.28RAID0.29|LVM2 RAID 0/Stripeset]] e encryption.}}

=== USE flags ===

{{USEflag|package=sys-fs/lvm2}}

=== Emerge ===

After reviewing the USE flags, ask Portage to install the {{Package|sys-fs/lvm2}} package:

{{Emerge|sys-fs/lvm2}}

== Configurazione ==

La configurazione di LVM è eseguita su più livelli:
# Gestione di LV, PV e VG attraverso le utilità di gestione;
# Messa a punto del sottosistema LVM attraverso il file di configurazione;
# La gestione dei servizi a livello di distribuzione;
# Configurazione tramite una ram iniziale del file system (initramfs).

La gestione dei volumi logici e fisici nonché i gruppi di volumi viene gestita tramite il capitolo [[#Usage|Utilizzo]].

=== File di configurazione di LVM ===

LVM ha un vasto file di configurazione in {{Path|/etc/lvm/lvm.conf}}. La maggior parte degli utenti non avranno bisogno di modificare le impostazioni in questo file per iniziare ad utilizzare LVM.

=== Gestione del servizio ===

Gentoo fornisce il servizio di LVM per rilevare e attivare i gruppi di volumi e i volumi logici automaticamente.

Il servizio può essere gestito attraverso il sistema di init.

==== openrc ====

Per avviare LVM manualmente:

{{RootCmd|/etc/init.d/lvm start}}

Per avviare LVM in fase di avvio:

{{RootCmd|rc-update add lvm boot}}

==== systemd ====

Per avviare LVM manualmente:

{{RootCmd|systemctl start lvm2-monitor.service}}

Per avviare LVM in fase di avvio:

{{RootCmd|systemctl enable lvm2-monitor.service}}

=== Utilizzare LVM in un initramfs ===

La maggior parte dei bootloader non può essere avviata direttamente da LVM - né GRUB legacy né LILO possono farlo. Grub 2 PUO' avviare da un volume logico LVM lineare, volume logico con mirroring e forse alcuni tipi di volumi logici RAID. Attualmente nessun bootloader supporta volumi logici sottili. 

Per questa ragione è raccomandabile utilizzare una partizione di avvio non-LVM e montare la root LVM da initramfs. Tale initramfs può essere generato automaticamente tramite [[Genkernel|genkernel]], {{Package|sys-kernel/genkernel-next}} e [[dracut]]:

* {{c|genkernel}} può avviare da tutti i tipi tranne dai volumi sottili (in quanto non costruisce la copia del pacchetto binario {{Package|thin-provisioning-tools}} dall'host di compilazione) e forse anche RAID10 (il supporto RAID10 richiede LVM2 2.02.98, ma genkernel 2.02.89, tuttavia, se i binari statici sono disponibili, può copiare quelli);
* {{c|genkernel-next}} può avviare da tutti i tipi di volumi, ma ha bisogno di un nuovo pacchetto {{Package|app-misc/pax-utils}} o i binari sottili risultanti saranno rotti (See {{Bug|482504}});
* {{c|dracut}} dovrebbe avviare tutti i tipi, ma include solo il supporto sottile initramfs se l'host viene eseguito su una root sottile.

==== Genkernel/Genkernel-next ====

Emergere o il pacchetto {{Package|sys-kernel/genkernel}} o ilpacchetto {{Package|sys-kernel/genkernel-next}}. La USE flag statica può anche essere abilitata per il pacchetto {{Package|sys-fs/lvm2}} così che genkernel utilizzerà il sistema binario (altrimenti compilerà la propria copia privata). Il seguente esempio compilerà solo un initramfs (non un interno kernel) e abiliterà il supporto per LVM.

{{RootCmd|genkernel --lvm initramfs}}

La pagina di manuale di genkernel delinea le altre opzioni a seconda delle esigenze del sistema.

L'initrd richiederà i parametri per stabilire come avviare LVM, ed essi sono forniti allo stesso modo di altri parametri del kernel. Per esempio:

{{FileBox|filename=/etc/default/grub|title=Aggiungere dolvm come parametro di avvio del kernel|lang=bash|1=
GRUB_CMDLINE_LINUX="dolvm"
}}

==== Dracut ====

Il pacchetto {{Package|sys-kernel/dracut}} è stato importato dal progetto Red Hat e offre uno strumento simile per generare un initramfs. Dal momento che è attualmente in ~arch per essere testato, gli utenti dovranno [[Knowledge_Base:Accepting_a_keyword_for_a_single_package|accept it]] (mediante {{Path|/etc/portage/package.accept_keywords}}) per emergerlo. Prima di fare ciò, la variabile <code>DRACUT_MODULES="lvm"</code> dovrebbe essere aggiunta sul file {{Path|/etc/portage/make.conf}}. Altri moduli possono essere desiderati, fare riferimento al [[Dracut]]. In generale, il seguente comando genererà un predefinito initramfs funzionale.

{{RootCmd|dracut -a lvm}}

L'initrd richiederà parametri per stabilire come avviare LVM, e questi sono in dotazione come gli altri parametri del kernel. Per esempio:

{{FileBox|filename=/etc/default/grub|title=Aggiungere il supporto LVM ai parametri di avvio del kernel|lang=bash|1=
GRUB_CMDLINE_LINUX="rd.lvm.vg=vol00"
}}

Per una lista globale delle opzioni di LVM all'interno di {{c|dracut}} vedere la sezione nel [https://www.kernel.org/pub/linux/utils/boot/dracut/dracut.html#_lvm Manuale di Dracut].

== Utilizzo ==

LVM organizza la memoria in tre diversi livelli come segue:
* dichi fissi, partizioni, sistemi RAID o altri mezzi di memorizzazione vengono inizializzati come Volumi Fisici (PVs)
* Volumi fisici (PV) sono raggruppati in Gruppi di Volumi (VG)
* Volumi logici (LV) sono gestiti in Gruppi di Volumi (VG)

=== PV (Volume Fisico) ===
I Volumi Fisici sono gli attuali hardware o sistemi di memoria di LVM.

==== Partizionamento ====

{{Note|Utilizzare partizioni separate per approvvigionare memoria a gruppi di volumi è necessario solo se non si desidera utilizzare l'intero disco per un singolo gruppo di volumi LVM. Se può essere utilizzato l'intero disco, saltare questo passaggio e inizializzare l'intero disco rigido come un volume fisico.}}

Il tipo di partizione per "LVM" è "8e" (LVM Linux).

Ad esempio, per impostare il tipo tramite {{c|fdisk}} per una partizione su {{Path|/dev/sda}}:

{{RootCmd|fdisk /dev/sda}}

In {{c|fdisk}}, creare partizioni utilizzando il tasto {{Key|n}} e variare il tipo di partizione con il tasto {{Key|t}} a "8e".

==== Creare PV ====

I volumi fisici possono essere creati/inizializzati con il comando   {{c|pvcreate}}.

Ad esempio, il seguente comando crea un volume fisico nella prima partizione primaria di {{Path|/dev/sda}} e {{Path|/dev/sdb}}:

{{RootCmd|pvcreate /dev/sd[ab]1}}

==== Lista PV ====

Con il comando {{c|pvdisplay}}, si può avere una panoramica di tutti i volumi fisici attivi sul sistema.

{{RootCmd|pvdisplay|output=<pre>
 --- Physical volume ---
  PV Name               /dev/sda1
  VG Name               volgrp
  PV Size               160.01 GiB / not usable 2.31 MiB
  Allocatable           yes 
  PE Size               4.00 MiB
  Total PE              40962
  Free PE               4098
  Allocated PE          36864
  PV UUID               3WHAz3-dh4r-RJ0E-5o6T-9Dbs-4xLe-inVwcV
  
 --- Physical volume ---
  PV Name               /dev/sdb1
  VG Name               volgrp
  PV Size               160.01 GiB / not usable 2.31 MiB
  Allocatable           yes 
  PE Size               4.00 MiB
  Total PE              40962
  Free PE               40962
  Allocated PE          0
  PV UUID               b031x0-6rej-BcBu-bE2C-eCXG-jObu-0Boo0x
</pre>}}

Se devono essere visualizzati più volumi fisici, {{c|pvscan}} può rilevare i volumi fisici inattivi, quindi attivarli.

{{RootCmd|pvscan|output=<pre>
  PV /dev/sda1  VG volgrp        lvm2 [160.01 GiB / 16.01 GiB free]
  PV /dev/sdb1  VG volgrp        lvm2 [160.01 GiB / 160.01 GiB free]
  Total: 2 [320.02 GB] / in use: 2 [320.02 GiB] / in no VG: 0 [0]
</pre>}}

==== Rimuovere PV ====

LVM distribuisce automaticamente i dati su tutti i volumi fisici disponibili (a meno che non impostato diversamente), ma in un approccio lineare. Se un richiesto volume logico (all'interno di un gruppo di volumi) è più piccolo rispetto alla quantità di spazio libero di un solo volume fisico, tutto lo spazio per il volume logico viene rivendicato su quel (singolo) volume fisico in modo contiguo. Questo viene fatto per motivi di prestazioni.

Se un volume fisico deve essere rimosso da un gruppo di volumi, i dati devono prima essere rimossi dal volume fisico. Con il comando  {{c|pvmove}} tutti i dati su un volume fisico vengono spostati su un altro volume fisico all'interno dello stesso gruppo di volumi.

{{RootCmd|pvmove -v /dev/sda1}}

Tale operazione può richiedere tempo a seconda della quantità di dati che devono essere spostati. Una volta terminata, non ci dovrebbero essere dati rimasti sul dispositivo. Verificare con pvdisplay che il volume fisico non è più utilizzato da nessun volume logico.

Il prossimo passo è rimuovere il volume fisico dal gruppo di volumi utilizzando {{c|vgreduce}}, dopodichè il dispositivo può essere "deselezionato" come volume fisico utilizzando pvremove:

{{RootCmd|vgreduce vg0 /dev/sda1 && pvremove /dev/sda1}}

=== VG (Gruppo di Volumi) ===

Un gruppo di volumi (VG) raggruppa un numero di volumi fisici e si presenta come {{Path|/dev/VG_NAME}} nel file system del dispositivo. Il nome di un gruppo di volumi è scelto dall'amministratore.

==== Creare VG ====

Il seguente comando crea un gruppo di volumi chiamato "vg0" con due volumi fisici assegnati: {{Path|/dev/sda1}} e {{Path|/dev/sdb1}}.

{{RootCmd|vgcreate vg0 /dev/sd[ab]1}}

==== Elenco VG ====

Per elencare tutti i gruppi di volumi attivi, utilizzare il comando {{c|vgdisplay}}:

{{RootCmd|vgdisplay|output=<pre>
  --- Volume group ---
  VG Name               vg0
  System ID             
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  8
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                6
  Open LV               6
  Max PV                0
  Cur PV                1
  Act PV                1
  VG Size               320.02 GiB
  PE Size               4.00 MiB
  Total PE              81924
  Alloc PE / Size       36864 / 144.00 GiB
  Free  PE / Size       45056 /176.01 GiB
  VG UUID               mFPXj3-DdPi-7YJ5-9WKy-KA5Y-Vd4S-Lycxq3
</pre>}}

Se i gruppi di volume sono mancanti, utilizzare il comando {{c|vgscan}} per localizzarli:

{{RootCmd|vgscan|output=<pre>
  Reading all physical volumes.  This may take a while...
  Found volume group "vg0" using metadata type lvm2
</pre>}}

==== Estendere VG ====

I gruppi di volume raggruppano i volumi fisici, permettendo agli amministratori di utilizzare un pool di risorse di memoria da destinare ai file systems. Quando un gruppo di volumi non ha sufficienti risorse di memoria, è necessario estendere il gruppo di volumi con volumi fisici aggiuntivi.

Il seguente esempio amplia il gruppo di volumi "vg0" di un volume fisico su {{Path|/dev/sdc1}}:

{{RootCmd|vgextend vg0 /dev/sdc1}}

Si ricorda che il volume fisico deve prima essere inizializzato come tale!

==== Ridurre VG ====

Se i volumi fisici devono essere rimossi dal gruppo di volumi, tutti i dati ancora in uso nel volume fisico devono essere spostati ad altri volumi fisici nel gruppo di volumi. Come visto prima, questo viene gestito tramite il comando {{c|pvmove}}, dopodichè il volume fisico può essere rimosso dal gruppo di volumi utilizzando vgreduce:

{{RootCmd|pvmove -v /dev/sdc1
|vgreduce vg0 /dev/sdc1}}

==== Rimuovere VG ====

Se un gruppo di volumi non è più necessario (o, in altre parole, il lotto di memoria che rappresenta non viene più utilizzato e i volumi fisici in esso contenuti necessitano di essere liberati per altri scopi), tale gruppo di volumi può essere rimosso con vgremove. Questo funziona solo se nessun volume logico è definito per il gruppo di volumi, e tutti, tranne un volume fisico, sono già stati rimossi dal lotto di memoria.

{{RootCmd|vgremove vg0}}

=== LV (Volume Logico) ===

I volumi logici sono i dispositivi meta finali che sono messi a disposizione dal sistema di solito per crearci sopra i file system. Essi vengono creati e gestiti in gruppi di volumi e si presentano come {{Path|/dev/VG_NAME/LV_NAME}}. Come per i gruppi di volumi, il nome usato per un volume logico è deciso dall'amministratore.

==== Creare LV ====

Per creare un volume logico si utilizza il comando {{c|lvcreate}}. I parametri per il comando sono la dimensione richiesta per il volume logico (che non può essere più grande della quantità di spazio libero nel gruppo di volumi), il gruppo di volumi da cui lo spazio è rivendicato ed il nome del volume logico da creare.

Nell'esempio seguente, un volume logico di nome "lvol1" è stato creato dal gruppo di volumi chiamato "vg0" e con una dimensione di 150 MB:

{{RootCmd|lvcreate -L 150M -n lvol1 vg0}}

E' possibile utilizzare {{c|lvcreate}} per usare tutto lo spazio libero all'interno del gruppo di volumi. Ciò viene fatto con l'opzione <code>-l</code> la quale seleziona la quantità di "estensioni" piuttosto che la dimensione (leggibile dall'uomo). I volumi logici sono divisi in "estensioni logiche" che sono blocchi di dati all'interno di un gruppo di volumi. Tutte le estensioni in un gruppo di volumi hanno la stessa dimensione. Con l'opzione <code>-l</code> {{c|lvcreate}} può essere utilizzato per allocare tutte le estensioni libere:

{{RootCmd|lvcreate -l 100%FREE -n lvol1 vg0}}

Dopo il "FREE", può essere utilizzata la chiave "VG" per indicare l'intera dimensione del gruppo di volume.

==== Elencare LV ====

Per elencare tutti i volumi logici, utilizzare il comando {{c|lvdisplay}}:

{{RootCmd|lvdisplay}}

If logical volumes are missing, then the {{c|lvscan}} command can be used to scan for logical volumes on all available volume groups.

{{RootCmd|lvscan}}

==== Estendere LV ====

Quando un volume logico ha bisogno di essere esteso, si può utilizzare il comando {{c|lvextend}} per aumentare lo spazio allocato per il volume logico.

Per esempio, per estendere il volume logico "lvol1" a un totale di 500 MB:

{{RootCmd|lvextend -L500M /dev/vg0/lvol1}}

E' anche possibile utilizzare la dimensione da aggiungere piuttosto che la dimensione totale:

{{RootCmd|lvextend -L+350MB /dev/vg0/lvol1}}

Un gruppo di volumi esteso non fornisce immediatamente la memoria addizionale agli utenti finali. Per questo, il file system in cima al gruppo di volumi deve essere incrementato in termini di dimensioni pure. Non tutti i file systems consentono il ridimensionamento, quindi, per ulteriori informazioni, controllare la documentazione per il file system in questione.

Per esempio, per ridimensionare un file system ext4 e farlo diventare con dimensione da 500 MB:

{{RootCmd|resize2fs /dev/vg0/lvol1 500M}}

==== Diminuire LV ====

Se un volume logico ha bisogno di essere ridotto di dimensione, per prima cosa ridurre il file system stesso. Non tutti i file system supportano la riduzione.

Per esempio, ext4 non supporta la riduzione così il file system prima deve essere smontato. E' anche raccomandato fare un controllo al file system per assicurarsi che non vi siano incongruenze:

{{RootCmd|umount /mnt/data
|e2fsck -f /dev/vg0/lvol1
|resize2fs /dev/vg0/lvol1 150M}}

Con la riduzione del file system, è ora possibile diminuire pure la dimensione del volume logico:

{{RootCmd|lvreduce -L150M /dev/vg0/lvol1}}

==== Autorizzazioni LV ====

LVM supporta i permessi sui volui logici.

Per esempio, un volume logico può essere impostato a "leggi solo" utilizzando il comando {{c|lvchange}}:

{{RootCmd|lvchange -p r /dev/vg0/lvol1
|mount -o remount /dev/vg0/lvol1}}

Rimontarlo è necessario in quanto la modifica non viene applicata immediatamente.

Per contrassegnare il volume logico come scrivibile di nuovo, utilizzare il permesso "rw":

{{RootCmd|lvchange -p rw /dev/vg0/lvol1 && mount -o remount /dev/vg0/lvol1}}

==== Rimuovere LV ====

Prima di rimuovere un volume logico, assicurarsi che non sia montato:

{{RootCmd|umount /dev/vg0/lvol1}}

Disattivare il volume logico in modo che nessuna ulteriore attività di scrittura possa avvenire:

{{RootCmd|lvchange -a n /dev/vg0/lvol1}}

Con il volume smontato e disattivato, ora può essere rimosso, liberando le estensioni ad esso attribuite per l'uso da parte di altri volumi logici nel gruppo di volumi:

{{RootCmd|lvremove /dev/vg0/lvol1}}

== Caratteristiche ==

LVM fornisce un bel pò di caratteristiche interessanti per gli amministratori di memoria, tra cui (ma non solo)
* sottile approvvigionamento (memoria over-committing)
* supporto istantaneo
* tipi di volume con metodi di allocazione di memoria diversi

=== Approvvigionamento sottile ===

La versione più recente di LVM2 (2.02.89) supporta i volumi sottili. I volumi sottili sono per dispositivi a blocchi come [[Wikipedia:Sparse_file|sparse files]] sono dei file systems. Quindi, un volume logico sottile all'interno di una vasca può essere "extra-impegnato": la sua dimensione può essere maggiore della dimensione allocata - può anche essere più grande della vasca stessa. Proprio come un sparse file, le estensioni vengono allocate come il dispositivo a blocchi viene popolato. Se il file system ha "scartato" le estensioni di supporto sono liberati ancora come i files sono rimossi, riducendo l'utilizzo degli spazi della vasca.

Dentro LVM, tale vasca sottile è un tipo speciale di volume logico, che a sua volta può ospitare volumi logici.

==== Creazione di una vasca sottile ====

{{Warning|Se si verifica un overflow all'interno della vasca di metadati sottile, la vasca sarà danneggiata. '''LVM non può recuperare da questo'''.}} 

{{Note|Se la vasca sottile si esaurisce, qualsiasi processo che avrebbe causato la vasca sottile di allocare più estensioni (non disponibili) sarà bloccato in stato di "sonno uccidibile" fino a quando la vasca sottile non viene estesa o il processo riceve SIGKILL.}}

Ogni vasca sottile ha metadati associati ad essa, i quali vengono aggiunti alla dimensione della vasca sottile. LVM  calcolerà la dimensione dei metadati in base alla dimensione della vasca sottile come il minimo di "pool_chunks * 64 bytes" o 2MiB, se superiore. L'amministratore può selezionare un formato di metadati diverso.

Per creare una vasca sottile, aggiungere le opzioni <code>--type thin-pool --thinpool thin_pool</code> su {{c|lvcreate}}:

{{RootCmd|lvcreate -L 150M --type thin-pool --thinpool thin_pool vg0}}

L'esempio sopra crea una vasca sottile chiamata "thin_pool" con una dimensione totale di 150 MB. Questa è la dimensione reale allocata per la vasca sottile (e quindi la quantità totale di memoria effettiva che può essere utilizzata).

Per richiedere esplicitamente una certa dimensione dei metadati, utilizzare l'opzione <code>--metadatasize</code>:

{{RootCmd|lvcreate -L 150M --poolmetadatasize 2M --type thin-pool --thinpool thin_pool vg0}}

Per via che il metadata viene aggiunto alla vasca sottile, la via migliore di utilizzare tutta la dimensione disponibile in un gruppo di volumi per un volume logico, non funziona (vedere LVM bug [https://bugzilla.redhat.com/show_bug.cgi?id=812726|812726]):

{{RootCmd|lvcreate -l 100%FREE --type thin-pool --thinpool thin_pool vg0|output=<pre>
Insufficient suitable allocatable extents for logical volume thin_pool: 549 more required
</pre>}}

Si noti che la vasca sottile non ha un nodo del dispositivo associato come altri LV.

==== Creazione di un volume logico sottile ====

Un "volume logico sottile" è un volume logico all'interno della vasca sottile (che è essa stessa un volume logico). Come i volumi logici sottili sono "scarsi", una dimensione virtuale invece di una dimensione fisica è specificata utilizzando l'opzione <code>-V</code> :

{{RootCmd|lvcreate -T vg0/thin_pool -V 300M -n lvol1}}

In questo esempio, il volume logico (sottile) "lvol1" è esposto come dispositivo da 300MB di dimensione, anche se la vasca sottostante contiene solo 150MB di memoria reale allocata.

E' anche possibile creare sia la vasca sottile che il volume logico all'interno della vasca sottile con un unico comando:

{{RootCmd|lvcreate -T vg0/thin_pool -V 300M -L150M -n lvol1}}

==== Elencare vasche sottili e volumi logici sottili ====

Le vasche sottili e i volumi logici sottili sono tipologie speciali di volumi logici, e come tali sono visualizzati tramite il comando {{c|lvdisplay}}. Il comando {{c|lvscan}} individuerà anche questi volumi logici.

==== Estendere una vasca sottile ====

{{Warning|Come per LVM2 2.02.89, la dimensione del metadata relativo alla vasca sottile non può essere ampliata, essa è fissata al momento della creazione}}

La vasca sottile è ampliata come un volume logico non sottile utilizzando {{c|lvextend}}. Per esempio:

{{RootCmd|lvextend -L500M vg0/thin_pool}}

==== Estendere un volume logico sottile ====

Un volume logico sottile è ampliato regolarmente proprio come un volume logico sottile:

{{RootCmd|lvextend -L1G vg0/lvol1}}

Notare che il comando {{c|lvextend}} utilizza l'opzione <code>-L</code> (o <code>-l</code> se si utilizzano i conteggi estesi) e non un'opzione di "dimensione virtuale" come utilizzata durante la creazione. 

==== Ridurre una vasca sottile ====

Attualmente, LVM non può ridurre la dimensione della vasca sottile. Vedere il bug LVM [https://bugzilla.redhat.com/show_bug.cgi?id=812731|812731].

==== Ridurre un volume logico sottile ====

I volumi logici sottili sono ridotti regolarmente proprio come i volumi logici.

Per esempio:
{{RootCmd|lvreduce -L300M vg0/lvol1l}}

Notare che il comando {{c|lvreduce}} utilizza l'opzione <code>-L</code> (o <code>-l</code> se si utilizzano i conteggi estesi) e non un opzione di "dimensione virtuale" come utilizzata durante la creazione.

==== Rimuovere vasche sottili ====

Le vasche sottili non possono essere rimosse fino a che tutti i volumi logici in esse contenuti non vengono rimossi.

Quando una vasca sottile non serve più a nessun volume logico, essa può essere rimossa attraverso il comando {{c|lvremove}}:

{{RootCmd|lvremove vg0/thin_pool}}

=== LVM2 istantanee e istantanee sottili ===

Un'istantanea è un volume logico che agiscecome copia di un altro volume logico. Essa visualizza lo stato del volume logico originale al tempo della creazione dell'istantanea.

{{Warning|Poichè il volume dell'istantanea logica ottiene la stessa "LABEL" e "UUID" del filesystem, assicurarsi che il file {{Path|/etc/fstab}} o l'initramfs '''non''' contengano annotazioni per questi filesystems utilizzando la sintassi <code>LABEL{{=}}</code> o <code>UUID{{=}}</code>. Altrimenti si potrebbe finire col montare l'istantanea invece del volume logico originale.}}

==== Creazione di un'istantanea di un volume logico ====

Un'istantanea di un volume logico viene creata utilizzando l'opzione <code>-s</code> di {{c|lvcreate}}. L'istantanea di un volume logico è sempre memoria allocata come "registro" LVM, tutte le variazioni sono fatte dal volume logico originale e questi cambiamenti vengono memorizzati nella memoria allocata per l'istantanea. LVM inizierà dal volume logico originale dopodichè controllerà tutte le variazioni registrate, "annullando" le modifiche prima di mostrare il risultato per l'utente.

L'istantanea del volume logico, d'ora in poi, "cresce" al tasso che le modifiche vengono fatte sul volume logico originale. Quando la memoria allocata per l'istantanea è utilizzata completamente, l'istantanea sarà rimossa automaticamente dal sistema.

{{RootCmd|lvcreate -l 10%VG -s -n 20140412_lvol1 /dev/vg0/lvol1}}

L'esempio di sopra crea un'istantanea di volume logico chiamata "20140412_lvol1", basata sul volume logico "lvol1" nel gruppo di volume "vg0". Essa utilizza il 10% dello spazio (estensioni reali) allocato dal gruppo di volume.

==== Accedere ad un'istantanea di volume logico ====

Le istantanee dei volumi logici possono essere montate come volumi logici normali. Esse non sono nemmeno limitate a operazioni di sola lettura - è possibile modificare le istantanee e quindi utilizzarle per testare cose, tipo provare variazioni prima di effettuarle realmente su un file system di "produzione".

Finché esistono istantanee di volumi logici, il volume logico normale/originale non può essere ridotto di dimensioni e non può essere rimosso.

==== Istantanee sottili LVM ====

{{Note|Una istantanea sottile può essere presa solo su una vasca sottile per un volume logico sottile. Il bersaglio dispositivo mappatore sottile supporta istantanee sottili di sola lettura dei volumi logici non-sottili, ma l'LVM2 non le supporta. Tuttavia, è possibile creare una regolare istantanea di volume logico (non-sottile) di un volume logico sottile.}}

Per creare una istantanea sottile, il comando {{c|lvcreate}} viene utilizzato con l'opzione <code>-s</code>. Nessuna indicazione di dimensione deve essere trasmessa:

{{RootCmd|lvcreate -s -n 20140413_lvol1 /dev/vg0/lvol1}}

Le istantanee sottili del volume logico hanno la stessa dimensione del loro volume logico sottile originale, ed utilizzano un'allocazione fisica di 0 proprio come tutti gli altri volumi logici. 

{{Important|Se viene specificata l'opzione ''-l'' o ''-L'', l'istantanea verrà ancora creata, ma l'istantanea risultante sarà un'istantanea regolare, non un'istantanea sottile.}}

E' possibile anche ottenere istantanee di istantanee:

{{RootCmd|lvcreate -s -n 1_20140413_lvol1 /dev/vg0/20140413_lvol1}}

Le istantanee sottili hanno vari vantaggi rispetto alle istantanee regolari. Primo, le istantanee sottili sono indipendenti dal loro volume logico originale una volta create. Il volume logico originale può essere ridotto o cancellato senza influenzare l'istantanea. Secondo, l'istantanea sottile può essere efficacemente creata ricorsivamente (istantanea di un'istantanea) senza il "concatenamento" globale di regolari istantanee LVM ricorsive.

==== Riportare indietro allo stato di istantanea ====

Per riportare indietro il volume logico alla versione dell'istantanea, utilizzare il seguente comando:

{{RootCmd|lvconvert --merge /dev/vg0/20140413_lvol1}}

Dovrebbe impiegarci una coppia di minuti, dipende dalla dimensione del volume. Prego notare che il riportare indietro si verificherà solo se il volume logico genitore sarà offline. Quindi un riavvio potrebbe essere necessario.

{{Important|L'istantanea scomparirà e questa variazione non è reversibile}}

==== Riportare indietro le istantanee sottili ====

Per i volumi sottili, {{c|lvconvert --merge}} non funziona. Invece, bisogna cancellare il volume logico originale e rinominare l'istantanea:

{{RootCmd|umount /dev/vg0/lvol1
|lvremove /dev/vg0/lvol1
|lvrename vg0/20140413_lvol1 lvol1}}

=== Diversi metodi di allocazione della memoria ===

LVM supporta diversi metodi di allocazione di memoria:
* Volumi lineari (che è di default);
* Volumi mirroring (in una configurazione pressappoco attivo/standby);
* Striping (RAID0);
* Volumi mirroring (RAID1 - che è più una configurazione attivo/attivo);
* Striping con parità (RAID4  e RAID5);
* Striping con doppia parità (RAID6);
* Striping e mirroring (RAID10).

==== Volumi lineari ====

I volumi lineari sono il tipo più comune di volumi LVM. LVM tenterà di allocare il volume logico per essere fisicamente il più contiguo possibile. Se questo è un volume fisico abbastanza grande da includere l'intero volume logico, LVM lo allocherà là, altrimenti lo frammenterà nel minor numero di pezzi possibile.

I comandi introdotti in precedenza per creare gruppi di volumi e volumi logici creano anche volumi lineari.

Visto che i volumi lineari non hanno richieste particolari, essi sono facili da manipolare e possono essere ridimensionati e riallocati a volontà. Se un volume logico è allocato attraverso multipli volumi fisici, e ogni volume fisico diventa non più disponibile, tale volume logico non può essere avviato più e sarà inutilizzabile.

==== Volumi Mirrored ====

LVM supporta i volumi "mirrored" (rispecchiati), i quali forniscono una tolleranza di errore in caso di guasto del disco. A differenza di RAID 1, non vi è alcun miglioramento delle prestazioni - tutte le letture e le scritture sono consegnate ad un solo lato del "mirror" (specchio).

Per tenere traccia dello stato del mirror, LVM richiede un "log". E' raccomandato (e spesso anche obbligatorio) posizionare questo log su un volume fisico che non contiene nessuno dei volumi logici  in mirroring. Questi sono tre tipi di logs che possono essere utilizzati per i mirrors:

# '''Disk''' è il tipo di log predefinito. Tutte le variazioni fatte sono registrate su estensioni extra metadata, che vengono gestite da LVM. Se il dispositivo fallisce, le variazioni sono mantenute nel log fino a che il mirror non viene ripristinato nuovamente.
# '''Mirror''' i logs sono '''disk''' logs i quali sono loro stessi in mirroring. 
# '''Core''' i logs mirror logs registra lo stato del mirror solo in memoria. LVM dovrà ricostruire il mirror ogni volta che è attivato. Questa tipologia è utile per i mirrors temporanei.

Per creare un volume logico con un singolo mirror, inserire l'opzione "-m 1" (per selezionare il mirroring standard) con il codice opzionale <code>--mirrorlog</code> per selezionare un particolare tipo di log:

{{RootCmd|lvcreate -m 1 --mirrorlog mirror -l 40%VG --nosync -n lvol1 vg0}}

L'opzione "-m 1" dice a LVM di creare un (addizionale) mirror, quindi richiede 2 volumi fisici. L'opzione <code>--nosync</code> è un'ottimizzazione - senza di essa LVM proverà a sincronizzare il mirror copiando i settori vuoti da un volume logico ad un altro.

E' possibile creare un mirror di un volume logico esistente:

{{RootCmd|lvconvert -m 1 -b vg0/lvol1}}

L'opzione <code>-b</code> fa la conversione in background visto che questo può richiedere molto tempo.

Per rimuovere un mirror, impostare il numero di mirror (quello precedente) da 0:

{{RootCmd|lvconvert -m0 vg0/lvol1}}

Se parte di un mirror non è disponibile (generalmente perchè il disco contenente il volume fisico è danneggiato), il gruppo di volumi dovrà essere portato in modalità degraded:

{{RootCmd|vgchange -ay --partial vg0}}

Nella prima scrittura, LVM noterà il guasto del mirror. Il procedimento di default ("remove") è quello di ridurre automaticamente il mirror in base al numero di parti disponibili. Un mirror a 3-parti con un volume fisico mancante verrà ridotto a mirror a 2-parti; un mirror a 2-parti sarà ridotto a volume lineare regolare. Se il guasto è solo transitorio, e il volume fisico mancante ritorna dopo che LVM ha guastato il mirror, i volumi logici mirrored dovranno essere ricreati su di esso. 

Per recuperare il mirror, il volume fisico guasto deve essere rimosso dal gruppo di volumi, e va aggiunto un volume fisico sostitutivo (o se il gruppo di volumi ha un volume fisico libero, il mirror può essere ricreato su questo). Ora il mirror può essere ricreato con il comando {{c|lvconvert}} e il vecchio volume fisico può essere rimosso dal gruppo di volumi:

{{RootCmd|vgextend vg0 /dev/sdc1
|lvconvert -b -m 1 --mirrorlog disk vg0/lvol1
|vgreduce --removemissing vg0}}

E' possibile che LVM crei il mirror con estensioni disponibili in volumi fisici differenti se da un lato non riesce. Per realizzare questo, impostare <code>mirror_image_fault_policy</code> di "allocate" su {{Path|lvm.conf}}.

==== Mirrors sottili ====

Non è ancora possibile creare una vasca sottile mirror o un volume sottile mirror. E' possibile creare una vasca sottile mirror con la creazione di un volume logico mirror normale e convertire il volume logico di una vasca sottile con il comando {{c|lvconvert}}. 2 volumi logici sono richiesti: uno per la vasca sottile e uno per il metadata sottile; il processo di conversione li unirà in un singolo volume logico.

{{Warning|E' richiesta la versione 2.02.98 o successive di LVM per far funzionare tutto correttamente. Le versioni precedenti non sono in grado di fare ciò, daranno errori di segmentazione e corromperanno il gruppo di volumi. Inoltre, la conversione di un mirror in vasca sottile '''distrugge''' tutti i dati esistenti nel mirror!}}

{{RootCmd|lvcreate -m 1 --mirrorlog mirrored -l40%VG -n thin_pool vg0
|lvcreate -m 1 --mirrorlog mirrored -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg0/thin_meta}}

==== Striping (RAID0) ====

Invece di un volume lineare, dove più volumi fisici contigui vengono aggiunti, è possibile creare un volume ''striped'' o ''RAID 0'' per migliorare le prestazioni. Questo alternerà le allocazioni di memoria attraverso i volumi fisici disponibili.

Per creare un volume striped sopra tre volumi fisici:

{{RootCmd|lvcreate -i 3 -l 20%VG -n lvol1_stripe vg0|output=<pre>
Using default stripesize 64.00 KiB
</pre>}}

L'opzione <code>-i</code> indica su quanti volumi fisici lo striping dovrebbe essere fatto.

E' possibile fare il mirror di una serie di stripe. Le opzioni <code>-i</code> e <code>-m</code> possono essere combinate per creare un mirror striped:

{{RootCmd|lvcreate -i 2 -m 1 -l 10%VG vg0}}

Questo crea 2 serie di volumi fisici stripe e ci rispecchia 2 differenti volumi fisici, per un totale di 4 volumi fisici. Una serie di stripe esistente può essere rispecchiata con {{c|lvconvert}}.

Una vasca sottile può essere striped come qualsiasi altro volume logico. Tutti i volumi sottili creati dalla vasca ereditano queste impostazioni - tali impostazioni non vanno specificate manualmente quando si crea un volume sottile.

Non è possibile creare lo stripe di un volume esistente, nè rimodellare gli stripes attraverso più o meno volumi fisici, nè convertire a differente volume RADI livello/lineare. Una serie di stripe possono essere rispechiati (mirrored). E' possibile estendere una serie di stripe attraverso volumi fisici addizionali, ma questi devono essere aggiunti in multipli delle serie di stripe originali (i quali efficacemente e linearmente aggiungeranno una nuova serie di stripe).

==== Mirroring (RAID) ====

A differenza di RAID0, il quale è striping, RAID1 è mirroring, ma implementato defferentemente dall'originale mirror LVM. Sotto RAID1, le letture sono distribuite su volumi fisici, migliorando le prestazioni. I guasti del mirror RAID1 non causano blocchi I/O perchè LVM non lo corrompe in scrittura.

In ogni posizione in cui il mirror LVM può essere utilizzato, un mirror RAID1 può essere usato nella stessa posizione. E' possibile che LVM crea dei mirrors RAID1 invece di mirrors regolari impostando implicitamente ''mirror_segtype_default'' di ''raid1'' su {{Path|lvm.conf}}.

{{Warning|Il mirroring LVM RAID1 non è ancora supportato da GRUB. Se si applica al volume LVM che contiene il kernel/initramfs (il volume di 'avvio'), il sistema sarà inavviabile. (Una correzione ci sarà dalla prossima versione di GRUB. Vedere GRUB bug [http://savannah.gnu.org/bugs/?44534 #44534] for details.)}}

Per creare un volume logico con un mirror singolo:

{{RootCmd|lvcreate -m 1 --type raid1 -l 40%VG --nosync -n lvm_raid1 vg0}}

Notare la differenza per creare un mirror: Qui non è specificato un "mirrorlog", perchè il volume logico RAID1 non ha un mirror log esplicito - esso è integrato nel volume logico.

E' possibile convertire un volume logico esistente a RAID1:

{{RootCmd|lvconvert -m 1 --type raid1 -b vg0/lvol1}}

Per rimuovere un mirror RAID1, impostare il numero di mirrors a 0:

{{RootCmd|lvconvert -m0 vg0/lvm_raid1}}

Se parte del RAID1 non è disponibile (generalmente perchè il disco contenente il volume fisico è in errore), il gruppo di volume dovrà essere portato in modalità degradata:

{{RootCmd|vgchange -ay --partial vg0}}

A differenza del mirror LVM, la scrittura non danneggia il mirroring. Se l'errore è solo transitorio, e il volume fisico mancante ritorna, LVM risincronizzerà il mirror copiando il segmento obsoleto invece che l'intero volume logico. Se l'errore è permanente, il volume fisico rovinato deve essere rimosso dal gruppo di volumi e deve essere aggiunto un volume fisico sostitutivo (o se il gruppo di volumi ha un volume fisico libero, esso può essere creato su un differente PV). Il mirror può quindi essere riparato con {{c|lvconvert}}, e il vecchio volume fisico può essere rimosso dal gruppo di volumi:

{{RootCmd|vgextend vg0 /dev/sdc1
|lvconvert --repair -b vg0/lvm_raid1
|vgreduce --removemissing vg0}}

==== RAID1 sottile ====

Non è (ancora) possibile creare una vasca sottile RAID1 o un volume sottile RAID1. E' possibile, invece, creare una vasca sottile RAID1 partendo da un volume logico mirrored che deve essere convertito in vasca sottile con il comando {{c|lvconvert}}. Sono richiesti 2 volumi logici: uno per la vasca sottile e uno per il metadata sottile; il processo di conversione li unirà in un singolo volume logico.

{{Warning|E' richiesta la versione 2.02.98 o successive di LVM per fare questo. Le versioni precedenti non vanno bene, danno errori di segmentazione e corrompono il VG. Inoltre, la conversione di un RAID1 in vasca sottile '''distrugge''' tutti i dati esistenti nel mirror!}}

{{RootCmd|lvcreate -m 1 --type raid1 -l40%VG -n thin_pool vg0
|lvcreate -m 1 --type raid1 -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg00/thin_meta}}

==== Striping con parità (RAID4 e RAID5) ====

{{Note|Striping con parità richiede almeno 3 volumi fisici.}}

RAID0 non tollera errori - se qualsiasi volume fisico si guasta il volume logico diventa inutilizzabile. Aggiungendo una parity stripe al RAID0 il volume logico può ancora funzionare anche se il volume fisico è mancante. Il nuovo volume fisico può quindi essere aggiunto per ripristinare il guasto.

Stripset con parity sono disponibili in 2 versioni: RAID4 e RAID5, tutte le stripes parity sono memorizzate nello stesso volume fisico. Questo può diventare un collo di bottiglia perchè tutte le scritture interessano quel volume fisico, e peggiorano più volumi fisici che sono nell'array. Con RAID5, il parity data è distribuito in modo uniforme tra i volumi fisici in modo che nessuno di loro diventi un collo di bottiglia. Per tale ragione, RAID4 è raramente utilizzato ed è considerato obsoleto. In pratica, tutte le stripeset con parity sono RAID5.

{{RootCmd|lvcreate --type raid5 -l 20%VG -i 2 -n lvm_raid5 vg0}}

Solo i volumi fisici di dati sono specificati con -i, e LVM ne aggiunge uno automaticamente per il parity. Così per i 3 volumi fisici RAID5, viene passato "-i 2" e non "-i 3".

Quando un volume fisico si guasta, il gruppo di volumi dovrà essere portato in modalità degradata:

{{RootCmd|vgchange -ay --partial vg0}}

Il volume, a questo punto, lavorerà normalmente, tuttavia questo degrada l'array di RAID0 fino a quando non viene aggiunto un volume fisico in sostituzione. Le prestazioni difficilmente sono influenzate quando l'array è in degrado - anche se c'è bisogno di ricalcolare i dai mancanti via parity, è richiesto semplicemente XOR per il parity block con i dati rimanenti. L'overhead è trascurabile rispetto al disco di I/O.

Per riparare RAID5:

{{RootCmd|lvconvert --repair vg0/lvm_raid5
|vgreduce --removemissing vg0}}

E' possibile sostituire un volume fisico che ancora sta lavorando in RAID5 così:

{{RootCmd|lvconvert --replace /dev/sdb1 vg0/lvm_raid5
|vgreduce vg0 /dev/sdb1}}

Le stesse restrizioni di stripeset si applicano anche a stripeset con parity: non è possibile abilitare striping con parity in un volume esistente, né rimodellare gli stripes con parity attraverso  più o meno volumi fisici, né convertire in un volume di livello RAID differente. Uno stripeset con parity puè essere mirrored. E' possibile estendere uno stripeset con parity attraverso volumi fisici addizionali, ma questi devono essere aggiunti in multipli dello stripset con parity originale (che aggiungererà un nuovo stripeset con parity).

==== Volume logico RAID5 sottile ====

Non è (ancora) possibile creare vasche sottili o volumi logici stripeset con parity (RAID5). E' possibile, invece, creare una vasca sottile RAID5 creando un normale volume logico RAID5 e convertendo il volume logico in una vasca sottile con il comando {{c|lvconvert}}. Sono richiesti 2 volumi logici: uno per la vasca sottile e uno per il metadata sottile; il processo di conversione li fonderà in un singolo volume logico.

{{Warning|Perchè questo funzioni è richiesta la versione 2.02.98 o successive di LVM. Le versioni precedenti non vanno bene, danno errori di segmentazione e corrompono il VG. Inoltre, la conversione di un RAID5 LV in vasca sottile '''distrugge''' tutti i dati esistenti nel LV!}}

{{RootCmd|lvcreate --type raid5 -i 2  -l20%VG -n thin_pool vg0
|lvcreate --type raid5 -i 2 -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg00/thin_meta}}

==== Striping con doppia parità (RAID6) ====

{{Note|RAID6 richiede almeno 5 volumi fisici.}}

RAID6 è simile a RAID5, tuttavia RAID6 può sopportare fino a "2"  guasti del volume fisico, offrendo così maggiore tolleranza ai guasti rispetto a quella di RAID5 a scapito dei volumi fisici aggiuntivi. 

{{RootCmd|lvcreate --type raid6 -l 20%VG -i 3 -n lvm_raid6 vg00}}

Come per RADI5, l'opzione <code>-i</code> è utilizzata per specificare il numero di volumi fisici per lo striping, escludendo i 2 volumi fisici per parity. Così, per i 5 volumi fisici RAID6 utilizzare l'opzione <code>-i 3</code> e non <code>-i 5</code>.

Il recupero per RAID6 è lo stesso che per RAID5.

{{Note|Diversamente da RAID5 dove il parity block è conveniente per il ricalcolo vs disk I/O, questa è solo una mezza verità in RAID6. RAID6 utilizza 2 parity stripes: uno stripe è computato come su RAID5 (XOR). Il secondo parity stripe è molto più difficile da computare - vedere [https://www.kernel.org/pub/linux/kernel/people/hpa/raid6.pdf|raid6 (pdf)] per maggiori informazioni.}}

==== Volume logico sottile RAID6 ====

Non è (ancora) possibile creare una vasca sottile o volumi sottili RAID6. E' possibile invece creare una vasca sottile RAID6 creando un normale volume logico RAID6 e convertendolo in vasca sottile tramite il comando {{c|lvconvert}}. Sono richiesti 2 volumi logici: uno per la vasca sottile e uno per il metadata sottile; il processo di conversione li fonderà entrambi in un unico volume logico.

{{Warning|Perchè questo funzioni è richiesta la versione 2.02.98 o successive di LVM. Le versioni precedenti non vanno bene, danno errori di segmentazione e corrompono il VG. Inoltre, la conversione di un RAID6 LV in vasca sottile distrugge tutti i dati esistenti nel LV!}}

{{RootCmd|lvcreate --type raid6 -i 2  -l20%VG -n thin_pool vg0
|lvcreate --type raid6 -i 2 -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg0/thin_meta}}

==== RAID10 LVM ====

{{Note|RAID10 richiede almeno 4 volumi fisici. Anche la sintassi LVM richiede che il numero di volumi fisici sia un multiplo del numero degli stripes e dei mirror, anche se per il formato RAID10 no}}

RAID10 è una combinazione tra RAID0 e RAID1. Esso è più potente di RAID0+RAID1 come il mirroring viene fatto a livello stripe invece che a livello di volume logico, e quindi la disposizione non deve essere simmetrica. Un volume RAID10 può tollerare almeno un singolo volume fisico mancante, e forse anche più.

{{Note|LVM attualmente limita RAID10 a un singolo mirror.}}

{{RootCmd|lvcreate --type raid10 -l 1020 -i 2 -m 1 --nosync -n lvm_raid10 vg0}}

Entrambe le opzioni <code>-i</code> e <code>-m</code> vanno specificate: <code>-i</code> indica il numero degli stripes e <code>-m</code> il numero dei mirrors. Due stripes e 1 mirror richiedono 4 volumi fisici.

==== RAID10 Sottile ====

Non è (ancora) possibile creare una vasca sottile o volumi logici RAID10. E' invece possibile creare una vasca sottile RAID10 creando un normale volume logico RAID10 e convertendolo in vasca sottile con il comando {{c|lvconvert}}. Sono richiesti 2 volumi logici: uno per la vasca sottile e uno per il metadata sottile; la conversione li fonderà entrambi in un singolo volume logico.

{{Warning|La conversione di un volume logico RAID10 in vasca sottile '''distrugge''' tutti i dati esistenti nel volume logico!}}

{{RootCmd|lvcreate -i 2 -m 1 --type raid10 -l 1012 -n thin_pool vg0
|lvcreate -i 2 -m 1 --type raid10 -l 6 -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg0/thin_meta}}

== Esperimenti con LVM ==

E' possibile fare esperimenti con LVM senza utilizzare dispositivi  di memoria reali. Per realizzare questo, bisogna creare dispositivi di loopback.

Prima di tutto assicurarsi di avere il modulo loopback caricato. 

{{RootCmd|modprobe -r loop && modprobe loop max_part{{=}}63}}

{{Note|Se il supporto loopback è costruito dentro il kernel, utilizzare <code>loop.max_part{{=}}63</code> come opzione di avvio.}}

Successivamente configurare LVM per non far ricercare i dispositivi a [[udev]]:

{{FileBox|filename=/etc/lvm/lvm.conf|title=Disabilitare udev nella configurazione di LVM|lang=ini|1=
obtain_device_list_from_udev = 0
}}

{{Important|Questo va fatto solo come test; assicurarsi di rimettere l'impostazione come era prima quando si ritorna a lavorare su dispositivi reali, poiché è molto più veloce utilizzare udev!}}

Creare alcuni files di immagine che diventeranno i dispositivi di memoria. L'esempio seguente utilizza cinque files per un totale di circa ~10GB di spazio reale su disco fisso:

{{RootCmd|mkdir /var/lib/lvm_img
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm0.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm1.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm2.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm3.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm4.img bs{{=}}1024 seek{{=}}2097152}}

Verificare che i dispositivi di loopback siano disponibili:

{{RootCmd|losetup -a}}

Supponendo che tutti i dispositivi di loopback siano disponibili, creare i dispositivi:

{{RootCmd|losetup /dev/loop0 /var/lib/lvm_img/lvm0.img
|losetup /dev/loop1 /var/lib/lvm_img/lvm1.img
|losetup /dev/loop2 /var/lib/lvm_img/lvm2.img
|losetup /dev/loop3 /var/lib/lvm_img/lvm3.img
|losetup /dev/loop4 /var/lib/lvm_img/lvm4.img}}

Il dispositivo {{Path|/dev/loop[0-4]}} è ora disponibile per essere utilizzato come ogni altro disco fisso nel sistema (e quindi è perfetto per i volumi fisici).

{{Note|Al prossimo riavvio, tutti i dispositivi loopback saranno rilasciati e la cartella {{Path|/var/lib/lvm_img}} può essere cancellata.}}

== Risoluzione dei problemi ==

LVM ha alcune caratteristiche che già forniscono un certo livello di ridondanza. Tuttavia, ci sono situazioni dove è possibile ripristinare volumi fisici o volumi logici persi.

=== Utilità vgcfgrestore ===

In serie, ogni variazione del volume fisico LVM, di gruppo di volumi, o di volume logico, LVM2 crea un file di backup di metadata in {{Path|/etc/lvm/archive}}. Questi files possono essere utilizzati per il recupero dopo una variazione accidentale (come per esempio la cancellazione del volume logico sbagliato). LVM mantiene anche una copia di backup del più recente metadata su {{Path|/etc/lvm/backup}}. Questa copia può essere utilizzata per ripristinare i metadata di un disco sostitutivo, o riparare il metadata corrotto.

Per vedere quali membri del gruppo di volumi sono disponibili per il ripristino (output parziale per migliorare la leggibilità):

{{RootCmd|vgcfgrestore --list vg00|output=<pre>
  File:		/etc/lvm/archive/vg0_00042-302371184.vg
  VG name:    	vg0
  Description:	Created *before* executing 'lvremove vg0/lvm_raid1'
  Backup Time:	Sat Jul 13 01:41:32 201
</pre>}}

==== Recupero di un volume logico cancellato accidentalmente ====

Supponendo che il volume logico "lvm_raid1" sia stato rimosso accidentalmente dal gruppo di volumi "vg0", è possibile recuperarlo come segue:

{{RootCmd|vgcfgrestore -f /etc/lvm/archive/vg0_00042-302371184.vg vg0}}

{{Important|vgcfgrestore ripristina solamente il metadata LVM, ''non'' i dati dentro il volume logico. Tuttavia pvremove, vgremove e lvremove puliscono solo il metadata, lasciando ogni dato intatto. Se però è impostato <code>issue_discards</code> su {{Path|/etc/lvm/lvm.conf}}, tali comandi ''sono'' distruttivi per i dati.}}

==== Sostituire un volume fisico fallito ====

E' possibile fare una vera "sostituzione" e ricreare il metadata nel nuovo volume fisico in modo da essere lo stesso del vecchio volume fisico:

{{RootCmd|vgdisplay --partial --verbose|output=<pre>
  --- Physical volumes ---
  PV Name               /dev/loop0     
  PV UUID               iLdp2U-GX3X-W2PY-aSlX-AVE9-7zVC-Cjr5VU
  PV Status             allocatable
  Total PE / Free PE    511 / 102
  
  PV Name               unknown device     
  PV UUID               T7bUjc-PYoO-bMqI-53vh-uxOV-xHYv-0VejBY
  PV Status             allocatable
  Total PE / Free PE    511 / 102
</pre>}}

La linea fondamentale qui è l'UUID "unknown device". 

{{RootCmd|pvcreate --uuid T7bUjc-PYoO-bMqI-53vh-uxOV-xHYv-0VejBY --restorefile /etc/lvm/backup/vg0 /dev/loop1|output=<pre>
  Couldn't find device with uuid T7bUjc-PYoO-bMqI-53vh-uxOV-xHYv-0VejBY.
  Physical volume "/dev/loop1" successfully created</pre>}}

Questo ricrea il metadata del volume fisico, ma non il volume logico mancante o i dati del gruppo di volumi sul volume fisico.

{{RootCmd|vgcfgrestore -f /etc/lvm/backup/vg0 vg0|output=<pre>
  Restored volume group vg0
</pre>}}

Questo ora ricostruisce tutti i metadata mancanti nel volume fisico, includendo il volume logico e i data del gruppo di volume. Tuttavia non ripristina i dati, così che il mirror è fuori sincronia.

{{RootCmd|vgchange -ay vg0|output=<pre>
  device-mapper: reload ioctl on  failed: Invalid argument
  1 logical volume(s) in volume group "vg0" now active
</pre>}}

{{RootCmd|lvchange --resync vg0/lvm_raid1|output=<pre>
Do you really want to deactivate logical volume lvm_raid1 to resync it? [y/n]: y
</pre>}}

Questo risincronizzerà il mirror. E' funzionante con RAID 4, 5 e anche con il 6.

=== Disattivare un volume logico ===

E' possibile disattivare un volume logico con il seguente comando:

{{RootCmd|umount /dev/vg0/lvol1
|lvchange -a n /dev/vg0/lvol1}}

Non è possibile montare il volume logico ovunque prima che esso sia riattivato:

{{RootCmd|lvchange -a y /dev/vg0/lvol1}}

== Risorse esterne ==

* [http://sourceware.org/lvm2/ LVM2 sourceware.org]
* [http://tldp.org/HOWTO/LVM-HOWTO/ LVM tldp.org]
* [http://sources.redhat.com/lvm2/wiki/ LVM2 Wiki redhat.com]


[[Category:Core system]]
