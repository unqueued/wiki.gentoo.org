<languages />
{{Metadata|abstract=포티지는 바이너리 꾸러미 빌드 및 설치를 지원합니다. 이 안내서는 바이너리 꾸러미 호스트를 만들고 바이너리 꾸러미를 활용하는 방법을 설명합니다.}}

일상의 ebuild 지원 요소 말고도, 포티지에서는 바이너리 꾸러미 빌드 및 설치를 지원합니다.
이 안내서에서는 바이너리 꾸러미를 만들고, 설치하는 방법, 그리고 바이너리 꾸러미 서버를 설정하는 방법을 설명합니다.

== 도입부 ==

관리자가 젠투의 바이너리 꾸러미 설치를 선호하는 몇가지 이유가 있습니다.

# 무엇보다도, 관리자가 ''유사 최신 시스템을 유지''할 수 있습니다. 모든 소스코드를 컴파일 한다는 건 상당한 시간 소모를 야기합니다. 일부가 느려질 가능성이 있다 하더라도 하나의 시스템에서 모든 소스코드를 컴파일 하고 다른 시스템에서는 바이너리 꾸러미를 재사용할 수 있을 경우 수많은 유사 시스템을 관리하는 일이 굉장히 쉬워질 수 있습니다.
# 두번째 이유는 ''안전한 업데이트 수행''입니다. 임무가 중요한 시스템에서는 가능한한 사용 가능한 상태를 유지하는 것이 중요합니다. 이 작업은 모든 업데이트를 우선 처리하는 스테이지 서버에서 처리할 수 있으며, 스테이지 서버 상태가 괜찮아지면 중요한 시스템에 적용할 수 있습니다. 다른 접근 방식으로는, 동일 시스템 내에서의 chroot 환경의 업데이트로 처리하고 실제 시스템에 만든 바이너리를 사용하는 방법이 있습니다.
# 세번째 이유는 ''백업''으로서의 의미가 있기 때문입니다. 가끔은 바이너리 꾸러미가 망가진 시스템(예: 컴파일러 망가짐)을 복구하는 유일한 수단이 될 수 있습니다. 바이너리 꾸러미 서버든, 로컬 머신 어디든 바이너리 꾸러미를 둔다면 굉장한 도움이 될 수 있습니다.
# 마지막으로, 이 방식은 ''상당히 오래된 시스템''의 업데이트를 지원합니다. 바이너리 꾸러미를 활용하면 굉장히 오래된 시스템을 업데이트 하는 작업을 매우 쉽게 처리할 수 있습니다. 설치하고 업데이트할 빌드 타임에 관계없이 바이너리 꾸러미를 쉽게 설치할 수 있으며, 빌드 과정상의 실패 상황을 피해갈 수 있습니다.

이 안내서에서는, 다음 내용에 집중했습니다
* 바이너리 꾸러미 만들기
* 바이너리 꾸러미를 클라이언트에 배포하기
* 바이너리 꾸러미 사용하기
* 바이너리 꾸러미 유지 관리하기

We end with a few more advanced topics on dealing with binary packages.

{{Note|All tools used in this guide are part of {{Package|sys-apps/portage}}, unless otherwise stated.}}

== 바이너리 꾸러미 만들기 ==

바이너리 꾸러미를 만드는 세가지 주요 방법은 다음과 같습니다:
# 일반 설치 과정 후, <code>quickpkg</code> 사용하기
# <code>--buildpkg (-b)</code> 옵션으로 emerge 처리 과정에 명시하기
# 포티지 FEATURES 변수에 <code>buildpkg</code>값을 넣어 자동으로 처리하기

All three methods will create a binary package in the directory pointed to by the <code>PKGDIR</code> variable (which defaults to {{Path|/usr/portage/packages}}).

=== quickpkg 사용하기 ===

The <code>quickpkg</code> application takes one or more dependency atoms (or package sets) and creates binary packages for all ''installed'' packages that match the atom.

For instance, to create binary packages of all installed GCC versions:

{{RootCmd|quickpkg sys-devel/gcc}}

To create binary packages of all installed packages, use the <code>*</code> glob:

{{RootCmd|quickpkg "*/*"}}

There is a caveat with this method though: it relies on the installed files, which can be a problem in case of configuration files. Administrators often change configuration files after installing software. Because this could leak out important or perhaps even confidential data into the packages, <code>quickpkg</code> by default does ''not'' include configuration files that are protected through the CONFIG_PROTECT method. To include those as well, use the <code>--include-config</code> or <code>--include-unmodified-config</code> options.

=== Using the --buildpkg emerge option ===

When installing software using <code>emerge</code>, portage can be asked to create binary packages as well by using <code>--buildpkg (-b)</code>:

{{Emerge|params+=--buildpkg|sys-devel/gcc}}

It is also possible to ask portage to ''only'' create a binary package but ''not'' to install the software on the live system. For this, the <code>--buildpkgonly (-B)</code> option can be used:

{{Emerge|params+=--buildpkgonly|sys-devel/gcc}}

The latter approach however requires that all build time dependencies are already installed.

=== Automatically using buildpkg feature ===

The most common way is to automatically create binary packages whenever a package is installed by <code>emerge</code>. This is done through the ''buildpkg'' feature, which can be set in {{Path|/etc/portage/make.conf}} like so:

{{File|/etc/portage/make.conf|Enabling buildpkg feature|<pre>
FEATURES="${FEATURES} buildpkg"
</pre>}}

Every time portage installs software, it will create a binary package as well.

=== Excluding creation of some packages ===

It is possible to tell portage not to create binary packages for a select few packages or categories. This is done through the <code>--buildpkg-exclude</code> option to emerge:

{{RootCmd|emerge -uDN @world --buildpkg --buildpkg-exclude "virtual/* sys-kernel/*-sources"}}

This could be used for packages that have little to no benefit in having a binary package available. Examples would be the Linux kernel source packages or upstream binary packages (those ending with ''-bin'' like {{Package|www-client/firefox-bin}}).

== Setting up a binary package host ==

Portage supports a number of protocols for downloading binary packages: FTP, FTPS, HTTP, HTTPS and SSH. This leaves room for many possible binary package host implementations.

There is, however, no out-of-the-box method provided by portage for distributing binary packages. Depending on the requested setup, additional software will need to be installed.

=== 웹기반 바이너리 꾸러미 호스트 ===

A common approach for distributing binary packages is to create a web based binary package host.

Use a web server (such as {{Package|www-servers/lighttpd}}) and configure it to provide read access to the <code>PKGDIR</code> location.

Then, on the clients, configure the <code>PORTAGE_BINHOST</code> variable accordingly:

{{File|/etc/portage/make.conf|Using a web based binary package host|<pre>
PORTAGE_BINHOST="http://binhost.genfic.com/Packages"
</pre>}}

=== SSH 바이너리 꾸러미 호스트 ===

To provide a more authenticated approach for binary packages, one can consider using SSH.

When using SSH, it is possible to use the portage Linux user's SSH key (without passphraze as the installations need to happen in the background) to connect to a remote binary package host.

To accomplish this, make sure that the portage user's SSH key is allowed on the server:

{{RootCmd|cat portage.id_rsa.pub >> /home/binpkguser/.ssh/authorized_keys}}

The <code>PORTAGE_BINHOST</code> could then look like so:

{{File|/etc/portage/make.conf|SSH 접근 용도로 PORTAGE_BINHOST 설정하기|<pre>
PORTAGE_BINHOST="ssh://binpkguser@yourbinhostserver/usr/portage/packages"
</pre>}}

=== NFS 내보내기 ===

When using binary packages on an internal network, it might be easier to just export the packages through NFS and mount it on the clients.

The {{Path|/etc/exports}} file could look like so:

{{File|/etc/exports|Exporting the packages directory|<pre>
/usr/portage/packages                            2001:db8:81:e2::/48(ro,no_subtree_check,root_squash) 192.168.100.1/24(ro,no_subtree_check,root_squash)
</pre>}}

On the clients, the location can then be mounted. An example {{Path|/etc/fstab}} entry would look like so:

{{File|/etc/fstab|Entry for mounting the packages folder|<pre>
binhost:/usr/portage/packages      /usr/portage/packages    nfs    defaults    0 0
</pre>}}


== Using binary packages ==

For binary packages to be usable on other systems they must fulfill some requirements.
* The client and server architecture and [[CHOST]] must match.
* The <code>CFLAGS</code> and <code>CXXFLAGS</code> that were used to build the binary packages must be compatible with all clients.
* USE flags for processor specific features (like MMX, SSE,...) have to be carefully selected; all clients need to support them.

{{Important|Portage can not validate if these requirements match. It is the responsibility of the administrator to guard over these settings.}}

Next to these, portage ''will'' check if the binary package is built using the same USE flags as expected on the client. If a package is built with a different USE flag combination, portage will either ignore the binary package (and use source-based build) or fail, depending on the options passed on to <code>emerge</code> (see [[#Installing binary packages|Installing binary packages]]).

On clients, a few configuration changes are needed in order for the binary packages to be used.

=== Installing binary packages ===

There are a few options that can be passed on to the <code>emerge</code> command that inform portage about using binary packages.

; <code>---usepkg (-k)</code>
: Try to use the binary package(s) in the locally available packages directory. Useful when using NFS-mounted binary package hosts. If the binary package is not found, a regular (source-based) installation will be done.
; <code>--usepkgonly (-K)</code>
: Similar to <code>--usepkg (-k)</code> but fail if the binary package cannot be found.
; <code>--getbinpkg (-g)</code>
: Download the binary package from a remote binary package host. If the binary package is not found, a regular (source-based) installation will be done.
; <code>--getbinpkgonly (-G)</code>
: Similar to <code>--getbinpkg (-g)</code> but fail if the binary package cannot be downloaded.

In order to automatically use binary package installations, the appropriate option can be added to the <code>EMERGE_DEFAULT_OPTS</code> variable:

{{File|/etc/portage/make.conf|Automatically fetching binary packages and fail if not available|<pre>
EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --getbinpkgonly"
</pre>}}

There is a portage feature that automatically implements the equivalent of <code>--getbinpkg (-g)</code> without the need for updating the <code>EMERGE_DEFAULT_OPTS</code> variable: ''getbinpkg''.

{{File|/etc/portage/make.conf|Enabling getbinpkg as portage feature|<pre>
FEATURES="${FEATURES} getbinpkg"
</pre>}}

=== Pulling packages from a binary package host ===

When using a binary package host, clients need to have the <code>PORTAGE_BINHOST</code> variable set. Otherwise the client will not know where the binary packages are stored (and how to retrieve them).

{{File|/etc/portage/make.conf|Setting PORTAGE_BINHOST|<pre>
PORTAGE_BINHOST="http://binhost.genfic.com/packages"
</pre>}}

The <code>PORTAGE_BINHOST</code> variable uses a space-separated list of URIs. This allows administrators to use several binary package servers simultaneously. The URI must always point to the directory in which the {{Path|Packages}} file resides.

{{Note|The support for multiple binary package servers is somewhat incomplete. If several servers serve a binary package for the same package version, then only the first one will be considered. This can be problematic when these binary packages differ in their USE configuration and the USE configuration of a later binary package would match the systems configuration.}}

=== Reinstalling modified binary packages ===

The <code>--rebuilt-binaries</code> option to <code>emerge</code> will reinstall every binary that has been rebuild since the package was installed. This is useful in case rebuilding tools like <code>revdep-rebuild</code> or <code>python-updater</code> are run on the binary package server.

A related option is <code>--rebuilt-binaries-timestamp</code>. It causes emerge not to consider binary packages for a re-install if those binary packages have been built before the given time stamp. This is useful to avoid re-installing all packages, if the binary package server had to be rebuild from scratch but <code>--rebuilt-binaries</code> is used otherwise.

=== Additional client settings ===

Next to the ''getbinpkg'' feature, portage also listens to the ''binpkg-logs'' feature. This one controls if log files for successful binary package installations should be kept. It is only relevant if <code>PORT_LOGDIR</code> is set and is enabled by default.

Similar to excluding binary packages for a certain set of packages or categories, clients can be configured to exclude binary package installations for a certain set of packages or categories.

To accomplish this, use the <code>--usepkg-exclude</code> option:

{{RootCmd|emerge -uDNg @world --usepkg-exclude "sys-kernel/gentoo-sources virtual/*"}}


== Maintaining binary packages ==

Exporting and distributing the binary packages will lead to useless storage consumption if the binary package list is not actively maintained.

=== Removing outdated binary packages ===

In the {{Package|app-portage/gentoolkit}} package an application called <code>eclean</code> is provided. It allows for maintaining portage-related variable files, such as downloaded source code files, but also binary packages.

The following command will remove all binary packages that have no corresponding ebuild:

{{RootCmd|eclean packages}}

For more details please read the [[Eclean]] article.

Another tool that can be used is the <code>qpkg</code> tool from the {{Package|app-portage/portage-utils}}. However, this tool is a bit less configurable.

To clean up ''unused'' binary packages (in the sense of used by the server on which the binary packages are stored):

{{RootCmd|qpkg -c}}

=== Maintaining the Packages file ===

Inside the packages directory, a file called {{Path|Packages}} exists. This file acts as a cache for the metadata of all binary packages in the packages directory. The file is updated whenever portage adds a binary package to the directory. Similarly, <code>eclean</code> updates it when it removes binary packages.

If for some reason binary packages are simply deleted or copied into the packages directory, or the {{Path|Packages}} file gets corrupted or deleted, then it needs to be recreated. This is done using <code>emaint</code>:

{{RootCmd|emaint binhost --fix}}

== Advanced topics==

=== Creating snapshots of the packages directory ===

When deploying binary packages for a large number of client systems it might become worthwhile to create snapshots of the packages directory. The client systems then don't use the packages directory directly but use binary packages from the snapshot.

Snapshots can be created using the {{Path|/usr/lib64/portage/bin/binhost-snapshot}} tool. It takes four arguments, 
# a source directory (the path to the packages directory), 
# a target directory (that must not exist),
# a URI, and 
# a binary package server directory.

The files from the package directory are copied to the target directory. A {{Path|Packages}} file is then created inside the binary package server directory (fourth argument) with the provided URI.

Client systems need to use an URI that points to the binary package server directory. From there they will be redirected to the URI that was given to <code>binhost-snapshot</code>. This URI has to refer to the target directory.

=== Understanding the binary package format ===

Binary packages created by portage have the file name ending tbz2. These files consist of two parts:
# an .tar.bz2 archive containing the files that will be installed on the system, and
# an xpak archive containing the metadata, the ebuild and the environment file.

See <code>man xpak</code> for a description of the format.

In {{Package|app-portage/portage-utils}} some tools exists that are able to split or create tbz2 and xpak files.

The following command will split the tbz2 into a {{Path|.tar.bz2}} and an {{Path|.xpak}} file:

{{Cmd|qtbz2 -s <package>.tbz2}}

The xpak file can be examined using <code>qxpak</code>.

To list the contents:

{{Cmd|qxpak -l <package>.xpak}}

The next command will extract a file called {{Path|USE}} which contains the enabled use flags for this package:

{{Cmd|qxpak -x package-manager-0.xpak USE}}

=== The PKGDIR layout ===

The currently used format version 2 has the following layout:

{{Code|Packages directory layout (version 2)|<pre>
PKGDIR
`+- Packages
 +- app-accessibility/
 |  +- pkg1-version.tbz2
 |  `- pkgN-version.tbz2
 +- app-admin/
 |  `- ...
 `- ...
</pre>}}

The {{Path|Packages}} is the major improvement (and also the trigger for portage to know that the binary package directory uses version 2) over the first binary package directory layout (version 1). In version 1, all binary packages were also hosted inside a single directory (called {{Path|All/}}) and the category directories only had symbolic links to the binary packages inside the {{Path|All/}} directory.

=== Unpacking with quickunpkg ===

Zoobab wrote a simple shell tool named [https://github.com/zoobab/quickunpkg quickunpkg] to quickly unpack tbz2 files.


[[Category:Portage]]
