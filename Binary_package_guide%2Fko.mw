<languages />
{{Metadata|abstract=포티지는 바이너리 꾸러미 빌드 및 설치를 지원합니다. 이 안내서는 바이너리 꾸러미 호스트를 만드는 방법과 바이너리 꾸러미 활용법을 설명합니다.}}

일상의 ebuild 지원 요소 말고도, 포티지에서는 바이너리 꾸러미 빌드 및 설치를 지원합니다. 이 안내서에서는 바이너리 꾸러미를 만들고, 설치하는 방법, 그리고 바이너리 꾸러미 서버를 설정하는 방법을 설명합니다.

== 도입부 ==

일부 시스템 관리자가 젠투에서 바이너리 꾸러미 설치를 좋아하는 이유는 몇가지가 있습니다.

# 무엇보다도, 관리자가 ''유사 최신 시스템을 유지''할 수 있습니다. 모든 소스코드를 컴파일 한다는 건 상당한 시간 소모를 야기합니다. 일부가 오래된 하드웨어이긴 하겠지만, 하나의 시스템에서 모든 소스코드를 컴파일 하고 다른 시스템에서는 바이너리 꾸러미를 재사용할 수 있을 경우 수많은 유사 시스템을 관리하는 일이 굉장히 쉬워질 수 있습니다.
# 두번째 이유는 ''안전한 업데이트 수행''입니다. 임무가 중요한 시스템에서는 가능한한 ''사용 가능한 상태''를 유지하는 것이 중요합니다. 이 작업은 모든 업데이트를 우선 처리하는 스테이지 서버에서 처리할 수 있으며, 스테이지 서버 상태가 괜찮아지면 중요한 시스템에 적용할 수 있습니다. 다른 접근 방식으로는, 동일 시스템 내에서의 chroot 환경의 업데이트로 처리하고 실제 시스템에 만든 바이너리를 사용하는 방법이 있습니다.
# 세번째 이유는 ''백업''으로서의 의미가 있기 때문입니다. 종종 바이너리 꾸러미가 망가진 시스템(예: 컴파일러 망가짐)을 복구하는 유일한 수단이 될 수 있습니다. 바이너리 꾸러미 서버든, 로컬 머신 어디든 미리 컴파일해둔 바이너리 꾸러미를 둔다면 툴체인이 망가졌을 때 굉장한 도움이 될 수 있습니다.
# 마지막으로, 이 방식은 ''상당히 오래된 시스템''의 업데이트를 지원합니다. 매우 오래된 시스템의 업데이트 작업은 바이너리 꾸러미를 사용하여 매우 쉽게 처리할 수 있습니다. 설치하고 업데이트 할 때 빌드 시간에 의지할 필요가 없는 바이너리 꾸러미 설치가 오래된 시스템에 종종 도움이 되기도 합니다. 바이너리 꾸러미는 미리 컴파일했기 때문에 빌드 과정의 실패 경우를 피할 수 있습니다.

이 안내서에서는, 다음 내용에 집중했습니다: 

* 바이너리 꾸러미를 만드는 방법;
* 바이너리 꾸러미를 클라이언트에 배포하는 방법;
* 바이너리 꾸러미 활용법;
* 바이너리 꾸러미 관리법.

바이너리 꾸러미를 다루는 몇가지 고급주제를 더 다루는 것으로 마칠 때가 왔습니다.

{{Note/ko|이 안내서에서 다루는 모든 도구는 별도로 명시하지 않는 한, {{Package|sys-apps/portage}}의 일부입니다.}}

== 바이너리 꾸러미 만들기 ==

바이너리 꾸러미를 만드는 세가지 주요 방법은 다음과 같습니다:

# 일반 설치 과정 후, {{c|quickpkg}} 사용하기
# <code>--buildpkg (-b)</code> 옵션으로 {{c|emerge}} 처리 과정에 명시하기
# 포티지 기능에 <code>buildpkg</code>값을 넣어 자동으로 처리하기

이 모든 세가지 방식은 <var>PKGDIR</var> 변수에서 가리치는 디렉터리에 바이너리 꾸러미를 만듭니다(기본값은 {{Path|/usr/portage/packages}}).

=== quickpkg 사용하기 ===

{{c|quickpkg}} 프로그램은 하나 이상의 의존 요소(또는 꾸러미 집합)를 취하며, 일치하는 모든 ''설치한'' 꾸러미에 대한 바이너리 꾸러미를 만듭니다.

예를 들어, ''설치한'' 모든 GCC 버전에 대해 바이너리 꾸러미를 만든다면:

{{RootCmd|quickpkg sys-devel/gcc}}

시스템에 이미 설치한 꾸러미의 바이너리 꾸러미를 만들려면 <code>*</code> 글롭을 사용하십시오:

{{RootCmd|quickpkg "*/*"}}

이 방식을 활용하는데 있어 위험성을 내포하고 있습니다. 설정 파일에서 문제가 될 수 있는 설치 파일에 의존합니다. 관리자는 종종 프로그램을 설치한 후 설정 파일을 편집합니다. 이 방법은 중요한 (비밀) 데이터를 꾸러미에 포함할 수 있기 때문에 {{c|quickpkg}}는 기본적으로 <var>CONFIG_PROTECT</var> 방식을 통해 보호한 설정 파일은 포함하지 ''않습니다''. 마찬가지로 설정 파일을 강제로 포함하려면, <code>--include-config</code> 또는 <code>--include-unmodified-config</code> 옵션을 사용하십시오.

=== --buildpkg 이머지 옵션 사용하기 ===

{{c|emerge}}로 프로그램을 설치할 때, <code>--buildpkg (-b)</code>를 사용하여 포티지에게 바이너리 꾸러미를 만들도록 요청할 수 있습니다:

{{Emerge|params+=--buildpkg|sys-devel/gcc}}

바이너리 꾸러미를 만들기''만'' 하고 라이브 시스템에 소프트웨어를 설치하지 ''않도록'' 요청할 수 있습니다. 이렇게 하려면 <code>--buildpkgonly (-B)</code> 옵션을 활용하시면 됩니다:

{{Emerge|params+=--buildpkgonly|sys-devel/gcc}}

그러나 후자 방식은 앞서 설치한 빌드 시간 의존성이 필요합니다.

=== 포티지 기능 buildpkg 적용 ===

포티지에서 꾸러미를 언제 설치하든지 바이너리 꾸러미를 자동으로 만드는 일반적인 방법은 다음과 같이 {{Path|/etc/portage/make.conf}} <code>buildpkg</code>를 사용하는 방식입니다:

{{FileBox|filename=/etc/portage/make.conf|title=포티지 buildpkg 기능 활성화|lang=bash|1=
FEATURES="${FEATURES} buildpkg"
}}

이 기능을 활성화하면, 항상 포티지에서는 프로그램을 설치할 때마다 바이너리 꾸러미도 함께 만듭니다.

=== 일부 꾸러미 생성 제외 ===

몇가지 꾸러미 또는 카테고리는 바이너리 꾸러미를 만들지 않게 할 수 있습니다. 이머지를 수행할 때 <code>--buildpkg-exclude</code> 옵션을 전달하면 됩니다:

{{RootCmd|emerge -uDN @world --buildpkg --buildpkg-exclude "virtual/* sys-kernel/*-sources"}}

이 방법은 존재하는 바이너리 패키지를 취하는데 조금 또는 어떠한 이득조차도 없이 꾸러미를 취득하는데 활용할 수 있습니다. 리눅스 커널 소스 꾸러미 또는 업스트림 바이너리 꾸러미가 예가 될 수 있습니다({{Package|www-client/firefox-bin}}과 같이 ''-bin''으로 끝나는 꾸러미).

== 바이너리 꾸러미 호스트 설정==

포티지는 바이너리 꾸러미를 다운로드할 다양한 프로토콜, FTP, FTPS, HTTP, HTTPS, SSH를 지원합니다. 이 특징은 바이너리 꾸러미 호스트 구현에 대한 다양한 가능성의 여지를 남겨놓았습니다.

그러나 포티지에서는 바이너리 꾸러미 배포에 있어 ''특별한 방식''을 제공하는 것은 아닙니다. 원하는 설정에 따라 추가 프로그램을 설치할 필요가 있습니다.

=== 웹기반 바이너리 꾸러미 호스트 ===

바이너리 꾸러미를 배포하는 일반적인 접근 방식은 웹기반 바이너리 꾸러미 호스트를 만드는 것입니다.

([[lighttpd]]{{Package|www-servers/lighttpd}}와 같은) 웹 서버를 사용하시고, {{Path|/etc/portage/make.conf}}의 <var>PKGDIR</var> 위치 값을 설정하여 읽기 권한을 부여하십시오.

{{FileBox|filename=/etc/lighttpd/lighttpd.conf|title=lighttpd 설정 예제|lang=bash|1=
# add this to the end of the standard configuration
server.modules += ( "mod_alias" )
alias.url = ( "/packages" => "/usr/portage/packages/" )
}}

다음, 클라이언트에서 이 설정값에 맞춰 <var>PORTAGE_BINHOST</var> 값을 설정하십시오:

{{FileBox|filename=/etc/portage/make.conf|title=웹기반 바이너리 꾸러미 호스트 사용하기|lang=bash|1=
PORTAGE_BINHOST="http://binhost.genfic.com/packages"
}}

=== SSH 바이너리 꾸러미 호스트 ===

바이너리 꾸러미를 인증 방식으로 제공하려면 SSH 사용을 고려할 수 있습니다.

SSH를 사용할 때, 원격 바이너리 꾸러미 호스트로 연결할 경우 리눅스 사용자의 SSH 키를(설치 과정처럼 뒤에서 무슨 일로 처리해야 할 경우 암호 없이) 사용할 수 있습니다.

이 과정을 수행하려면, 포티지 사용자의 SSH 키를 서버에서 허용했는지 확인해야 합니다:

{{RootCmd|cat portage.id_rsa.pub >> /home/binpkguser/.ssh/authorized_keys}}

<var>PORTAGE_BINHOST</var> 변수 값은 다음과 같이 바꿀 수 있습니다:

{{FileBox|filename=/etc/portage/make.conf|title=SSH 접근 용도로 PORTAGE_BINHOST 설정하기|lang=bash|1=
PORTAGE_BINHOST="ssh://binpkguser@binhostserver/usr/portage/packages"
}}

{{Note/ko|1=포티지에서 꾸러미를 클라이언트에 전달할 때 포트와 사용자 이름을 무시하므로 ~/.ssh/config를 사용하지 마십시오. 대신 <var>PORTAGE_BINHOST=</var> 변수에 모든 옵션을 올바르게 설정하십시오.}}

=== NFS 내보내기 ===

내부 네트워크에서 바이너리 꾸러미를 사용한다면, NFS를 통해 꾸러미를 바로 내보내고 클라이언트에서 마운트하는 일련의 과정이 쉽습니다.

{{Path|/etc/exports}} 파일은 다음과 같이 바꿀 수 있습니다:

{{FileBox|filename=/etc/exports|title=꾸러미 디렉터리 내보내기|1=
/usr/portage/packages                            2001:db8:81:e2::/48(ro,no_subtree_check,root_squash) 192.168.100.1/24(ro,no_subtree_check,root_squash)
}}

이 과정이 끝나면 클라이언트에서는 해당 위치를 마운트할 수 있습니다. {{Path|/etc/fstab}} 예제 항목은 다음과 같습니다:

{{FileBox|filename=/etc/fstab|title=꾸러미 폴더 마운트 항목|1=
binhost:/usr/portage/packages      /usr/portage/packages    nfs    defaults    0 0
}}

== 바이너리 꾸러미 사용하기 ==

다른 시스템에서 바이너리 꾸러미를 쓸만하게 하려면 몇가지 요구조건을 만족해야 합니다:

* The client and server architecture and [[CHOST]] must match.
* The <var>CFLAGS</var> and <var>CXXFLAGS</var> variables used to build the binary packages must be compatible with all clients.
* USE flags for processor specific features (like MMX, SSE,...) have to be carefully selected; all clients need to support them.

{{Important|Portage can not validate if these requirements match. It is the responsibility of the system administrator to guard these settings.}}

Next to these, Portage will check if the binary package is built using the same USE flags as expected on the client. If a package is built with a different USE flag combination, Portage will either ignore the binary package (and use source-based build) or fail, depending on the options passed to the emerge command upon invocation (see [[#Installing binary packages|Installing binary packages]]).

클라이언트쪽에서는, 사용할 바이너리 꾸러미에 대한 약간의 설정을 바꾸기만 하면 됩니다.

=== 바이너리 꾸러미 설치 ===

There are a few options that can be passed on to the {{c|emerge}} command that inform Portage about using binary packages:

{| class="table table-condensed table-striped"
|-
! Option !! Description
|-
| <code>--usepkg</code> <br> <code>(-k)</code> || Tries to use the binary package(s) in the locally available {{Path|packages}} directory. Useful when using [[NFS]] or [[SSHFS]] mounted binary package hosts. If the binary packages are not found, a regular (source-based) installation will be performed.
|-
| <code>--usepkgonly</code> <br> <code>(-K)</code> || Similar to <code>--usepkg (-k)</code> but fail if the binary package cannot be found. This option is useful if only ''pre-built'' binary packages are to be used.
|-
| <code>--getbinpkg</code> <br> <code>(-g)</code> || Download the binary package(s) from a remote binary package host. If the binary packages are not found, a regular (source-based) installation will be performed.
|-
| <code>--getbinpkgonly</code> <br> <code>(-G)</code> || Similar to <code>--getbinpkg (-g)</code> but will fail if the binary package(s) cannot be downloaded. This option is useful if only ''pre-built'' binary packages are to be used.
|}

In order to automatically use binary package installations, the appropriate option can be added to the <var>EMERGE_DEFAULT_OPTS</var> variable:

{{FileBox|filename=/etc/portage/make.conf|title=Automatically fetching binary packages and fail if not available|lang=bash|1=
EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --getbinpkgonly"
}}

There is a Portage feature that automatically implements the equivalent of <code>--getbinpkg (-g)</code> without the need for updating the <var>EMERGE_DEFAULT_OPTS</var> variable: <code>getbinpkg</code>

{{FileBox|filename=/etc/portage/make.conf|title=Enabling getbinpkg as Portage feature|lang=bash|1=
FEATURES="${FEATURES} getbinpkg"
}}

=== 바이너리 꾸러미 호스트에서 꾸러미 가져오기 ===

When using a binary package host, clients need to have the <var>PORTAGE_BINHOST</var> variable set. Otherwise the client will not know where the binary packages are stored which results in Portage being unable to retrieve them.

{{FileBox|filename=/etc/portage/make.conf|title=PORTAGE_BINHOST 설정|lang=bash|1=
PORTAGE_BINHOST="http://binhost.genfic.com/packages"
}}

The <var>PORTAGE_BINHOST</var> variable uses a space-separated list of URIs. This allows administrators to use several binary package servers simultaneously. The URI must always point to the directory in which the {{Path|Packages}} file resides.

{{Note|The support for multiple binary package servers is somewhat incomplete. If several servers serve a binary package for the same package version, then only the first one will be considered. This can be problematic when these binary packages differ in their <var>USE</var> configuration and the <var>USE</var> configuration of a later binary package would match the systems configuration.}}

=== 수정한 바이너리 꾸러미 재설치 ===

Passing the <code>--rebuilt-binaries</code> option to emerge will reinstall every binary that has been rebuilt since the package was installed. This is useful in case rebuilding tools like {{c|revdep-rebuild}} or {{c|python-updater}} are run on the binary package server.

관련 옵션은 <code>--rebuilt-binaries-timestamp</code>입니다. 이 옵션은 바이너리 꾸러미를 타임스탬프를 부여받기 이전에 빌드했을 경우 이머지가 바이너리 꾸러미를 재설치를 고려하지 않도록 합니다. 이 옵션은 바이너리 꾸러미 서버를 처음부터 다시 빌드했지만 <code>--rebuilt-binaries</code> 옵션을 다른 경우에 활용했을 경우 유용합니다.

=== 추가 클라이언트 설정 ===

Next to the ''getbinpkg'' feature, Portage also listens to the ''binpkg-logs'' feature. This one controls if log files for successful binary package installations should be kept. It is only relevant if the <var>PORT_LOGDIR</var> variable has been set and is enabled by default.

몇가지 꾸러미 모음 또는 항목 분류에서 바이너리 꾸러미를 제외하는 유사한 방법으로, 클라이언트에서 꾸러미 모음 또는 항목 분류와 같은 바이너리 꾸러미 설치를 제외하도록 설정할 수 있습니다.

설정을 완료하려면, <code>--usepkg-exclude</code> 옵션을 사용하십시오:

{{RootCmd|emerge -uDNg @world --usepkg-exclude "sys-kernel/gentoo-sources virtual/*"}}

== 바이너리 꾸러미 관리 ==

바이너리 꾸러미를 내보내고 배포하는 작업은 실제로 바이너리 꾸러미 목록을 유지하지 않을 경우 불필요한 저장소 낭비를 초래할 수 있습니다.

=== 오래된 바이너리 꾸러미 제거 ===

In the {{Package|app-portage/gentoolkit}} package an application called {{c|eclean}} is provided. It allows for maintaining Portage-related variable files, such as downloaded source code files, but also binary packages.

다음 명령은 ebuild에 관계없는 모든 각각의 바이너리 꾸러미를 제거합니다:

{{RootCmd|eclean packages}}

자세한 내용은 [[Eclean]] 게시물을 읽어보십시오.

Another tool that can be used is the {{c|qpkg}} tool from the {{Package|app-portage/portage-utils}} package. However, this tool is a bit less configurable.

(바이너리 꾸러미를 저장한 서버에서 사용하는 개념 차원에서)''사용하지 않는'' 바이너리 꾸러미를 지우려면:

{{RootCmd|qpkg -c}}

=== 꾸러미 파일 관리 ===

Inside the packages directory, a file called {{Path|Packages}} exists. This file acts as a cache for the metadata of all binary packages in the packages directory. The file is updated whenever Portage adds a binary package to the directory. Similarly, {{c|eclean}} updates it when it removes binary packages.

If for some reason binary packages are simply deleted or copied into the packages directory, or the {{Path|Packages}} file gets corrupted or deleted, then it must be recreated. This is done using {{c|emaint}} command:

{{RootCmd|emaint binhost --fix}}

== 고급 주제 ==

=== 꾸러미 디렉터리 스냅샷 만들기 ===

When deploying binary packages for a large number of client systems it might become worthwhile to create snapshots of the packages directory. The client systems then do not use the packages directory directly but use binary packages from the snapshot.

Snapshots can be created using the {{Path|/usr/lib64/portage/python2.7/binhost-snapshot}} or {{Path|/usr/lib64/portage/python3.3/binhost-snapshot}} tool. It takes four arguments:

# A source directory (the path to the packages directory).
# A target directory (that must not exist).
# A URI.
# A binary package server directory.

꾸러미 디렉터리의 파일은 대상 디렉터리로 복사합니다. 그 다음 주어진 URI의 바이너리 꾸러미 서버 디렉터리(네번째 매개변수)에 {{Path|Packages}} 파일을 만듭니다.

Client systems need to use an URI that points to the binary package server directory. From there they will be redirected to the URI that was given to {{c|binhost-snapshot}}. This URI has to refer to the target directory.

=== 바이너리 꾸러미 형식 이해 ===

Binary packages created by Portage have the file name ending with {{Path|.tbz2}}. These files consist of two parts:

# A {{Path|.tar.bz2}} archive containing the files that will be installed on the system.
# A {{Path|xpak}} archive containing package metadata, the ebuild, and the environment file.

파일 형식의 설명을 보려면 {{c|man xpak}} 를 참고하십시오.

{{Package|app-portage/portage-utils}} 에 {{Path|tbz2}}와 {{Path|xpak}} 형식의 파일을 나누거나 만들 수 있는 몇가지 도구가 있습니다.

다음 명령은 {{Path|tbz2}}를 {{Path|.tar.bz2}} 파일과 {{Path|.xpak}} 파일로 나눕니다:

{{Cmd|qtbz2 -s <package>.tbz2}}

{{c|qxpak}}을 활용하여 xpak 파일을 검사할 수 있습니다.

내용을 조회하려면:

{{Cmd|qxpak -l <package>.xpak}}

The next command will extract a file called {{Path|USE}} which contains the enabled USE flags for this package:

{{Cmd|qxpak -x package-manager-0.xpak USE}}

=== PKGDIR 배치 ===

현재 사용하는 버전 2 형식은 다음 배치를 따릅니다:

{{CodeBox|title=Packages directory layout (version 2)|1=
PKGDIR
`+- Packages
 +- app-accessibility/
 {{!}}  +- pkg1-version.tbz2
 {{!}}  `- pkgN-version.tbz2
 +- app-admin/
 {{!}}  `- ...
 `- ...
}}

The {{Path|Packages}} file is the major improvement (and also the trigger for Portage to know that the binary package directory uses version 2) over the first binary package directory layout (version 1). In version 1, all binary packages were also hosted inside a single directory (called {{Path|All/}}) and the category directories only had symbolic links to the binary packages inside the {{Path|All/}} directory.

=== quickunpkg로 꾸러미 해제하기 ===

Zoobab wrote a simple shell tool named [https://github.com/zoobab/quickunpkg quickunpkg] to quickly unpack {{Path|tbz2}} files.


[[Category:Portage]]
