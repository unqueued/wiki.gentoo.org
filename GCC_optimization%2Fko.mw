<languages />

{{Metadata|abstract=이 안내서에서는 안전하고 멀쩡한 CFLAGS와 CXXFLAGS를 사용하여 컴파일한 코드를 최적화 하는 방법을 소개합니다.  일반적으로 최적화 하기 이전의 이론적인 내용도 설명합니다.}}

이 안내서에서는 안전하고 멀쩡한 CFLAGS와 CXXFLAGS를 사용하여 컴파일한 코드를 최적화 하는 방법을 소개합니다.  일반적으로 최적화 하기 이전의 이론적인 내용도 설명합니다.

== 도입부 ==

=== CFLAGS와 CXXFLAGS란게 뭔가요? ===

CFLAGS와 CXXFLAGS는 소스코드를 컴파일할 때 어떤 종류의 스위치를 사용할지 GNU 컴파일러 모음 <code>GCC</code>에 알려주는 환경 변수입니다. CFLAGS는 C로 작성한 코드용, CXXFLAGS는 C++로 작성한 코드용 변수입니다. 

이 변수는 프로그램에 대한 많은 양의 디버그 메시지를 줄여주거나 오류 경고 수준을 높이고, 물론 생산 코드의 최적화 수준을 조절하는데 사용할 수도 있습니다. [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC 설명서] 에서는 이들 변수에서 사용할 수 있는 옵션과 목적에 대한 완전한 목록을 제공합니다. 

=== 어떻게 사용하나요? ===

CFLAGS와 CXXFLAGS는 두가지 방식으로 사용합니다. 첫번째 방법으로는 automake가 만든 MakeFile에서 프로그램별로 사용할 수 있습니다. 

그러나 포티지 트리에서 설치 패키지를 찾았을때는 이걸 활용할 수는 없습니다.  대신 {{Path|/etc/portage/make.conf}}의 CFLAGS와 CXXFLAGS를 설정합니다. 이 방식으로 여러분이 지정한 옵션을 사용하여 모든 패키지를 컴파일합니다. 

{{Code|/etc/portage/make.conf의 CFLAGS|<pre>
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
</pre>
}}

보시는 바와 같이, CXXFLAGS는 CFLAGS에 나타나는 모든 옵션을 사용하는 집합입니다. 이 방식이야 말로 거의 별다른 문제 없이 처리하길 원하는 방법입니다. CXXFLAGS에 추가 옵션을 지정할 필요조차도 없습니다.

=== 오해 ===

CFLAGS와 CXXFLAGS는 소스 코드를 작고 동작이 빠른 바이너리로 만드는데 매우 효율적인 수단이 될 수 있음을 의미하기도 하지만, 코드 기능을 망가뜨리거나, 바이너리 크기를 키우기도 하고, 실행 시간을 늦추며, 심지어는 컴파일 실패를 야기하기도 합니다. 

CFLAGS가 만병 통치약 같은건 아닙니다. 시스템을 자동적으로 좀 더 빠르게 동작하게 하거나 디스크상에서 바이너리가 적은 공간을 차지하게 하진 않습니다. 시스템을 최적화(또는 "성능을 좋게") 하려는 플래그를 추가하면 할수록 골로 가게 하는 확실한 방법이 됩니다. 그러니까 .. 성능을 감소시키는 시점이 있습니다. 

인터넷에서 찾아보겠다고 큰소리 치실지 모르겠지만, CFLAGS와 CXXFLAGS를 과감하게 이것저것 설정하는 것은 오히려 좋은 상황으로 끌고가기 보다는 프로그램을 더욱 안좋게 할 수가 있습니다. 특별한 목적으로 특별한 시점에서 플래그를 사용하도록 설계한것이 처음 장소에 플래그가 존재하는 이유임을 기억하십시오. CFLAG 일부는 코드 일부에 좋을 뿐이지만 이것이 결코 머신에 설치하는 모든 컴파일 요소에 맞춰진 것임을 의미하는게 아닙니다. 

=== 준비됐죠? ===

이제 약간의 위험성이 있다는 사실을 인지하고, 여러분의 컴퓨터에 멀쩡하고 안전한 최적화를 수행하도록 해보겠습니다. 여러분께 도움이 될 것이고 [https://bugs.gentoo.org/ 버그질라]에 문제를 알리면 개발자들에게 촉망받을 것입니다. (개발자들은 종종 어떤 문제가 집요하게 나타나면 최소한의 CFLAGS로 패키지를 다시 컴파일 하라고 합니다. 과감한 플래그 설정은 오히려 코드를 제대로 동작하지 못하게 함을 기억하십시오.) 

== 최적화 ==

=== 기본 ===

CFLAGS와 CXXFLAGS를 사용하는 목적은 시스템에 코드를 잘 다듬어 놓기 위함입니다. 가능하면 잘 빠지고 빠르게 제 기능을 완벽하게 다 할 것입니다. 가끔은 상호간에 배타적이어서 두 요소가 잘 동작하게 붙들고 있을 때도 있습니다. 이상적으로는 어떤 CPU 아키텍처에든 잘 돌아갑니다. 후반에 적극적인 플래그를 언급하여 여러분이 알아보고자 하는 바를 알 수 있게끔 할 것입니다. <code>GCC</code> 설명서에 있는 모든 옵션(수백개!)에 대해 언급하지 않겠지만 대부분 기본적이고 일반적인 플래그를 다루도록 하겠습니다. 

{{Note/ko|어떤 플래그가 실제로 어떤 역할을 하는지 확신할 수 없을 때면 [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC 설명서]의 관련 장을 참고하십시오. 그래도 무슨 얘긴지 모르겠다면 구글에서 검색해보든지, <code>GCC</code> [http://gcc.gnu.org/lists.html 메일링 리스트]에서 확인해 보십시오.}}

=== -march ===

제일 처음에 나오는 가장 중요한 옵션은 <code>-march</code>입니다. 이 플래그는 프로세서 [http://en.wikipedia.org/wiki/Microarchitecture 아키텍처] (또는 ''arch'')에 대해 어떤 코드를 만들어야 하는지 컴파일러에게 일러줍니다. 각각의 CPU에 맞춰 코드를 만들어야 함을 알려줍니다. 각기 다른 CPU에서는 각자 다른 기능을 보유하고, 다른 명령셋을 지원하며, 코드 실행에 다른 방식을 활용합니다. <code>-march</code> 플래그는 보유한 CPU에 맞게 기능, 특징, 명령셋, 고유의 동작 등을 포함한 코드를 컴파일러에게 만들어달라고 지시합니다. 

{{Path|/etc/portage/make.conf}}의 CHOST 변수에 일반적으로 아키텍처에서 사용하는 플래그를 지정하지만, <code>-march</code> 플래그는 지정 프로세서에 대해 프로그램을 최적화하는데 사용할 수 있습니다. (다른 CPU 중에서) x86과 x86-64 CPU는 <code>-march</code> 플래그를 사용해야 합니다. 

어떤 CPU를 가지고 있나요? 찾아보려면 다음 명령을 실행하십시오: 

{{Cmd|cat /proc/cpuinfo}}

이제 <code>-march</code> 동작을 보도록 하겠습니다. 예제는 옛날 펜티엄 III 칩입니다: 

{{Code|/etc/portage/make.conf: Pentium III|<pre>
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>
}}

64-bit AMD CPU에 대한 또 다른 설정 내용입니다: 

{{Code|/etc/portage/make.conf: AMD64|<pre>
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
</pre>
}}

그래도 어떤 CPU를 쓰는지 모르겠다면, 아마 그냥<code>-march=native</code>를 사용하고 싶을 것입니다. 이 플래그를 사용하면 GCC는 프로세서를 감지하고 자동으로 적당한 플래그를 설정합니다. '''그러나 다른 CPU에서 사용할 패키지를 컴파일하려 한다면 이 플래그를 쓰면 안됩니다.''' 

하나의 컴퓨터에서 패키지를 컴파일 하는데 다른 컴퓨터에서 실행하려 한다면(예를 들어 더 느리고 오래된 머신에서 실행할 바이너리를 빌드하는데 더 빠른 컴퓨터를 사용하는 경우), <code>-march=native</code>를 ''사용하지 마십시오''. "Native"는 말 그대로 해당 CPU에서''만'' 동작할 코드를 만듦을 의미합니다. AMD Athlon 64 CPU에서 <code>-march=native</code> 플래그로 빌드한 프로그램은 옛날 VIA C3 CPU에서 실행할 수 없습니다. 

Also available are the <code>-mtune</code> and <code>-mcpu</code> flags. These flags are normally only used when there is no available <code>-march</code> option; certain processor architectures may require <code>-mtune</code> or even <code>-mcpu</code>. Unfortunately, <code>GCC</code>'s behavior isn't very consistent with how each flag behaves from one architecture to the next. 

On x86 and x86-64 CPUs, <code>-march</code> will generate code specifically for that CPU using all its available instruction sets and the correct ABI; it will have no backwards compatibility for older/different CPUs. If you don't need to execute code on anything other than the system you're running Gentoo on, continue to use <code>-march</code>. You should only consider using <code>-mtune</code> when you need to generate code for older CPUs such as i386 and i486. <code>-mtune</code> produces more generic code than <code>-march</code>; though it will tune code for a certain CPU, it doesn't take into account available instruction sets and ABI. Don't use <code>-mcpu</code> on x86 or x86-64 systems, as it is deprecated for those arches. 

Only non-x86/x86-64 CPUs (such as Sparc, Alpha, and PowerPC) may require <code>-mtune</code> or <code>-mcpu</code> instead of <code>-march</code>. On these architectures, <code>-mtune</code> / <code>-mcpu</code> will sometimes behave just like <code>-march</code> (on x86/x86-64)... but with a different flag name. Again, <code>GCC</code>'s behavior and flag naming just isn't consistent across architectures, so be sure to check the <code>GCC</code> [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] to determine which one you should use for your system. 

{{Note|For more suggested <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> settings, please read chapter 5 of the appropriate [http://www.gentoo.org/doc/en/handbook/ Gentoo Installation Handbook] for your arch. Also, read the <code>GCC</code> manual's list of [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options], as well as more detailed explanations about the differences between <code>-march</code>, <code>-mcpu</code>, and <code>-mtune</code>.}}

=== -O ===

Next up is the <code>-O</code> variable. This controls the overall level of optimization. This makes the code compilation take somewhat more time, and can take up much more memory, especially as you increase the level of optimization. 

There are seven <code>-O</code> settings: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code>, and <code>-Ofast</code>. You should use only one of them in {{Path|/etc/portage/make.conf}}. 

With the exception of <code>-O0</code>, the <code>-O</code> settings each activate several additional flags, so be sure to read the GCC manual's chapter on [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimization options] to learn which flags are activated at each <code>-O</code> level, as well as some explanations as to what they do. 

각각의 최적화 레벨을 살펴보도록 하겠습니다: 

*  <code>-O0</code>: This level (that's the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in CFLAGS or CXXFLAGS.  This reduces compilation time and can improve debugging info, but some applications will not work properly without optimization enabled.  This option is not recommended except for debugging purposes.

*  <code>-O1</code>: This is the most basic optimization level. The compiler will try to produce faster, smaller code without taking much compilation time. It's pretty basic, but it should get the job done all the time.

*  <code>-O2</code>: A step up from <code>-O1</code>. This is the ''recommended'' level of optimization unless you have special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code>. With <code>-O2</code>, the compiler will attempt to increase code performance without compromising on size, and without taking too much compilation time.

*  <code>-O3</code>: This is the highest level of optimization possible.  It enables optimizations that are expensive in terms of compile time and memory usage.  Compiling with <code>-O3</code> is not a guaranteed way to improve performance, and in fact in many cases can slow down a system due to larger binaries and increased memory usage.  <code>-O3</code> is also known to break several packages.  Therefore, using <code>-O3</code> is not recommended.

*  <code>-Os</code>: This option will optimize your code for size. It activates all <code>-O2</code> options that don't increase the size of the generated code. It can be useful for machines that have extremely limited disk storage space and/or have CPUs with small cache sizes.

*  <code>-Og</code>: In GCC 4.8, a new general optimization level, <code>-Og</code>, has been introduced. It addresses the need for fast compilation and a superior debugging experience while providing a reasonable level of runtime performance. Overall experience for development should be better than the default optimization level <code>-O0</code>.  Note that <code>-Og</code> does not imply <code>-g</code>, it simply disables optimizations that may interfere with debugging.

*  <code>-Ofast</code>: New in GCC 4.7, consists of <code>-O3</code> plus <code>-ffast-math</code>, <code>-fno-protect-parens</code>, and <code>-fstack-arrays</code>. This option breaks strict standards compliance, and is not recommended for use.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and you aren't using <code>-O2</code>, try rebuilding with that option.  As a fallback option, try setting your CFLAGS and CXXFLAGS to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).

=== -pipe ===

A common flag is <code>-pipe</code> . This flag actually has no effect on the generated code, but it makes the compilation process faster. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, GCC might get killed. In that case, do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but you may need to activate it yourself by adding it to your flags. Though the <code>GCC</code> manual does not specify all architectures it is turned on by using <code>-O</code>, you will need to explicitly activate it on x86. However, using this flag will make debugging hard to impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. However, if you don't plan to do much software debugging and haven't added any other debugging-related CFLAGS such as <code>-ggdb</code>, then you can try using <code>-fomit-frame-pointer</code>. 

{{Important|Do ''not'' combine <code>-fomit-frame-pointer</code> with the similar flag <code>-momit-leaf-frame-pointer</code>. Using the latter flag is discouraged, as <code>-fomit-frame-pointer</code> already does the job properly. Furthermore, <code>-momit-leaf-frame-pointer</code> has been shown to negatively impact code performance.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE], [http://en.wikipedia.org/wiki/SSE2 SSE2], [http://en.wikipedia.org/wiki/SSSE3 SSE3], [http://en.wikipedia.org/wiki/MMX MMX], and [http://en.wikipedia.org/wiki/3dnow 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to check if your CPU supports these by running <code>cat /proc/cpuinfo</code>. The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

You normally don't need to add any of these flags to {{Path|/etc/portage/make.conf}} as long as you are using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code>). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these you'll need to enable additional flags where appropriate after checking the output of <code>cat /proc/cpuinfo</code>. 

{{Note|You should check the [http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options list] of x86 and x86-64-specific flags to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then you don't need to specify it; it will be turned on by using the proper <code>-march</code> setting.}}

== 최적화 자주 묻는 질문 ==

=== 근데 -funroll-loops -fomg-optimize로 성능이 더 좋아졌는데요?! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt your applications when used system-wide. Even the <code>GCC</code> [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> makes code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

The truth of the matter is that they are dangerously aggressive flags. Take a good look around the [https://forums.gentoo.org/ Gentoo Forums] and [https://bugs.gentoo.org/ Bugzilla] to see what those flags do: nothing good! 

You don't need to use those flags globally in CFLAGS or CXXFLAGS. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat your code and get your bugs marked INVALID or WONTFIX. 

You don't need dangerous flags like these. '''Don't use them'''. Stick to the basics: <code>-march</code>, <code>-O</code>, and <code>-pipe</code>.

=== 3 보다 높은 -O 레벨은 어떤가요? ===

Some users boast about even better performance obtained by using <code>-O4</code>, <code>-O9</code>, and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept CFLAGS like <code>-O4</code>, but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code>, nothing more. 

Need more proof? Examine the <code>code</code> [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup source code]: 

{{Code|-O 소스 코드|<pre>
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>
}}

As you can see, any value higher than 3 is treated as just <code>-O3</code>.

=== 중복 플래그는 무엇인가요? ===

Oftentimes CFLAGS and CXXFLAGS that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}}. Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all CFLAGS and CXXFLAGS, or it may replace <code>-O</code> with a different level. 

The [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] outlines where and how flag filtering/replacing works. 

It's possible to circumvent <code>-O</code> filtering by redundantly listing the flags for a certain level, such as <code>-O3</code>, by doing things like: 

{{Code|중복 CFLAGS 지정|<pre>
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>
}}

However, '''this is not a smart thing to do'''. CFLAGS are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers''. Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

You will most likely continue to run into problems when you build a package with unacceptable flags. When you report your troubles on Bugzilla, the flags you use in {{Path|/etc/portage/make.conf}} will be readily visible and you will be told to recompile without those flags. Save yourself the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume that you know better than the developers.

=== What about LDFLAGS? ===

The Gentoo developers have already set basic, safe LDFLAGS in the base profiles, so you don't need to change them. 

=== 패키지별로 플래그를 사용해도 되나요? ===

{{Warning/ko|패키지당 플래그를 사용하면 디버그와 지원이 복잡해질 수 있습니다. 버그 보고서 작성시 이러한 기능을 사용했는지 어떻게 무얼 바꾸었는지에 대한 언급 여부를 확인하십시오.}}

패키지별 환경 변수 사용법(CFLAGS 포함)은 [http://www.gentoo.org//doc/en/handbook/handbook-amd64.xml?part=3&chap=6#doc_chap2 젠투 핸드북, "패키지별 환경 변수"]편에 설명되어 있습니다.

== 자료 ==

다음 자료는 최적화에 대해 더 이해하는데 도움이 될 것입니다: 

* [http://gcc.gnu.org/onlinedocs/ GCC 온라인 문서] 

* [http://www.gentoo.org/doc/en/handbook/ 젠투 설치 핸드북] 5장 

* <code>man make.conf</code>

* [https://en.wikipedia.org/ 위키피디아]

* [https://forums.gentoo.org/ 젠투 포럼]

== 감사문 ==

이 안내서에 제공한 노고에 대해 다음 작성자와 편집자분들께 감사의 말을 전하고자 합니다:

* nightmorph
