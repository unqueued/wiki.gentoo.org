<languages />

{{Metadata|abstract=이 안내서에서는 안전하고 멀쩡한 CFLAGS와 CXXFLAGS를 사용하여 컴파일한 코드를 최적화 하는 방법을 소개합니다.  일반적으로 최적화 하기 이전의 이론적인 내용도 설명합니다.}}

이 안내서에서는 안전하고 멀쩡한 <var>CFLAGS</var>와 <var>CXXFLAGS</var>를 사용하여 컴파일한 코드를 최적화 하는 방법을 소개합니다.  일반적으로 최적화 하기 이전의 이론적인 내용도 설명합니다.

== 도입부 ==

=== CFLAGS와 CXXFLAGS란 뭔가요? ===

<var>CFLAGS</var>와 <var>CXXFLAGS</var>는 C/C++ 코드를 컴파일할 때 빌드 시스템에 컴파일러 옵션을 늘상 전달할 때 활용하는 환경 변수 중 하나입니다. 이 변수를 표준화한 건 아니지만, 언제 어디서든 활용하며 컴파일러를 실행할 때 추가, 제대로 작성한 빌드에 개별 옵션을 전달할 때 제대로 이해하도록 해야합니다. 이 분야에서 일반적으로 활용하는 변수 일부 목록을 보려면 [https://www.gnu.org/software/make/manual/make.html#Implicit-Variables GNU make] 정보 페이지를 확인하십시오.

젠투 시스템을 이루는 꾸러미의 대부분은 C/C++ 언어로 작성했기 때문에, 관리자가 올바르게 설정하려는 이 두가지 변수는 시스템을 빌드하는 과정에 상당한 영향을 줍니다.

They can be used to decrease the amount of debug messages for a program, increase error warning levels, and, of course, to optimize the code produced. The [https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC manual] maintains a complete list of available options and their purposes.

=== 어떻게 사용하나요? ===

보통 설정 스크립트를 실행하거나 {{c|automake}}로 만든 makefile로 <var>CFLAGS</var>와 <var>CXXFLAGS</var>를 설정합니다. 젠투 시스템에서는 <var>CFLAGS</var> 변수와 <var>CXXFLAGS</var> 변수를 {{Path|/etc/portage/make.conf}}에 설정합니다. 이 파일에 설정한 변수는  이 옵션을 기반으로 모든 꾸러미를 컴파일하는 포티지에서 실행할 프로그램의 환경으로 내보냅니다.

{{CodeBox|title=/etc/portage/make.conf의 CFLAGS 설정|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important|USE 플래그에 여러 줄을 넣을 수 있지만, <var>CFLAGS</var>에 똑같이 하면 {{c|cmake}} 같은 프로그램에 문제가 될 수 있습니다. <var>CFLAGS</var> 선언을 한 줄로 했는지, 문제를 막기 위해 가능한 한 공백을 줄였는지 확인하십시오. 예제로 {{Bug|500034}}를 보십시오.}}

보시는 바와 같이, <var>CXXFLAGS</var>는 <var>CFLAGS</var>에 나타나는 모든 옵션을 사용하는 집합입니다. 대부분의 모든 시스템에서는 이 방식으로 설정해야합니다. <var>CXXFLAGS</var> 추가 옵션은 일반적이지 않으며, 보통 여기 언급한 설정이 전체적으로 설정할만하므로 보통 적용하지 않습니다.

{{Tip|[[Safe_CFLAGS|Safe CFLAGS]] article might help beginners start optimizing their systems.}}

=== 오해 ===

<var>CFLAGS</var>에 컴파일러 최적화 옵션을 여러개 설정해두면 작고 빠르게 동작하는 이진 파일을 만들 수 있지만, 비정상적으로 코드가 동작할 수 있고, 크기가  부풀어오를 수 있으며, 실행 시간이 늘어나거나, 빌드에 실패할 수 있습니다. <var>CFLAGS</var>를 다루다보면 빨라지기보단 오히려 성능 저하 측면으로 돌아갑니다. 임의로 설정하지 마십시오.

{{Path|/etc/portage/make.conf}}에 설정한 전역 <var>CFLAGS</var> 변수는 시스템의 모든 꾸러미에 적용하므로 보통 관리자만 광범위하게 적용할 수 있는 값으로 설정합니다. 개별 꾸러미에서는 이빌드 또는 빌드 시스템 자체에서 컴파일러를 실행할 때 사용할 최종 플래그 셋을 만들 때 옵션을 수정합니다.

=== 준비됐죠? ===

이제 약간의 위험성이 있다는 사실을 인지하고, 여러분의 컴퓨터에 멀쩡하고 안전한 최적화를 수행하도록 해보겠습니다. 여러분께 도움이 될 것이고 [https://bugs.gentoo.org/ 버그질라]에 문제를 알리면 개발자들에게 촉망받을 것입니다. (개발자들은 종종 어떤 문제가 집요하게 나타나면 최소한의 <var>CFLAGS</var>로 패키지를 다시 컴파일 하라고 합니다. 과감한 플래그 설정은 오히려 코드를 제대로 동작하지 못하게 함을 기억하십시오.) 

== 최적화 ==

=== 기본 ===

<var>CFLAGS</var>와 <var>CXXFLAGS</var>를 사용하는 목적은 시스템에 코드를 잘 다듬어 놓기 위함입니다. 가능하면 잘 빠지고 빠르게 제 기능을 완벽하게 다 할 것입니다. 가끔은 상호간에 배타적이어서 두 요소가 잘 동작하게 붙들고 있을 때도 있습니다. 이상적으로는 어떤 CPU 아키텍처에든 잘 돌아갑니다. 후반에 적극적인 플래그를 언급하여 여러분이 알아보고자 하는 바를 알 수 있게끔 할 것입니다. GCC 설명서에 있는 모든 옵션(수백개!)에 대해 언급하지 않겠지만 대부분 기본적이고 일반적인 플래그를 다루도록 하겠습니다. 

{{Note|When unaware of what a flag does refer to the relevant chapter of the [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual]. If still stumped after viewing the manual, try a search engine or check out the [https://gcc.gnu.org/lists.html GCC mailing lists].}}

=== -march ===

제일 처음에 나오는 가장 중요한 옵션은 <code>-march</code>입니다. 이 플래그는 프로세서 [https://en.wikipedia.org/wiki/Microarchitecture 아키텍처] (또는 ''arch'')에 대해 어떤 코드를 만들어야 하는지 컴파일러에게 일러줍니다. GCC에게 각각의 CPU에 맞춰 코드를 만들어야 함을 알려줍니다. 각기 다른 시스템의 CPU에서는 각자 다른 기능을 보유하고, 다른 명령셋을 지원하며, 개별 코드 실행에 각각 다른 방식을 활용합니다. <code>-march</code> 플래그는 보유한 CPU에 맞게 기능, 특징, 명령셋, 고유의 동작 등을 포함한 코드를 컴파일러에게 만들어달라고 지시합니다.

<code>-march=</code> is an ISA selection option; it tells the compiler that it may use the instructions from the ISA. On an Intel/AMD64 platform with <code>-march=native -O2</code> or lower OPT level, the code will likely end up with AVX instructions used but using shorter SSE XMM registers. To take full advantage of AVX YMM registers, the <code>-ftree-vectorize</code>, <code>-O3</code> or <code>-Ofast</code> options should be used as well<ref>GNU GCC Bugzilla, [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57952#c8 AVX/AVX2 no ymm registers used in a trivial reduction]. Retrieved on 2017/07/18.</ref>.

<code>-ftree-vectorize</code> is an optimization option (default at <code>-O3</code> and <code>-Ofast</code>), which attempts to vectorize loops using the selected ISA if possible.  The reason it isn't enabled at <code>-O2</code> is that it doesn't always improve code, it can make code slower as well, and usually makes the code larger; it really depends on the loop etc. 

Even though the <var>CHOST</var> variable in {{Path|/etc/portage/make.conf}} specifies the general architecture used, <code>-march</code> should still be used so that programs can be optimized for the system specific processor. x86 and x86-64 CPUs (among others) should make use of the <code>-march</code> flag. 

어떤 CPU를 가지고 있나요? 찾아보려면 다음 명령을 실행하십시오: 

{{Cmd|cat /proc/cpuinfo}}

or even install {{Package|app-portage/cpuinfo2cpuflags}} and add the available CPU-specific options to the {{Path|make.conf}} file, which the tool does through e.g. the [[CPU FLAGS X86|CPU_FLAGS_X86]] variable:

{{Cmd|cpuinfo2cpuflags-x86 >> /etc/portage/make.conf}}

<code>march</code>와 <code>mtune</code> 값에 대한 자세한 내용을 살펴보려면, 다음 두 명령을 사용할 수 있습니다.

* 처음 명령은 컴파일러에 링크 작업을 수행하지 말라고 하는(<code>-c</code>) 대신, 명령행 옵션을 분명하게 보여주는 <code>--help</code> 옵션을 해석하여 어떤 옵션을 활성화했고 비활성화했는지(<code>-Q</code>) 보여줍니다. 이 경우 선택한 대상 아키텍처에 대해 활성화한 옵션을 보여줍니다:
{{Cmd|gcc -c -Q -march{{=}}native --help{{=}}target}}

* 두번째 명령은 헤더 파일을 빌드할 컴파일러 지시자를 보여줍니다만, 실제 동작 과정 없이 화면에 보여줍니다(<code>-###</code>). 최종 출력 행에는 모든 최적화 옵션과 아키텍처 선택을 지닌 명령이 나타납니다.
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

이제 <code>-march</code> 동작을 보겠습니다. 예제는 옛날 펜티엄 III 칩입니다: 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium III 예제|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

64-bit AMD CPU에 대한 또 다른 설정 내용입니다: 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64 예제|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

어떤 CPU를 쓰는지 모르겠거나 어떤 설정을 선택해야 할지 모르겠다면, 아마 그냥<code>-march=native</code> 설정을 사용할 수 있습니다. 이 플래그를 사용하면 GCC는 프로세서를 감지하고 자동으로 적당한 플래그를 설정합니다. '''그러나 다른 CPU에서 사용할 패키지를 컴파일하려 한다면 이 플래그를 쓰면 안됩니다.''' 

{{Warning|{{c|[[Distcc/ko#-march.3Dnative|distcc]]}}로 컴파일 할 때는 {{Path|make.conf}}의 <var>CFLAGS</var> 또는 <var>CXXFLAGS</var> 값을 <code>-march{{=}}native</code> 또는 <code>-mtune{{=}}native</code>로 사용하지 '''마십시오'''.}}

하나의 컴퓨터에서 패키지를 컴파일 하는데 다른 컴퓨터에서 실행하려 한다면(예를 들어 더 느리고 오래된 머신에서 실행할 바이너리를 빌드하는데 더 빠른 컴퓨터를 사용하는 경우), <code>-march=native</code>를 ''사용하지 마십시오''. "Native"는 말 그대로 해당 CPU에서''만'' 동작할 코드를 만듦을 의미합니다. AMD Athlon 64 CPU에서 <code>-march=native</code> 플래그로 빌드한 프로그램은 옛날 VIA C3 CPU에서 실행할 수 '''없습니다'''. 

또한 이 말고도 <code>-mtune</code>와 <code>-mcpu</code> 플래그가 있습니다. 이 플래그는 보통 <code>-march</code> 옵션을 쓰지 못할때만 사용합니다. 어떤 프로세서 아키텍처에서는 <code>-mtune</code>아니면 <code>-mcpu</code>가 필요합니다. 불행하게도 GCC의 동작은 어떤 한 아키텍처에서 다음 아키텍처로 각각의 플래그를 부여하는데 있어 일관성이 꽤 있는 것이 아닙니다. 

x86과 x86-64 CPU에서 <code>-march</code> 플래그를 통해 존재하는 모든 명령 셋과 올바른 ABI를 활용하여 CPU에 대한 지정 코드를 생성합니다. 이전의 다른 CPU에 대한 이전 호환성은 없습니다. i386과 i486 같은 예전 CPU에 대해 코드를 생성할 때만 <code>-mtune</code>의 사용을 고려하는것이 좋습니다. <code>-mtune</code> 플래그는 <code>-march</code>보다 훨씬 일반적인 코드를 만들어냅니다. 각각의 CPU에 대한 적당한 코드를 만들어내겠지만서도, 존재하는 명령셋과 ABI에 맞춰주진 못합니다. x86이나 x86-64 시스템에서 <code>-mcpu</code> 플래그는 오래된 요소이므로 사용하지 마십시오. 

비 x86/x86-64 CPU에서는(Sparc, 알파 PowerPC) <code>-march</code> 대신 <code>-mtune</code> 또는 <code>-mcpu</code>가 필요할듯 합니다. 이 아키텍처에서는 <code>-mtune</code> / <code>-mcpu</code> 옵션이 (x86/x86-64의) <code>-march</code> 처럼 동작하기도 합니다...만 플래그 이름은 달라집니다. 다시 말해, GCC의 동작과 플래그 이름은 전 아키텍처에 대해 일관성이 있는건 아니므로, 시스템에서 사용할 아키텍처가 무엇인지 정하려면 GCC [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options 설명서]를 확인하십시오. 

{{Note|For more suggested <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> settings, please read chapter 5 of the appropriate [[HandBook:Main_Page|Gentoo Installation Handbook]] for the arch. Also, read the GCC manual's list of [https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options], as well as more detailed explanations about the differences between <code>-march</code>, <code>-mcpu</code>, and <code>-mtune</code>.}}

=== -O ===

다음은 <code>-O</code> 변수입니다. 이 변수는 최적화의 전체 수준을 제어합니다. 이 값을 늘려 바꾸면 최적화 설정을 통해 특히 최적화 레벨을 올리는 만큼 코드 컴파일 과정의 시간을 더 걸리게 하거나, 메모리를 더 많이 소비합니다. 

7가지의 <code>-O</code> 레벨 설정 <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code>, <code>-Ofast</code>가 있습니다. {{Path|/etc/portage/make.conf}} 파일에서 이들 중 하나만을 사용해야 합니다.

With the exception of <code>-O0</code>, the <code>-O</code> settings each activate several additional flags, so be sure to read the GCC manual's chapter on [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimization options] to learn which flags are activated at each <code>-O</code> level, as well as some explanations as to what they do. 

각각의 최적화 레벨을 살펴보도록 하겠습니다: 

* <code>-O0</code>: 이 레벨(글자"O" 다음에 숫자 영이 따라옴)은 최적화를 완전히 끄고, <var>CFLAGS</var> 또는 <var>CXXFLAGS</var>에 <code>-O</code> 레벨을 기본으로 지정하지 않았을 경우에 기본값이 됩니다. 컴파일 시간을 줄이고 디버그 정보를 개선할 수 있지만, 어떤 프로그램은 최적화를 활성화 하지 않으면 제대로 동작하지 않는 수가 있습니다. 이 옵션은 디버깅 목적이 아니라면 사용하지 않는 것이 좋습니다.

* <code>-O1</code>: 이 레벨은 매우 기본적인 최적화를 수행합니다. 컴파일러는 더 많은 컴파일 시간을 소비하지 않고도 빠르고 작은 코드를 만들어냅니다. 기본적일 수는 있지만 항상 컴파일 작업이 완료됩니다.

* <code>-O2</code>: <code>-O1</code>에서 한 단계 상승합니다. 시스템에서 특별하게 필요한 경우가 아닌 한 ''권장하는'' 최적화 레벨입니다. <code>-O2</code> 플래그는 <code>-O1</code> 플래그로 활성화 한 플래그보다 더 많은 플래그를 활성화 합니다. <code>-O2</code> 플래그로, 컴파일러에서는 바이너리 크기와의 절충 없이 무조건 코드 성능을 끌어올리여 하며, 컴파일 시간을 너무 많이 소비하지 않습니다.

* <code>-O3</code>: 가능한 가장 높은 최적화 레벨입니다. 컴파일 시간과 메모리 사용에 있어 그 이상의 최적화를 활성화합니다. <code>-O3</code>으로 컴파일 할 때는 성능을 개선한다는 보장이 없으며, 실제로 대부분의 경우, 바이너리가 커지고 메모리 사용량이 증가하여 시스템을 느리개 할 수 있습니다. <code>-O3</code>는 또한 몇가지 꾸러미를 깨뜨리는 걸로 알려져 있습니다. <code>-O3</code> 플래그 사용을 권장하지 않습니다.

* <code>-Os</code>: 코드 크기를 최적화 합니다. 만든 코드의 크기가 늘어나지 않게 하는 모든 <code>-O2</code> 옵션을 활성화 합니다. 매우 제한된 디스크 저장소 공간을 가지고 있거나 CPU의 캐시 크기가 작을 경우 유용합니다.

* <code>-Og</code>: GCC4.8에 새로운 일반 최적화 레벨 <code>-Og</code>를 도입했습니다. 빠른 컴파일을 필요로 하며 실행시간 성능의 타당한 수준을 제공하면서 우수한 디버깅 경험을 할 수 있게 바로 잡았습니다. 개발에 있어 전체적인 경험은 기본 최적화 레벨 <code>-O0</code>보단 낫습니다. 참고로 <code>-Og</code>는 <code>-g</code>를 의미하지 않으며, 디버깅에 혼란을 주는 최적화 기능을 끌 뿐입니다.

* <code>-Ofast</code>: GCC 4.7에서 새로 도입했으며, <code>-O3</code>,  <code>-ffast-math</code>, <code>-fno-protect-parens</code>, and <code>-fstack-arrays</code>로 이루어져 있습니다. 이 옵션은 엄격한 표준 준수를 깨며, 사용을 권장하지 않습니다.

이전에 말한 바와 같이, <code>-O2</code>가 추천하는 최적화 레벨입니다. <code>-O2</code>를 사용하지 않아 패키지 컴파일에 실패했다면 이 옵션으로 다시 빌드해보십시오. 대체 옵션으로 <code>-O1</code>또는 <code>-O0 -g2 -ggdb</code> 같은 더 낮은 최적화 레벨의 플래그로 <var>CFLAGS</var>와 <var>CXXFLAGS</var>를 설정해보십시오(오류 보고 및 존재하는 문제 확인용).

=== -pipe ===

일반적인 플래그로 <code>-pipe</code>가 있습니다. 이 플래그는 실제로 코드를 생성하는덴 아무런 영향잉 벗습니다만, 컴파일 과정을 좀 더 ''빠르게'' 합니다. 컴파일러에게 메모리를 더욱 소비하는 제각기 다른 스테이지에서 컴파일을 수행하는 동안 임시 파일 대신 파이프를 사용하라고 알려줍니다. 시스템에서 메모리가 부족하면 GCC가 갑자기 끝납니다. 이 경우, 이 플래그를 사용하지 마십시오. 

=== -fomit-frame-pointer ===

생성 코드의 크기를 줄이도록 설계한 가장 일반적인 플래그입니다. (x86-64 같은) 디버깅에 혼란을 겪지 않는 아키텍처에서 모든 <code>-O</code> 레벨(<code>-O0</code> 제외)을 켜놓겠지만 활성화해야합니다. 이 경우 플래그에 추가하십시오. GCC 설명서에는 모든 아키텍처 별로 다루지 않지만 <code>-O</code> 옵션을 켜놓았습니다. 아직까지도 GCC 4.6 이상을 쓰거나 어떤 GCC 버전에서든 <code>-Os</code> 플래그를 사용한다면, x86-32 에 대해 <code>-fomit-frame-pointer</code> 옵션을 분명히 활성화해야합니다. 그러나 <code>-fomit-frame-pointer</code> 옵션을 활성화하면 디버깅을 어렵게 하거나 불가능하게 할 수 있습니다. 

다만 일부의 경우에는, Java가 이 플래그로 인해 코드에만 영향을 받는 것이 아니기 때문에 Java로 작성한 프로그램의 문제 해결을 더 어렵게 합니다. 따라서 플래그는 어디엔가 도움이 된다면, 디버깅을 어렵게 하며, 백트레이싱이 무용지물이 됩니다. 그러나 프로그램 디버깅을 면밀하게 진행할 생각이 없거나, <code>-ggdb</code>와 같은 디버깅 관련 <var>CFLAGS</var>를 추가하지 않았다면, <code>-fomit-frame-pointer</code>를 사용해볼 수 있습니다. 

{{Important|<code>-fomit-frame-pointer</code> 플래그를 유사한 플래그 <code>-momit-leaf-frame-pointer</code>와 함께 사용하지 ''마십시오''. <code>-fomit-frame-pointer</code> 플래그가 제대로 동작하므로 후자의 플래그 사용은 권장하지 않습니다. 게다가 <code>-momit-leaf-frame-pointer</code> 플래그는 코드 성능에 부정적 영향을 주는걸로 나타납니다.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extensions] (SSE), [https://en.wikipedia.org/wiki/SSE2 SSE2], [https://en.wikipedia.org/wiki/SSSE3 SSE3], [https://en.wikipedia.org/wiki/MMX_(instruction_set) MMX], and [https://en.wikipedia.org/wiki/3DNow! 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to see if the CPU supports these instruction sets by running {{c|cat /proc/cpuinfo}}. The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

보통, 올바른 <code>-march</code> (예: <code>-march=nocona</code> 는 암묵적으로 <code>-msse3</code>을 의미) 플래그 설정을 이미 사용하고 있어왔기 때문에, 어떤 플래그도 {{Path|/etc/portage/make.conf}}에 추가할 필요는 없습니다. (SSE3와 같이) <code>-march</code>가 암시하지 않는 기계 명령을 지원하는 최근의 VIA와 AMD64 CPU에는 참고할 만한 별도의 고려사항이 있습니다. 이들 CPU 같은 경우는 {{c|/proc/cpuinfo}}의 내용을 확인하여 적당한 플래그를 넣고 활성화해야합니다. 

{{Note|Check the [https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags] to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then it does not need to be separately specified; it will be turned on by using the proper <code>-march</code> setting.}}

== 최적화 자주 묻는 질문 ==

=== 근데 -funroll-loops -fomg-optimize로 성능이 더 좋아졌는데요?! ===

No, people only ''think'' they do because someone has convinced them that more flags are better. Aggressive flags will only hurt applications when used system-wide. Even the GCC [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> will make code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

사실은 이런 플래그 추가 사용이 굉장히 무모한 행위라는 점입니다. 어떤 플래그가 무슨 역할을 하는지에 대해서는 바람직한 [https://forums.gentoo.org/ 젠투 포럼]<sup style="color:#ff0077">en</sup> 과 [https://bugs.gentoo.org/ 버그질라]<sup style="color:#ff0077">en</sup> 에서 확인해보십시오. 좋을게 하나도 없습니다! 

<var>CFLAGS</var> 또는 <var>CXXFLAGS</var>에서 시스템 전체적으로 이 플래그를 사용할 필요는 없습니다. 전체적으로 사용하면 성능만 떨어뜨릴 뿐입니다. 최첨단의 고성능 시스템을 만들 것 같지만 아무 효과가 없으며, 코드를 부풀리고 잘못된 버그(INVALID) 내지는 고치지 않을 버그(WONTFIX)로 처리됩니다. 

이런 위험한 플래그는 필요하지 않습니다. '''사용하지 마십시오'''. 기본 플래그 <code>-march</code>, <code>-O</code>, <code>-pipe</code>에 집착하십시오.

=== 3 보다 높은 -O 레벨은 어떤가요? ===

어떤 사용자는 <code>-O4</code>, <code>-O9</code> 등의 플래그를 사용하여 더 나은 성능으로 끌어올렸다고 자랑하기까지 합니다만, 실제로는 3보다 큰 <code>-O</code> 레벨은 효과가 없습니다. <code>-O4</code>와 같은 <var>CFLAGS</var>를 컴파일러가 받아들이겠지만, 실제로는 이들 플래그가 하는 일은 없습니다. <code>-O3</code> 이상의 플래그는 그 이상의 최적화를 수행하지 않습니다. 

증명이 좀 더 필요한가요? [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup 소스 코드]를 시험해보십시오: 

{{CodeBox|title=-O 소스 코드|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

보신 바와 같이, 3보다 큰 값은 <code>-O3</code> 처럼 취급합니다.

=== 대상 머신이 아닌곳에서 컴파일은 어떤가요? ===

일부 독자들은 명백하게 저질인 CPU가 달린 대상 머신 이외의 머신이나 GCC 하위 아키텍처에서 컴파일하면 (자체적으로 컴파일하는 과정에 비해) 저질 최적화가 되는지 궁금해하실텐데, 간단하게 말씀드리자면 '''아닙니다'''. 컴파일한 실제 하드웨어가 어딘지, GCC가 빌드할 CHOST 값이 어떤지와는 상관 없이 <small>(<code>-march=native</code>는 제외한)</small> 비슷한 길이의 인자를 사용하며 동일한 GCC 버전을 사용하여<small>(마이너 버전은 차이가 있을지 모르겠지만)</small>, 최적화 결과는 완전히 동일합니다.

예시를 하나 들어보자면 GCC CHOST값이 ''i686-pc-linux-gnu''인 머신에 젠투를 설치했고, GCC의 CHOST값이 ''i486-linux-gnu''인 다른 컴퓨터에 [[Distcc/ko|DiscCC]] 서버를 설정했다면, 원격 컴파일러 또는 하드웨어의 하위 아키텍처가 저질이라 결과가 덜 이상적일지도 모른다는 걱정을 하지 않아도 됩니다. 결과는 각 컴파일러에 동일한 옵션을 전달(하고 <code>-march</code>  매개변수에 <code>native</code> 인자를 전달하지 않으므로)자체 빌드 결과물 만큼 최적화 처리 됩니다. 이런 경우 대상 아키텍처는 [[Distcc/ko#-march.3Dnative|DistCC와 -march=native]]에 설명한 대로 분명하게 지정해야합니다.

다른 하위 아키텍처를 대상으로 빌드한 두 GCC 버전의 동작상 유일한 차이점이 있다면, 명령줄에서 분명하게 전달하지 않을 때, GCC의 CHOST 에서 전달하는 <code>-march</code> 매개변수에 기본 인자를 생략한다는 점입니다.

=== 중복 플래그는 무엇인가요? ===

종종 다양한 <code>-O</code> 레벨로 맞춰놓은 <var>CFLAGS</var> 와 <var>CXXFLAGS</var> 값은 {{Path|/etc/portage/make.conf}}에 중복 지정되어 있습니다. 가끔은 무시하는걸로 끝나지만, 플래그를 걸러내거나 플래그를 바꾸는 일을 막아주기도 합니다. 

포티지 트리에서 대부분의 이빌드가 플래그를 걸러내거나 바꿉니다. 어떤 <code>-O</code> 레벨에 대해서는 꾸러미에서 컴파일 오류가 나거나 추가 플래그를 사용했을 경우 소스코드가 민감하게 동작하기 때문에 이렇게 처리합니다. 이빌드는 <var>CFLAGS</var>와 <var>CXXFLAGS</var> 둘 중 하나 또는 전부를 걸러내거나, <code>-O</code> 레벨을 다른 레벨로 바꿉니다. 

The [https://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] outlines where and how flag filtering/replacing works. 

다음처럼 <code>-O3</code> 같은 플래그를 각 레벨에 대해 반복해서 나열하면 <code>-O</code> 필터링을 피해살 수 있습니다: 

{{CodeBox|title=중복 CFLAGS 지정|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

그러나 '''이건 현명한 방법이 아닙니다'''. <var>CFLAGS</var>를 어떤 이유로 무시할 수 있습니다. 플래그를 가려 인식하면, 해당 플래그로 구러미를 빌드하는것이 안전하지 않음을 의미합니다. 분명하게 말해서 어떤 꾸러미에 대해 <code>-O3</code> 레벨로 플래그를 활성화하면 문제가 생길 경우, 이 레벨로 전체 시스템을 컴파일 하는게 안전''하지 않다''는 의미가 됩니다. 그러니, 꾸러미를 관리하는 개발자보다 "앞서 나가려" 하지 마십시오. "개발자를 믿으십시오". 플래그를 선별하고 대체하는건 이미 시스템 및 프로그램의 안정화 확보를 목적으로 끝냈습니다! 이빌드에 다른 플래그를 정의했다면 다른곳에 넣으려 하지 마십시오. 

허용할 수 없는 플래그로 꾸러미를 빌드하면 거의 대부분 문제 상황으로 끌려갑니다. 버그질라에 이 문제를 보고할 때면, {{Path|/etc/portage/make.conf}}에 사용한 플래그가 분명히 나타나며, 누군가는 해당 플래그를 빼고 다시 컴파일하라고 알려줄겁니다. 처음에 언급한대로 중복 플래그를 빼서 다시 컴파일하는일이 없도록 하십시오! 개발자들보다 여러분이 더 잘 알거라고 멋대로 판단하지 마십시오.

=== LDFLAGS란 무엇인가요? ===

젠투 개발자는 기본적이고 안전한 <var>LDFLAGS</var> 값을 기반 프로파일에 설정했으므로, 바꿀 필요가 없습니다.

=== 패키지별로 플래그를 사용해도 되나요? ===

{{Warning|패키지별로 플래그를 사용하면 디버그와 지원이 복잡해질 수 있습니다. 버그 보고서 작성시 사용한 기능과 바꾼 부분의 언급 여부를 확인하십시오.}}

패키지별 환경 변수 사용법(<var>CFLAGS</var> 포함)은 [[Handbook:AMD64/Portage/Advanced/ko#.EA.BE.B8.EB.9F.AC.EB.AF.B8.EB.B3.84_.ED.99.98.EA.B2.BD_.EB.B3.80.EC.88.98|젠투 핸드북, "꾸러미별 환경 변수"]]편에 설명했습니다.

== See also ==

* [[Handbook:AMD64/Installation/Stage#Configuring_compile_options|Configuring compile options]] (AMD64 Handbook)

== 자료 ==

다음 자료는 최적화에 대해 더 이해하는데 도움이 될 것입니다: 

* The [https://gcc.gnu.org/onlinedocs/ GCC online documentation] 

* <kbd>man make.conf</kbd>

* [https://en.wikipedia.org/ 위키피디아]

* [https://forums.gentoo.org/ 젠투 포럼]

== References ==

{{reflist}}

{{Migrated|originalauthors=nightmorph}}


[[Category:Compilation]]
