<languages />

{{Metadata|abstract=Данная статья поможет создавать бездисковые станции под управлением Gentoo Linux}}

Это HOWTO поможет создать и настроить бездисковые рабочие станции с Gentoo Linux.

== Введение ==

=== Об этом руководстве ===

Это руководство поможет настроить ''бездисковые'' рабочие станции основанные на дистрибутиве Gentoo Linux. Это руководство предназначено для того чтобы сделать этот процесс удобным для Linux-новичков, насколько это возможно, потому что все когда-то были новичками в какой-то момент :&#41;. В то время как опытные пользователи могут с легкостью объединить множество доступных руководств по бездисковым станциям и сетям вместе, надеемся, что это руководство сможет облегчить установку для всех заинтересованных пользователей, независимо от того, гики они или нет.

=== Что такое бездисковая машина? ===

Бездисковая машина - это компьютер без каких-либо обычных загрузочных устройств, таких как жесткие диски, дискеты, или оптические диски. Бездисковые станции загружаются по сети и им необходим сервер, который обеспечит их местом для хранения данных, как это сделал бы локальный жесткий диск. С этого момента, будем называть сервер ведущим устройством - ''master'', в то время как бездисковая машина будет ведомым устройством - ''slave''. Ведомый узел требует сетевую плату с поддержкой загрузки PXE или Etherboot; проверьте поддерживаемый список по адресу [http://www.etherboot.org Etherboot.org]. Большинство современных плат поддерживает PXE, множество встроенных в материнскую плату сетевые платы также будут работать. 

=== Перед тем как начать ===

Необходимо установить Gentoo на master-узел и иметь достаточно пространства на master-узле, чтобы хранить файловые системы slave-узлов. Также, удостоверьтесь, что один из интерфейсов подключен к интернету отдельно от подключения к локальной сети. 

== Конфигурация ведущего и ведомых компьютеров ==

=== Информация о ядрах ===

Ядро - это программа, которая располагается между аппаратным обеспечением и всеми остальными программами, которые загружены в системе. По существу, это сердце операционной системы, включающей в себя ядро. Когда компьютер загружается, BIOS выполняет инструкции, найденные в зарезервированном загрузочном пространстве жесткого диска. Эти инструкции обычно являются загрузчиком, который загружает ядро. После того, как ядро загружено, все процессы управляются им. 

For more information on kernels and kernel configuration check out the [[kernel]] article. 

=== Конфигурация ядра на ведущем компьютере ===

Ядро ведущей машины может быть как и настолько большим, так и настроенным особые нужды, но в то же время, существует несколько требуемых параметров ядра, которые необходимо выбрать. Перейдете в меню конфигурации ядра, введя: 

{{RootCmd|cd /usr/src/linux
|make menuconfig}}

Должен быть графический интерфейс, серого и синего цвета, который предлагает безопасную альтернативу редактированию файла {{Path|/usr/src/linux/.config}} вручную. Если ядро на данный момент функционирует нормально, можно сохранить текущий файл конфигурации, выйдя из графического интерфейса и введя следующую команду: 

{{RootCmd|cp .config .config_working}}

Перейдите в следующие подменю и убедитесь, что перечисленные элементы меню отмечены как встроенные в ядро - built-in (а ''не как'' модули - modular). Параметры, показанные ниже, взяты из ядра версии 2.6.10. Если используется другая версия, текст, или последовательность элементов меню может различаться. Просто убедитесь, что выбраны хотя бы те элементы, которые показаны ниже. 

{{KernelBox|title=Параметры ядра для master системы|<pre>
[*] Networking support --->
  Networking options --->
    <*> Packet socket
    <*> Unix domain sockets
    [*] TCP/IP networking
    [*]   IP: multicasting
    [ ] Network packet filtering (replaces ipchains)
  
File systems --->
  Network File Systems  --->
    <*> NFS server support
    [*]   Provide NFSv3 server support
</pre>}}

Если необходим доступ к интернету на master-узле и/или нужен безопасный межсетевой экран, убедитесь, что добавили поддержку iptables:

{{KernelBox|title=Включение поддержки iptables|<pre>
  [*] Network packet filtering (replaces ipchains)
  IP: Netfilter Configuration  --->
    <*> Connection tracking (required for masq/NAT)
    <*> IP tables support (required for filtering/masq/NAT)
</pre>
}}

If packet filtering is required, add the rest as modules later. Make sure to read the [[Security_Handbook/Firewalls|Gentoo Security Handbook Chapter about Firewalls]] on how to set this up properly. 

{{Note|Эти параметры конфигурации ядра должны быть добавлены только к параметрам конфигурации, характерным для системы, и не предназначены для того, чтобы полностью заменить собой настройки ядра.}}

После того, как ядро переконфигурировано на master-узле, его нужно собрать заново:

{{RootCmd|make && make modules_install
|cp arch/i386/boot/bzImage /boot/bzImage-master}}

Затем, добавьте запись для нового ядра в {{Path|lilo.conf}} или {{Path|grub.conf}}, в зависимости от используемого загрузчика, и сделайте новое ядро загружаемым по умолчанию. Теперь когда новый файл bzImage скопирован в загрузочный каталог, все, что требуется сделать - перезагрузить систему чтобы активировать новые параметры. 

=== Настройки ведомого ядра ===

Рекомендуется, чтобы slave ядро было собрано без модулей, так как их загрузка и настройка в случае удаленной загрузки ядра - сложный и ненужный процесс. Вдобавок, slave ядро должно быть настолько маленьким и компактным, насколько это возможно, чтобы эффективно загрузиться по сети. slave ядро будет скомпилировано в том же месте, где было сконфигурировано master. 

Во избежание путаницы и пустой траты времени, возможно, неплохой идеей является сделать резервное копирование файла конфигурации ведущего ядра вводом следующих команд: 

{{RootCmd|cp /usr/src/linux/.config /usr/src/linux/.config_master}}

The slave's kernel is now to be configured in the same fashion as the master's kernel. If a fresh configuration file is needed it can be recovered from the default {{Path|/usr/src/linux/.config}} file by typing: 

{{RootCmd|cd /usr/src/linux
|cp .config_master .config}}

Теперь, перейдите в графический интерфейс конфигурации вводом следующей команды: 

{{RootCmd|cd /usr/src/linux
|make menuconfig}}

Make sure to select the following options as built-in and ''NOT'' as kernel modules: 

{{KernelBox|title=Параметры ядра для slave|<pre>
[*] Networking support --->
  Networking options --->
    <*> Packet socket
    <*> Unix domain sockets
    [*] TCP/IP networking
    [*]   IP: multicasting
    [*]   IP: kernel level autoconfiguration
    [*]     IP: DHCP support
  
File systems --->
  Network File Systems  --->
    <*> file system support
    [*]   Provide NFSv3 client support
    [*]   Root file system on NFS
</pre>
}}

{{Note/ru|Альтернативой dhcp-серверу является настройка BOOTP сервера.}}

{{Important|Важно добавить поддержку сетевой платы в ядро (не как модуль) на нодах. Тем не менее, использование модулей, в основном, не будет проблемой для бездисковых нод.}}

Now the slave's kernel needs to be compiled. Be careful here not to overwrite or mess up the modules (if any) that have been built for the master:

{{RootCmd|cd /usr/src/linux
|make}}

Now create the directory on the master that will be used to hold slaves' files and required system files. The {{Path|/diskless}} is used but any location preferred may be chosen here. Now copy the slave's bzImage into the {{Path|/diskless}} directory: 


{{Note|If there are different architectures being used it might be useful to save each config into {{Path|.config_arch}} . Do the same with the images: save them into the {{Path|/diskless}} as {{Path|bzImage_arch}} .}}


{{RootCmd|mkdir /diskless
|cp /usr/src/linux/arch/i386/boot/bzImage /diskless}}

=== Конфигурация предварительных файловых систем для slave-узлов ===

The master and slave filesystems can be tweaked and changed a lot. Right now the only point of interest is in getting a preliminary filesystem of appropriate configuration files and mount points. First it's required to create a directory within {{Path|/diskless}} for the first slave. Each slave needs its own root file system because sharing certain system files will cause permission problems and hard crashes. These directories can be called anything the administrator deems appropriate but the author suggests using the slaves IP addresses as they are unique and not confusing. The static IP of the first slave will be, for instance, <code>192.168.1.21</code> : 

{{RootCmd|mkdir -p /diskless/192.168.1.21/etc}}

Various configuration files in {{Path|/etc}} need to be altered to work on the slave. Copy the master's {{Path|/etc}} directory onto the new slave root by typing: 

{{RootCmd|cp -r /etc/* /diskless/192.168.1.21/etc/}}

Все же, эта файловая система пока не готова, потому что ей требуются разные точки монтирования и каталоги. Чтобы их создать, введите: 

{{RootCmd|mkdir /diskless/192.168.1.21/home
|mkdir /diskless/192.168.1.21/dev
|mkdir /diskless/192.168.1.21/proc
|mkdir /diskless/192.168.1.21/tmp
|mkdir /diskless/192.168.1.21/mnt
|chmod a+w /diskless/192.168.1.21/tmp
|mkdir /diskless/192.168.1.21/mnt/.initd
|mkdir /diskless/192.168.1.21/root}}

{{RootCmd|mkdir /diskless/192.168.1.21/sys
|mkdir /diskless/192.168.1.21/var
|mkdir /diskless/192.168.1.21/var/empty
|mkdir /diskless/192.168.1.21/var/lock
|mkdir /diskless/192.168.1.21/var/log
|mkdir /diskless/192.168.1.21/var/run
|mkdir /diskless/192.168.1.21/var/spool
|mkdir /diskless/192.168.1.21/usr
|mkdir /diskless/192.168.1.21/opt
}}

Most of these "stubs" should be recognizable; stubs like {{Path|/dev}} , {{Path|/proc}} or {{Path|/sys}} will be populated when the slave starts, the others will be mounted later. The {{Path|/diskless/192.168.1.21/etc/conf.d/hostname}} file should also be changed to reflect the hostname of the slave. Binaries, libraries and other files will be populated later in this HOWTO right before attempting to boot the slave. 

Even though {{Path|/dev}} is populated by <code>udev</code> later on, the {{Path|console}} entry needs to be created. If not, the error message "unable to open initial console" will be encountered. 

{{RootCmd|mknod /diskless/192.168.1.21/dev/console c 5 1}}

== Конфигурация DHCP-сервера ==

=== Информация о DHCP-сервере ===

DHCP означает Dynamic Host Configuration Protocol (протокол динамической настройки узла). DHCP-сервер - это первый компьютер с которым будут соединяться slave-узлы при PXE-загрузке. Основной целью DHCP-сервера является назначение IP-адресов. DHCP-сервер может назначать IP-адреса, основываясь на MAC-адресах сети на основе ethernet. Как только slave-узел получит IP-адрес, DHCP-сервер сообщит этому компьютеру где можно получить его первичную файловую систему и ядро. 

=== Перед тем как начать ===

There are several things to make sure of, that they are working properly before beginning. First check the network connectivity: 

{{RootCmd|ifconfig eth0 multicast
|ifconfig -a}}

Make sure there is an ''eth0'' device running. It should look something like this: 

{{CodeBox|title=A properly working eth0 device|1=
eth0      Link encap:Ethernet  HWaddr 00:E0:83:16:2F:D6
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:26460491 errors:0 dropped:0 overruns:2 frame:0
          TX packets:32903198 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:100
          RX bytes:2483502568 (2368.4 Mb)  TX bytes:1411984950 (1346.5 Mb)
          Interrupt:18 Base address:0x1800
}}

It's important that it says ''MULTICAST'', if it doesn't then the kernel will have to be recompiled to include multicast support.

=== Установка DHCP-сервера ===

If the network does not already have a DHCP server installed, one needs to be installed now: 

{{Emerge|dhcp}}

If the network already has a DHCP server installed, edit the configuration file to get the PXE boot to function correctly. 

=== Конфигурация DHCP-сервера ===

There is only one configuration file that needs to be edited before starting the DHCP server: {{Path|/etc/dhcp/dhcpd.conf}}. Copy and edit the provided sample file: 

{{RootCmd|cp /etc/dhcp/dhcpd.conf.sample /etc/dhcp/dhcpd.conf
|nano -w /etc/dhcp/dhcpd.conf}}

Основная схема этого файла задана в виде отступов и выглядит следующим образом: 

{{CodeBox|title=Образец схемы файла {{Path|dhcpd.conf}}|1=
# глобальные параметры
ddns-update-style none;
shared-network LOCAL-NET {
  # параметры shared network
  subnet 192.168.1.0 netmask 255.255.255.0 {
    # параметры subnet network
    host slave{
        # параметры, относящиеся к хосту
    }
    group {
        # параметры, относящиеся к группе
    }
  }
}
}}

The <code>shared-network</code> block is optional and should be used for IPs that are required to be assigned that belong to the same network topology. At least one <code>subnet</code> must be declared and the optional <code>group</code> block allows options to be grouped between items. A good example of {{Path|dhcpd.conf}} looks like this: 

{{CodeBox|title=Образец файла {{Path|dhcpd.conf}}|1=
#
# Образец файла dhcpd.conf для бездисковых клиентов
#
  
# Отключение динамической DNS
ddns-update-style none;
  
# Предположим, достаточно одного шлюза по умолчанию
option routers 192.168.1.1;
  
# Предоставление DNS-информации клиентам
option domain-name-servers 192.168.1.1;
option domain-name "mydomain.com";
  
# Указание используемого TFTP-сервера
next-server 192.168.1.1;
  
# Объявление вендор-зависимого буфера параметров для клиентов PXE:
# Code 1: Групповой (multicast) IP-адрес загрузочного файлового сервера
# Code 2: UDP-порт, отслеживаемый клиентом для MTFTP-ответов
# Code 3: UDP-порт, используемый MTFTP-серверами для прослушивания MTFTP-запросов
# Code 4: Количество секунд, в течение которого клиент должен ожидать каких-либо действий,
#         перед тем, как начать новую MTFTP-передачу
# Code 5: Количество секунд, в течение которого клиент должен ожидать, перед перезапуском
#         MTFTP-передачи
  
option space PXE;
option PXE.mtftp-ip               code 1 = ip-address;
option PXE.mtftp-cport            code 2 = unsigned integer 16;
option PXE.mtftp-sport            code 3 = unsigned integer 16;
option PXE.mtftp-tmout            code 4 = unsigned integer 8;
option PXE.mtftp-delay            code 5 = unsigned integer 8;
option PXE.discovery-control      code 6 = unsigned integer 8;
option PXE.discovery-mcast-addr   code 7 = ip-address;
  
# Определите подсеть для размещения бездисковых рабочих станций
subnet 192.168.1.0 netmask 255.255.255.0 {
  
  # Предоставление PXE-клиентам необходимой информации
  class "pxeclient" {
    match if substring(option vendor-class-identifier, 0, 9) = "PXEClient";
    vendor-option-space PXE;
  
    # Должен быть настроен по меньшей мере один из вендор-зависимых PXE-параметров
    # для того, чтобы загрузочные ПЗУ клиента - boot ROMs - располагали информацией, о том, что этот сервер PXE-совместим.
    # Мы устанавливаем MCAST IP-адрес в значение 0.0.0.0 чтобы сообщить boot ROM
    # что мы не можем предоставить групповой TFTP.
  
    option PXE.mtftp-ip 0.0.0.0;
  
    # Это имя файла, который должны загрузить загрузочные ПЗУ - boot ROMs.
    filename "pxelinux.0";
  }
  
  # Предоставьте необходимую информацию Etherboot-клиентам
  class "etherboot" {
    match if substring(option vendor-class-identifier, 0, 9) = "Etherboot";
    filename "vmlinuz_arch";
  }
  
  # Добавьте одно объявление хоста для каждой бездисковой рабочей станции
  host slave21 {
    hardware ethernet 00:02:A5:04:3B:66;
    fixed-address 192.168.1.21;
  }
}
}}

{{Note|There is nothing prohibiting the use of both PXE boot and Etherboot together. The above Code Listing is merely an example; if there are issues, please consult the DHCPd documentation.}}

The IP address after <code>next-server</code> will be asked for the specified <code>filename</code>. This IP address should be the IP of the tftp server, usually the same as the master's IP address. The <code>filename</code> is relative to the {{Path|/diskless}} directory (this is due to the tftp server specific options which will be covered later). Inside the <code>host</code> block, the <code>hardware ethernet</code> option specifies a MAC address, and <code>fixed-address</code> assigns a fixed IP address to that particular MAC address. There is a pretty good man page on {{Path|dhcpd.conf}} with options that are beyond the scope of this HOWTO. The man page can be read by typing: 

{{Cmd|man dhcpd.conf}}

=== Запуск DHCP-сервера ===

Before starting the dhcp initialization script edit the {{Path|/etc/conf.d/dhcp}} file so that it looks something like this: 

{{CodeBox|title=Sample {{Path|/etc/conf.d/dhcp}}|lang=bash|1=
IFACE="eth0"
# Добавьте любые индивидуальные настройки по необходимости
}}

Переменная <code>IFACE</code> - это устройство, на котором необходимо запустить DHCP-сервер, в этом случае <code>eth0</code>. Добавление большего количества аргументов к переменной <code>IFACE</code> может быть полезно в случае сложной топологии сети с большим количеством Ethernet-адаптеров. Чтобы запустить dhcp-сервер, введите: 

{{RootCmd|/etc/init.d/dhcpd start}}

Чтобы добавить dhcp-сервер к сценариям иницализации, введите: 

{{RootCmd|rc-update add dhcpd default}}

=== Устранение неполадок, связанных с DHCP-сервером ===

Чтобы проверить загружается ли узел сети, посмотрите сообщения в {{Path|/var/log/messages}} . Если узел загружается успешно, файл {{Path|messages}} должен содержать внизу несколько строчек, выглядящих следующим образом: 

{{CodeBox|title=Образец записей лог-файла, созданных dhcp|<pre>
DHCPDISCOVER from 00:00:00:00:00:00 via eth0
DHCPOFFER on 192.168.1.21 to 00:00:00:00:00:00 via eth0
DHCPREQUEST for 192.168.1.21 from 00:00:00:00:00:00 via eth0
DHCPACK on 192.168.1.21 to 00:00:00:00:00:00 via eth0
</pre>
}}

{{Note|Этот лог-файл может также помочь в обнаружении MAC-адресов slave-узлов.}}

Если встречается следующее сообщение, это возможно означает, что с файлом конфигурации что-то не то, но в то же время DHCP сервер передает данные верно. 

{{CodeBox|title=Образец ошибки сервера dhpc|1=
no free leases on subnet LOCAL-NET
}}

Каждый раз, после изменения файла конфигурации, нужно перезапускать DHCP-сервер. Чтобы перезапустить сервер, введите: 

{{RootCmd|/etc/init.d/dhcpd restart}}

== Настройка TFTP-сервера и PXE загрузчика Linux и/или Etherboot ==

=== Информация о TFTP-сервере ===

TFTP означает простой протокол передачи файлов (англ. Trivial File Transfer Protocol). TFTP-сервер предоставит ведомым компьютерам ядра и первичную файловую систему для начальной загрузки. Все ядра и файловые системы ведомых машин будут храниться на TFTP-сервере, поэтому, хорошей идеей будет сделать master-узел TFTP-сервером. 

=== Установка TFTP-сервера ===

Высоко рекомендуемый tftp-сервер доступен в качестве пакета tftp-hpa. Этот tftp-сервер написан автором SYSLINUX и очень хорошо работает с pxelinux. Чтобы его установить, просто введите: 

{{Emerge|tftp-hpa}}

=== Настройка TFTP-сервера ===

Отредактируйте файл {{Path|/etc/conf.d/in.tftpd}}. Необходимо указать каталог tftproot в <code>INTFTPD_PATH</code> и также, любые параметры командной строки в <code>INTFTPD_OPTS</code>. Это должно выглядеть следующим образом: 

{{FileBox|filename=Образец файла /etc/conf.d/in.tftpd|1=
INTFTPD_PATH="/diskless"
INTFTPD_OPTS="-l -v -s ${INTFTPD_PATH}"
}}

Параметр <code>-l</code> обозначает то, что сервер слушает в автономном режиме (stand alone mode), поэтому нет необходимости запускать inetd. <code>-v</code> означает, что уровень вывода сообщений log/error должен быть подробный. <code>-s /diskless</code> указывает на корневой каталог tftp-сервера.

=== Запуск TFTP-сервера ===

Чтобы запустить tftp-сервер, введите: 

{{RootCmd|/etc/init.d/in.tftpd start}}

Эта команда должна запустить tftp-сервер с параметрами, которые указаны в {{Path|/etc/conf.d/in.tftpd}}. Если нужно, чтобы этот сервер автоматически запускался во время загрузки, наберите: 

{{RootCmd|rc-update add in.tftpd default}}

=== Информация о PXELINUX ===

Этот раздел не требуется если используется только Etherboot. PXELINUX — это сетевой загрузчик, эквивалентный LILO или GRUB, который обслуживается через TFTP. По существу, это небольшой набор инструкций, который сообщает клиенту где разместить его ядро и временную файловую систему и разрешает различные параметры ядра. 

=== Перед началом ===

Now the file pxelinux.0 is required, which comes in the SYSLINUX package by H. Peter Anvin. This package can be installed by typing: 

{{Emerge|syslinux}}

=== Настройка PXELINUX ===

{{Note/ru|Это не требуется для Etherboot}}

Before starting the tftp server pxelinux needs to be set up. First copy the pxelinux binary into the {{Path|/diskless}} directory: 

{{RootCmd|cp /usr/share/syslinux/pxelinux.0 /diskless
|mkdir /diskless/pxelinux.cfg
|touch /diskless/pxelinux.cfg/default}}

Это создаст файл конфигурации загрузчика по умолчанию. Двоичный файл {{Path|pxelinux.0}} просматривает каталог {{Path|pxelinux.cfg}} в поисках файла с таким же именем, как и IP-адрес клиента в шестнадцатеричной системе. Если он не находит этот файл, он убирает самую правую цифру из имени файла и продолжает поиск, пока цифры не закончатся. Версии syslinux 2.05 и более поздние сперва выполнят поиск файла с таким же именем, как и MAC-адрес. Если таких файлов не найдено, начинается поиск по алгоритму, описанному выше. Если ничего не найдено, используется файл {{Path|default}} . 

{{CodeBox|title=Файлы, которые ищет PXE в каталоге {{Path|pxelinux.cfg/}}, по порядку|1=
## (01 в начале означает Ethernet, следующие байты соответствуют MAC-адресу slave-узла)
01-00-40-63-c2-ca-c9
  
## (Assigned IP in hexadecimal)
C0A80115
C0A8011
C0A801
C0A80
C0A8
C0A
C0
C
  
default
}}

{{Note/ru|Все буквы являются строчными.}}

Давайте начнем с файла {{Path|default}}: 

{{CodeBox|title=Образец файла {{Path|pxelinux.cfg/default}}|1=
DEFAULT gentoo
LABEL gentoo
LINUX /bzImage
APPEND ip=dhcp root=/dev/nfs nfsroot=192.168.1.1:/diskless/192.168.1.21
}}

The <code>DEFAULT</code> tag directs pxelinux to the kernel bzImage that was compiled earlier. The <code>APPEND</code> tag appends kernel initialisation options. Since the slave kernel was compiled with <code>NFS_ROOT_SUPPORT</code> , the nfsroot will be specified here. The first IP is the master's IP and the second IP is the directory that was created in {{Path|/diskless}} to store the slave's initial filesystem.

=== Информация об Etherboot ===

{{Note|Это не требуется, если используется PXE boot.}}

Etherboot boots network boot images from a TFTP server. As the PXE this is equivalent to LILO or GRUB. The <code>mknbi</code> utility enables the creation of different images using different options. 

=== Перед тем как начать ===

The <code>mknbi</code> (utility for making tagged kernel images useful for netbooting) package is needed to create the Etherboot images. This tool will create a preconfigured kernel image from the original kernel. This contains the boot options as shown further down. 

{{Emerge|mknbi}}

=== Настройка Etherboot ===

In this section a simple etherboot image will be created. As the dhcp server gives out the clients root-path in the "option root-path" dhcp.conf, this does not have to be included here. More details can be found in the mknbi manual. 

{{Cmd|man mknbi}}

Создание загрузочных образов. Это создаст загружаемый образ системы в формате ELF, способный передать ядру dhcp и путь к корневому каталогу. Это также заставит ядро просмотреть сеть в поисках dhcp-сервера. 

{{RootCmd|mkelf-linux -ip{{=}}dhcp /diskless/bzImage > /diskless/vmlinuz }}

{{Note|For the arch specific images <code>bzImage_arch</code> and <code>vmlinuz_arch</code> have to be typed.}}

=== Устранение неполадок в процессе сетевой загрузки ===

There are a few things that can be done to debug the network boot process. Primarily a tool called <code>tcpdump</code> can be used. To install <code>tcpdump</code> type: 

{{Emerge|tcpdump}}

Now various network traffic can be listened to, to make sure the client/server interactions are functioning. If something isn't working there are a few things that could be checked. First make sure that the client/server is physically connected properly and that the networking cables are not damaged. If the client/server is not receiving requests on a particular port make sure that there is no firewall interference. To listen to interaction between two computers type: 

{{RootCmd|tcpdump host client_ip and server_ip}}

The <code>tcpdump</code> command can also be configured to listen on particular port such as the tftp port by typing: 

{{RootCmd|tcpdump port 69}}

A common error that might be received is: "PXE-E32: TFTP open time-out". This is probably due to firewall issues. If <code>TCPwrappers</code> is being used, it might be worth checking {{Path|/etc/hosts.allow}} and {{Path|etc/hosts.deny}} and make sure that they are configured properly. The client should be allowed to connect to the server.

== Конфигурация NFS-сервера ==

=== Информация об NFS-сервере ===

NFS stands for Network File System. The NFS server will be used to serve directories to the slave. This part can be somewhat personalized later, but right now all that is wanted is a preliminary slave node to boot diskless. 

=== Информация о Portmapper ===

Различные клиент-серверные службы не слушают отдельный порт, но, вместо этого, полагаются на RPCs (Remote Procedure Calls - удаленный вызов процедур). Когда сервис инициализируется, он прослушивает случайный порт, и затем регистрирует этот порт с помощью утилиты Portmapper. NFS полагается на RPCs и, таким образом, требует того, чтобы Portmapper был запущен перед ее запуском. 

=== Перед началом ===

The NFS Server needs kernel level support so if the kernel does not have this, the master's kernel needs to be recompiled. To double check the master's kernel configuration type: 

{{RootCmd|grep NFS /usr/src/linux/.config_master}}

The output should look something like this if the kernel has been properly configured: 

{{KernelBox|title=Proper NFS specific options in the master's kernel configuration|<pre>
CONFIG_PACKET=y
# CONFIG_PACKET_MMAP is not set
# CONFIG_NETFILTER is not set
CONFIG_NFS_FS=y
CONFIG_NFS_V3=y
# CONFIG_NFS_V4 is not set
# CONFIG_NFS_DIRECTIO is not set
CONFIG_NFSD=y
CONFIG_NFSD_V3=y
# CONFIG_NFSD_V4 is not set
# CONFIG_NFSD_TCP is not set
</pre>
}}

=== Установка NFS-сервера ===

Пакет NFS может быть установлен с помощью системы Portage, посредством ввода: 

{{Emerge|nfs-utils}}

Этот пакет установит утилиту для проброса портов (portmapping utility), nfs-сервер, и утилиты nfs-клиентов, а также автоматически обработает зависимости инициализации. 

== Настройка NFS-сервера ==

There are three major configuration files that will have to be edited: 

{{CodeBox|title=Nfs configuration files|1=
/etc/exports
/diskless/192.168.1.21/etc/fstab
/etc/conf.d/nfs
}}

Файл {{Path|/etc/exports}} указывает как, кому и что можно экспортировать через NFS. Файл fstab slave-узла будет изменен таким образом, чтобы было можно примонтировать файловые системы NFS, экспортируемые master-узлом. 

Обычный файл {{Path|/etc/exports}} для master-узла должен выглядеть следующим образом: 

{{FileBox|filename=/etc/exports|title=master exports file|1=
# one line like this for each slave
/diskless/192.168.1.21   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
# common to all slaves
/opt   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/usr   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/home  192.168.1.0/24(sync,rw,no_root_squash,no_all_squash)
# if you want to have a shared log
/var/log   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
}}

Первое поле обозначает каталог для экспорта, а следующее за ним поле указывает, кому и как надо передать содержащуюся в нем информацию. Это поле может быть поделено на две части: кому разрешено монтировать этот отдельный каталог, и что монтирующий этот каталог клиент может делать с файловой системой: <code>ro</code> - доступ только для записи, <code>rw</code> - для чтения/записи; параметры <code>no_root_squash</code> и <code>no_all_squash</code> являются важными для бездисковых клиентов, которые осуществляют запись на диск, так чтобы они не были "сброшены" механизмом ограничения прав доступа root squash при I/O запросах. Файл fstab на ведомом узле, {{Path|/diskless/192.168.1.21/etc/fstab}} , должен выглядеть так: 

{{CodeBox|title=Sample slave {{Path|fstab}}|1=
# these entries are essential
master:/diskless/192.168.1.21   /         nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
master:/opt                     /opt      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/usr                     /usr      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/home                    /home     nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
none                            /proc     proc    defaults                                     0 0
# useful but superfluous
master:/var/log                 /var/log  nfs     hard,intr,rw                                 0 0
}}

In this example, ''master'' is just the hostname of the master but it could easily be the IP of the master. The first field indicates the directory to be mounted and the second field indicates where. The third field describes the filesystem and should be NFS for any NFS mounted directory. The fourth field indicates various options that will be used in the mounting process (see mount(1) for info on mount options). Some people have had difficulties with soft mount points so here they are made hard mounts, a look into various {{Path|/etc/fstab}} options should be done to make the cluster more efficient. 

Последний файл, который необходимо отредактировать — это файл {{Path|/etc/conf.d/nfs}}, который описывает несколько параметров для nfs при инициализации. Он выглядит так: 

{{CodeBox|title=Sample master {{Path|/etc/conf.d/nfs}}|1=
# Config file for /etc/init.d/nfs
  
# Number of servers to be started up by default
RPCNFSDCOUNT=8
  
# Options to pass to rpc.mountd
RPCMOUNTDOPTS=""
}}

The <code>RPCNFSDCOUNT</code> should be changed to the number of diskless nodes on the network. 

=== Запуск NFS-сервера ===

The nfs server should be started with its init script located in {{Path|/etc/init.d}} by typing: 

{{RootCmd|/etc/init.d/nfs start}}

If this script is to be started every time the system boots simply type: 

{{RootCmd|rc-update add nfs default}}

== Завершение построения файловой системы на slave-узлах ==

=== Копирование недостающих файлов ===

Now the slave's file system will be made in sync with the master's and provide the necessary binaries while still preserving slave specific files. 

{{RootCmd|rsync -avz /bin /diskless/192.168.1.21
|rsync -avz /sbin /diskless/192.168.1.21
|rsync -avz /lib /diskless/192.168.1.21}}

{{Note/ru|Причиной, по которой используется команда rsync -avz вместо cp, является сохранение символьных ссылок и разрешений.}}

=== Настройки сети на бездисковых машинах ===

In order to prevent the networking initscript from killing the connection to the NFS server, an option needs to be added to {{Path|/etc/conf.d/net}} on the diskless client's filesystem. 

{{CodeBox|title=Editing {{Path|/etc/conf.d/net}}|1=
config_eth0=( "noop" )
}}

{{Note/ru|Чтобы получить больше информации, пожалуйста, прочитайте {{Path|/usr/share/doc/openrc-*/net.example.bz2}} .}}

=== Сценарии инициализации ===

Init scripts for slaves are located under {{Path|/diskless/192.168.1.21/etc/runlevels}} for services needed on the diskless nodes. Each slave can be set up and customized here, it all depends on what each slave is meant to do. 

{{Warning|Do not use the <code>rc-update</code> program to add or remove scripts from the slave runlevels when logged on to the master. This would change the master runlevels. The links need to be manually created or by logging into the slave nodes using ssh or connecting a screen and keyboard to the slave.}}

{{CodeBox|title=Typical slave runlevels|1=
/diskless/192.168.1.21/etc/runlevels/:
total 16
drwxr-xr-x    2 root     root         4096 2003-11-09 15:27 boot
drwxr-xr-x    2 root     root         4096 2003-10-01 21:10 default
drwxr-xr-x    2 root     root         4096 2003-03-13 19:05 nonetwork
drwxr-xr-x    2 root     root         4096 2003-02-23 12:26 single
  
/diskless/192.168.1.21/etc/runlevels/boot:
total 0
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 bootmisc -> /etc/init.d/bootmisc
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 checkfs -> /etc/init.d/checkfs
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 domainname -> /etc/init.d/domainname
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 hostname -> /etc/init.d/hostname
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 localmount -> /etc/init.d/localmount
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 modules -> /etc/init.d/modules
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 net.lo -> /etc/init.d/net.lo
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 netmount -> /etc/init.d/netmount
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 rmnologin -> /etc/init.d/rmnologin
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 urandom -> /etc/init.d/urandom
  
/diskless/192.168.1.21/etc/runlevels/default:
total 0
lrwxrwxrwx    1 root     root           23 2003-10-18 17:28 consolefont -> /etc/init.d/consolefont
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 distccd -> /etc/init.d/distccd
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 keymaps -> /etc/init.d/keymaps
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 sshd -> /etc/init.d/sshd
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 syslog-ng -> /etc/init.d/syslog-ng
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 vixie-cron -> /etc/init.d/vixie-cron
  
/diskless/192.168.1.21/etc/runlevels/nonetwork:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
  
/diskless/192.168.1.21/etc/runlevels/single:
total 0
}}

Now is a good time to boot the slave and cross some fingers. It works? Congratulations, you are now the proud owner of (a) diskless node(s).

{{Migrated|originalauthors=Michael Andrews, Kristian Jerpetjoen, Xavier Neys}}
