<languages />


{{Metadata|abstract=이 설명서는 대안 젠투 설치 방법을 담아둔 저장소를 의도하며, 특별한 설치 방법은 CD-ROM이 빠져있거나 CD로 부팅할 수 있는 컴퓨터와 같은 환경이 필요합니다.}}

이 설명서는 대안 젠투 설치 방법을 담아둔 저장소를 의도하며, 특별한 설치 방법은 CD-ROM이 빠져있거나 CD로 부팅할 수 있는 컴퓨터와 같은 환경이 필요합니다.

== 이 문서 정보 ==

CD에서 부팅하는 표준 설치 방식으로 진행할 수 없을 경우(또는 이 방식이 싫다면)의 설명서를 이제 여기에 준비했습니다. 이 문서는 젠투 리눅스를 다른 방법으로 설치하는 방법을 보관해둔 내용을 필요한 이들에게 제공합니다. 또는 이 방식이 좋다면 유별난 설치 방법이 될 수 있습니다. 쓸만한 설치 방법을 찾았거나 젠투를 설치하는 재밌는 방법을 발견했다면, 망설이지 말고  [https://bugs.gentoo.org/ Bugzilla]에 알려주십시오.

== 스마트 부트매니저로 설치 CD 부팅 ==

[http://btmgr.sourceforge.net/download.html http://btmgr.sourceforge.net/download.html]에서 스마트 부트매니저를 다운로드하십시오. 리눅스 소스 코드 또는 바이너리 형식, 윈도우 .exe 버전이 있으며, 여러가지 언어 꾸러미도 존재합니다. 그러나 지금 준비한 방식은 최신 버전의 NASM으로 소스코드를 컴파일할 수 없으므로 바이너리 형식을 사용하겠습니다. 

소스 코드 꾸러미를 컴파일 하거나 바이너리를 취할 수 있습니다. 아래에서 보시는 바와 같이 부팅 가능한 플로피를 만드는 동안 활용할 수 있는 몇가지 선택지가 있습니다. 

{{CodeBox|title=Smart BootManager 옵션|1=
sbminst [-t theme] [-d drv] [-b backup_file] [-u backup_file]
  
   -t theme       select the theme to be used, in which the theme could be:
                    us = English theme       de = German theme
                    hu = Hungarian theme     zh = Chinese theme
                    ru = Russian theme       cz = Czech theme
                    es = Spanish theme       fr = French theme
                    pt = Portuguese theme
  
   -d drv         set the drive that you want to install Smart BootManager on;
                  for Linux:
                    /dev/fd0 is the first floppy driver,
                    /dev/hda is the first IDE harddisk driver.
                    /dev/sda is the first SCSI harddisk driver.
                  for DOS:
                    0   is the first floppy drive
                    128 is the first hard drive;
  
   -c             disable CD-ROM booting feature;
  
   -b backup_file backup the data that will be overwritten for
                  future uninstallation;
  
   -u backup_file uninstall Smart BootManager, should be used alone;
  
   -y             do not ask any question or warning.
}}

<code>sbminst</code> 명령으로 부팅 플로피를 만드십시오:

{{RootCmd|sbminst -t us  -d /dev/fd0}}

{{Note|{{Path|fd0}}과 이름이 다르다면 이 대신 사용중인 플로피 장치 이름으로 바꾸십시오.}}

이제 컴퓨터의 플로피 드라이브에 플로피 디스크를 넣고 마찬가지로 CD-ROM에 설치 CD를 넣은 다음 컴퓨터를 부팅하십시오. 

Smart BootManager 대화 상자를 마주할 것입니다. CD-ROM과 부팅할 설치 CD를 선택하고 엔터키를 누르십시오. 부팅이 끝나면 표준 설치 과정을 진행합니다. 

Smart BootManager에 대한 더 많은 도움말은 [http://btmgr.sourceforge.net/ http://btmgr.sourceforge.net/]에서 찾아보십시오.

== 비 젠투 LiveCD에서 설치 ==

=== 도입부 ===

{{Important|The Gentoo developers cannot support you if something goes wrong with a non-Gentoo LiveCD, as there's no way to fix, troubleshoot, or document every quirk of every LiveCD out there. Only Gentoo LiveCDs are officially supported. If you run into problems with alternative installation media, please visit the [https://forums.gentoo.org/ Gentoo Forums] for community help.}}

It is possible to boot some other LiveCD besides the Gentoo-provided CDs. This will give you a functional environment to use while you're compiling and installing Gentoo. The instructions provided here should work in principle with just about any other LiveCD. 

There are too many LiveCDs out there to [http://distrowatch.com/search.php list], but you might try [http://www.knoppix.org/ Knoppix]. It provides a full graphical desktop, with office applications, web browsers, and games to keep you busy. Knoppix is only available for x86 users, so depending on your needs you may need to find a different LiveCD. 

{{Warning|Be aware that if you save anything in your LiveCD's home directory while waiting for your Gentoo system to install, it will not be available when you reboot into Gentoo. Be sure to save important files on the hard disk or on some other computer!}}

=== 설치 절차 ===

LiveCD로 부팅하십시오. 터미널을 열고 <kbd>su -</kbd>를 실행하여 암호를 바꿀 수 있게 하십시오. CD의 루트 암호를 바꿀 수 있습니다. 이제 젠투를 원격으로 설치할 때 활용할 원격 로그인을 목적으로 sshd 데몬을 설정할 수 있습니다. 다음, {{Path|/mnt/gentoo}} 마운트 지점을 만들어야합니다. 

{{RootCmd|mkdir /mnt/gentoo}}

이 시점에서 [[Handbook:AMD64/Installation/Disks/ko|디스크 준비하기]]에 있는 표준 설치 문서를 따라할 수 있습니다. proc 시스템 마운트를 요청할 때, 대신 다음 명령을 실행하십시오: 

{{RootCmd|mount -o bind /proc /mnt/gentoo/proc}}

[[Handbook:AMD64/Installation/Stage/ko#.EC.8A.A4.ED.85.8C.EC.9D.B4.EC.A7.80_.ED.83.80.EB.A5.B4.EB.B3.BC_.EC.95.95.EC.B6.95_.ED.95.B4.EC.A0.9C|스테이지 타르볼 압축 해제]]에서 스테이지 타르볼을 압축 해제할 준비가 띁나면, 압축 해제한 스테이지에 강제할 적당한 그룹 ID를 확인하기 위해 다른 <tt>tar</tt> 명령을 사용해야합니다: 

{{RootCmd|tar --numeric-owner -xvjpf stage3-*.tar.bz2}}

우분투를 사용한다면, {{Path|/dev/shm}}은 {{Path|/run/shm}}의 심볼릭 링크임을 참고하십시오. (chroot한 경로에서) 이 위치를 바인딩하거나 tmpfs를 만들어야합니다. chroot를 실행하기 전에:

{{RootCmd|mount --rbind /run/shm /mnt/gentoo/run/shm}}

This is to avoid {{Bug|496328}} where Python sees <code>sem_open()</code> as broken (due to lack of {{Path|/dev/shm}}) and Portage seeing that as an error (technically Python configuration would continue and build assuming <code>POSIX_SEMAPHORES_NOT_ENABLED</code> but this would lead to a very undesired Python build).

Once you're ready to chroot into your unpacked stage in [[Handbook:AMD64/Installation/Base|Installing Base System]], you will need to use a different chroot command sequence. This ensures that your environment variables are properly setup. 

{{Note|Some LiveCDs use a funny environment setup, hence the <code>env -i</code> option for
cleaning it up to a reasonable state.}}

{{RootCmd|chroot /mnt/gentoo /bin/env -i TERM{{=}}$TERM /bin/bash
|env-update
|source /etc/profile
|export PS1{{=}}"(chroot) $PS1"}}

Finally, know that some Portage FEATURES may not work in your LiveCD. Especially watch out for <code>userpriv</code> and <code>usersandbox</code>. If you find yourself getting errors, it might be wise to disable some or all of the optional FEATURES.

== PXE 및 LiveCD의 kernel/initrd/squashfs를 활용한 무 디스크 설치 ==

This method is easier to configure than PXE boot based on iSCSI or NFS. Multiple machines can boot from the same set of images distributed via TFTP and can be easily extended to also work over HTTP or other protocol.

Some other distributions including Fedora already distribute images needed to bootstrap a live or installation CD but with Gentoo it's necessary to (1) extract kernel, initrd and [[SquashFS|squashfs]] from the live CD, (2) patch initrd contents and (3) merge squashfs into initrd. Only then it is possible to configure a PXE based boot loader that will load the images and boot into a live system.

Save the following script and make sure it is executable and in <code>$PATH</code> or follow its steps manually.


{{CodeBox|title=gentoo-pxe-boot|<nowiki>
#!/bin/bash -xe

tftproot="$1"
image="$2"
tmp="./tmp"

test -z "$tftproot" -o -z "$image" && echo "Usage: $0 <tftproot> <gentoo-iso>" >&2 && exit 1
test -e "$tmp" && echo "Temporary path '$tmp' already exists." >&2 && exit 1

iso="$tmp/iso"
initrd="$tmp/initrd.dir"

# prepare directories
mkdir -p "$tmp" "$iso" "$initrd/mnt/cdrom"

# extract files from ISO image
mount -o ro,loop "$image" "$iso"
cp "$iso"/{image.squashfs,isolinux/gentoo,isolinux/gentoo.igz} "$tmp"
umount "$iso"

# rename kernel
mv "$tmp/gentoo" "$tmp/kernel"

# patch initramfs and add squashfs to it
xz -dc "$tmp/gentoo.igz" | ( cd "$initrd" && cpio -idv )
patch -d "$initrd" -p0 <<'EOF'
--- init.orig	2012-05-21 16:14:35.000000000 +0400
+++ init	2012-05-21 18:14:43.000000000 +0400
@@ -368,10 +368,10 @@
 		[ ! -e "${NEW_ROOT}/dev/tty1" ] && mknod "${NEW_ROOT}/dev/tty1" c 4 1
 	fi
 
-	if [ "${REAL_ROOT}" != "/dev/nfs" ] && [ "${LOOPTYPE}" != "sgimips" ]
-	then
-		bootstrapCD
-	fi
+#	if [ "${REAL_ROOT}" != "/dev/nfs" ] && [ "${LOOPTYPE}" != "sgimips" ]
+#	then
+#		bootstrapCD
+#	fi
 
 	if [ "${REAL_ROOT}" = '' ]
 	then
@@ -456,7 +456,7 @@
 		else
 			bad_msg "Block device ${REAL_ROOT} is not a valid root device..."
 			REAL_ROOT=""
-			got_good_root=0
+			got_good_root=1
 		fi
 	done
 
@@ -520,7 +520,7 @@
 	[ -z "${LOOP}" ] && find_loop
 	[ -z "${LOOPTYPE}" ] && find_looptype
 
-	cache_cd_contents
+	#cache_cd_contents
 
 	# If encrypted, find key and mount, otherwise mount as usual
 	if [ -n "${CRYPT_ROOT}" ]
EOF
cp "$tmp/image.squashfs" "$initrd/mnt/cdrom"
( cd "$initrd" && find . -print | cpio -o -H newc | gzip -9 -c - ) > "$tmp/initrd"

# prepare boot data
grub2-mknetdir -v --net-directory="$tftproot"
cat > "$tftproot/boot/grub/grub.cfg" <<'EOF'
menuentry "Gentoo Live" {
    linux /boot/kernel root=/dev/ram0 init=/linuxrc loop=/image.squashfs looptype=squashfs cdroot=1 real_root=/
    initrd /boot/initrd
}
EOF
cp "$tmp"/{kernel,initrd} "$tftproot/boot"

# cleanup
rm -rf "$tmp"
</nowiki>}}


Download <code>install-amd64-minimal-20141204.iso</code> (or try with the current version if it differs). Install {{Package|net-ftp/tftp-hpa}}, make sure it serves <code>/tftproot</code> and start it.

적당한 매개 변수를 넣어 스크립트를 실행하십시오.

{{RootCmd|gentoo-pxe-boot /tftproot install-amd64-minimal-20141204.iso}}

Now your tftp boot service is ready and you need to configure your DHCP
service. You can set up DHCP server on the same machine and make sure
booted machines are connected to it, or you can just tweak the configuration
of your existing router.

Example configuration for OpenWRT dhcp service follows:

{{CodeBox|title=/etc/config/dhcp|
config boot linux                   
        option filename boot/grub/i386-pc/core.0
        option servername boot
        option serveraddress 84.246.161.86
}}

== Diskless install using PXE boot and NFS ==

=== 요구 사항 ===

PXE (Preboot eXecution Environment) is a method for booting computers over a PXE-capable network interface (and using a PXE-supporting BIOS). It is also supported as a boot method from block devices (like CDs or USBs) in case the system does not support PXE boot from the network interface or BIOS. In such cases, a minimal boot environment mimics the PXE supporting network card (see also [http://etherboot.org Etherboot/gPXE]). 

=== 서버 베이스 설정 ===

Create directories: The first thing to do is to create the directories where your diskless system will be stored. Create a directory called {{Path|/diskless}} which houses a directory for each diskless client. For the rest of this howto we'll be working on the client 'eta'. 

{{RootCmd|mkdir /diskless
|mkdir /diskless/eta
}}

DHCP and TFTP setup: The client will get boot informations using DHCP and download all the required files using TFTP. 

For dhcpd, just run <code>emerge dhcp</code> (or any other DHCP server of your choice). Make sure that the correct interface is selected in {{Path|/etc/conf.d/dhcpd}}, and configure it for your basic needs. Then, add the following on {{Path|/etc/dhcp/dhcpd.conf}}. 

{{Note|This provides a static IP address for the client and the path of a PXE boot image, here {{Path|pxegrub}}. You have to replace the MAC address of the ethernet card of the client and the directory where you will put the client files with the one you use.}}

{{FileBox|filename=dhcpd.conf|title=|lang=bash|1=
option option-150 code 150 = text ;
ddns-update-style none ;
host eta {
hardware ethernet 00:00:00:00:00:00;
fixed-address ip.add.re.ss;
option option-150 "/eta/boot/grub.lst";
filename "/eta/boot/pxegrub";
}
}}

Next you'll need to configure your interface in {{Path|/etc/conf.d/net}} so that it doesn't get cleared at bootup. See {{Path|/usr/share/doc/openrc-*/net.example.bz2}} for more information. 

{{FileBox|filename=/etc/conf.d/net|title=부팅시 인터페이스(예제에서는 eth0)를 다시 설정하지 않도록 확인|lang=bash|1=
config_eth0=( "noop" )
}}

TFTP에서는 {{Package|net-ftp/tftp-hpa}}를 이머지하십시오. {{Path|/etc/conf.d/in.tftpd}}에 다음 설정을 넣으십시오. 

{{FileBox|filename=in.tftpd|title=|lang=bash|1=
INTFTPD_PATH="/diskless"
INTFTPD_USER="nobody"
INTFTPD_OPTS="-u ${INTFTPD_USER} -l -vvvvvv -p -c -s ${INTFTPD_PATH}"
}}

Setup GRUB: Older versions of GRUB used the <code>netboot</code> USE flag to create a PXE image.

{{RootCmd|echo "sys-boot/grub netboot" >> /etc/portage/package.use}}

GRUB을 설치하십시오.

{{RootCmd|emerge -av grub}}

GRUB을 컴파일하고 나면 디스크가 없는 클라이언트의 부팅 디렉터리를 만드십시오.

{{RootCmd|grub2-mknetdir --net-directory{{=}}/diskless/eta}}

무 디스크 클라이언트에 PXE 이미지를 복사하는 방식이 원래 방식이지만 해당 경로는 더이상 존재하지 않는 것 같습니다(?).

{{RootCmd|mkdir /diskless/eta/boot|cp /usr/lib/grub/pxegrub /diskless/eta/boot/pxegrub}}

위 명령을 처리하고 나면 {{Path|grub.lst}} 설정 파일을 편집하십시오.

{{RootCmd|nano -w /diskless/eta/boot/grub.lst}}

{{FileBox|filename=grub.lst|title=|lang=bash|1=
default 0
timeout 30
  
title=Diskless Gentoo
root (nd)
kernel /eta/bzImage ip=dhcp root=/dev/nfs nfsroot=ip.add.re.ss:/diskless/eta
  
# For the nfsroot option, the IP address is the one of the server and
the directory is the one where your diskless client files are located (on the server).
}}

Setup NFS: NFS is quite easy to configure. The only thing you have to do is to add a line on the {{Path|/etc/exports}} config file: 

{{FileBox|filename=/etc/exports|title=|lang=bash|1=
/diskless/eta eta(rw,sync,no_root_squash)
}}

Update your hosts: One important thing to do now is to modify your {{Path|/etc/hosts}} file to fit your needs. 

{{FileBox|filename=/etc/hosts|title=|lang=bash|1=
127.0.0.1 localhost
192.168.1.10 eta.example.com eta
192.168.1.20 sigma.example.com sigma
</pre>
}}

=== 서버에 시스템 만들기 ===

You might want to reboot the server with a Gentoo Install CD, although you can very well continue immediately if you know how to proceed with the Gentoo Installation Instructions from an existing installation. Follow the standard install procedure as explained in the [[Handbook:Main_Page|Gentoo Handbook]] BUT with the following differences: When you mount the file system, do the following (where {{Path|sdaX}} is the partition where you created the {{Path|/diskless}} directory). You do not need to mount any other partitions as all of the files will reside in the {{Path|/diskless/eta}} directory. 

{{RootCmd|mount /dev/sdaX /mnt/gentoo}}

Stage tarballs and chroot: This example uses a stage3 tarball. Mount {{Path|/proc}} to your diskless directory and chroot into it to continue with the install. Then follow the installation manual until kernel configuration. 

{{Warning|스테이지 타르볼을 풀 위치를 신중하게 다루십시오. 기존 설치 결과물에 압축 해제시 덮어쓰기 하여 끝장을 내고 싶어하진 않을겝니다.}}

{{RootCmd|cd /mnt/gentoo/diskless/eta/
|tar -xvjpf  /mnt/cdrom/gentoo/stage3-*.tar.bz2
|mount -t proc /proc /mnt/gentoo/diskless/eta/proc
|cp /etc/resolv.conf /mnt/gentoo/diskless/eta/etc/resolv.conf
|chroot /mnt/gentoo/diskless/eta/ /bin/bash
|env-update
|source /etc/profile}}

Kernel configuration: When you do the <code>make menuconfig</code> of your kernel configuration, don't forget to enable the following options with the others recommended into the install howto. 

{{KernelBox|title=무(無)디스크 설치시 필요한 옵션|<pre>
- Your network card device support
(In the kernel, *not* as a module!)
  
-*- Networking support --->  
  Networking options --->
    [*] TCP/IP networking
    [*] IP: kernel level autoconfiguration
    [*] IP: DHCP support
    [*] IP: BOOTP support
  
File systems --->
  [*] Network File Systems --->
    <*> NFS file system support
    [*] Provide NFSv3 client support
    [*] Root file system on NFS
</pre>}}

Save the kernel in your chrooted {{Path|/}} (not in {{Path|/boot}}) according to the pxegrub setting defined earlier. Next configure your diskless client's {{Path|/etc/fstab}}. 

{{FileBox|filename=/etc/fstab|title=|lang=bash|<pre>
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
</pre>
}}

또한 클라이언트가 파일 시스템을 검사하지 못하게 막아야합니다: 

{{RootCmd|touch /fastboot
|echo "touch /fastboot" >> /etc/conf.d/local.start}}

클라이언트가 상당히 의존하는 {{Package|nfs-utils}} 꾸러미를 설치하십시오: 

{{Emerge|nfs-utils}}

부트로더가 남았습니다만, pxegrub을 이미 설치했으므로 다른 부트로더는 설치하지 마십시오. 설치를 마치고 서버를 재시작하기만 하면 됩니다. 클라이언트를 부팅할 때 필요한 서비스 DHCP, TFTPD, NFS를 시작하십시오. 

{{RootCmd|/etc/init.d/dhcp start
|/etc/init.d/in.tftpd start
|/etc/init.d/nfs start}}

=== 새 클라이언트 부팅 ===

For the new client to boot properly, you'll need to configure the BIOS and the network card to use PXE as the first boot method - before CD-ROM or floppy. For help with this consult your hardware manuals or manufacturers website. The network card should get an IP address using DHCP and download the GRUB PXE image using TFTP. Then, you should see a nice black and white GRUB bootmenu where you will select the kernel to boot and press Enter. If everything is ok the kernel should boot, mount the root filesystem using NFS and provide you with a login prompt. Enjoy.

== 기존 리눅스 배포판에서 젠투 설치 ==

=== 요구 사항 ===

In order to install Gentoo from your existing Linux distribution you need to have chroot command installed, and have a copy of the Gentoo installation tarball or ISO you want to install. A network connection would be preferable if you want more than what's supplied in your tarball. (by the way, a tarball is just a file ending in .tbz or .tar.gz). Let's get started! 

=== 간단히 살펴보기 ===

We will first allocate a partition to Gentoo by resizing our existing Linux partition, mount the partition, untar the tarball to the partition that is mounted, chroot inside the pseudo-system and start building. Once the bootstrap process is done, we will do some final configuration on the system so as to make sure it boots, then we are ready to reboot and use Gentoo. 

=== 젠투에 얼마나 많은 공간이 필요한가요? ===

The root partition is the filesystem mounted under {{Path|/}} . A quick run of <code>mount</code> on my system shows what I am talking about. We well also use <code>df</code> (disk free) to see how much space I have left and how I will be resizing. Note that it is not mandatory to resize your root partition! You could be resizing anything else supported by our resizer, but let's talk about that later. 

{{RootCmd|mount|output=<pre>
/dev/sdb2 on / type ext3 (rw)
none on /proc type proc (rw)
none on /dev/pts type devpts (rw,gid=5,mode=620)
none on /dev/shm type tmpfs (rw,nodev,nosuid,noexec)
</pre>}}

{{RootCmd|df -h|output=<pre>
Filesystem           Size Used Avail Use% Mounted on
/dev/sdb2            4.0G 1.9G  2.4G  82% /
none                  38M    0   38M   0% /dev/shm
</pre>
}}

As we can see, the partition mounted as {{Path|/}} named {{Path|/dev/sdb2}} has 2.4 GB free. In my case, I think I will resize it as to leave 400 MB free of space, therefore allocating 2 GB for Gentoo. Not bad, I could have quite some stuff installed. However, I think that even 1 GB is enough for most users. So let's partition this thing!

=== 파티션 크기를 조절할 parted 빌드 ===

{{Warning|This section is outdated and will be removed when the older parted versions have left the Gentoo Portage tree. The ability to resize partitions has been removed from parted, as explained [https://www.gnu.org/software/parted/manual/html_node/Command-explanations.html here].}}

{{Package|Parted}} is an utility supplied by the GNU foundation, an old and respectable huge project whose software you are using in this very moment. There is one tool, however, that is extremely useful for us at the moment. It's called <code>parted</code>, partition editor and we can get it from [http://www.gnu.org/software/parted/ http://www.gnu.org/software/parted/].

{{Note|There are other tools for doing resize of partitions as well, but the author is unsure/uninterested whether PartitionMagic or other software of the kind do the job. It's the reader's job to check them out.}}

Look up on that page the type of file system you want to resize and see if parted can do it. If not, you're out of luck, you will have to destroy some partition to make space for Gentoo, and reinstall back. Go ahead by downloading the software, install it. Here we have a problem. We want to resize our Linux root partition, therefore we must boot from a floppy disk a minimal Linux system and use previously-compiled parted copied to a diskette in order to resize {{Path|/}}. However, if you can unmount the partition while still in Linux you are lucky, you don't need to do what follows. Just compile parted and run it on an unmounted partition you chose to resize. Here's how I did it for my system. 

{{Important|Make sure that the operations you want to do on your partition are supported by parted!}}

Get the mininux boot/root disk (a 2.4-powered mini Linux distribution on a floppy - free of charge) from [http://mininux.free.fr/uk/ http://mininux.free.fr/uk/], create a floppy as suggested in the Documentation that accompanies the software package and insert a new floppy in the drive for the next step. 

{{Note|Note again that Linux is synonym of "There's one more way to do it". Your objective is to run parted on an unmounted partition so it can do its work. You might use some boot/root diskset other than mininux. You might not even need to do this step at all, ie. you might only have umount the filesystem you want to repartition in your Linux session and run parted on it.}}

{{RootCmd|mkfs.minix /dev/fd0|output=<pre>
480 inodes
1440 blocks
Firstdatazone=19 (19)
Zonesize=1024
Maxsize=268966912
</pre>
}}

We will now proceed with the build of parted. If it's not already downloaded and untarred, do so now and <code>cd</code> into the corresponding directory. Now run the following set of commands to build the utility and copy it to your floppy disk. 

{{RootCmd|mkdir /floppy
|mount -t minix /dev/fd0 /floppy
|export CFLAGS{{=}}"-O3 -pipe -fomit-frame-pointer -static"
|./configure
|make
|cp parted/parted /floppy
|umount /floppy }}

Congratulations, you are ready to reboot and resize your partition. Do this only after taking a quick look at the parted documentation on the GNU website. The resize should take under 30 minutes for the largest hard-drives, be patient. Reboot your system with the mininux boot disk (just pop it inside), and once you are logged in, switch the disk in the drive with your utility disk we have created above and type <code>mount /dev/fd0 /floppy</code> to have parted under {{Path|/floppy}}. There you go. Run parted and you will be able to resize your partition. Once this lenghty process done, we are ready to have the real fun, by installing Gentoo. Reboot back into your old Linux system for now. The drive you wish to operate on is the drive containing the partition we want to resize. For example, if we want to resize {{Path|/dev/sda3}}, the drive is {{Path|/dev/sda}}. 

{{RootCmd|mount /dev/fd0 /floppy 
|cd /floppy
|./parted <drive>}}

{{Cmd|print|prompt=(parted) |output=<pre>
Disk geometry for /dev/sdb: 0.000-9787.148 megabytes
Disk label type: msdos
Minor    Start       End     Type      Filesystem  Flags
1          0.031   2953.125  primary   ntfs
3       2953.125   3133.265  primary   linux-swap
2       3133.266   5633.085  primary   ext3
4       5633.086   9787.148  extended
5       5633.117   6633.210  logical
6       6633.242   9787.148  logical   ext3</pre>}}

{{Cmd|help resize|prompt=(parted) |output=<pre>
(parted)  help resize 
  resize MINOR START END        resize filesystem on partition MINOR
  
        MINOR is the partition number used by Linux.  On msdos disk labels, the
        primary partitions number from 1-4, and logical partitions are 5
        onwards.
        START and END are in megabytes
</pre>}}

{{Cmd|resize 2 3133.266 4000.000|prompt=(parted) }}

{{Important|Be patient! The computer is working! Just look at the harddrive LED on your case to see that it is really working. This should take between 2 and 30 minutes.}}

Once you have resized, boot back into your old Linux as described. Then go to [[Handbook:X86/Installation/Disks|The Gentoo Handbook: Preparing the Disks]] and follow the instructions. When chrooting, use the following command to flush your environment: 

{{RootCmd|env -i HOME{{=}}$HOME TERM{{=}}$TERM chroot /mnt/gentoo /bin/bash
|/usr/sbin/env-update
|source /etc/profile}}

Enjoy!

[[Category:Core system]] {{Migrated|originalauthors=Gerald Normandin Jr., Travis Tilley, Oleg Raisky, Alex Garbutt, Alexandre Georges, Magnus Backanda, Faust A. Tanasescu, Daniel Ahlberg, Sven Vermeulen, Ken Nowack, Tiemo Kieft, Benny Chuang, Jonathan Smith, nightmorph}}
