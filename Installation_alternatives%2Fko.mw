<languages />


{{Metadata|abstract=이 안내서는 대안 젠투 설치 방법을 담아둔 저장소를 의도하며, 특별한 설치 방법은 CDROM이 빠져있거나 CD로 부팅할 수 있는 컴퓨터와 같은 환경이 필요합니다.}}

이 안내서는 대안 젠투 설치 방법을 담아둔 저장소를 의도하며, 특별한 설치 방법은 CDROM이 빠져있거나 CD로 부팅할 수 있는 컴퓨터와 같은 환경이 필요합니다.

== 이 문서 정보 ==

If the standard boot-from-CD install method doesn't work (or just impossible to use, or is just disliked), some help can be found here. This document serves to provide a repository of alternative Gentoo Linux installation techniques to those who need them. Or, if preferred, it serves as a place to put wacky installation methods. If there is an installation method that has been found useful, or the reader has devised an amusing way of installing Gentoo, please don't hesitate to write something up and post it on [https://bugs.gentoo.org/ Bugzilla].

== 스마트 부트매니저로 설치 CD 부팅 ==

Download Smart BootManager available from [http://btmgr.sourceforge.net/download.html http://btmgr.sourceforge.net/download.html]. Linux source or binary format and windows {{Path|.exe}} versions are available as well as many language packs. However, at this time, the preferred method would be to use the binary format, as the source will not compile with newer versions of NASM. 

Either compile the package from source or just grab the binary. There are several options that can be utilized while creating a boot floppy, as seen below. 

{{CodeBox|title=Smart BootManager 옵션|1=
sbminst [-t theme] [-d drv] [-b backup_file] [-u backup_file]
  
   -t theme       select the theme to be used, in which the theme could be:
                    us = English theme       de = German theme
                    hu = Hungarian theme     zh = Chinese theme
                    ru = Russian theme       cz = Czech theme
                    es = Spanish theme       fr = French theme
                    pt = Portuguese theme
  
   -d drv         set the drive that you want to install Smart BootManager on;
                  for Linux:
                    /dev/fd0 is the first floppy driver,
                    /dev/hda is the first IDE harddisk driver.
                    /dev/sda is the first SCSI harddisk driver.
                  for DOS:
                    0   is the first floppy drive
                    128 is the first hard drive;
  
   -c             disable CD-ROM booting feature;
  
   -b backup_file backup the data that will be overwritten for
                  future uninstallation;
  
   -u backup_file uninstall Smart BootManager, should be used alone;
  
   -y             do not ask any question or warning.
}}

{{c|sbminst}} 명령으로 부팅 플로피를 만드십시오:

{{RootCmd|sbminst -t us  -d /dev/fd0}}

{{Note|{{Path|fd0}}을 올바른 플로피 장치 이름으로 바꾸십시오.}}

이제 컴퓨터의 플로피 드라이브에 플로피 디스크를 넣고 마찬가지로 CD-ROM에 설치 CD를 넣은 다음 컴퓨터를 부팅하십시오. 

Smart BootManager 대화 상자가 나타납니다. CDROM을 선택하고 {{Key|Enter}} (Return)키를 눌러 설치 CD로 부팅하십시오. 부팅이 끝나면 표준 설치 과정을 진행합니다. 

Smart BootManager에 대한 더 많은 도움말은 [http://btmgr.sourceforge.net/ http://btmgr.sourceforge.net/]에서 찾아보십시오.

== 비 젠투 LiveCD에서 설치 ==

=== 도입부 ===

{{Important|비 젠투 LiveCD로 인해 뭔가가 잘못되어, 문제를 고치거나, 해결할 수 없고, LiveCD 어디에든 도움이 될만한 문서를 찾을 수 없다면 젠투 개발자가 지원해드릴 수 없습니다. 오직 젠투 LiveCD를 사용하는 경우에만 공식적으로 지원합니다. 대체 설치 미디어를 사용하는 동안 문제에 휘말렸다면, [https://forums.gentoo.org/ 젠투 포럼] 커뮤니티를 방문하십시오.}}

Users can boot other LiveCDs besides the Gentoo-provided CDs. Regardless, these LiveCDs provide a functional environment to use while compiling and installing Gentoo. The instructions provided here should work in principle with just about any other LiveCD. 

There are too many LiveCDs out there to [http://distrowatch.com/search.php list], but an option might be to try out [http://www.knoppix.org/ Knoppix]. It provides a full graphical desktop, with office applications, web browsers, and games to keep busy. Knoppix is only available for x86 users, so depending on the user's requirements another LiveCD or method may need to be used. 

{{Warning|젠투 시스템을 설치하는데 기다리는 동안 LiveCD의 내 폴더에 무언가를 저장했는지 확인하십시오. 젠투로 다시 부팅하면 저장한 내용은 사용할 수 없습니다. 중요한 파일은 하드디스크 또는 다른 컴퓨터에 저장하십시오!}}

=== 설치 절차 ===

LiveCD로 부팅하십시오. 터미널을 열고 {{c|su -}}를 실행하여 암호를 바꿀 수 있게 하십시오. CD의 루트 암호를 바꿀 수 있습니다. 이제 필요할 경우 원격 로그인을 목적으로 sshd 데몬을 설정할 수 있습니다. 다음, {{Path|/mnt/gentoo}} 마운트 지점을 만들어야합니다. 

{{RootCmd|mkdir /mnt/gentoo}}

이 시점에서 [[Handbook:AMD64/Installation/Disks/ko|디스크 준비]]에 있는 표준 설치 문서를 따라할 수 있습니다. 시스템에서 proc 시스템 마운트를 요청하면, 다음 명령을 대신 실행하십시오: 

{{RootCmd|mount -o bind /proc /mnt/gentoo/proc}}

When unpacking the [[stage tarball]] in [[Handbook:AMD64/Installation/Stage#Unpacking_the_stage_tarball|Unpacking the stage tarball]], different {{c|tar}} command options are needed to ensure that proper group IDs are enforced on the unpacked stage: 

{{RootCmd|tar --numeric-owner --xattrs -xvjpf stage3-*.tar.bz2 -C /mnt/gentoo }}

If Ubuntu is being used, note that {{Path|/dev/shm}} is a symbolic link to {{Path|/run/shm}}. It must be bind-mounted or a tmpfs mount has to be set at this location (within the chroot path). To bind-mount the location, run the following command (before chrooting):

{{RootCmd|mount --rbind /run/shm /mnt/gentoo/run/shm}}

This is to avoid {{Bug|496328}} where Python sees <code>sem_open()</code> as broken (due to lack of {{Path|/dev/shm}}) and Portage seeing that as an error (technically Python configuration would continue and build assuming the <var>POSIX_SEMAPHORES_NOT_ENABLED</var> variable has been enabled but this would lead to a very undesired Python build).

Once ready to chroot into the unpacked stage in [[Handbook:AMD64/Installation/Base|Installing Base System]], a different chroot command sequence will need to be used. This ensures that the environment variables are properly setup. 

{{Note|일부 LiveCD는 괴상한 환경 설정을 사용하기 때문에, 이런 상태를 정리하고 제대로 된 환경을 만들려면 {{c|env -i}}  옵션을 활용하십시오.}}

{{RootCmd|chroot /mnt/gentoo /bin/env -i TERM{{=}}$TERM /bin/bash
|env-update
|source /etc/profile
|export PS1{{=}}"(chroot) $PS1"}}

마지막으로 LiveCD에서 포티지 <var>FEATURES</var> 변수 설정이 동작하지 않음을 알아두십시오. 특히 <code>userpriv</code> 와 <code>usersandbox</code>를 확인하십시오. 오류를 발견했다면 <var>FEATURES</var>의 일부 또는 모든 설정 값을 비활성해보십시오.

== PXE 및 LiveCD의 kernel/initrd/squashfs를 활용한 무 디스크 설치 ==

이 방식은 iSCSI 또는 NFS 기반의 PXE 부팅보다 쉽습니다. TFTP를 통해 배포한 동일한 이미지 셋으로 여러대의 머신이 부팅할 수 있으며 HTTP 또는 기타 프로토콜을 통해 쉽게 확장할 수 있습니다.

이미 이미지로 배포하는 페도라 같은 일부 기타 배포판에서는 라이브 또는 설치 CD를 부트스트래핑 해야 합니다. 젠투에는 해당하지 않습니다. 대신 사용자는 다음 과정을 거쳐야합니다.

# kernel, initrd, [[SquashFS|squashfs]]를 라이브 CD에서 추출하고, 
# initrd를 패치한 다음,
# squashfs를 initrd에 합쳐 넣습니다.

Only then can a PXE based boot loader be configured that will load the images and boot into a live system.

Save the following script, make it executable and put its directory in <var>$PATH</var> (or follow the documented steps manually).


{{CodeBox|title=gentoo-pxe-boot|<nowiki>
#!/bin/bash -xe

tftproot="$1"
image="$2"
tmp="./tmp"

test -z "$tftproot" -o -z "$image" && echo "Usage: $0 <tftproot> <gentoo-iso>" >&2 && exit 1
test -e "$tmp" && echo "Temporary path '$tmp' already exists." >&2 && exit 1

iso="$tmp/iso"
initrd="$tmp/initrd.dir"

# prepare directories
mkdir -p "$tmp" "$iso" "$initrd/mnt/cdrom"

# extract files from ISO image
mount -o ro,loop "$image" "$iso"
cp "$iso"/{image.squashfs,isolinux/gentoo,isolinux/gentoo.igz} "$tmp"
umount "$iso"

# rename kernel
mv "$tmp/gentoo" "$tmp/kernel"

# patch initramfs and add squashfs to it
xz -dc "$tmp/gentoo.igz" | ( cd "$initrd" && cpio -idv )
patch -d "$initrd" -p0 <<'EOF'
--- init.orig	2016-01-02 00:00:00.000000000 +0100
+++ init	2016-01-02 00:00:00.000000000 +0100
@@ -455,9 +455,9 @@
 		CHROOT=${NEW_ROOT}
 	fi
 
-	if [ /dev/nfs != "$REAL_ROOT" ] && [ sgimips != "$LOOPTYPE" ] && [ 1 != "$aufs" ]; then
-		bootstrapCD
-	fi
+#	if [ /dev/nfs != "$REAL_ROOT" ] && [ sgimips != "$LOOPTYPE" ] && [ 1 != "$aufs" ]; then
+#		bootstrapCD
+#	fi
 
 	if [ "${REAL_ROOT}" = '' ]
 	then
@@ -591,7 +591,7 @@
 		else
 			bad_msg "Block device ${REAL_ROOT} is not a valid root device..."
 			REAL_ROOT=""
-			got_good_root=0
+			got_good_root=1
 		fi
 	done
 
@@ -670,7 +670,7 @@
 	[ -z "${LOOP}" ] && find_loop
 	[ -z "${LOOPTYPE}" ] && find_looptype
 
-	cache_cd_contents
+	#cache_cd_contents
 
 	# If encrypted, find key and mount, otherwise mount as usual
 	if [ -n "${CRYPT_ROOT}" ]
EOF
cp "$tmp/image.squashfs" "$initrd/mnt/cdrom"
( cd "$initrd" && find . -print | cpio -o -H newc | gzip -9 -c - ) > "$tmp/initrd"

# prepare boot data
grub2-mknetdir -v --net-directory="$tftproot"
cat > "$tftproot/boot/grub/grub.cfg" <<'EOF'
menuentry "Gentoo Live" {
    linux /boot/kernel root=/dev/ram0 init=/linuxrc loop=/image.squashfs looptype=squashfs cdroot=1 real_root=/
    initrd /boot/initrd
}
EOF
cp "$tmp"/{kernel,initrd} "$tftproot/boot"

# cleanup
rm -rf "$tmp"
</nowiki>}}


Download {{Path|install-amd64-minimal-20151231.iso}} (or try with the current version if it differs). Install {{Package|net-ftp/tftp-hpa}}, make sure it serves {{Path|/tftproot}} and start it.

적당한 매개 변수를 넣어 스크립트를 실행하십시오.

{{RootCmd|gentoo-pxe-boot /tftproot install-amd64-minimal-20141204.iso}}

Now the tftp boot service is ready, so the next step is to configure a DHCP service. Setting up a DHCP server on the same machine is possible - just make sure that the booted machines are connected to it. Or just tweak the configuration of an existing router.

OpenWRT DHCP 서비스용 설정 예제는 다음과 같습니다:

{{CodeBox|title=/etc/config/dhcp|
config boot linux                   
        option filename boot/grub/i386-pc/core.0
        option servername boot
        option serveraddress 84.246.161.86
}}

== PXE 부팅 방식 및 NFS로 무(無)디스크 설치 ==

=== 요구 사항 ===

PXE (Preboot eXecution Environment) is a method for booting computers over a PXE-capable network interface (and using a PXE-supporting BIOS). In case the system does not support PXE boot from the network interface or BIOS, PXE can also be used as a boot method from block devices (like CDs or USBs). In such cases, a minimal boot environment mimics the PXE supporting network card (see also [http://etherboot.org Etherboot/gPXE]). 

=== 서버 베이스 설정 ===

Create directories: The first thing to do is to create the directories where the diskless system will be stored. Create a directory called {{Path|/diskless}} which houses a directory for each diskless client. For the remainder of this howto, the client that is being worked on will be called 'eta'. 

{{RootCmd|mkdir /diskless
|mkdir /diskless/eta
}}

DHCP 및 TFTP 설정: 클라이언트는 DHCP로 부팅 정보를 가져오며 TFTP를 통해 필요한 모든 파일을 다운로드합니다. 

For dhcpd, just run {{c|emerge dhcp}} (or any other DHCP server of choice). Make sure that the correct interface is selected in {{Path|/etc/conf.d/dhcpd}}, and configure it accordingly. Then, add the following on {{Path|/etc/dhcp/dhcpd.conf}}. 

{{Note|This provides a static IP address for the client and the path of a PXE boot image, here {{Path|pxegrub}}. The MAC address of the ethernet card of the client in the example has to be replaced with the correct MAC address, as well as the directory where the client files will be stored.}}

{{FileBox|filename=dhcpd.conf|title=|lang=bash|1=
option option-150 code 150 = text ;
ddns-update-style none ;
host eta {
hardware ethernet 00:00:00:00:00:00;
fixed-address ip.add.re.ss;
option option-150 "/eta/boot/grub.lst";
filename "/eta/boot/pxegrub";
}
}}

Next configure the interface in {{Path|/etc/conf.d/net}} so that it doesn't get cleared at bootup. See {{Path|/usr/share/doc/openrc-*/net.example.bz2}} for more information. 

{{FileBox|filename=/etc/conf.d/net|title=Ensure the interface (here eth0 as example) is not reconfigured at boot|lang=bash|1=
config_eth0=( "noop" )
}}

TFTP에서는 {{Package|net-ftp/tftp-hpa}}를 이머지하십시오. {{Path|/etc/conf.d/in.tftpd}}에 다음 설정을 넣으십시오. 

{{FileBox|filename=in.tftpd|title=|lang=bash|1=
INTFTPD_PATH="/diskless"
INTFTPD_USER="nobody"
INTFTPD_OPTS="-u ${INTFTPD_USER} -l -vvvvvv -p -c -s ${INTFTPD_PATH}"
}}

GRUB  설정: 이전 버전의 GRUB은 <code>netboot</code> USE 플래그를 사용하여 PXE 이미지를 만듭니다.

{{RootCmd|echo "sys-boot/grub netboot" >> /etc/portage/package.use}}

GRUB을 설치하십시오.

{{RootCmd|emerge -av grub}}

GRUB을 컴파일하고 나면 디스크가 없는 클라이언트의 부팅 디렉터리를 만드십시오.

{{RootCmd|grub2-mknetdir --net-directory{{=}}/diskless/eta}}

무 디스크 클라이언트에 PXE 이미지를 복사하는 방식이 원래 방식이지만 해당 경로는 더이상 존재하지 않는 것 같습니다(?).

{{RootCmd|mkdir /diskless/eta/boot|cp /usr/lib/grub/pxegrub /diskless/eta/boot/pxegrub}}

위 명령을 처리하고 나면 {{Path|grub.lst}} 설정 파일을 편집하십시오.

{{RootCmd|nano -w /diskless/eta/boot/grub.lst}}

{{FileBox|filename=grub.lst|title=|lang=bash|1=
default 0
timeout 30
  
title=Diskless Gentoo
root (nd)
kernel /eta/bzImage ip=dhcp root=/dev/nfs nfsroot=ip.add.re.ss:/diskless/eta
  
# For the nfsroot option, the IP address is the one of the server and
the directory is the one where the diskless client files are located (on the server).
}}

Setup NFS: NFS is quite easy to configure. The only thing that has to be done is to add a line on the {{Path|/etc/exports}} config file: 

{{FileBox|filename=/etc/exports|title=|lang=bash|1=
/diskless/eta eta(rw,sync,no_root_squash)
}}

Update the hosts: One important thing to do now is to modify the {{Path|/etc/hosts}} file to fit requirements. 

{{FileBox|filename=/etc/hosts|title=|lang=bash|1=
127.0.0.1 localhost
192.168.1.10 eta.example.com eta
192.168.1.20 sigma.example.com sigma
</pre>
}}

=== 서버에 시스템 만들기 ===

A next step is to reboot the server with a Gentoo installation CD (although experienced administrators can continue without if they are sufficiently versed in Gentoo installations). Follow the standard install procedure as explained in the [[Handbook:Main_Page|Gentoo Handbook]] BUT with the following differences: when mounting the file system, execute the next step (where {{Path|sdaX}} is the partition where the {{Path|/diskless}} directory was created).

{{RootCmd|mount /dev/sdaX /mnt/gentoo}}

{{Path|/diskless/eta}} 디렉터리에 모든 파일이 있기 때문에 다른 파티션은 굳이 마운트할 필요가 없습니다. 

[[Stage tarball]]s and chroot: This example uses a stage3 tarball. Mount {{Path|/proc}} to the diskless directory and chroot into it to continue with the install. Then follow the installation manual until kernel configuration. 

{{Warning|Be very careful when extracting the stage tarball to its destination, so as to not end up extracting over an existing installation.}}

{{RootCmd|cd /mnt/gentoo/diskless/eta/
|tar -xvjpf  /mnt/cdrom/gentoo/stage3-*.tar.bz2
|mount -t proc /proc /mnt/gentoo/diskless/eta/proc
|cp /etc/resolv.conf /mnt/gentoo/diskless/eta/etc/resolv.conf
|chroot /mnt/gentoo/diskless/eta/ /bin/bash
|env-update
|source /etc/profile}}

Kernel configuration: When doing the {{c|make menuconfig}} of the kernel configuration, don't forget to enable the following options with the others recommended into the install guide. 

{{KernelBox|title=Necessary options for diskless installations|<pre>
- The network card device support
(In the kernel, *not* as a module!)
  
-*- Networking support --->  
  Networking options --->
    [*] TCP/IP networking
    [*] IP: kernel level autoconfiguration
    [*] IP: DHCP support
    [*] IP: BOOTP support
  
File systems --->
  [*] Network File Systems --->
    <*> NFS file system support
    [*] Provide NFSv3 client support
    [*] Root file system on NFS
</pre>}}

Save the kernel in the chrooted {{Path|/}} (not in {{Path|/boot}}) according to the pxegrub setting defined earlier. Next configure the diskless client's {{Path|/etc/fstab}}. 

{{FileBox|filename=/etc/fstab|title=|lang=bash|<pre>
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
</pre>
}}

Now to prevent the client from running a filesystem check: 

{{RootCmd|touch /fastboot
|echo "touch /fastboot" >> /etc/conf.d/local.start}}

Install {{Package|nfs-utils}} since the client will heavily depend on it: 

{{Emerge|nfs-utils}}

Bootloader. Don't install another bootloader because there is already one - pxegrub. Simply finish the install and restart the server. Start the services that are needed to boot the new client: DHCP, TFTPD, and NFS. 

{{RootCmd|/etc/init.d/dhcp start
|/etc/init.d/in.tftpd start
|/etc/init.d/nfs start}}

=== 새 클라이언트 부팅 ===

For the new client to boot properly, the BIOS and the network card need to be configured to use PXE as the first boot method - before CD-ROM or floppy. For help with this consult the hardware manuals or manufacturers website. The network card should get an IP address using DHCP and download the GRUB PXE image using TFTP. Then, a nice black and white GRUB bootmenu should be displayed from where users can select the kernel to boot and press the {{Key|Enter}} (Return) key. If everything is ok the kernel should boot, mount the root filesystem using NFS and provide a login prompt. Enjoy.

== 기존 리눅스 배포판에서 젠투 설치 ==

=== 요구 사항 ===

In order to install Gentoo from an existing Linux distribution it needs to have the chroot command installed, and have a copy of the Gentoo installation or ISO that's desired to install. A network connection is highly recommended as otherwise the installation can only work with the files available in the installation media. By the way, a tarball is just a file ending in {{Path|.tbz}} or {{Path|.tar.gz}}. Let's get started!

=== 간단히 살펴보기 ===

First allocate a partition to Gentoo by resizing an existing Linux partition, mount the partition, untar the tarball to the partition that is mounted, chroot inside the pseudo-system and start building. Once the bootstrap process is done, do some final configuration on the system so as to make sure it boots, then reboot and use Gentoo. 

=== 젠투에 얼마나 많은 공간이 필요한가요? ===

The root partition is the filesystem mounted under {{Path|/}}. The first example shows the output of {{c|mount}} on a system . The second example uses {{c|df}} (disk free) to see how much space there is left and how it will be resized. Note that resizing the root partition is not mandatory! Anything else supported by the resizer can be resized, but let's talk about that later. 

{{RootCmd|mount|output=<pre>
/dev/sdb2 on / type ext3 (rw)
none on /proc type proc (rw)
none on /dev/pts type devpts (rw,gid=5,mode=620)
none on /dev/shm type tmpfs (rw,nodev,nosuid,noexec)
</pre>}}

{{RootCmd|df -h|output=<pre>
Filesystem           Size Used Avail Use% Mounted on
/dev/sdb2            4.0G 1.9G  2.4G  82% /
none                  38M    0   38M   0% /dev/shm
</pre>
}}

As can be seen, the partition mounted as {{Path|/}} named {{Path|/dev/sdb2}} has 2.4 GB free. In this case, it was decided to be resized as to leave 400 MB of free space, therefore allocating 2 GB for Gentoo. Not bad, it could have quite some stuff installed. However, 1 GB is deemed enough for most users. So now partition this thing!

=== 파티션 크기를 조절할 parted 빌드 ===

{{Warning|이 장은 오래되었기 때문에 parted 버전이 한물 간 채로 젠투 포티지 트리에 남아있다면 제거하겠습니다. 분할 공간 재 조정 기능은 [https://www.gnu.org/software/parted/manual/html_node/Command-explanations.html 여기]에서 언급한 바와 같이 parted에서 제거했습니다.}}

{{Package|sys-block/parted}} is an utility supplied by the GNU foundation, an old and respectable huge project whose software you are using in this very moment. There is one tool, however, that is extremely useful at the moment: {{c|parted}}, a partition editor that can be found at [http://www.gnu.org/software/parted/ http://www.gnu.org/software/parted/].

{{Note|There are other tools for doing resize of partitions as well, but an elaborate description of these tools is outside the scope of this guide.}}

Look up on that page the type of file system to resize and see if parted can do it. If not: tough luck, some partitions might need to be destroyed to make space for Gentoo, and reinstall back. Go ahead by downloading the software and install it. In the next step, a problem arises. The Linux root partition needs to be resized, therefore a floppy disk with a minimal Linux system must be booted and to use a previously-compiled parted copied to a diskette in order to resize {{Path|/}}. If the partition can be unmounted while still running in Linux then the following steps are not needed. Just compile parted and run it on a chosen unmounted partition to resize. Here's how it was done on this system. 

{{Important|Make sure that the operations that are required for partitioning are supported by parted!}}

[http://mininux.free.fr/uk/ http://mininux.free.fr/uk/]에서 mininux 부트/루트 디스크(2.4 커널을 갖춘 플로피 디스크 미니 리눅스 배포판 - 꽁짜!)를 가져오시고 플로피 디스크를 프로그램 꾸러미에 딸려온 문서에서 제안한 대로 만든 후, 다음 과정을 위해 새 플로피 디스크를 드라이브에 넣으십시오. 

{{Note|Note again that Linux is synonym of "There's one more way to do it". The objective is to run parted on an unmounted partition so it can do its work. A boot/root diskset other than mininux can be used. This step might not even be needed to do at all: there may only be the need to umount the filesystem to repartition in the Linux session and run parted on it.}}

{{RootCmd|mkfs.minix /dev/fd0|output=<pre>
480 inodes
1440 blocks
Firstdatazone=19 (19)
Zonesize=1024
Maxsize=268966912
</pre>
}}

Proceed with the build of parted. Download and untar the utility, and {{c|cd}} into the corresponding directory. Now run the following set of commands to build the utility and copy it to the floppy disk. 

{{RootCmd|mkdir /floppy
|mount -t minix /dev/fd0 /floppy
|export CFLAGS{{=}}"-O3 -pipe -fomit-frame-pointer -static"
|./configure
|make
|cp parted/parted /floppy
|umount /floppy }}

이제 재부팅한 다음 분할 영역 크기를 조절할 때입니다. GUI 웹사이트에 있는 parted 문서를 간단하게 훑어보신 다음에만 이 과정을 진행하십시오. 큰 하드 드라이브의 분할 영역 크기를 조절하는데 30분 이내의 시간이 걸리니 조금만 참으십시오. 시스템을 미니눅스 부팅 디스크로 다시 부팅하고, 로그인한 후, 위에서 만든 유틸리티 디스크로 바꾸십시오. 그 다음 {{c|mount /dev/fd0 /floppy}} 명령으로  {{Path|/floppy}} 디렉터리에 플로피 드라이브를 마운트하십시오. parted를 실행하여 분할 영역의 크기를 다시 조절할 수 있게 하십시오. 긴 과정이 끝나면 젠투 설치를 계속 진행하십시오. 이제 예전 리눅스 시스템으로 다시 부팅하여 돌아가십시오. 이제 가동할 드라이브에는 크기를 조절해야 하는 분할 영역이 들어있습니다. 예를 들면 크기를 조절해야 할 분할 영역이 {{Path|/dev/sda3}}이다, 그러면 드라이브는 {{Path|/dev/sda}}입니다. 

{{RootCmd|mount /dev/fd0 /floppy 
|cd /floppy
|./parted <drive>}}

{{Cmd|print|prompt=(parted) |output=<pre>
Disk geometry for /dev/sdb: 0.000-9787.148 megabytes
Disk label type: msdos
Minor    Start       End     Type      Filesystem  Flags
1          0.031   2953.125  primary   ntfs
3       2953.125   3133.265  primary   linux-swap
2       3133.266   5633.085  primary   ext3
4       5633.086   9787.148  extended
5       5633.117   6633.210  logical
6       6633.242   9787.148  logical   ext3</pre>}}

{{Cmd|help resize|prompt=(parted) |output=<pre>
(parted)  help resize 
  resize MINOR START END        resize filesystem on partition MINOR
  
        MINOR is the partition number used by Linux.  On msdos disk labels, the
        primary partitions number from 1-4, and logical partitions are 5
        onwards.
        START and END are in megabytes
</pre>}}

{{Cmd|resize 2 3133.266 4000.000|prompt=(parted) }}

{{Important| 좀 기다리십시오! 컴퓨터가 동작합니다! 동작중인지 확인하려면 하드드라이브 LED를 확인하십시오. 2분에서 30분 가량 걸립니다.}}

분할 공간의 크기 재조절이 끝나면, 설명한 바와 같이 이전 리눅스 시스템으로 다시 부팅하십시오. 그 다음 [[Handbook:X86/Installation/Disks/ko|젠투 핸드북: 디스크 준비]] 편으로 가서 절차를 따르십시오. 루트를 전환할 때, 다음 명령을 실행하여 환경 정보를 제거하십시오: 

{{RootCmd|env -i HOME{{=}}$HOME TERM{{=}}$TERM chroot /mnt/gentoo /bin/bash
|/usr/sbin/env-update
|source /etc/profile}}

고생하셨습니다!

[[Category:Core system]] {{Migrated|originalauthors=Gerald Normandin Jr., Travis Tilley, Oleg Raisky, Alex Garbutt, Alexandre Georges, Magnus Backanda, Faust A. Tanasescu, Daniel Ahlberg, Ken Nowack, Tiemo Kieft, Benny Chuang, Jonathan Smith, nightmorph}}
