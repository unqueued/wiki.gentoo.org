<languages />


{{Metadata|abstract=이 설명서는 대안 젠투 설치 방법을 담아둔 저장소를 의도하며, 특별한 설치 방법은 CD-ROM이 빠져있거나 CD로 부팅할 수 있는 컴퓨터와 같은 환경이 필요합니다.}}

이 설명서는 대안 젠투 설치 방법을 담아둔 저장소를 의도하며, 특별한 설치 방법은 CD-ROM이 빠져있거나 CD로 부팅할 수 있는 컴퓨터와 같은 환경이 필요합니다.

== 이 문서 정보 ==

CD에서 부팅하는 표준 설치 방식으로 진행할 수 없을 경우(또는 이 방식이 싫다면)의 설명서를 이제 여기에 준비했습니다. 이 문서는 젠투 리눅스를 다른 방법으로 설치하는 방법을 보관해둔 내용을 필요한 이들에게 제공합니다. 또는 이 방식이 좋다면 유별난 설치 방법이 될 수 있습니다. 쓸만한 설치 방법을 찾았거나 젠투를 설치하는 재밌는 방법을 발견했다면, 망설이지 말고  [https://bugs.gentoo.org/ Bugzilla]에 알려주십시오.

== 스마트 부트매니저로 설치 CD 부팅 ==

[http://btmgr.sourceforge.net/download.html http://btmgr.sourceforge.net/download.html]에서 스마트 부트매니저를 다운로드하십시오. 리눅스 소스 코드 또는 바이너리 형식, 윈도우 .exe 버전이 있으며, 여러가지 언어 꾸러미도 존재합니다. 그러나 지금 준비한 방식은 최신 버전의 NASM으로 소스코드를 컴파일할 수 없으므로 바이너리 형식을 사용하겠습니다. 

소스 코드 꾸러미를 컴파일 하거나 바이너리를 취할 수 있습니다. 아래에서 보시는 바와 같이 부팅 가능한 플로피를 만드는 동안 활용할 수 있는 몇가지 선택지가 있습니다. 

{{CodeBox|title=Smart BootManager 옵션|1=
sbminst [-t theme] [-d drv] [-b backup_file] [-u backup_file]
  
   -t theme       select the theme to be used, in which the theme could be:
                    us = English theme       de = German theme
                    hu = Hungarian theme     zh = Chinese theme
                    ru = Russian theme       cz = Czech theme
                    es = Spanish theme       fr = French theme
                    pt = Portuguese theme
  
   -d drv         set the drive that you want to install Smart BootManager on;
                  for Linux:
                    /dev/fd0 is the first floppy driver,
                    /dev/hda is the first IDE harddisk driver.
                    /dev/sda is the first SCSI harddisk driver.
                  for DOS:
                    0   is the first floppy drive
                    128 is the first hard drive;
  
   -c             disable CD-ROM booting feature;
  
   -b backup_file backup the data that will be overwritten for
                  future uninstallation;
  
   -u backup_file uninstall Smart BootManager, should be used alone;
  
   -y             do not ask any question or warning.
}}

<code>sbminst</code> 명령으로 부팅 플로피를 만드십시오:

{{RootCmd|sbminst -t us  -d /dev/fd0}}

{{Note|{{Path|fd0}}과 이름이 다르다면 이 대신 사용중인 플로피 장치 이름으로 바꾸십시오.}}

이제 컴퓨터의 플로피 드라이브에 플로피 디스크를 넣고 마찬가지로 CD-ROM에 설치 CD를 넣은 다음 컴퓨터를 부팅하십시오. 

Smart BootManager 대화 상자를 마주할 것입니다. CD-ROM과 부팅할 설치 CD를 선택하고 엔터키를 누르십시오. 부팅이 끝나면 표준 설치 과정을 진행합니다. 

Smart BootManager에 대한 더 많은 도움말은 [http://btmgr.sourceforge.net/ http://btmgr.sourceforge.net/]에서 찾아보십시오.

== 비 젠투 LiveCD에서 설치 ==

=== 도입부 ===

{{Important|비 젠투 LiveCD로 인해 뭔가가 잘못되어, 문제를 고치거나, 해결할 수 없고, LiveCD 어디에든 도움이 될만한 문서를 찾을 수 없다면 젠투 개발자가 지원해드릴 수 없습니다. 오직 젠투 LiveCD를 사용하는 경우에만 공식적으로 지원합니다. 대체 설치 미디어를 사용하는 동안 문제가 발생했다면, [https://forums.gentoo.org/ 젠투 포럼]<sup style="color:#ff0077">en</sup>커뮤니티의 도움을 받으십시오.}}

젠투에서 제공하는 CD 외에 다른 LiveCD로 부팅할 수 있습니다. 젠투를 컴파일하고 설치하는 동안 활용할 동작 환경을 제공합니다. 여기서 소개하는 절차를 통해서도 다른 LiveCD로 진행하는 상황과 마찬가지로 근본적인 동작을 해야합니다. 

[http://distrowatch.com/search.php 목록]에 수많은 LiveCD가 있지만, [http://www.knoppix.org/ Knoppix]를 써보실겁니다. 완벽한 그래픽 데스크톱, 오피스 프로그램, 웹 브라우저, 게임 등 여러분을 바쁘게 만들어드릴 요건을 제공합니다. Knoppix는 x86 사용자용으로 제공하므로, 다른 아키텍처 머신 사용자라면 필요에 따라 다른 LiveCD를 찾아야합니다. 

{{Warning|젠투 시스템을 설치하는데 기다리는 동안 LiveCD의 내 폴더에 무언가를 저장했는지 확인하십시오. 젠투로 다시 부팅할 때 이 내용은 사용할 수 없습니다. 중요한 파일은 하드디스크 또는 다른 컴퓨터에 저장하십시오!}}

=== 설치 절차 ===

LiveCD로 부팅하십시오. 터미널을 열고 <kbd>su -</kbd>를 실행하여 암호를 바꿀 수 있게 하십시오. CD의 루트 암호를 바꿀 수 있습니다. 이제 젠투를 원격으로 설치할 때 활용할 원격 로그인을 목적으로 sshd 데몬을 설정할 수 있습니다. 다음, {{Path|/mnt/gentoo}} 마운트 지점을 만들어야합니다. 

{{RootCmd|mkdir /mnt/gentoo}}

이 시점에서 [[Handbook:AMD64/Installation/Disks/ko|디스크 준비하기]]에 있는 표준 설치 문서를 따라할 수 있습니다. proc 시스템 마운트를 요청할 때, 대신 다음 명령을 실행하십시오: 

{{RootCmd|mount -o bind /proc /mnt/gentoo/proc}}

[[Handbook:AMD64/Installation/Stage/ko#.EC.8A.A4.ED.85.8C.EC.9D.B4.EC.A7.80_.ED.83.80.EB.A5.B4.EB.B3.BC_.EC.95.95.EC.B6.95_.ED.95.B4.EC.A0.9C|스테이지 타르볼 압축 해제]]에서 스테이지 타르볼을 압축 해제할 준비가 띁나면, 압축 해제한 스테이지에 강제할 적당한 그룹 ID를 확인하기 위해 다른 <tt>tar</tt> 명령을 사용해야합니다: 

{{RootCmd|tar --numeric-owner -xvjpf stage3-*.tar.bz2}}

우분투를 사용한다면, {{Path|/dev/shm}}은 {{Path|/run/shm}}의 심볼릭 링크임을 참고하십시오. (chroot한 경로에서) 이 위치를 바인딩하거나 tmpfs를 만들어야합니다. chroot를 실행하기 전에:

{{RootCmd|mount --rbind /run/shm /mnt/gentoo/run/shm}}

이 방식은 파이썬에서 <code>sem_open()</code> 함수게 깨진걸로 나타내는 {{Bug|496328}}를 피하는 방편이며 포티지는 이를 오류로 보고합니다(기술적으로 이야기하자면 파이썬 설정을 계속하고 <code>POSIX_SEMAPHORES_NOT_ENABLED</code>값을 설정했다고 간주하여 빌드하지만 원하지 않는 파이썬 빌드 결과를 이끌어냅니다).

 [[Handbook:AMD64/Installation/Base/ko|베이스 시스템 설치]]에서 스테이지 압축을 풀고 루트를 전환할 준비가 끝나면 다른 chroot 명령 순서를 따라야합니다. 이 순서를 따라야 환경 변수를 통해 올바른 설치를 진행하도록 보장합니다. 

{{Note|일부 LiveCD는 괴상한 환경 설정을 사용하기 때문에 이런 상태를 없애기 위해 <code>env -i</code>  옵션을 활용하십시오.}}

{{RootCmd|chroot /mnt/gentoo /bin/env -i TERM{{=}}$TERM /bin/bash
|env-update
|source /etc/profile
|export PS1{{=}}"(chroot) $PS1"}}

마지막으로 LiveCD에서 포티지 <var>FEATURES</var> 변수 설정이 동작하지 않음을 인지하십시오. 특히나 <code>userpriv</code> 와 <code>usersandbox</code>를 확인하십시오. 오류를 발견했다면 <var>FEATURES</var>의 일부 또는 모든 설정 값을 비활성하는 것이 좋습니다.

== PXE 및 LiveCD의 kernel/initrd/squashfs를 활용한 무 디스크 설치 ==

이 방식은 iSCSI 또는 NFS 기반의 PXE 부팅보다 쉽습니다. TFTP를 통해 배포한 동일한 이미지 셋으로 여러대의 머신이 부팅할 수 있으며 HTTP 또는 기타 프로토콜을 통해 쉽게 확장할 수 있습니다.

페도라 같은 일부 기타 배포판에서는 라이브 또는 설치 CD에 필요한 부트스트랩 이미지를 배포하고 있지만, 젠투에서는 (1) 커널, 초기 램 디스크, [[SquashFS|squashfs]]를 라이브 CD에서 끄집어내어 압축을 풀고, (2) initrd 내용을 패치한 후 (3) squashfs를 initrd에 통합합니다. 라이브 시스템에서 이미지를 불러오고 부팅할 PXE 기반 부트 로더를 설정할 때만 가능합니다.

다음 스크립트를 저장하고 <code>$PATH</code> 경로 또는 다음 과정에서 실행 가능한지 직접 확인하십시오.


{{CodeBox|title=gentoo-pxe-boot|<nowiki>
#!/bin/bash -xe

tftproot="$1"
image="$2"
tmp="./tmp"

test -z "$tftproot" -o -z "$image" && echo "Usage: $0 <tftproot> <gentoo-iso>" >&2 && exit 1
test -e "$tmp" && echo "Temporary path '$tmp' already exists." >&2 && exit 1

iso="$tmp/iso"
initrd="$tmp/initrd.dir"

# prepare directories
mkdir -p "$tmp" "$iso" "$initrd/mnt/cdrom"

# extract files from ISO image
mount -o ro,loop "$image" "$iso"
cp "$iso"/{image.squashfs,isolinux/gentoo,isolinux/gentoo.igz} "$tmp"
umount "$iso"

# rename kernel
mv "$tmp/gentoo" "$tmp/kernel"

# patch initramfs and add squashfs to it
xz -dc "$tmp/gentoo.igz" | ( cd "$initrd" && cpio -idv )
patch -d "$initrd" -p0 <<'EOF'
--- init.orig	2012-05-21 16:14:35.000000000 +0400
+++ init	2012-05-21 18:14:43.000000000 +0400
@@ -368,10 +368,10 @@
 		[ ! -e "${NEW_ROOT}/dev/tty1" ] && mknod "${NEW_ROOT}/dev/tty1" c 4 1
 	fi
 
-	if [ "${REAL_ROOT}" != "/dev/nfs" ] && [ "${LOOPTYPE}" != "sgimips" ]
-	then
-		bootstrapCD
-	fi
+#	if [ "${REAL_ROOT}" != "/dev/nfs" ] && [ "${LOOPTYPE}" != "sgimips" ]
+#	then
+#		bootstrapCD
+#	fi
 
 	if [ "${REAL_ROOT}" = '' ]
 	then
@@ -456,7 +456,7 @@
 		else
 			bad_msg "Block device ${REAL_ROOT} is not a valid root device..."
 			REAL_ROOT=""
-			got_good_root=0
+			got_good_root=1
 		fi
 	done
 
@@ -520,7 +520,7 @@
 	[ -z "${LOOP}" ] && find_loop
 	[ -z "${LOOPTYPE}" ] && find_looptype
 
-	cache_cd_contents
+	#cache_cd_contents
 
 	# If encrypted, find key and mount, otherwise mount as usual
 	if [ -n "${CRYPT_ROOT}" ]
EOF
cp "$tmp/image.squashfs" "$initrd/mnt/cdrom"
( cd "$initrd" && find . -print | cpio -o -H newc | gzip -9 -c - ) > "$tmp/initrd"

# prepare boot data
grub2-mknetdir -v --net-directory="$tftproot"
cat > "$tftproot/boot/grub/grub.cfg" <<'EOF'
menuentry "Gentoo Live" {
    linux /boot/kernel root=/dev/ram0 init=/linuxrc loop=/image.squashfs looptype=squashfs cdroot=1 real_root=/
    initrd /boot/initrd
}
EOF
cp "$tmp"/{kernel,initrd} "$tftproot/boot"

# cleanup
rm -rf "$tmp"
</nowiki>}}


<code>install-amd64-minimal-20141204.iso</code> 이미지를 다운로드(또는 차이가 있다면 현재 버전으로)하십시오. {{Package|net-ftp/tftp-hpa}}를 설치하시고  <code>/tftproot</code>를 서비스 중인지 확인하시고 시작하십시오.

적당한 매개 변수를 넣어 스크립트를 실행하십시오.

{{RootCmd|gentoo-pxe-boot /tftproot install-amd64-minimal-20141204.iso}}

이제 TFTP 부팅 서비스를 준비했고 DHCP 서비스를 설정할 차례입니다. 동일한 머신에 DHCP 서버를 설정할 수 있으며, 부팅한 머신을 연결할 수 있는지 확인하거나 기존 라우터의 설정을 조금 바꿀 수 있습니다.

OpenWRT DHCP 서비스용 설정 예제는 다음과 같습니다:

{{CodeBox|title=/etc/config/dhcp|
config boot linux                   
        option filename boot/grub/i386-pc/core.0
        option servername boot
        option serveraddress 84.246.161.86
}}

== PXE 부팅 방식 및 NFS로 무(無)디스크 설치 ==

=== 요구 사항 ===

PXE(Preboot eXecution Environment)는 PXE 기능을 갖춘 네트워크 인터페이스(와 PXE 지원 BIOS)로 컴퓨터를 부팅하는 방식입니다. (CD 또는 USB 같은) 블록 장치로 부팅하는 방식도 지원하는데, 이러한 경우는 네트워크 인터페이스 또는 BIOS에서 PXE 부팅을 지원하지 않는 경우입니다. 각각의 경우에 최소한의 부팅 환경은 PXE 지원 네트워크 카드 동작을 흉내냅니다([http://etherboot.org Etherboot/gPXE] 참조). 

=== 서버 베이스 설정 ===

디렉터리 만들기: 우선 해야할 일은 무 디스크 시스템을 저장할 디렉터리를 만드는것입니다. 만들 디렉터리의 이름은 {{Path|/diskless}} 이며, 디스크가 없는 클라이언트를 위한 공간입니다. 나머지 절차를 진행하기 위해 클라이언트 'eta' 에서 진행하도록 하겠습니다. 

{{RootCmd|mkdir /diskless
|mkdir /diskless/eta
}}

DHCP 및 TFTP 설정: 클라이언트는 DHCP로 부팅 정보를 가져오며 TFTP를 통해 필요한 모든 파일을 다운로드합니다. 

dhcpd를 활용하려면 {{c|emerge dhcp}}만 실행하십시오(또는 다른 DHCP 서버를 원한다면 해당 서버를 이머지하십시오).  {{Path|/etc/conf.d/dhcpd}}에서 올바른 인터페이스를 지정했는지 확인하고, 기본적으로 필요한 사항을 설정하십시오. 여기까지 마무리가 끝나면, 다음 내용을 {{Path|/etc/dhcp/dhcpd.conf}}에 추가하십시오. 

{{Note|{{Path|pxegrub}}에서는 클라이언트에 정적 IP 주소와 PXE 부팅 이미지 경로를 제공합니다. 클라이언트 이더넷 카드의 MAC 주소와 여러분이 사용할 클라이언트의 파일을 넣을 디렉터리를 바꾸어야합니다.}}

{{FileBox|filename=dhcpd.conf|title=|lang=bash|1=
option option-150 code 150 = text ;
ddns-update-style none ;
host eta {
hardware ethernet 00:00:00:00:00:00;
fixed-address ip.add.re.ss;
option option-150 "/eta/boot/grub.lst";
filename "/eta/boot/pxegrub";
}
}}

다음 {{Path|/etc/conf.d/net}}에 인터페이스를 설정하여 부팅할 때 삭제되지 않도록 해야 합니다. 방법은 {{Path|/usr/share/doc/openrc-*/net.example.bz2}} 파일을 참고하십시오. 

{{FileBox|filename=/etc/conf.d/net|title=부팅시 인터페이스(예제에서는 eth0)를 다시 설정하지 않도록 확인|lang=bash|1=
config_eth0=( "noop" )
}}

TFTP에서는 {{Package|net-ftp/tftp-hpa}}를 이머지하십시오. {{Path|/etc/conf.d/in.tftpd}}에 다음 설정을 넣으십시오. 

{{FileBox|filename=in.tftpd|title=|lang=bash|1=
INTFTPD_PATH="/diskless"
INTFTPD_USER="nobody"
INTFTPD_OPTS="-u ${INTFTPD_USER} -l -vvvvvv -p -c -s ${INTFTPD_PATH}"
}}

GRUB  설정: 이전 버전의 GRUB은 <code>netboot</code> USE 플래그를 사용하여 PXE 이미지를 만듭니다.

{{RootCmd|echo "sys-boot/grub netboot" >> /etc/portage/package.use}}

GRUB을 설치하십시오.

{{RootCmd|emerge -av grub}}

GRUB을 컴파일하고 나면 디스크가 없는 클라이언트의 부팅 디렉터리를 만드십시오.

{{RootCmd|grub2-mknetdir --net-directory{{=}}/diskless/eta}}

무 디스크 클라이언트에 PXE 이미지를 복사하는 방식이 원래 방식이지만 해당 경로는 더이상 존재하지 않는 것 같습니다(?).

{{RootCmd|mkdir /diskless/eta/boot|cp /usr/lib/grub/pxegrub /diskless/eta/boot/pxegrub}}

위 명령을 처리하고 나면 {{Path|grub.lst}} 설정 파일을 편집하십시오.

{{RootCmd|nano -w /diskless/eta/boot/grub.lst}}

{{FileBox|filename=grub.lst|title=|lang=bash|1=
default 0
timeout 30
  
title=Diskless Gentoo
root (nd)
kernel /eta/bzImage ip=dhcp root=/dev/nfs nfsroot=ip.add.re.ss:/diskless/eta
  
# For the nfsroot option, the IP address is the one of the server and
the directory is the one where your diskless client files are located (on the server).
}}

NFS 설정: NFS는 꽤 설정하기 쉽습니다. 유일하게 할 일은 {{Path|/etc/exports}} 설정 파일에 한 줄만 추가하는 것입니다: 

{{FileBox|filename=/etc/exports|title=|lang=bash|1=
/diskless/eta eta(rw,sync,no_root_squash)
}}

호스트 업데이트: 지금은 요구사항에 따라 {{Path|/etc/hosts}} 파일을 수정하는 일이 중요합니다. 

{{FileBox|filename=/etc/hosts|title=|lang=bash|1=
127.0.0.1 localhost
192.168.1.10 eta.example.com eta
192.168.1.20 sigma.example.com sigma
</pre>
}}

=== 서버에 시스템 만들기 ===

기존 설치로부터 젠투 설치 과정을 알고 있다면 바로 다음 단계로 진행할 수 있다 하더라도 젠투 설치 CD로 서버를 재부팅하려 할 것입니다. [[Handbook:Main_Page/ko|젠투 핸드북]]에 언급한대로 표준 설치 절차를 따르겠지만 다음 차이점이 있습니다. 파일 시스템을 마운트할 때 ({{Path|/diskless}} 디렉터리를 만든 위치가 {{Path|sdaX}} 분할 공간) 다음 절차를 따르십시오. 모든 파일이 {{Path|/diskless/eta}} 디렉터리에 있으므로 다른 분할 공간에는 마운트할 필요가 없습니다. 

{{RootCmd|mount /dev/sdaX /mnt/gentoo}}

스테이지 타르볼 및 루트 전환: 이 예제에서는 스테이지 3 타르볼을 다룹니다. {{Path|/proc}} 을 무 디스크 디렉터리에 마운트하고 해당 디렉터리로 루트 위치를 전환하여 설치를 계속 진행합니다. 이 과정이 끝나면 커널 설정 과정에 도달하기 전까지 설치 설명서를 따르십시오. 

{{Warning|스테이지 타르볼을 풀 위치를 신중하게 다루십시오. 기존 설치 결과물에 압축 해제시 덮어쓰기 하여 끝장을 내고 싶어하진 않을겝니다.}}

{{RootCmd|cd /mnt/gentoo/diskless/eta/
|tar -xvjpf  /mnt/cdrom/gentoo/stage3-*.tar.bz2
|mount -t proc /proc /mnt/gentoo/diskless/eta/proc
|cp /etc/resolv.conf /mnt/gentoo/diskless/eta/etc/resolv.conf
|chroot /mnt/gentoo/diskless/eta/ /bin/bash
|env-update
|source /etc/profile}}

커널 설정: 커널 설정시 {{c|make menuconfig}}를 실행할 경우 설치 방법상 추천하는 옵션과 함께 다음 옵션을 잊지 말고 활성화 하십시오. 

{{KernelBox|title=무(無)디스크 설치시 필요한 옵션|<pre>
- Your network card device support
(In the kernel, *not* as a module!)
  
-*- Networking support --->  
  Networking options --->
    [*] TCP/IP networking
    [*] IP: kernel level autoconfiguration
    [*] IP: DHCP support
    [*] IP: BOOTP support
  
File systems --->
  [*] Network File Systems --->
    <*> NFS file system support
    [*] Provide NFSv3 client support
    [*] Root file system on NFS
</pre>}}

앞서 pxegrub을 설정한 대로 ({{Path|/boot}}가 아닌) 루트를 전환한 위치에 커널을 저장하십시오. 다음 무 디스크 클라이언트의 {{Path|/etc/fstab}}을 설정하십시오. 

{{FileBox|filename=/etc/fstab|title=|lang=bash|<pre>
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
</pre>
}}

또한 클라이언트가 파일 시스템을 검사하지 못하게 막아야합니다: 

{{RootCmd|touch /fastboot
|echo "touch /fastboot" >> /etc/conf.d/local.start}}

클라이언트가 상당히 의존하는 {{Package|nfs-utils}} 꾸러미를 설치하십시오: 

{{Emerge|nfs-utils}}

부트로더가 남았습니다만, pxegrub을 이미 설치했으므로 다른 부트로더는 설치하지 마십시오. 설치를 마치고 서버를 재시작하기만 하면 됩니다. 클라이언트를 부팅할 때 필요한 서비스 DHCP, TFTPD, NFS를 시작하십시오. 

{{RootCmd|/etc/init.d/dhcp start
|/etc/init.d/in.tftpd start
|/etc/init.d/nfs start}}

=== 새 클라이언트 부팅 ===

새 클라이언트가 제대로 부팅하려면 BIOS를 설정하고 CD-ROM 또는 플로피 드라이브보다 네트워크 카드가 먼저 PXE 기능을 사용하여 부팅하도록 설정해야합니다. 이 과정의 도움을 받으려면 하드웨어 설명서 또는 제조사 웹사이트를 살펴보십시오. 네트워크 카드에서 DHCP를 통해 IP 주소를 가져오고 TFTP로 GRUB PXE 이미지를 가져와야합니다. 이 과정이 끝나면, 커널을 선택하고 엔터키를 누를 흑백의 멋진 GRUB 부팅 메뉴가 나타납니다. 모든 과정이 끝나면 커널 부팅을 진행하고, NFS로 루트 파일 시스템을 마운트하며 로그인 프롬프트가 뜹니다. 계속 즐기세요.

== 기존 리눅스 배포판에서 젠투 설치 ==

=== 요구 사항 ===

기존 리눅스 배포판에서 젠투를 설치하려면 chroot 명령을 설치하고 젠투 설치 타르볼 또는 설치하려는 ISO 이미지의 사본을 보유해야합니다. 타르볼이외에 더 많은 요소를 저장하려 한다면 네트워크 연결을 준비할 수 있습니다(헌데, 타르볼은 .tbz 또는 .tar.gz로 끝나는 파일입니다). 이제 과정을 시작하겠습니다! 

=== 간단히 살펴보기 ===

기존의 리눅스 분할 공간의 크기를 조절하여 젠투만의 공간을 우선적으로 할당하고, 분할 공간에 마운트하며, 타르볼을 마운트한 해당 분할 공간에 풀어놓고 가상 시스템으로 루트를 옮겨간 후 빌드를 시작하겠스빈다. 부팅 과정이 끝나면, 시스템의 최종 설정을 진행하여 부팅을 확인하고, 확인이 끝나면 재부팅을 진행하여 젠투를 활요하겠습니다. 

=== 젠투에 얼마나 많은 공간이 필요한가요? ===

루트 분할 공간은 {{Path|/}}에 마운트한 파일 시스템입니다. 필자의 시스템에서 {{c|mount}}를 간단하게 실행하는 모습을 보여드리면서 할 이야기를 진행하겠습니다. 또한 {{c|df}}(disk free) 도 활용하여 남은 공간이 얼마나 있는지 어떻게 여분의 공간을 조절할 지를 살펴보겠습니다. 참고로 루트 분할 공간을 조절하는건 필수가 아닙니다! 분할 공간 조절 도구에서 지원한다면 할 수 있지만, 이에 대해서는 나중에 언급하겠습니다. 

{{RootCmd|mount|output=<pre>
/dev/sdb2 on / type ext3 (rw)
none on /proc type proc (rw)
none on /dev/pts type devpts (rw,gid=5,mode=620)
none on /dev/shm type tmpfs (rw,nodev,nosuid,noexec)
</pre>}}

{{RootCmd|df -h|output=<pre>
Filesystem           Size Used Avail Use% Mounted on
/dev/sdb2            4.0G 1.9G  2.4G  82% /
none                  38M    0   38M   0% /dev/shm
</pre>
}}

보시는 바와 같이 {{Path|/}} 로 마운트 한 {{Path|/dev/sdb2}} 분할 공간에 2.4GB 남아있습니다. 이 경우 400MB 빈 공간이 남도록 다시 조절하여 2GB를 젠투용으로 사용하겠습니다. 여기에 뭔가 더 설치할 수 있으니 그다지 나쁘진 않습니다. 그러나, 대부분 사용자에게는 1GB는 충분하다고 봅니다. 그러니 이렇게 공간을 분할하겠습니다!

=== 파티션 크기를 조절할 parted 빌드 ===

{{Warning|이 장은 오래되었기 때문에 parted 버전이 한물 간 채로 젠투 포티지 트리에 남아있다면 제거하겠습니다. 분할 공간 재 조정 기능은 [https://www.gnu.org/software/parted/manual/html_node/Command-explanations.html 여기]<sup style="color:#ff0077">en</sup>에서 언급한 바와 같이 parted에서 제거했습니다.}}

{{Package|sys-block/parted}}는 GNU 재단에서 제공하는 유틸리티이며, 여러분이 이 과정에서 아주 잠깐 사용할, 오래되었고 훌륭한 거대 프로젝트입니다. 허나 이 도구는 이 순간 굉장히 쓸모가 있습니다. 분할 공간 편집기 <code>parted</code>는  [http://www.gnu.org/software/parted/ http://www.gnu.org/software/parted/]에서 가져올 수 있습니다.

{{Note|분할 공간을 조절하는 다른 여러가지 도구도 마찬가지로 존재하지만, 저자 본인은 PartitionMagic 또는 다른 프로그램이 이런 작업을 할 수 있을지 확신할 수 없으며, 관심도 없습니다. 되는지 안되는지 여부 확인은 독자 여러분이 할 일입니다.}}

Look up on that page the type of file system you want to resize and see if parted can do it. If not, you're out of luck, you will have to destroy some partition to make space for Gentoo, and reinstall back. Go ahead by downloading the software, install it. Here we have a problem. We want to resize our Linux root partition, therefore we must boot from a floppy disk a minimal Linux system and use previously-compiled parted copied to a diskette in order to resize {{Path|/}}. However, if you can unmount the partition while still in Linux you are lucky, you don't need to do what follows. Just compile parted and run it on an unmounted partition you chose to resize. Here's how I did it for my system. 

{{Important|여러분이 조절하고자 하는 분할 공간의 형식이 parted에서 지원하는지 확인하십시오!}}

Get the mininux boot/root disk (a 2.4-powered mini Linux distribution on a floppy - free of charge) from [http://mininux.free.fr/uk/ http://mininux.free.fr/uk/], create a floppy as suggested in the Documentation that accompanies the software package and insert a new floppy in the drive for the next step. 

{{Note|Note again that Linux is synonym of "There's one more way to do it". Your objective is to run parted on an unmounted partition so it can do its work. You might use some boot/root diskset other than mininux. You might not even need to do this step at all, ie. you might only have umount the filesystem you want to repartition in your Linux session and run parted on it.}}

{{RootCmd|mkfs.minix /dev/fd0|output=<pre>
480 inodes
1440 blocks
Firstdatazone=19 (19)
Zonesize=1024
Maxsize=268966912
</pre>
}}

We will now proceed with the build of parted. If it's not already downloaded and untarred, do so now and <code>cd</code> into the corresponding directory. Now run the following set of commands to build the utility and copy it to your floppy disk. 

{{RootCmd|mkdir /floppy
|mount -t minix /dev/fd0 /floppy
|export CFLAGS{{=}}"-O3 -pipe -fomit-frame-pointer -static"
|./configure
|make
|cp parted/parted /floppy
|umount /floppy }}

고생하셨습니다. 이제 재부팅한 후 분할 공간의 크기를 조절할 준비가 끝났습니다. GNU 웹 사이트의 parted 문서를 간단하게 훑어본 후에만 진행하십시오. 분할 공간 재조정은 큰 하드 드라이브의 경우 30분쯤 걸릴테니 충분히 기다리십시오. mininux 부트디스크(그냥 그대로 빼두십시오)로 재부팅하고, 로그인을 끝내면 위에서 만든 유틸리티 디스크를 통해 드라이브에 있는 디스크로 전환하고, {{Path|/floppy}}에서 <code>mount /dev/fd0 /floppy</code>를 입력하십시오. 플로피 드라이브로 이동하십시오. 이제 젠투 설치과정을 통해 재밌는 놈을 가지게 됐습니다. 이전 리눅스 시스템으로 재부팅하여 되돌아가십시오. 동작하고자 하는 드라이브에는 우리가 다시 조절하고자 하는 분할 영역이 있습니다. 예를 들어, {{Path|/dev/sda3}}의 크기를 조절하고 싶다면, 해당 드라이브는 {{Path|/dev/sda}}입니다. 

{{RootCmd|mount /dev/fd0 /floppy 
|cd /floppy
|./parted <drive>}}

{{Cmd|print|prompt=(parted) |output=<pre>
Disk geometry for /dev/sdb: 0.000-9787.148 megabytes
Disk label type: msdos
Minor    Start       End     Type      Filesystem  Flags
1          0.031   2953.125  primary   ntfs
3       2953.125   3133.265  primary   linux-swap
2       3133.266   5633.085  primary   ext3
4       5633.086   9787.148  extended
5       5633.117   6633.210  logical
6       6633.242   9787.148  logical   ext3</pre>}}

{{Cmd|help resize|prompt=(parted) |output=<pre>
(parted)  help resize 
  resize MINOR START END        resize filesystem on partition MINOR
  
        MINOR is the partition number used by Linux.  On msdos disk labels, the
        primary partitions number from 1-4, and logical partitions are 5
        onwards.
        START and END are in megabytes
</pre>}}

{{Cmd|resize 2 3133.266 4000.000|prompt=(parted) }}

{{Important| 좀 기다리십시오! 컴퓨터가 여전히 동작합니다! 정말 동작중인지는 하드디스크 드라이브 LED를 지겨보십시오. 2분에서 30분 가량 걸립니다.}}

Once you have resized, boot back into your old Linux as described. Then go to [[Handbook:X86/Installation/Disks|The Gentoo Handbook: Preparing the Disks]] and follow the instructions. When chrooting, use the following command to flush your environment: 

{{RootCmd|env -i HOME{{=}}$HOME TERM{{=}}$TERM chroot /mnt/gentoo /bin/bash
|/usr/sbin/env-update
|source /etc/profile}}

고생하셨쇼!

[[Category:Core system]] {{Migrated|originalauthors=Gerald Normandin Jr., Travis Tilley, Oleg Raisky, Alex Garbutt, Alexandre Georges, Magnus Backanda, Faust A. Tanasescu, Daniel Ahlberg, Sven Vermeulen, Ken Nowack, Tiemo Kieft, Benny Chuang, Jonathan Smith, nightmorph}}
