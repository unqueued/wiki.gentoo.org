<languages />


<div class="mw-translate-fuzzy">
{{Metadata|abstract=이 안내서는 대안 젠투 설치 방법을 담아둔 저장소를 의도하며, 특별한 설치 방법은 CDROM이 빠져있거나 CD로 부팅할 수 있는 컴퓨터와 같은 환경이 필요합니다.}}
</div>

<div class="mw-translate-fuzzy">
이 안내서는 대안 젠투 설치 방법을 담아둔 저장소를 의도하며, 특별한 설치 방법은 CDROM이 빠져있거나 CD로 부팅할 수 있는 컴퓨터와 같은 환경이 필요합니다.
</div>

<div class="mw-translate-fuzzy">
== 이 문서 정보 ==
</div>

<div class="mw-translate-fuzzy">
CD에서 부팅하는 표준 설치 방식으로 진행할 수 없을 경우(또는 이 방식이 싫다면)의 설명서를 이제 여기에 준비했습니다. 이 문서는 젠투 리눅스를 다른 방법으로 설치하는 방법을 보관해둔 내용을 필요한 이들에게 제공합니다. 또는 이 방식이 좋다면 유별난 설치 방법이 될 수 있습니다. 쓸만한 설치 방법을 찾았거나 젠투를 설치하는 재밌는 방법을 발견했다면, 망설이지 말고  [https://bugs.gentoo.org/ Bugzilla]에 알려주십시오.
</div>

== 스마트 부트매니저로 설치 CD 부팅 ==

<div class="mw-translate-fuzzy">
[http://btmgr.sourceforge.net/download.html http://btmgr.sourceforge.net/download.html]에서 스마트 부트매니저를 다운로드하십시오. 리눅스 소스 코드 또는 바이너리 형식, 윈도우 .exe 버전이 있으며, 여러가지 언어 꾸러미도 존재합니다. 그러나 지금 준비한 방식은 최신 버전의 NASM으로 소스코드를 컴파일할 수 없으므로 바이너리 형식을 사용하겠습니다.
</div> 

<div class="mw-translate-fuzzy">
소스 코드 꾸러미를 컴파일 하거나 바이너리를 취할 수 있습니다. 아래에서 보시는 바와 같이 부팅 가능한 플로피를 만드는 동안 활용할 수 있는 몇가지 선택지가 있습니다.
</div> 

<div class="mw-translate-fuzzy">
{{CodeBox|title=Smart BootManager 옵션|1=
sbminst [-t theme] [-d drv] [-b backup_file] [-u backup_file]
  
   -t theme       select the theme to be used, in which the theme could be:
                    us = English theme       de = German theme
                    hu = Hungarian theme     zh = Chinese theme
                    ru = Russian theme       cz = Czech theme
                    es = Spanish theme       fr = French theme
                    pt = Portuguese theme
  
   -d drv         set the drive that you want to install Smart BootManager on;
                  for Linux:
                    /dev/fd0 is the first floppy driver,
                    /dev/hda is the first IDE harddisk driver.
                    /dev/sda is the first SCSI harddisk driver.
                  for DOS:
                    0   is the first floppy drive
                    128 is the first hard drive;
  
   -c             disable CD-ROM booting feature;
  
   -b backup_file backup the data that will be overwritten for
                  future uninstallation;
  
   -u backup_file uninstall Smart BootManager, should be used alone;
  
   -y             do not ask any question or warning.
}}
</div>

{{c|sbminst}} 명령으로 부팅 플로피를 만드십시오:

{{RootCmd|sbminst -t us  -d /dev/fd0}}

{{Note|{{Path|fd0}}을 올바른 플로피 장치 이름으로 바꾸십시오.}}

이제 컴퓨터의 플로피 드라이브에 플로피 디스크를 넣고 마찬가지로 CD-ROM에 설치 CD를 넣은 다음 컴퓨터를 부팅하십시오. 

<div class="mw-translate-fuzzy">
Smart BootManager 대화 상자가 나타납니다. CDROM을 선택하고 {{Key|Enter}} (Return)키를 눌러 설치 CD로 부팅하십시오. 부팅이 끝나면 표준 설치 과정을 진행합니다.
</div> 

Smart BootManager에 대한 더 많은 도움말은 [http://btmgr.sourceforge.net/ http://btmgr.sourceforge.net/]에서 찾아보십시오.

== 비 젠투 LiveCD에서 설치 ==

=== 도입부 ===

{{Important|비 젠투 LiveCD로 인해 뭔가가 잘못되어, 문제를 고치거나, 해결할 수 없고, LiveCD 어디에든 도움이 될만한 문서를 찾을 수 없다면 젠투 개발자가 지원해드릴 수 없습니다. 오직 젠투 LiveCD를 사용하는 경우에만 공식적으로 지원합니다. 대체 설치 미디어를 사용하는 동안 문제에 휘말렸다면, [https://forums.gentoo.org/ 젠투 포럼] 커뮤니티를 방문하십시오.}}

<div class="mw-translate-fuzzy">
젠투에서 제공하는 CD 외에 다른 LiveCD로 부팅할 수 있습니다. 젠투를 컴파일하고 설치하는 동안 활용할 동작 환경을 제공합니다. 여기서 소개하는 절차를 통해서도 다른 LiveCD로 진행하는 상황과 마찬가지로 근본적인 동작을 해야합니다.
</div> 

<div class="mw-translate-fuzzy">
[http://distrowatch.com/search.php 목록]에 수많은 LiveCD가 있지만, [http://www.knoppix.org/ Knoppix]를 써보실겁니다. 완벽한 그래픽 데스크톱, 오피스 프로그램, 웹 브라우저, 게임 등 여러분을 바쁘게 만들어드릴 요건을 제공합니다. Knoppix는 x86 사용자용으로 제공하므로, 다른 아키텍처 머신 사용자라면 필요에 따라 다른 LiveCD를 찾아야합니다.
</div> 

{{Warning|젠투 시스템을 설치하는데 기다리는 동안 LiveCD의 내 폴더에 무언가를 저장했는지 확인하십시오. 젠투로 다시 부팅하면 저장한 내용은 사용할 수 없습니다. 중요한 파일은 하드디스크 또는 다른 컴퓨터에 저장하십시오!}}

=== 설치 절차 ===

LiveCD로 부팅하십시오. 터미널을 열고 {{c|su -}}를 실행하여 암호를 바꿀 수 있게 하십시오. CD의 루트 암호를 바꿀 수 있습니다. 이제 필요할 경우 원격 로그인을 목적으로 sshd 데몬을 설정할 수 있습니다. 다음, {{Path|/mnt/gentoo}} 마운트 지점을 만들어야합니다. 

{{RootCmd|mkdir /mnt/gentoo}}

이 시점에서 [[Handbook:AMD64/Installation/Disks/ko|디스크 준비]]에 있는 표준 설치 문서를 따라할 수 있습니다. 시스템에서 proc 시스템 마운트를 요청하면, 다음 명령을 대신 실행하십시오: 

{{RootCmd|mount -o bind /proc /mnt/gentoo/proc}}

<div class="mw-translate-fuzzy">
[[Handbook:AMD64/Installation/Stage/ko#.EC.8A.A4.ED.85.8C.EC.9D.B4.EC.A7.80_.ED.83.80.EB.A5.B4.EB.B3.BC_.EC.95.95.EC.B6.95_.ED.95.B4.EC.A0.9C|스테이지 타르볼 압축 해제]]에서 스테이지 타르볼을 압축 해제할 준비가 띁나면, 압축 해제한 스테이지에 강제할 적당한 그룹 ID를 확인하기 위해 다른 <tt>tar</tt> 명령을 사용해야합니다:
</div> 

{{RootCmd|tar --numeric-owner --xattrs -xvjpf stage3-*.tar.bz2 -C /mnt/gentoo }}

<div class="mw-translate-fuzzy">
우분투를 사용한다면, {{Path|/dev/shm}}은 {{Path|/run/shm}}의 심볼릭 링크임을 참고하십시오. (chroot한 경로에서) 이 위치를 바인딩하거나 tmpfs를 만들어야합니다. chroot를 실행하기 전에:
</div>

{{RootCmd|mount --rbind /run/shm /mnt/gentoo/run/shm}}

<div class="mw-translate-fuzzy">
이 방식은 파이썬에서 <code>sem_open()</code> 함수게 깨진걸로 나타내는 {{Bug|496328}}를 피하는 방편이며 포티지는 이를 오류로 보고합니다(기술적으로 이야기하자면 파이썬 설정을 계속하고 <code>POSIX_SEMAPHORES_NOT_ENABLED</code>값을 설정했다고 간주하여 빌드하지만 원하지 않는 파이썬 빌드 결과를 이끌어냅니다).
</div>

<div class="mw-translate-fuzzy">
 [[Handbook:AMD64/Installation/Base/ko|베이스 시스템 설치]]에서 스테이지 압축을 풀고 루트를 전환할 준비가 끝나면 다른 chroot 명령 순서를 따라야합니다. 이 순서를 따라야 환경 변수를 통해 올바른 설치를 진행하도록 보장합니다.
</div> 

{{Note|일부 LiveCD는 괴상한 환경 설정을 사용하기 때문에, 이런 상태를 정리하고 제대로 된 환경을 만들려면 {{c|env -i}}  옵션을 활용하십시오.}}

<div class="mw-translate-fuzzy">
{{RootCmd|chroot /mnt/gentoo /bin/env -i TERM{{=}}$TERM /bin/bash
|env-update
|source /etc/profile
|export PS1{{=}}"(chroot) $PS1"}}
</div>

<div class="mw-translate-fuzzy">
마지막으로 LiveCD에서 포티지 <var>FEATURES</var> 변수 설정이 동작하지 않음을 알아두십시오. 특히 <code>userpriv</code> 와 <code>usersandbox</code>를 확인하십시오. 오류를 발견했다면 <var>FEATURES</var>의 일부 또는 모든 설정 값을 비활성해보십시오.
</div>

== PXE 및 LiveCD의 kernel/initrd/squashfs를 활용한 무 디스크 설치 ==

이 방식은 iSCSI 또는 NFS 기반의 PXE 부팅보다 쉽습니다. TFTP를 통해 배포한 동일한 이미지 셋으로 여러대의 머신이 부팅할 수 있으며 HTTP 또는 기타 프로토콜을 통해 쉽게 확장할 수 있습니다.

Having a nice router or one capable of running open source firmware such as [https://lede-project.org/ LEDE], the successor to [https://openwrt.org/ OpenWRT], is one way to centralize TFTP and DHCP. Getting the firmware online could be an uphill battle, depending on your experience.

이미 이미지로 배포하는 페도라 같은 일부 기타 배포판에서는 라이브 또는 설치 CD를 부트스트래핑 해야 합니다. 젠투에는 해당하지 않습니다. 대신 사용자는 다음 과정을 거쳐야합니다.

<div class="mw-translate-fuzzy">
# kernel, initrd, [[SquashFS|squashfs]]를 라이브 CD에서 추출하고, 
# initrd를 패치한 다음,
# squashfs를 initrd에 합쳐 넣습니다.
</div>

Only then can a PXE based boot loader be configured that will load the images and boot into a live system.

There are different flavors of PXE, but all of them are going to need the kernel and initrd file, so let's create those files now. Download the [https://www.gentoo.org/downloads/ minimal installation CD]. Then, execute the following script as root. The new files '''initrd''' and '''kernel''' will be created in your specified output directory.


{{CodeBox|title=pxe-craft-initrd-kernel|lang=bash|<nowiki>
#!/bin/bash -xe
# Create kernel and initrd files from a Gentoo LiveCD (DVD?) for PXE boot.

print-usage() {
  echo "Usage: $0 <output-dir> <gentoo-iso>" >&2
}

# Example Invocation
# sudo ./gen-pxe-initrd-kernel pxe-boot-files ~/Downloads/install-amd64-minimal-20171228T214501Z.iso

outdir="$1"
image="$2"
tmp="$outdir/tmp"

if [ $(id -u) -ne "0" ]; then
  echo "You must run as root or with sudo. This is necessary for the loop mount" && 
  print-usage &&
  exit 2
fi

test -z "$outdir" -o -z "$image" && print-usage && exit 1
test -e "$tmp" && echo "Temporary path '$tmp' already exists." >&2 && exit 1

iso="$tmp/iso"
initrd="$tmp/initrd.dir"

# prepare directories
mkdir -p "$outdir" "$tmp" "$iso" "$initrd/mnt/cdrom"

# extract files from ISO image
mount -o ro,loop "$image" "$iso"
cp "$iso"/{image.squashfs,isolinux/gentoo,isolinux/gentoo.igz} "$tmp"
umount "$iso"

# rename kernel
mv "$tmp/gentoo" "$tmp/kernel"

# patch initramfs and add squashfs to it
xz -dc "$tmp/gentoo.igz" | ( cd "$initrd" && cpio -idv )
patch -d "$initrd" -p0 <<'EOF'
--- init.orig	2016-01-02 00:00:00.000000000 +0100
+++ init	2016-01-02 00:00:00.000000000 +0100
@@ -455,9 +455,9 @@
 		CHROOT=${NEW_ROOT}
 	fi
 
-	if [ /dev/nfs != "$REAL_ROOT" ] && [ sgimips != "$LOOPTYPE" ] && [ 1 != "$aufs" ]; then
-		bootstrapCD
-	fi
+#	if [ /dev/nfs != "$REAL_ROOT" ] && [ sgimips != "$LOOPTYPE" ] && [ 1 != "$aufs" ]; then
+#		bootstrapCD
+#	fi
 
 	if [ "${REAL_ROOT}" = '' ]
 	then
@@ -591,7 +591,7 @@
 		else
 			bad_msg "Block device ${REAL_ROOT} is not a valid root device..."
 			REAL_ROOT=""
-			got_good_root=0
+			got_good_root=1
 		fi
 	done
 
@@ -670,7 +670,7 @@
 	[ -z "${LOOP}" ] && find_loop
 	[ -z "${LOOPTYPE}" ] && find_looptype
 
-	cache_cd_contents
+	#cache_cd_contents
 
 	# If encrypted, find key and mount, otherwise mount as usual
 	if [ -n "${CRYPT_ROOT}" ]
EOF
cp "$tmp/image.squashfs" "$initrd/mnt/cdrom"
( cd "$initrd" && find . -print | cpio -o -H newc | gzip -9 -c - ) > "$tmp/initrd"

mv "$tmp"/{kernel,initrd} "$outdir"
rm -rf "$tmp"
</nowiki>}}


If you know what you're doing, you can be on your way! Enjoy Gentoo on PXE. Otherwise, see below for more directions depending on the PXE flavor you're using.

=== TFTP ===

This will be needed in tandem with a DHCP server for most PCs equipped with PXE boot. However, realize that you could use iPXE to boot without a TFTP or DHCP server! See [http://ipxe.org/ ipxe.org] for info on embedding scripts, chainloading, and manual booting. There are still merits to TFTP booting such as wide-range device support, so let's get to serving TFTP!

<div class="mw-translate-fuzzy">
{{Path|install-amd64-minimal-20151231.iso}}(또는 차이가 있다면 현재 버전으로) 이미지를 다운로드하십시오. {{Package|net-ftp/tftp-hpa}}를 설치하신 후,{{Path|/tftproot}}를 서비스 중인지 확인하시고 시작하십시오.
</div>

<div class="mw-translate-fuzzy">
이제 tftp 부팅 서비스를 준비했고 DHCP 서비스를 설정할 차례입니다. 동일한 머신에 DHCP 서버를 설정할 수 있습니다. 그냥 부팅한 머신을 연결했는지 확인만 하면 됩니다. 또는 기존 라우터의 설정을 조금 손보십시오.
</div> 

=== DHCP ===

Setting up a DHCP server on the same machine is possible - just make sure that the booted machines are connected to it. Or just tweak the configuration of an existing router.

<div class="mw-translate-fuzzy">
OpenWRT DHCP 서비스용 설정 예제는 다음과 같습니다:
</div>

<div class="mw-translate-fuzzy">
{{CodeBox|title=/etc/config/dhcp|
config boot linux                   
        option filename boot/grub/i386-pc/core.0
        option servername boot
        option serveraddress 84.246.161.86
}}
</div>

From here, directions will change depending on what flavor your PXE is (i.e. GRUB, iPXE). 


=== GRUB ===

After executing the '''pxe-craft-initrd-kernel''' script, run the following '''pxe-install-grub''' to output proper files into your tftp root directory.

{{CodeBox|title=pxe-install-grub|lang=bash|<nowiki>
#!/bin/bash -xe
# prepare boot data
 
print-usage() {
  echo "Usage: $0 -i [initrd-file] -k [kernel-file] <tftproot>" >&2
}
 
POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
 
case $key in
    -i|--initrd)
    initrd="$2"
    shift # past argument
    shift # past value
    ;;
    -k|--kernel)
    kernel="$2"
    shift # past argument
    shift # past value
    ;;
    *)    # unknown option
    POSITIONAL+=("$1") # save it in an array for later
    shift # past argument
    ;;
esac
done
set -- "${POSITIONAL[@]}" # restore positional parameters
 
tftproot="$1"
 
test ! -e "$initrd" && echo "initrd Not found" && print-usage && exit 1
test ! -e "$kernel" && echo "kernel Not found" && print-usage && exit 1
test -z "$tftproot" && echo "tftproot not specified" && print-usage && exit 1
                                                                          
echo "initrd:$initrd"
echo "kernel:$kernel"
echo "tftproot:$tftproot"
 
grub-mknetdir -v --net-directory="$tftproot"
cat > "$tftproot/boot/grub/grub.cfg" <<'EOF'
menuentry "Gentoo Live" {
    linux /boot/kernel root=/dev/ram0 init=/linuxrc loop=/image.squashfs looptype=squashfs cdroot=1 real_root=/
    initrd /boot/initrd
}
EOF
 
cp "$kernel" "$initrd" "$tftproot/boot"
</nowiki>}}


=== iPXE ===

Here are relevant stanzas for iPXE.

{{CodeBox|title=gentoo-pxe-boot|<nowiki>
#!ipxe                                                                    
menu THRONG OF BAZ                                                       
item --gap LAN
item gentoo Gentoo x86_64 minimal
 
:gentoo                                                                   
set g http://baz.com/ipxe/gentoo                                        
kernel ${g}/kernel root=/dev/ram0 init=/linuxrc loop=/image.squashfs looptype=squashfs cdroot=1 real_root=/
initrd ${g}/initrd                                                        
boot
</nowiki>}}

== PXE 부팅 방식 및 NFS로 무(無)디스크 설치 ==

=== 요구 사항 ===

PXE(Preboot eXecution Environment)는 PXE 기능을 갖춘 네트워크 인터페이스(와 PXE 지원 BIOS)로 컴퓨터를 부팅하는 방식입니다. 시스템의 네트워크 인터페이스 또는 BIOS에서 PXE 부팅을 지원하지 않는 경우, 블록 장치(CD 또는 USB)에서 부팅하는 방식처럼 PXE를 활용할 수 있습니다. 각각의 경우, 최소한의 부팅 환경은 PXE 지원 네트워크 카드 동작을 흉내냅니다([http://etherboot.org Etherboot/gPXE] 참조). 

=== 서버 베이스 설정 ===

디렉터리 만들기: 우선 해야할 일은 무 디스크 시스템을 저장할 디렉터리를 만드는것입니다. 만들 디렉터리의 이름은 {{Path|/diskless}} 이며, 디스크가 없는 클라이언트를 위한 공간입니다. 이후 이 설명서에서는, 동작하는 클라이언트를 'eta'라고 하겠습니다. 

<div class="mw-translate-fuzzy">
{{RootCmd|mkdir /diskless
|mkdir /diskless/eta
}}
</div>

<div class="mw-translate-fuzzy">
DHCP 및 TFTP 설정: 클라이언트는 DHCP로 부팅 정보를 가져오며 TFTP를 통해 필요한 모든 파일을 다운로드합니다.
</div> 

<div class="mw-translate-fuzzy">
dhcpd를 활용하려면 {{c|emerge dhcp}}만 실행하십시오(또는 다른 DHCP 서버를 원한다면 해당 서버를 이머지하십시오).  {{Path|/etc/conf.d/dhcpd}}에서 올바른 인터페이스를 지정했는지 확인하고, 기본적으로 필요한 사항을 설정하십시오. 여기까지 마무리가 끝나면, 다음 내용을 {{Path|/etc/dhcp/dhcpd.conf}}에 추가하십시오.
</div> 

<div class="mw-translate-fuzzy">
{{Note|{{Path|pxegrub}}에서는 클라이언트에 정적 IP 주소와 PXE 부팅 이미지 경로를 제공합니다. 클라이언트 이더넷 카드의 MAC 주소와 여러분이 사용할 클라이언트의 파일을 넣을 디렉터리를 바꾸어야합니다.}}
</div>

<div class="mw-translate-fuzzy">
{{FileBox|filename=dhcpd.conf|title=|lang=bash|1=
option option-150 code 150 = text ;
ddns-update-style none ;
host eta {
hardware ethernet 00:00:00:00:00:00;
fixed-address ip.add.re.ss;
option option-150 "/eta/boot/grub.lst";
filename "/eta/boot/pxegrub";
}
}}
</div>

<div class="mw-translate-fuzzy">
다음 {{Path|/etc/conf.d/net}}에 인터페이스를 설정하여 부팅할 때 삭제되지 않도록 해야 합니다. 방법은 {{Path|/usr/share/doc/openrc-*/net.example.bz2}} 파일을 참고하십시오.
</div> 

<div class="mw-translate-fuzzy">
{{FileBox|filename=/etc/conf.d/net|title=부팅시 인터페이스(예제에서는 eth0)를 다시 설정하지 않도록 확인|lang=bash|1=
config_eth0=( "noop" )
}}
</div>

TFTP에서는 {{Package|net-ftp/tftp-hpa}}를 이머지하십시오. {{Path|/etc/conf.d/in.tftpd}}에 다음 설정을 넣으십시오. 

{{FileBox|filename=in.tftpd|title=|lang=bash|1=
INTFTPD_PATH="/diskless"
INTFTPD_USER="nobody"
INTFTPD_OPTS="-u ${INTFTPD_USER} -l -vvvvvv -p -c -s ${INTFTPD_PATH}"
}}

<div class="mw-translate-fuzzy">
GRUB을 설치하십시오.
</div>

<div class="mw-translate-fuzzy">
{{RootCmd|emerge -av grub}}
</div>

<div class="mw-translate-fuzzy">
GRUB을 컴파일하고 나면 디스크가 없는 클라이언트의 부팅 디렉터리를 만드십시오.
</div>

{{RootCmd|grub2-mknetdir --net-directory{{=}}/diskless/eta}}

<div class="mw-translate-fuzzy">
무 디스크 클라이언트에 PXE 이미지를 복사하는 방식이 원래 방식이지만 해당 경로는 더이상 존재하지 않는 것 같습니다(?).
</div>

<div class="mw-translate-fuzzy">
{{RootCmd|mkdir /diskless/eta/boot|cp /usr/lib/grub/pxegrub /diskless/eta/boot/pxegrub}}
</div>

위 명령을 처리하고 나면 {{Path|grub.lst}} 설정 파일을 편집하십시오.

{{RootCmd|nano -w /diskless/eta/boot/grub.lst}}

<div class="mw-translate-fuzzy">
{{FileBox|filename=grub.lst|title=|lang=bash|1=
default 0
timeout 30
  
title=Diskless Gentoo
root (nd)
kernel /eta/bzImage ip=dhcp root=/dev/nfs nfsroot=ip.add.re.ss:/diskless/eta
  
# For the nfsroot option, the IP address is the one of the server and
the directory is the one where your diskless client files are located (on the server).
}}
</div>

<div class="mw-translate-fuzzy">
NFS 설정: NFS는 꽤 설정하기 쉽습니다. 유일하게 할 일은 {{Path|/etc/exports}} 설정 파일에 한 줄만 추가하는 것입니다:
</div> 

{{FileBox|filename=/etc/exports|title=|lang=bash|1=
/diskless/eta eta(rw,sync,no_root_squash)
}}

<div class="mw-translate-fuzzy">
호스트 업데이트: 지금은 요구사항에 따라 {{Path|/etc/hosts}} 파일을 수정하는 일이 중요합니다.
</div> 

<div class="mw-translate-fuzzy">
{{FileBox|filename=/etc/hosts|title=|lang=bash|1=
127.0.0.1 localhost
192.168.1.10 eta.example.com eta
192.168.1.20 sigma.example.com sigma
</pre>
}}
</div>

=== 서버에 시스템 만들기 ===

<div class="mw-translate-fuzzy">
기존 설치로부터 젠투 설치 과정을 알고 있다면 바로 다음 단계로 진행할 수 있다 하더라도 젠투 설치 CD로 서버를 재부팅하려 할 것입니다. [[Handbook:Main_Page/ko|젠투 핸드북]]에 언급한대로 표준 설치 절차를 따르겠지만 다음 차이점이 있습니다. 파일 시스템을 마운트할 때 ({{Path|/diskless}} 디렉터리를 만든 위치가 {{Path|sdaX}} 분할 공간) 다음 절차를 따르십시오. 모든 파일이 {{Path|/diskless/eta}} 디렉터리에 있으므로 다른 분할 공간에는 마운트할 필요가 없습니다.
</div>

{{RootCmd|mount /dev/sdaX /mnt/gentoo}}

{{Path|/diskless/eta}} 디렉터리에 모든 파일이 있기 때문에 다른 파티션은 굳이 마운트할 필요가 없습니다. 

<div class="mw-translate-fuzzy">
스테이지 타르볼 및 루트 전환: 이 예제에서는 스테이지 3 타르볼을 다룹니다. {{Path|/proc}} 을 무 디스크 디렉터리에 마운트하고 해당 디렉터리로 루트 위치를 전환하여 설치를 계속 진행합니다. 이 과정이 끝나면 커널 설정 과정에 도달하기 전까지 설치 설명서를 따르십시오.
</div> 

<div class="mw-translate-fuzzy">
{{Warning|스테이지 타르볼을 풀 위치를 신중하게 다루십시오. 기존 설치 결과물에 압축 해제시 덮어쓰기 하여 끝장을 내고 싶어하진 않을겝니다.}}
</div>

<div class="mw-translate-fuzzy">
{{RootCmd|cd /mnt/gentoo/diskless/eta/
|tar -xvjpf  /mnt/cdrom/gentoo/stage3-*.tar.bz2
|mount -t proc /proc /mnt/gentoo/diskless/eta/proc
|cp /etc/resolv.conf /mnt/gentoo/diskless/eta/etc/resolv.conf
|chroot /mnt/gentoo/diskless/eta/ /bin/bash
|env-update
|source /etc/profile}}
</div>

<div class="mw-translate-fuzzy">
커널 설정: 커널 설정시 {{c|make menuconfig}}를 실행할 경우 설치 방법상 추천하는 옵션과 함께 다음 옵션을 잊지 말고 활성화 하십시오.
</div> 

<div class="mw-translate-fuzzy">
{{KernelBox|title=무(無)디스크 설치시 필요한 옵션|<pre>
- Your network card device support
(In the kernel, *not* as a module!)
  
-*- Networking support --->  
  Networking options --->
    [*] TCP/IP networking
    [*] IP: kernel level autoconfiguration
    [*] IP: DHCP support
    [*] IP: BOOTP support
  
File systems --->
  [*] Network File Systems --->
    <*> NFS file system support
    [*] Provide NFSv3 client support
    [*] Root file system on NFS
</pre>}}
</div>

<div class="mw-translate-fuzzy">
앞서 pxegrub을 설정한 대로 ({{Path|/boot}}가 아닌) 루트를 전환한 위치에 커널을 저장하십시오. 다음 무 디스크 클라이언트의 {{Path|/etc/fstab}}을 설정하십시오.
</div> 

<div class="mw-translate-fuzzy">
{{FileBox|filename=/etc/fstab|title=|lang=bash|<pre>
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
</pre>
}}
</div>

<div class="mw-translate-fuzzy">
또한 클라이언트가 파일 시스템을 검사하지 못하게 막아야합니다:
</div> 

<div class="mw-translate-fuzzy">
{{RootCmd|touch /fastboot
|echo "touch /fastboot" >> /etc/conf.d/local.start}}
</div>

<div class="mw-translate-fuzzy">
클라이언트가 상당히 의존하는 {{Package|nfs-utils}} 꾸러미를 설치하십시오:
</div> 

<div class="mw-translate-fuzzy">
{{Emerge|nfs-utils}}
</div>

<div class="mw-translate-fuzzy">
부트로더가 남았습니다만, pxegrub을 이미 설치했으므로 다른 부트로더는 설치하지 마십시오. 설치를 마치고 서버를 재시작하기만 하면 됩니다. 클라이언트를 부팅할 때 필요한 서비스 DHCP, TFTPD, NFS를 시작하십시오.
</div> 

<div class="mw-translate-fuzzy">
{{RootCmd|/etc/init.d/dhcp start
|/etc/init.d/in.tftpd start
|/etc/init.d/nfs start}}
</div>

=== 새 클라이언트 부팅 ===

<div class="mw-translate-fuzzy">
새 클라이언트가 제대로 부팅하려면 BIOS를 설정하고 CD-ROM 또는 플로피 드라이브보다 네트워크 카드가 먼저 PXE 기능을 사용하여 부팅하도록 설정해야합니다. 이 과정의 도움을 받으려면 하드웨어 설명서 또는 제조사 웹사이트를 살펴보십시오. 네트워크 카드에서 DHCP를 통해 IP 주소를 가져오고 TFTP로 GRUB PXE 이미지를 가져와야합니다. 이 과정이 끝나면, 커널을 선택하고 엔터키를 누를 흑백의 멋진 GRUB 부팅 메뉴가 나타납니다. 모든 과정이 끝나면 커널 부팅을 진행하고, NFS로 루트 파일 시스템을 마운트하며 로그인 프롬프트가 뜹니다. 계속 즐기세요.
</div>

== 기존 리눅스 배포판에서 젠투 설치 ==

=== 요구 사항 ===

<div class="mw-translate-fuzzy">
기존 리눅스 배포판에서 젠투를 설치하려면 chroot 명령을 설치하고 젠투 설치 타르볼 또는 설치하려는 ISO 이미지의 사본을 보유해야합니다. 타르볼이외에 더 많은 요소를 저장하려 한다면 네트워크 연결을 준비할 수 있습니다(헌데, 타르볼은 .tbz 또는 .tar.gz로 끝나는 파일입니다). 이제 과정을 시작하겠습니다!
</div>

=== 간단히 살펴보기 ===

<div class="mw-translate-fuzzy">
기존의 리눅스 분할 공간의 크기를 조절하여 젠투만의 공간을 우선적으로 할당하고, 분할 공간에 마운트하며, 타르볼을 마운트한 해당 분할 공간에 풀어놓고 가상 시스템으로 루트를 옮겨간 후 빌드를 시작하겠스빈다. 부팅 과정이 끝나면, 시스템의 최종 설정을 진행하여 부팅을 확인하고, 확인이 끝나면 재부팅을 진행하여 젠투를 활요하겠습니다.
</div> 

=== 젠투에 얼마나 많은 공간이 필요한가요? ===

<div class="mw-translate-fuzzy">
루트 분할 공간은 {{Path|/}}에 마운트한 파일 시스템입니다. 필자의 시스템에서 {{c|mount}}를 간단하게 실행하는 모습을 보여드리면서 할 이야기를 진행하겠습니다. 또한 {{c|df}}(disk free) 도 활용하여 남은 공간이 얼마나 있는지 어떻게 여분의 공간을 조절할 지를 살펴보겠습니다. 참고로 루트 분할 공간을 조절하는건 필수가 아닙니다! 분할 공간 조절 도구에서 지원한다면 할 수 있지만, 이에 대해서는 나중에 언급하겠습니다.
</div> 

{{RootCmd|mount|output=<pre>
/dev/sdb2 on / type ext3 (rw)
none on /proc type proc (rw)
none on /dev/pts type devpts (rw,gid=5,mode=620)
none on /dev/shm type tmpfs (rw,nodev,nosuid,noexec)
</pre>}}

{{RootCmd|df -h|output=<pre>
Filesystem           Size Used Avail Use% Mounted on
/dev/sdb2            4.0G 1.9G  2.4G  82% /
none                  38M    0   38M   0% /dev/shm
</pre>
}}

<div class="mw-translate-fuzzy">
보시는 바와 같이 {{Path|/}} 로 마운트 한 {{Path|/dev/sdb2}} 분할 공간에 2.4GB 남아있습니다. 이 경우 400MB 빈 공간이 남도록 다시 조절하여 2GB를 젠투용으로 사용하겠습니다. 여기에 뭔가 더 설치할 수 있으니 그다지 나쁘진 않습니다. 그러나, 대부분 사용자에게는 1GB는 충분하다고 봅니다. 그러니 이렇게 공간을 분할하겠습니다!
</div>

=== 파티션 크기를 조절할 parted 빌드 ===

{{Warning|이 장은 오래되었기 때문에 parted 버전이 한물 간 채로 젠투 포티지 트리에 남아있다면 제거하겠습니다. 분할 공간 재 조정 기능은 [https://www.gnu.org/software/parted/manual/html_node/Command-explanations.html 여기]에서 언급한 바와 같이 parted에서 제거했습니다.}}

<div class="mw-translate-fuzzy">
{{Package|sys-block/parted}}는 GNU 재단에서 제공하는 유틸리티이며, 여러분이 이 과정에서 아주 잠깐 사용할, 오래되었고 훌륭한 거대 프로젝트입니다. 허나 이 도구는 이 순간 굉장히 쓸모가 있습니다. 분할 공간 편집기 <code>parted</code>는  [http://www.gnu.org/software/parted/ http://www.gnu.org/software/parted/]에서 가져올 수 있습니다.
</div>

<div class="mw-translate-fuzzy">
{{Note|분할 공간을 조절하는 다른 여러가지 도구도 마찬가지로 존재하지만, 저자 본인은 PartitionMagic 또는 다른 프로그램이 이런 작업을 할 수 있을지 확신할 수 없으며, 관심도 없습니다. 되는지 안되는지 여부 확인은 독자 여러분이 할 일입니다.}}
</div>

<div class="mw-translate-fuzzy">
페이지를 보시면 공간의 크기를 다시 조절할 파일 시스템 형식이 보이고 해당 공간 형식이 공간 조절이 가능한 형식인지 살펴볼 수 있습니다. 그렇지 않으면, 재수가 없는 상황이니 젠투를 설치할 공간을 만들려면 일부 공간을 박살내야 하고 다시 설치해야합니다. 프로그램을 다운로드하시고 설치하십시오. 여기서 문제를 만다게 됩니다. 리눅스 루트 분할 공간의 크기를 조절하여 최소한의 리눅스 시스템을 갖춘 플로피 디스크를 만들어야하고, {{Path|/}} 경로의 크기를 다시 조절할 앞서 컴파일한 parted를 디스켓에 복사하여 사용해야합니다. 그러나 리눅스에서 분할 공간의 마운트를 해제할 줄 안다면 정말 운이 좋은데 이 부분은 따라가지 않아도 됩니다. 그냥 parted를 컴파일하고 마운트 해제한 분할 공간에 대해 parted를 실행하면 됩니다. 여기서 저자의 시스템에 대해 어떻게 진행했는지 보여드리도록 하겠습니다.
</div> 

<div class="mw-translate-fuzzy">
{{Important|여러분이 조절하고자 하는 분할 공간의 형식이 parted에서 지원하는지 확인하십시오!}}
</div>

[http://mininux.free.fr/uk/ http://mininux.free.fr/uk/]에서 mininux 부트/루트 디스크(2.4 커널을 갖춘 플로피 디스크 미니 리눅스 배포판 - 꽁짜!)를 가져오시고 플로피 디스크를 프로그램 꾸러미에 딸려온 문서에서 제안한 대로 만든 후, 다음 과정을 위해 새 플로피 디스크를 드라이브에 넣으십시오. 

<div class="mw-translate-fuzzy">
{{Note|다시 언급하건대, 리눅스는 "할 수 있는 오만가지 수단이 있다"는 문장의 동의어입니다. 아직 마운트하지 않은 분할 공간상에서 parted를 실행하여 분할 공간을 동작하게 하는게 이 과정 진행의 목표입니다. mininux 외의 다른 부트/루트 디스크 셋을 사용할 수도 있습니다. 허나 이 과정이외에는 필요치 않습니다. 예를 들자면, 지금 조건에서는 파일 시스템의 마운트를 해제하고 이 파일 시스템의 공간을 리눅스 세션에서 재분할하며, 여기서 parted를 다시 실행하는 과정밖에 할 일이 없습니다.}}
</div>

{{RootCmd|mkfs.minix /dev/fd0|output=<pre>
480 inodes
1440 blocks
Firstdatazone=19 (19)
Zonesize=1024
Maxsize=268966912
</pre>
}}

<div class="mw-translate-fuzzy">
이제 빌드한 parted로 계속 진행하겠습니다. 아직 다운로드하고 압축을 해제하지 않았다면 이제 진행하시고 관련 디렉터리로 이동하십시오. 그러면 다음 명령 모음을 실행하여 유틸리티를 빌드하고 플로피디스크로 복사하겠습니다.
</div> 

{{RootCmd|mkdir /floppy
|mount -t minix /dev/fd0 /floppy
|export CFLAGS{{=}}"-O3 -pipe -fomit-frame-pointer -static"
|./configure
|make
|cp parted/parted /floppy
|umount /floppy }}

이제 재부팅한 다음 분할 영역 크기를 조절할 때입니다. GUI 웹사이트에 있는 parted 문서를 간단하게 훑어보신 다음에만 이 과정을 진행하십시오. 큰 하드 드라이브의 분할 영역 크기를 조절하는데 30분 이내의 시간이 걸리니 조금만 참으십시오. 시스템을 미니눅스 부팅 디스크로 다시 부팅하고, 로그인한 후, 위에서 만든 유틸리티 디스크로 바꾸십시오. 그 다음 {{c|mount /dev/fd0 /floppy}} 명령으로  {{Path|/floppy}} 디렉터리에 플로피 드라이브를 마운트하십시오. parted를 실행하여 분할 영역의 크기를 다시 조절할 수 있게 하십시오. 긴 과정이 끝나면 젠투 설치를 계속 진행하십시오. 이제 예전 리눅스 시스템으로 다시 부팅하여 돌아가십시오. 이제 가동할 드라이브에는 크기를 조절해야 하는 분할 영역이 들어있습니다. 예를 들면 크기를 조절해야 할 분할 영역이 {{Path|/dev/sda3}}이다, 그러면 드라이브는 {{Path|/dev/sda}}입니다. 

{{RootCmd|mount /dev/fd0 /floppy 
|cd /floppy
|./parted <drive>}}

{{Cmd|print|prompt=(parted) |output=<pre>
Disk geometry for /dev/sdb: 0.000-9787.148 megabytes
Disk label type: msdos
Minor    Start       End     Type      Filesystem  Flags
1          0.031   2953.125  primary   ntfs
3       2953.125   3133.265  primary   linux-swap
2       3133.266   5633.085  primary   ext3
4       5633.086   9787.148  extended
5       5633.117   6633.210  logical
6       6633.242   9787.148  logical   ext3</pre>}}

{{Cmd|help resize|prompt=(parted) |output=<pre>
(parted)  help resize 
  resize MINOR START END        resize filesystem on partition MINOR
  
        MINOR is the partition number used by Linux.  On msdos disk labels, the
        primary partitions number from 1-4, and logical partitions are 5
        onwards.
        START and END are in megabytes
</pre>}}

{{Cmd|resize 2 3133.266 4000.000|prompt=(parted) }}

<div class="mw-translate-fuzzy">
{{Important| 좀 기다리십시오! 컴퓨터가 동작합니다! 동작중인지 확인하려면 하드드라이브 LED를 확인하십시오. 2분에서 30분 가량 걸립니다.}}
</div>

<div class="mw-translate-fuzzy">
분할 공간의 크기 재조절이 끝나면, 설명한 바와 같이 이전 리눅스 시스템으로 다시 부팅하십시오. 그 다음 [[Handbook:X86/Installation/Disks/ko|젠투 핸드북: 디스크 준비]] 편으로 가서 절차를 따르십시오. 루트를 전환할 때, 다음 명령을 실행하여 환경 정보를 제거하십시오:
</div> 

<div class="mw-translate-fuzzy">
{{RootCmd|env -i HOME{{=}}$HOME TERM{{=}}$TERM chroot /mnt/gentoo /bin/bash
|/usr/sbin/env-update
|source /etc/profile}}
</div>

고생하셨습니다!

[[Category:Core system]] {{Migrated|originalauthors=Gerald Normandin Jr., Travis Tilley, Oleg Raisky, Alex Garbutt, Alexandre Georges, Magnus Backanda, Faust A. Tanasescu, Daniel Ahlberg, Ken Nowack, Tiemo Kieft, Benny Chuang, Jonathan Smith, nightmorph}}
