<languages />

<div class="mw-translate-fuzzy">
{{Metadata|abstract=nvidia-drivers는 nVidia 그래픽 카드용 상용 그래픽 드라이버입니다. 대신 사용하는 오픈 소스는 nouveau가 있습니다.}}
</div>

<div class="mw-translate-fuzzy">
{{Package|x11-drivers/nvidia-drivers}}는 엔비디아 그래픽 카드용 상용 그래픽 드라이버입니다. 대신 사용하는 오픈 소스는 [[nouveau]]가 있습니다.
</div>

<div class="mw-translate-fuzzy">
트리에 있는 {{Package|x11-drivers/nvidia-drivers}}는 엔비디아가 출시하며 리눅스 커널에 대응하여 빌드합니다. 카드와 엄청난 양의 데이터를 주고받는 바이너리 블롭이 들어 있습니다. 드라이버는 두 부분으로 나뉘는데 하나는 커널 모듈이고 다른 하나는 X11 드라이버 입니다. 두 부분은 단일 꾸러미에 들어있습니다. 엔비디아가 자체적으로 드라이버를 꾸러미에 담아두므로 드라이버를 설치하기 전에 어떤 드라이버 사용할지 선택해야 합니다.
</div>

<div class="mw-translate-fuzzy">
{{Package|x11-drivers/nvidia-drivers}} 꾸러미에는 엔비디아의 ''모든'' 카드를 지원하는 최신 드라이버와 카드가 얼마나 오래됐는지의 여부에 따라 다양한 버전이 들어있습니다. 어떤 카드를 사용하는지 감지하는 eclass를 사용하므로 적당한 버전을 설치합니다.
</div>

== USE flags ==
{{USEflag|package=x11-drivers/nvidia-drivers}}

== 하드웨어 호환성 ==

<div class="mw-translate-fuzzy">
{{Package|x11-drivers/nvidia-drivers}} 꾸러미에서는 다양한 엔비디아 카드를 지원합니다. 가지고 있는 카드에 따라 설치할 여러가지 버전이 존재합니다. 어떤 nvidia-drivers 버전을 사용해야 하는지에 대해서는 [http://www.nvidia.com/object/IO_32667.html 구형 드라이버란 무엇인가?] 라는 공식 엔비디아 문서를 보십시오. [http://www.nvidia.com/Download/Find.aspx 여기] 에서 제공하는 대화형 양식을 통해 꽤 괜찮은 방법으로 이 문서를 찾아 볼 수도 있습니다. 가지고 있는 그래픽 카드를 입력('제품 형식' 필드에 Legacy 옵션이 있습니다) 하면 양식 하단에서 지원하는 가장 최상의 버전을 찾을 수 있습니다.
</div>

<div class="mw-translate-fuzzy">
가지고 있는 카드가 구형 카드임을 확인했다면 {{Package|nvidia-drivers}}의 최근 릴리즈를 가려야 합니다. 예를 들자면:
</div>

If the card has been identified as a legacy card then mask the more recent releases of {{Package|nvidia-drivers}}, e.g.:

{{FileBox|filename=/etc/portage/package.mask|title=Masking drivers with version higher than 174|1=
>x11-drivers/nvidia-drivers-174
}}

젠투에서는 71.86.xx 버전을 제공하지 않음을 참고하십시오. 이 드라이버가 필요하다면 [[nouveau]] 드라이버를 사용하시는것이 낫습니다.

== Installation ==

<div class="mw-translate-fuzzy">
== 커널 ==
</div>

<div class="mw-translate-fuzzy">
위에 말한 바와 같이 엔비디아 커널 드라이버는 현재 설치한 커널에 대해 빌드하고 실행합니다. 모듈로 빌드하기 때문에 커널에서 모듈 불러오기를 지원해야 합니다 (하단 참조).
</div>

<div class="mw-translate-fuzzy">
커널 모듈(nvidia.ko)은 그래픽 칩을 다루는 상업용 부분(일반적으로 "바이너리 블롭"이라고 함)과 바이너리 블롭과 커널간을 실행 시간에 중재하는 오픈소스 부분("접착제"역할)이 있습니다. 함께 제대로 동작해야 하는데 그렇지 않으면 데이터 손실(커널 망가짐, X 프로그램에서 데이터를 저장하지 않은 채로 X 서버 깨짐)에 직면하고 심지어는 하드웨어 동작 실패 현상이 일어나기도 합니다(과열되거나 전원 관리 관련 문제가 떠오를 것입니다).
</div>

<div class="mw-translate-fuzzy">
=== 커널 호환성 ===
</div>

때때로 새 커널 릴리스에는 드라이버에 대한 내부 ABI가 바뀌는데, 모든 드라이버가 이 ABI를 사용하도록 즉시 바꾸어야 합니다. 오픈소스 드라이버에서는 특히 커널에 배포하는 드라이버의 경우 드라이버간의 호출 매개를 연결하는 전체적인 부분을 수정해야 함은 자명한 사실이며 커널의 다른 부분은 쉽게 검토해볼 수 있습니다. nvidia.ko와 같은 상업용 드라이버는 조금 다르게 동작합니다. 내부 ABI가 바뀌면 "붙어 있는 요소"를 거의 수정할 수 없는데 상업 코드 부분에서 사용하는 고착 부분을 어떻게 활용하는지 알 수 없기 때문입니다. 심지어 그럴싸하게 동작하도록 패치하고 난 후 지원하지 않는 새 커널에서 위험을 감수해가며 nvidia.ko를 실행하면, 데이터를 잃을 수 있고, 하드웨어가 망가질 수 있습니다.

<div class="mw-translate-fuzzy">
비호환 새 커널버전이 출시되면 당분간은 새로 지원하는 커널에 그대로 의지하는 것이 좋습니다. Nvidia 에서는 보통 사용하는데 적합하다고 간주하는 새 상업 릴리스를 준비하는데 몇 주가 걸립니다. 그냥 기다리십시오. 정말 필요하다면 nvidia-drivers 이빌드의 epatch_user 명령을 활용할 수 있습니다. 지원하지 않는 최신 커널 릴리즈에 맞춰 사용자가 패치할 수 있습니다. 참고로 nvidia-drivers 메인테이너나 nVidia 이 부분을 지원하지 않습니다. 하드웨어 보증이 날라가며, nVidia 만 버그를 제대로 발견할 수 있는 상업용 드라이버이기 때문에 젠투 메인테이너가 문제를 수정할 수 없고, 커널 메인테이너(젠투 및 업스트림)는 분명히 상업용 드라이버 또는 문제 상황으로 치달아 "꼬여버린" 시스템을 지원하지 않습니다.
</div>

<div class="mw-translate-fuzzy">
커널을 설정하는데 <tt>genkernel all</tt> 옵션을 사용했다면, 모든 항목이 설정되어 있습니다만, 그렇지 않다면 지원 기능을 활성화 했는지 커널 설정을 다시 확인하십시오:
</div>

{{KernelBox|title=Enable loadable module support|1=
[*] Enable loadable module support --->
}}

커널에서 ''Memory Type Range Register''도 활성화해야 합니다:

{{KernelBox|title=MTRR 지원 활성화|1=
Processor type and features --->
    [*] MTRR (Memory Type Range Register) support
}}

With at least some if not all driver versions it may also be required to enable VGA Arbitration and the IPMI message handler:

{{KernelBox|title=Enable VGA Arbitration|1=
Device Drivers --->
   Graphics support --->
      [*] VGA Arbitration
}}
{{KernelBox|title=Enable IPMI message handler|1=
Device Drivers --->
   Character devices --->
      [*] IPMI top-level message handler
}}

<div class="mw-translate-fuzzy">
또한 AGP 그래픽 카드를 보유하고 있다면, 추가적으로 커널에서 커널에 컴파일 하여 포함한 방식 또는 모듈로 <tt>agpgart</tt> 지원을 활성화 할 수 있습니다. 커널에 포함한 <tt>agpgart</tt>를 사용하지 않으면 드라이버에서는 <tt>NvAGP</tt>라는 자체 <tt>agpgart</tt> 구현체를 활용합니다. 어떤 시스템에서는 커널에 포함한 <tt>agpgart</tt>보다 더욱 우수한 성능을 보이며, 그렇지 않은 경우 그 반대의 성능을 보입니다. 여러분은 최상의 성능을 취하기 위해 드라이버를 시험해보려 할 것입니다. 무엇이 어떤지 확실하게 판단이 되지 않으면 커널에 있는 <tt>agpgart</tt>를 사용하십시오:
</div>

{{KernelBox|title=Enable agpgart support|1=
Device Drivers --->
   Graphics support --->
      -*- /dev/agpgart (AGP Support) --->
}}

<div class="mw-translate-fuzzy">
{{Note|amd64에서는 IOMMU가 agpgart 설정을 관리합니다.}}
</div>

{{Important|For x86 and AMD64 processors, the in-kernel [[framebuffer]] driver conflicts with the binary driver provided by NVIDIA. When compiling the kernel for these CPUs, completely remove support for the in-kernel driver as shown:
{{KernelBox|title=Disable support for the in-kernel driver|1=
Device Drivers --->
    Graphics support --->
        Frame buffer Devices --->
            <*> Support for frame buffer devices --->
            < >   nVidia Framebuffer Support
            < >   nVidia Riva support
}}
Now make sure the nouveau driver is disabled:
{{KernelBox|
Device Drivers  --->
    Graphics support  --->
        < > Nouveau (nVidia) cards
}}
}}

A framebuffer alternative is [[uvesafb]], which can be installed parallel to {{Package|x11-drivers/nvidia-drivers}}. 

{{Important|For x86 and AMD64 processors, the [[uvesafb]] driver conflicts with the binary driver provided by NVIDIA above 361.28 versions.}}

For (U)EFI systems, uvesafb will not work. Be warned that enabling ''efifb'' support in kernel (<code>CONFIG_FB_EFI=y</code>) causes intermittent problems with the initialization of the NVIDIA drivers. There are reports of success from marking legacy framebuffers as generic and enabling the simple framebuffer while disabling all others:

{{KernelBox|title=Enable simple framebuffer|1=
Bus options (PCI etc.)  --->
   [*] Mark VGA/VBE/EFI FB as generic system framebuffer
Device Drivers --->
   Graphics support --->
        Frame buffer Devices --->
            [*] Simple framebuffer support
}}

The '''nvidia-drivers''' ebuild automatically discovers the kernel version based on the {{Path|/usr/src/linux}} symlink. Please ensure that this symlink is pointing to the correct sources and that the kernel is correctly configured. Please refer to the "Configuring the Kernel" section of the [[Handbook:Main_Page|Gentoo Handbook]] for details on configuring the kernel.

First, choose the right kernel source using {{c|eselect}}. When using {{Package|sys-kernel/gentoo-sources}} version 3.7.10 for instance, the kernel listing might look something like this:

{{RootCmd|eselect kernel list|output=<pre>
Available kernel symlink targets:
  [1]   linux-3.7.10-gentoo *
  [2]   linux-3.7.9-gentoo
</pre>}}

In the above output, notice that the linux-3.7.10-gentoo kernel is marked with an asterisk (<code>*</code>) to show that it is the kernel that the symbolic link points to.

If the symlink is not pointing to the correct sources, update the link by selecting the number of the desired kernel sources, as in the example above.

{{RootCmd|eselect kernel set 1}}

== Configuration ==

<div class="mw-translate-fuzzy">
== 드라이버 ==
</div> 

이제 드라이버를 설치할 차례입니다. 먼저 [[Xorg/Guide|X서버 설정 안내서]]를 따른 후, {{Path|/etc/portage/make.conf}}에 <code>VIDEO_CARDS="nvidia"</code> 설정을 넣으십시오. 그러면 X 서버를 설치할 때 올바른 버전의 {{Package|x11-drivers/nvidia-drivers}}를 알아서 설치합니다.

<div class="mw-translate-fuzzy">
{{Note/ko|{{Path|/etc/portage/make.conf}}에 '''gtk''' USE 플래그를 설정하여 드라이버를 설치할 수 있습니다. 이렇게 설치하면 {{Package|media-video/nvidia-settings}}를 함께 설치하는데 이 꾸러미는 nVidia 카드의 전반적인 측면을 보고 설정할 수 있게 하는 간편한 그래픽 도구입니다.}}
</div>

<div class="mw-translate-fuzzy">
{{Important/ko|[[Kernel/Upgrade/ko|새 커널 컴파일]]을 하거나 현재 커널을 컴파일 하는 언제든지, nVidia 커널 모듈을 다시 설치해야 합니다. 이빌드로 설치한 ({{Package|x11-drivers/nvidia-drivers}}같은)모듈을 쉽게 다시 빌드하려면 {{c|emerge @module-rebuild}}를 실행하십시오.}}
</div>

<div class="mw-translate-fuzzy">
설치가 끝나면, {{c|modprobe nvidia}}를 실행하여 메모리로 커널 모듈을 불러내십시오. 업그레이드라면 이전 모듈을 먼저 제거해야 합니다.
</div>

{{RootCmd
|lsmod {{!}} grep nvidia
|rmmod nvidia
|modprobe nvidia
}}

<div class="mw-translate-fuzzy">
부팅할 때마다 모듈을 수동으로 하나하나 불러오는 일을 피하려 시스템을 매번 부팅할 때 자동으로 처리하려 할테니, {{Path|/etc/conf.d/modules}}를 편집하여 <code>nvidia</code>를 추가하십시오.
</div>

<div class="mw-translate-fuzzy">
{{Important/ko|<code>agpgart</code>를 모듈로 컴파일하면, 마찬가지로 {{Path|/etc/conf.d/modules}}에 추가해야 합니다.}}
</div>

=== Kernel module signing (optional) ===

{{Note|The information in this section in unnecessary for systems that do not implement signed kernel modules. Feel free to skip it.}}

If secure boot kernel signing is used, then the NVIDIA kernel modules need to be signed before they can be loaded.

This can be accomplished by using the kernel-provided {{c|perl}} script as follows.

{{RootCmd|/usr/src/linux/scripts/sign-file sha512 /usr/src/linux/certs/signing_key.priv /usr/src/linux/certs/signing_key.x509 /lib/modules/Kernel-Version-modules-path/video/nvidia-uvm.ko}}

{{RootCmd|/usr/src/linux/scripts/sign-file sha512 /usr/src/linux/certs/signing_key.priv /usr/src/linux/certs/signing_key.x509 /lib/modules/Kernel-Version-modules-path/video/nvidia.ko}}

As of driver version 358.09 a new module has been made to handle monitor mode setting and for this driver version this module must also be signed.

{{RootCmd|/usr/src/linux/scripts/sign-file sha512 /usr/src/linux/certs/signing_key.priv /usr/src/linux/certs/signing_key.x509 /lib/modules/Kernel-Version-modules-path/video/nvidia-modeset.ko}}

Once the modules are signed, the driver will load as expected on boot up. This module signing method can be used to sign other modules too - not only the nvidia-drivers. Just modify the path and corresponding module accordingly.

=== The X server ===

Once the appropriate drivers are installed, configure the X server to use the <code>nvidia</code> driver instead of the default <code>nv</code> driver.

{{VIDEO_CARDS/xorg.conf|nvidia}}

Run {{c|eselect}} so that the X server uses the NVIDIA GLX libraries:

{{RootCmd|eselect opengl set nvidia}}

=== Permissions ===

{{VIDEO_CARDS/Permissions|nvidia}}

=== Enabling global nvidia support ===

Some tools, such as {{Package|media-video/mplayer}} and {{Package|media-libs/xine-lib}}, use a local USE flag called <code>xvmc</code> which enables XvMCNVIDIA support, useful when watching high resolution movies. Add in <code>xvmc</code> in the USE variable in {{Path|/etc/portage/make.conf}} or add it as USE flag to {{Package|media-video/mplayer}} and/or {{Package|media-libs/xine-lib}} in {{Path|/etc/portage/package.use}}.

GeForce 8 series and later GPUs do come with VDPAU support which superseded XvMCNVIDIA support. See the [[VDPAU]] article for enabling VDPAU support.

There are also some applications that use the <code>nvidia</code> USE flag, so it might be a good idea to add it to {{Path|/etc/portage/make.conf}}.

Then, run {{c|emerge -uD --newuse @world}} to rebuild the applications that benefit from the USE flag change.

=== Using the nVidia settings tool ===

NVIDIA also provides a settings tool. This tool allows the user to monitor and change graphical settings without restarting the X server and is available through Portage as part of {{Package|x11-drivers/nvidia-drivers}} with the <code>tools</code> USE flag set.

=== OpenGL/OpenCL 활성화 ===

To enable OpenGL and OpenCL though the device, run:

{{RootCmd
|eselect opengl set nvidia
|eselect opencl set nvidia
}}

Make sure that the Xorg server is not running during these changes.

== Usage ==

<div class="mw-translate-fuzzy">
== 카드 시험하기 ==
</div>

<div class="mw-translate-fuzzy">
nVidia 카드를 시험하려면, X를 실행 후 {{Package|x11-apps/mesa-progs}} 꾸러미에 있는 {{c|glxinfo}}를 실행하십시오. 이 프로그램에서 DRM을 활성화했는지 나와야 합니다:
</div>

{{Cmd|glxinfo {{!}} grep direct|output=<pre>
direct rendering:  Yes
</pre>}}

<div class="mw-translate-fuzzy">
FPS를 확인하려면 {{c|glxgears}}를 실행하십시오.
</div>

== 문제 해결 ==

<div class="mw-translate-fuzzy">
* {{Bug|nvidia-drivers|search=package}}
</div>

=== FATAL: modpost: GPL-incompatible module *.ko uses GPL-only symbol ===

When the ebuild is complaining about the 'mutex_destroy' GPL-only symbol:

{{RootCmd|emerge nvidia-drivers|output=<pre>
FATAL: modpost: GPL-incompatible module nvidia.ko uses GPL-only symbol 'mutex_destroy' 
</pre>}}

Be sure to disable <var>CONFIG_DEBUG_MUTEXES</var> in the kernel's {{Path|.config}} file, as suggested by [https://forums.gentoo.org/viewtopic-p-7964326.html this forum thread].

== MSI 인터럽트를 활성화 하면 드라이버 초기화에 실패하네요 ==

리눅스 NVIDIA 드라이버는 메시지 신호 인터럽트(MSI)를 기본으로 사용합니다. 이 기능은 호환성과 확장성의 장점을 제공하는데, 주된 이유라면 IRQ 공유를 막기 위해서입니다. 어떤 시스템에서는 가상 연결 인터럽트로 제대로 동작하지만, 일부 시스템에서는 MSI 지원에 문제가 있어보입니다. 이 문제는 NVIDIA 드라이버로 X를 시작하는데 있어서 불가능한 것으로 보이며, 또는 CUDA 초기화 문제로 보이기도 합니다.

MSI 인터럽트는 NVIDIA 커널 모듈 매개변수에 <code>NVreg_EnableMSI=0</code> 값을 부여하여 비활성화 할 수 있습니다. 이 값은 모듈을 불러오는 과정에서, 또는 배포본에서 제공하는 커널 모듈 설정 파일({{Path|/etc/modprobe.d/}} 같은 디렉터리에 있음)에서 설정할 수 있습니다.

예를 들자면:

<div class="mw-translate-fuzzy">
{{FileBox|filename=/etc/modprobe.d/nvidia.conf|title=nVidia NVreg_EnableMSI 설정|1=<nowiki>
# Nvidia drivers support
alias char-major-195 nvidia
alias /dev/nvidiactl char-major-195
  
# To tweak the driver the following options can be used, note that
# you should be careful, as it could cause instability!! For more 
# options see /usr/share/doc/nvidia-drivers-337.19/README 
#
# !!! SECURITY WARNING !!!
# DO NOT MODIFY OR REMOVE THE DEVICE FILE RELATED OPTIONS UNLESS YOU KNOW
# WHAT YOU ARE DOING.
# ONLY ADD TRUSTED USERS TO THE VIDEO GROUP, THESE USERS MAY BE ABLE TO CRASH,
# COMPROMISE, OR IRREPARABLY DAMAGE THE MACHINE.
options nvidia NVreg_DeviceFileMode=432 NVreg_DeviceFileUID=0 NVreg_DeviceFileGID=27 NVreg_ModifyDeviceFiles=1 NVreg_EnableMSI=0
</nowiki>}}
</div>

=== 4GB 이상 용량의 메모리를 가진 머신에서 2D 가속 활성화하기 ===

<div class="mw-translate-fuzzy">
nVidia 2D 가속에 문제가 있다면 MTRR의 write-combining 범위를 설정할 수 없는 경우일지도 모릅니다. 원인을 확인하려면  다음 명령으로 {{Path|/proc/mtrr}}의 내용을 확인하십시오:
</div>

{{RootCmd|cat /proc/mtrr}}

<div class="mw-translate-fuzzy">
모든 줄에 <tt>write-back</tt> 또는 <tt>write-combining</tt>이 있어야 합니다. <tt>uncachable</tt>이 있다면, 이 문제를 고치기 위해 BIOS 설정을 바꾸어야 합니다.
</div>

<div class="mw-translate-fuzzy">
다시 부팅하고 BIOS로 들어가신 다음 MTRR 설정을 찾으십시오(아마 "CPU 설정"에 있을겁니다). <tt>continuous</tt>에서 <tt>discrete</tt>로 설정을 바꾸고 리눅스로 돌아가십시오. 더이상 <tt>uncachable</tt>이 없고, 튐 현상 없이 2D 가속이 잘 동작하는걸 보실 수 있습니다.
</div>

=== 커널 모듈을 불러오려는데 "no such device" 메시지를 받았습니다 ===

보통 다음 문제 중 하나가 원인입니다:

<div class="mw-translate-fuzzy">
# 어쨌거나 nVidia 카드를 가지고 있지 않습니다. {{c|lspci}} 출력을 보고 nVidia 그래픽 카드를 설치했고 감지했는지 확인하십시오.
# 현재 설치한 {{Package|x11-drivers/nvidia-drivers}} 버전이 설치한 그래픽 카드 모델을 지원하지 않습니다. {{Path|/usr/share/nvidia-drivers-*/}}의 README에서 지원 장치 목록을 확인하거나 [http://www.geforce.com/drivers http://www.geforce.com/drivers]에서 드라이버를 검색하십시오.
# 다른 커널 드라이버에 하드웨어 제어 기능이 있습니다. "nouveau"와 같은 드라이버가 그래픽 카드를 다루고 있는지 {{c|lspci -k}} 명령으로 확인하십시오. 만약 이 상황이라면 비활성화하거나 이 드라이버를 블랙 리스트에 넣으십시오.
</div>

=== Xorg 에서 어떤 화면도 찾을 수 없다고 함 ===

컴퓨터를 부팅하고나서 GUI 화면 대신 어두컴컴한 화면이나 콘솔 프롬프트로 돌아가는 경우가 있습니다. GUI로 부팅하지 못했을 때 {{Key|Ctrl}}+{{Key|Alt}}+{{Key|F2}}키를 눌러서 가상 콘솔로 갈 수 있습니다. 그런 후 다음 명령을 실행하십시오:

<div class="mw-translate-fuzzy">
{{RootCmd| /etc/init.d/xdm stop}}
</div>

{{Cmd| startx}}

{{Cmd| startx}}를 실행하여 Xorg 출력을 살펴보십시오. 처음 나타나는 오류가 Xorg에서 어떤 화면도 찾을 수 없다는 문제라면, 이 문제를 해결하기 위해 다음 단계를 따르십시오.

다시 부팅하기 전에 다음 명령을 확실하게 실행해야 합니다:

<div class="mw-translate-fuzzy">
{{Cmd| /opt/bin/nvidia-xconfig}}
</div>

<div class="mw-translate-fuzzy">
동작하지 않으면, {{c|lspci}}를 실행하여 다음과 같이 비디오 카드가 시작되는 내용을 찾아야 합니다:
</div>

{{RootCmd|lspci|output=<pre>
 . . .
01:00.0 VGA compatible controller: make and model of videocard
 . . . 
</pre>
}}

처음 부분 <code>01.00.0</code>을 찾아서 {{Path|/etc/X11/xorg.conf}} 의 <code>BusID</code> 옵션에 넣으십시오:

<div class="mw-translate-fuzzy">
{{FileBox|filename=/etc/X11/xorg.conf|lang=xorg_conf|1=
# this is not the whole file, only the part that needs edited
# the file should already exist after running nvidia-xconfig
 
Section "Device"
    Identifier     "Device0"
    Driver         "nvidia"
    VendorName     "NVIDIA Corporation"
    BusID          "PCI:1:0:0"
EndSection
}}
</div>

=== 직접 렌더링이 활성화되지 않아요 ===

직접 렌더링이 동작하지 않는다면, 드라이버와 충돌하게끔 커널에서 직접 렌더링 관리자를 활성화했기 때문일 수도 있습니다. [[#.EC.B9.B4.EB.93.9C_.EC.8B.9C.ED.97.98.ED.95.98.EA.B8.B0|카드 시험하기]] 장의 절차를 따라 직접 렌더링 상태를 볼 수 있습니다.

먼저 직접 렌더링 관리자(<code>CONFIG_DRM</code>)를 커널에서 비활성화 하십시오:

{{KernelBox|title=직접 렌더링 관리자(DRM) 비활성화|1=
Device drivers --->
    Graphics support --->
        < > Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)
}}

그리고 커널 DRM 심볼에 대해 드라이버를 빌드했을터이니 {{Package|x11-drivers/nvidia-drivers}}를 다시 빌드하십시오. 이리 하면 문제를 해결할 수 있습니다.

=== 동영상 재생이 버벅거리고 느린데요 ===

<div class="mw-translate-fuzzy">
최근 NVidia 바이너리 드라이버에서 느린 동영상 재생이라든지 점진적으로 버벅이는 현상을 야기하여 몇가지 형식의 동영상 재생이 멈추는 것 같습니다. 이 문제는 아마도 일부 CPU에서 일반적인 ACPI CPU 대기 정책 대신에 인텔 CPU 전력 대기 정책으로 대신 처리 과정에서  발생하는 것 같습니다.
</div>

<div class="mw-translate-fuzzy">
커널 명령줄 부팅 방식에 <code>intel_idle.max_cstate=0</code> 설정을 사용하여 이전 ACPI CPU 대기 정책을 대신 사용하도록 인텔 CPU 대기 정책을 끄십시오. 또한 NVidia Powermizer 기능을 끄든지 <tt>nvidia-settings</tt>에서 안내하는 바와 같이 최대 성능으로 설정하십시오. 인텔 CPU 대기 정책을 최근 기본으로 도입했지만, i5 CPU와 i7 CPU용 (ACPI CPU 대기 정책에 대응하여) CPU 대기 정책은 이 시점에서 근본 원인으로 지목됩니다. 이러한 대기 정책은 상당히 눈에 띄도록 문제를 해결하지만, 디인터레이싱을 활성화하면 일부 미새한 버벅임이라든지, 느린 동영상 재생이 나타납니다. 이 현상은, 그러니까, 동영상을 이미 디인터레이싱 했을 경우에 나타나는 것 같습니다(예를 들자면 {{c|mplayer -vo vdpau:deint=0:denoise=0:nochroma-deint:colorspace=0:hqscaling=1, video.mpg}}와 유사한 {{c|mplayer-nodeint}} 명령으로 회피하시면 됨).
</div>

If you're using GRUB2 as your bootloader, you can add this kernel parameter to <code>/etc/default/grub</code> like so:
{{FileBox|filename=/etc/default/grub|title=Adding intel_idle.max_cstate kernel parameter in GRUB2|1=
GRUB_CMDLINE_LINUX_DEFAULT="intel_idle.max_cstate=0"
}}
Don't forget to run <code>grub-mkconfig -o /boot/grub/grub.cfg</code> after making the change, so that the new configuration is generated (see [https://wiki.gentoo.org/wiki/GRUB2#Main_configuration_file the GRUB2 page] for further details).

After you have rebooted, you can verify that the change is active:
{{Cmd|cat /sys/module/intel_idle/parameters/max_cstate <pre>
0</pre>}}

=== No vertical synchronization (no VSync, tearing) in OpenGL applications ===

Adding the following option to the screen section prevents tearing on GTX 660, 660 Ti, and probably some other GPUs ([https://devtalk.nvidia.com/default/topic/543305/linux/screen-video-tearing-gtx6xx-7xx-kepler-9xx-maxwell-in-almost-all-applications-including-desktop/post/3958593/ reference]):

{{FileBox|filename=/etc/X11/xorg.conf|1=
Section "Screen"
     . . .
    Option         "metamodes" "nvidia-auto-select +0+0 { ForceFullCompositionPipeline = On }"
     . . .
EndSection
}}

== 전문가 설정 ==

=== 문서 ===

 {{Package|x11-drivers/nvidia-drivers}} 꾸러미에는 실용적인 문서가 있습니다. 이 문서는 {{Path|/usr/share/doc}}에 있으며 다음 명령으로 살펴볼 수 있습니다:

{{Cmd|less /usr/share/doc/nvidia-drivers-*/README.bz2}}

=== 커널 모듈 매개 변수 ===

<div class="mw-translate-fuzzy">
<tt>nvidia</tt> 커널 모듈은 드라이버의 동작을 세밀하게 설정할 수 있는 몇가지 매개 변수(옵션)를 받아들입니다. 대부분 이 매개 변수 설명은 문서에 있습니다. 이 매개 변수의 값을 추가하거나 바꾸려면 {{Path|/etc/modprobe.d/nvidia.conf}} 파일을 편집하십시오. 이 파일을 편집한 다음 {{c|update-modules}}실행을 잊지 마시고, 새 설정을 적용하기 전에 <code>nvidia</code> 모듈을 다시 불러와야 함도 잊지 마십시오.
</div>

{{Warning|Pay close attention to this section as these kernel options can enable features that the hardware may or may not support. These options are not forgiving, so be careful with the parameters. Do not made any changes without validating and double-checking that the change is needed.}}

{| class="table table-condensed table-striped"
|-
! Attribute !! Default !! Description
|-
| <code>NVreg_DeviceFileUID</code> || <code>0</code> || Modify the user ID for the device file. The default value sets it to the {{c|root}} user. Setting this to another user ID will make the driver module create the device file with access available to that user ID.
|-
| <code>NVreg_DeviceFileGID</code> || <code>27</code> || Modify the Group ID for the device file. The default value sets it to the {{c|video}} group.
|-
| <code>NVreg_DeviceFileMode</code> || Undefined || Set the permissions for the device file. A value of 0660 grants the owner and group-owner read-write access while other users cannot access the device file.
|-
| <code>NVreg_ModifyDeviceFiles</code> || <code>1</code> || Instruct the driver to enable or disable dynamic device file management.
|-
| <code>NVreg_EnablePCIeGen3</code> || <code>0</code> || Enable PCIe Gen 3.x support. If the system supports this 8GT high speed bus then enable it with this module option flag. When this is enabled but the system does not support Gen 3.0, the behavior of the system can become irratic and unstable. Some have even reported damage to hardware enabling this when it is not properly supported. By default the Nvidia driver is set to use PCIe Gen 2.x for compatibility reasons.
|-
| <code>NVreg_UsePageAttributeTable</code> || <code>0</code> || This is one of the latest and newest additions to the Nvidia driver modules option. It allows the driver to take full advantage of the PAT technology - a newer way of allocating memory, replacing the older Memory Type Range Register (MTRR) method. The PAT method creates a partition type table at a specific address mapped inside the register and utilizes the memory architecture and instruction set more efficiently and faster. If the computer supports PAT and the feature is enabled in the kernel then this flag can be enabled. Without PAT support, users may experience unstable performance and even crashes if this is enabled. So be careful with these options.
|-
| <code>NVreg_EnableVia4x</code> || <code>0</code> || Enable AGP 4x mode in the the NVIDIA driver on Via-chipset-powered systems. Some of these hardware configurations would not work properly in AGP 4x mode when others would. The default leaves it at AGP 2x mode.
|-
| <code>NVreg_EnableALiAGP</code> || <code>0</code> || On ALi1541 and ALi1647 chipsets, AGP support is by default disabled by the NVIDIA drivers. The value specifies the speed factor to use, so the values 1, 2, 4 and 8 represent AGP 1x, 2x, 4x and 8x respectively. NVIDIA does not recommend changing the value as it may lead to unstable systems.
|-
| <code>NVreg_ReqAGPRate</code> || Unspecified || Forces the AGP mode on the driver. For instance, a value of 1 means AGP 1x, while a value of 4 means AGP 4x.
|-
| <code>NVreg_NvAGP</code> || || Changes the AGP Gart mode setting. Possible values are: <code>0</code> (Disable), <code>1</code> (Enable using NVIDIAs internal AGP-Gart), <code>2</code> (Enable using the Linux kernel AGP-Gart) and <code>3</code> (Enable and use any available, but try th NVIDIA internal one first).
|-
| <code>NVreg_EnableAGPSBA</code> || <code>0</code> || Disables (<code>0</code>) or enables (<code>1</code>) AGP Side Banding. For stability reasons, the setting is by default disabled, but the setting can be enabled for testing and debugging purposes. This is not supported by NVIDIA though.
|-
| <code>NVreg_EnableAGPFW</code> || <code>0</code> || Enables AGP Fast-Writes when set to <code>1</code>. Depending on the system's chipset this may cause stability issues if enabled.
|-
| <code>NVreg_Mobile</code> || <code>0</code> || Through this setting, users can force the EDID information for particular systems. This workaround is provided for mobile GPU's where EDID information is either non-functional or disabled. Potential values are <code>0</code> (Auto detection of the correct setting), <code>1</code> (Dell notebooks), <code>2</code> (non-Compa1 Toshiba laptops), <code>3</code> (All other notebooks/laptops), <code>4</code> (Compa1 Toshiba laptops) or <code>5</code> (Gateway machines).
|-
| <code>NVreg_RemapLimit</code> || <code>60</code> || Maximum amount of system memory remapping. It specifies the amount of memory that the driver will be allowed to remap through the IOMMU/SWIOTLB on a 64-bit system. Only use it if the IOMMU or SMIOTLB is larger than 64mb. NVIDIA recommends to subtract 4mb from the total amount of memory to use. For instance, the default value is <code>60</code> which is in fact 64mb. To set it to 128mb, set the value to <code>124</code>.
|-
|<code>NVreg_UpdateMemoryTypes</code> || <code>0</code> || Tweak the use of page table attributes. Possible values are: <code>0</code> (Nvidias logic mechanism), <code>1</code> (Enable the use of changed page table attributes) and <code>2</code> (Disable the use of page table attributes).
|-
|<code>NVreg_InitializeSystemMemoryAllocations</code> || <code>1</code> || Tell the NVIDIA driver to clear system memory allocations prior to using it for the GPUs. Disabling can give a slight performance boost but at the cost of increased security risks. By default the driver will wipe the allocated by zeroing out its content.
|-
| <code>NVreg_UseVBios</code> || <code>1</code> || Enable or disable the use of the video BIOS int10 code. Set to <code>0</code> to disable.
|-
| <code>NVreg_RMEdgeIntrCheck</code> || Unspecified || Enable or disable checking for edge-triggered interrupts.
|-
| <code>NVreg_EnableMSI</code> || <code>0</code> || Enable or disable PCIe-MSI capabilities. Enable this to use MSI interrupts instead of wired interrupts.
|-
| <code>NVreg_MapRegistersEarly</code> || <code>0</code> || If set to <code>1</code>, allow the driver to map the memory locations early when the system is probing the hardware instead of the default option of doing this when loaded by {{c|modprobe}} or during {{c|startx}}. This is a debugging feature.
|-
| <code>NVreg_RegisterForACPIEvents</code> || <code>1</code> || Enable the driver to register with the ACPI of the system to receive ACPI events. This can be disabled (<code>0</code>) when issues occur with ACPI or while debugging an issue. 
|}

<div class="mw-translate-fuzzy">
편집기에서 {{Path|/etc/modprobe.d/nvidia.conf}}를 편집하십시오:
</div>

{{RootCmd|update-modules}}

<div class="mw-translate-fuzzy">
nvidia 모듈을 불러온 상태를 취소하십시오...
</div>

{{RootCmd|modprobe -r nvidia}}

...그리고 다시 불러오십시오:

{{RootCmd|modprobe nvidia}}

=== 고급 X 설정 ===

GLX 계층에는 설정 가능한 상당히 많은 옵션이 있습니다. TV 출력, 듀얼 디스플레이, 모니터 주파수 감지 등의 설정을 다룰 수 있습니다. 다시 말씀드리지만, 여기에 있는 모든 옵션은 문서에 자세히 설명되어 있습니다.

이 옵션을 사용하려면 X 설정 파일의 관련 장치 섹션에 있는 목록을 살펴봐야 합니다(보통 '''/etc/X11/xorg.conf'''에 있음). 가령, 스플래시 로고를 비활성화 하려는 상황을 가정해보겠습니다.

<div class="mw-translate-fuzzy">
{{FileBox|filename=/etc/X11/xorg.conf|title=스플래시 로고 비활성화|lang=xorg_conf|
Section "Device"
  Identifier "nVidia Inc. GeForce2"
  Driver     "nvidia"
  Option     "NoLogo" "true"
  VideoRam   65536
EndSection
}}
</div>

== 추가 참조 ==

<div class="mw-translate-fuzzy">
* [[nouveau & nvidia-drivers switching]]
* [[NVIDIA Driver with Optimus Laptops]]
</div>

{{Migrated|originalauthors={{Dev|SwifT}}, {{Dev|nightmorph}}, M Curtis Napier and Chris Gianelloni}}

[[Category:Graphics Adapters]]
[[Category:Binary kernel modules]]
