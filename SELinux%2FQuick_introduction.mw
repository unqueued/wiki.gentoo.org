SELinux is an access control mechanism, supported through the Linux kernel, that works alongside the Linux regular access controls. But unlike the regular access controls, it is a ''mandatory'' access control system, ensuring that users cannot work around the rules set by the administrator. But before we get into the gritty details of SELinux, let's first see how the regular access controls on a Linux system work. Then, we continue with the SELinux features one by one, explaining most of the models supported by SELinux.

== Regular Linux access control ==

Assume a user wants to execute a script, then the Linux discretionary access control system will check the information of the process that the user is running (which is most likely a shell process) and that of the script itself to decide if the execution can go further.

[[File:Linux_DAC_permissions.png|Schematic overview of a script execution|link=]]

In the example above, Linux will allow the execution, because the permissions on the file (which are <code>-rwxr-xr-x</code>) allow other users to execute it.

The discretionary part comes from the fact that the owner of the file can decide on the access rights to the file. Even if the file wasn't executable at first, the user could easily assign the proper permission set to the file:

{{Cmd|chmod o+x /path/to/script}}

On a multi-user system, a user will be able to share whatever resources he has access to with the other users. All he needs to do is to open up the rights to these resources for other users (or if they all share the same group, to the group owner). And although the example of "sharing" files is a simple one, it can go further than that. In some enterprises, access to particular software on a system is governed through the group membership. Developers might be assigned a ''developer'' group, allowing them access to the system compiler. But once a developer can access the compiler, he can easily also copy all compiler files into his own directory and share that directory with other, non-developer users who can then call the compiler as well.

The discretionary part of the Linux permission system goes further than just users. Services too, such as the Apache web server, can decide how they open up their resources. And although it might not be by design, a malfunctioning service might expose sensitive data to users through this aspect. 

== Mandatory access control ==

With a mandatory access control, the permissions are not governed by the owner of the resource, nor can they be worked around by users. Instead, they are set in stone by the security administrator. In SELinux, this is done through the SELinux policy that is loaded at the start of the system.

[[File:SELinux_MAC_permissions.png|Schematic overview of a script execution under SELinux|link=]]

The interaction shown is still the same, but an ''additional'' set of components is added: the SELinux subsystem (running in the Linux kernel) and the policy.

=== SELinux security subsystem ===

SELinux is a security subsystem that works inside the Linux kernel. It uses Linux Security Modules (LSM) hooks provided by the Linux kernel developers to intercept any call and check if the call is allowed or not. If it is, then the activity can go through. Otherwise, a ''Permission Denied'' error is returned to the system and a denial message is sent to the audit subsystem. This way, administrators can investigate denials (as they usually reflect unwanted behavior being exerted on the system) and rest assured that security rules cannot be worked around.

It is important to understand that the SELinux permission check happens ''after'' the Linux DAC check. In other words, SELinux cannot be used to override access controls on the system. If the regular permission system disallows an activity, then SELinux is not even consulted.

=== Context based approach ===

SELinux uses ''contexts'' to identify resources. In the example, two contexts take part in the activity: 
# the context of the user process (such as a shell), which is <code>user_u:user_r:user_t</code>
# the context of the target file, which is <code>system_u:object_r:lib_t</code>

A context in SELinux consists out of 3, sometimes 4 parts:
# it starts with a SELinux user (which is ''not'' the same as a Linux user),
# followed by the SELinux role,
# followed by the SELinux type,
# and then ''optionally'' followed by a sensitivity

Or, in a regular schematic representation:

[[File:SELinux_context.png|Schematic overview of a SELinux context|link=]]

Each field is used by SELinux for deciding access controls. Most of the rules however are made for the ''SELinux type'' of a context, which is why contexts are often reduced to just the type.

=== SELinux policy ===

The SELinux security subsystem checks any access attempt through the policy. SELinux uses a deny-by-default setup, so it looks for explicit allow statements on the ''SELinux type''. In our case, it looks for an allow rule that allows <code>user_t</code> <code>execute</code> rights on a <code>file</code> resource with the <code>lib_t</code> type assigned to it:

{{Code|Small set of SELinux policy rules|<pre>
...
allow user_t bin_t:file { execute };
allow user_t user_bin_t:file { execute };
...
</pre>}}

In our example, it doesn't find such a rule, so it denies the execution attempt.

== Access controls ==

The SELinux subsystem has various access controls in place. One of them we roughly saw, which is called the ''type enforcement''. Next to this, SELinux also supports ''role-based access control'' and ''user-based access control''. The last access control system we'll briefly cover is the ''multi-level security'' model.

=== Type enforcement ===

The ''type enforcement'' access control system focuses on the ''SELinux type'' within a SELinux context. It is also what most of the SELinux rules are written for and covers the vast majority of SELinux rules in a SELinux policy.

The access check that SELinux performs as part of the type enforcement is based on the '''access vector''' built up from the attempt. Such an access vector contains
- the source context (such as <code>user_t</code>)
- the target context (such as <code>lib_t</code>)
- the class of the target (such as <code>file</code>)
- the activity that is invoked (such as <code>execute</code>)

If an allow statement exists for the entire access vector, then the activity is allowed. If not, it is denied. The allow statement for our example would look like so:

{{Code|Allow executing lib_t for user_t|<pre>
allow user_t lib_t : file { execute };
</pre>}}

The source context type and target context type are defined by the policy developer (or security administrator). On an average SELinux system several hundreds, if not thousands of types exist. These types are declared every time differentiation is needed on the access. For instance, policy developers noticed that there were cases where a shell script only needed to call the shell interpreter itself (such as <code>bash</code>) but no other binaries. If the shell interpreter was labeled as <code>bin_t</code> then these shell scripts had access to all binaries labeled <code>bin_t</code>. So the policy developers created a second type, <code>shell_exec_t</code>, so that shell scripts only needed access to that type and were prevented from executing other, generic binaries.

{{Note|Labeling is the action of putting a context on a resource. The context of a file is often called the label of that file. A relabeling operation means that the label of the files is reset to the right value.}}

Next to the types, SELinux also supports a large set of classes. This allows SELinux to differentiate accesses based on the class of a resource. Privileges on a <code>lib_t</code> file versus those of a <code>lib_t</code> socket file or directory are completely separate for SELinux. This is unlike the discretionary access controls on a Linux system.

The set of classes can be seen on a SELinux enabled system like so:

{{RootCmd|ls /sys/fs/selinux/class|output=<pre>
appletalk_socket  db_procedure  file            netlink_audit_socket           node           socket              x_cursor     x_screen
association       db_schema     filesystem      netlink_dnrt_socket            nscd           sock_file           x_device     x_selection
blk_file          db_sequence   ipc             netlink_firewall_socket        packet         system              x_drawable   x_server
capability        db_table      kernel_service  netlink_ip6fw_socket           packet_socket  tcp_socket          x_event      x_synthetic_event
capability2       db_tuple      key             netlink_kobject_uevent_socket  passwd         tun_socket          x_extension
chr_file          dbus          key_socket      netlink_nflog_socket           peer           udp_socket          x_font
context           db_view       lnk_file        netlink_route_socket           process        unix_dgram_socket   x_gc
db_blob           dccp_socket   memprotect      netlink_selinux_socket         rawip_socket   unix_stream_socket  x_keyboard
db_column         dir           msg             netlink_socket                 security       x_application_data  x_pointer
db_database       fd            msgq            netlink_tcpdiag_socket         sem            x_client            x_property
db_language       fifo_file     netif           netlink_xfrm_socket            shm            x_colormap          x_resource
</pre>}}

Each class has its own set of supported privileges. The supported permissions of a regular file for instance:

{{RootCmd|ls /sys/fs/selinux/class/file/perms/|output=<pre>
append      execmod           getattr  lock     quotaon      relabelto  swapon
create      execute           ioctl    mounton  read         rename     unlink
entrypoint  execute_no_trans  link     open     relabelfrom  setattr    write
</pre>}}

The supported permissions for a TCP socket:

{{RootCmd|ls /sys/fs/selinux/class/tcp_socket/perms/|output=<pre>
accept      bind       create   ioctl   name_bind     node_bind  recv_msg     send_msg  setopt
acceptfrom  connect    getattr  listen  name_connect  read       relabelfrom  sendto    shutdown
append      connectto  getopt   lock    newconn       recvfrom   relabelto    setattr   write
</pre>}}

With such a vast set of possible access vectors, policy development is a large undertaking. Luckily, distributions such as Gentoo Linux come with a complete set of default policies to use, with thanks to the [http://oss.tresys.com/projects/refpolicy reference policy] project which manages a base policy for distributions to work with.

=== Role-based access control ===

=== Used-based access control ===

=== Multi-level security ===

== Integration ==
