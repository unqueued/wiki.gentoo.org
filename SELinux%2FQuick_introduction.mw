SELinux is an access control mechanism, supported through the Linux kernel, that works alongside the Linux regular access controls. But unlike the regular access controls, it is a ''mandatory'' access control system, ensuring that users cannot work around the rules set by the administrator. But before we get into the gritty details of SELinux, let's first see how the regular access controls on a Linux system work. Then, we continue with the SELinux features one by one, explaining most of the models supported by SELinux.

== Regular Linux access control ==

Assume a user wants to execute a script, then the Linux discretionary access control system will check the information of the process that the user is running (which is most likely a shell process) and that of the script itself to decide if the execution can go further.

[[File:Linux_DAC_permissions.png|Schematic overview of a script execution|link=]]

In the example above, Linux will allow the execution, because the permissions on the file (which are <code>-rwxr-xr-x</code>) allow other users to execute it.

The discretionary part comes from the fact that the owner of the file can decide on the access rights to the file. Even if the file wasn't executable at first, the user could easily assign the proper permission set to the file:

{{Cmd|chmod o+x /path/to/script}}

On a multi-user system, a user will be able to share whatever resources he has access to with the other users, as well as enable any action (such as writing to or executing the files). All he needs to do is to open up the rights to these resources for other users (or if they all share the same group, to the group owner). And although the example of "sharing" files is a simple one, it can go further than that. In some enterprises, access to particular software on a system is governed through the group membership. Developers might be assigned a ''developer'' group, allowing them access to the system compiler. But once a developer can access the compiler, he can easily also copy all compiler files into his own directory and share that directory with other, non-developer users who can then call the compiler as well.

The discretionary part of the Linux permission system goes further than just users. Services too, such as the Apache web server, can decide how they open up their resources. And although it might not be by design, a malfunctioning service might expose sensitive data to users through this aspect.

== Mandatory access control ==

With a mandatory access control, the permissions are not governed by the owner of the resource, nor can they be worked around by users. Instead, they are set in stone by the security administrator. In SELinux, this is done through the SELinux policy that is loaded at the start of the system.

[[File:SELinux_MAC_permissions.png|Schematic overview of a script execution under SELinux|link=]]

The interaction shown is still the same, but an ''additional'' set of components is added: the SELinux subsystem (running in the Linux kernel) and the policy.

=== SELinux security subsystem ===

SELinux is a security subsystem that works inside the Linux kernel. It uses Linux Security Modules (LSM) hooks provided by the Linux kernel developers to intercept any call and check if the call is allowed or not. If it is, then the activity can go through. Otherwise, a ''Permission Denied'' error is returned to the system and a denial message is sent to the audit subsystem. This way, administrators can investigate denials (as they usually reflect unwanted behavior being exerted on the system) and rest assured that security rules cannot be worked around.

It is important to understand that the SELinux permission check happens ''after'' the Linux DAC check. In other words, SELinux cannot be used to override access controls on the system. If the regular permission system disallows an activity, then SELinux is not even consulted.

=== Context based approach ===

SELinux uses ''contexts'' to identify resources. In the example, two contexts take part in the activity: 
# the context of the user process (such as a shell), which is <code>user_u:user_r:user_t</code>
# the context of the target file, which is <code>system_u:object_r:lib_t</code>

A context in SELinux consists out of 3, sometimes 4 parts:
# it starts with a SELinux user (which is ''not'' the same as a Linux user),
# followed by the SELinux role,
# followed by the SELinux type,
# and then ''optionally'' followed by a sensitivity

Or, in a regular schematic representation:

[[File:SELinux_context.png|Schematic overview of a SELinux context|link=]]

Each field is used by SELinux for deciding access controls. Most of the rules however are made for the ''SELinux type'' of a context, which is why contexts are often reduced to just the type.

=== SELinux policy ===

The SELinux security subsystem checks any access attempt through the policy. SELinux uses a deny-by-default setup, so it looks for explicit allow statements on the ''SELinux type''. In our case, it looks for an allow rule that allows <code>user_t</code> <code>execute</code> rights on a <code>file</code> resource with the <code>lib_t</code> type assigned to it:

{{Code|Small set of SELinux policy rules|<pre>
...
allow user_t bin_t:file { execute };
allow user_t user_bin_t:file { execute };
...
</pre>}}

In our example, it doesn't find such a rule, so it denies the execution attempt.

== Access controls ==

The SELinux subsystem has various access controls in place. One of them we roughly saw, which is called the ''type enforcement''. Next to this, SELinux also supports ''role-based access control'' and ''user-based access control''. The last access control system we'll briefly cover is the ''multi-level security'' model.

=== Type enforcement ===

The ''type enforcement'' access control system focuses on the ''SELinux type'' within a SELinux context. It is also what most of the SELinux rules are written for and covers the vast majority of SELinux rules in a SELinux policy.

The access check that SELinux performs as part of the type enforcement is based on the '''access vector''' built up from the attempt. Such an access vector contains
- the source context (such as <code>user_t</code>)
- the target context (such as <code>lib_t</code>)
- the class of the target (such as <code>file</code>)
- the activity that is invoked (such as <code>execute</code>)

If an allow statement exists for the entire access vector, then the activity is allowed. If not, it is denied. The allow statement for our example would look like so:

{{Code|Allow executing lib_t for user_t|<pre>
allow user_t lib_t : file { execute };
</pre>}}

The source context type and target context type are defined by the policy developer (or security administrator). On an average SELinux system several hundreds, if not thousands of types exist. These types are declared every time differentiation is needed on the access. For instance, policy developers noticed that there were cases where a shell script only needed to call the shell interpreter itself (such as <code>bash</code>) but no other binaries. If the shell interpreter was labeled as <code>bin_t</code> then these shell scripts had access to all binaries labeled <code>bin_t</code>. So the policy developers created a second type, <code>shell_exec_t</code>, so that shell scripts only needed access to that type and were prevented from executing other, generic binaries.

{{Note|Labeling is the action of putting a context on a resource. The context of a file is often called the label of that file. A relabeling operation means that the label of the files is reset to the right value.}}

Next to the types, SELinux also supports a large set of classes. This allows SELinux to differentiate accesses based on the class of a resource. Privileges on a <code>lib_t</code> file versus those of a <code>lib_t</code> socket file or directory are completely separate for SELinux. This is unlike the discretionary access controls on a Linux system.

The set of classes can be seen on a SELinux enabled system like so:

{{RootCmd|ls /sys/fs/selinux/class|output=<pre>
appletalk_socket  db_procedure  file            netlink_audit_socket           node           socket              x_cursor     x_screen
association       db_schema     filesystem      netlink_dnrt_socket            nscd           sock_file           x_device     x_selection
blk_file          db_sequence   ipc             netlink_firewall_socket        packet         system              x_drawable   x_server
capability        db_table      kernel_service  netlink_ip6fw_socket           packet_socket  tcp_socket          x_event      x_synthetic_event
capability2       db_tuple      key             netlink_kobject_uevent_socket  passwd         tun_socket          x_extension
chr_file          dbus          key_socket      netlink_nflog_socket           peer           udp_socket          x_font
context           db_view       lnk_file        netlink_route_socket           process        unix_dgram_socket   x_gc
db_blob           dccp_socket   memprotect      netlink_selinux_socket         rawip_socket   unix_stream_socket  x_keyboard
db_column         dir           msg             netlink_socket                 security       x_application_data  x_pointer
db_database       fd            msgq            netlink_tcpdiag_socket         sem            x_client            x_property
db_language       fifo_file     netif           netlink_xfrm_socket            shm            x_colormap          x_resource
</pre>}}

Each class has its own set of supported privileges. The supported permissions of a regular file for instance:

{{RootCmd|ls /sys/fs/selinux/class/file/perms/|output=<pre>
append      execmod           getattr  lock     quotaon      relabelto  swapon
create      execute           ioctl    mounton  read         rename     unlink
entrypoint  execute_no_trans  link     open     relabelfrom  setattr    write
</pre>}}

The supported permissions for a TCP socket:

{{RootCmd|ls /sys/fs/selinux/class/tcp_socket/perms/|output=<pre>
accept      bind       create   ioctl   name_bind     node_bind  recv_msg     send_msg  setopt
acceptfrom  connect    getattr  listen  name_connect  read       relabelfrom  sendto    shutdown
append      connectto  getopt   lock    newconn       recvfrom   relabelto    setattr   write
</pre>}}

With such a vast set of possible access vectors, policy development is a large undertaking. Luckily, distributions such as Gentoo Linux come with a complete set of default policies to use, with thanks to the [http://oss.tresys.com/projects/refpolicy reference policy] project which manages a base policy for distributions to work with.

=== Role-based access control ===

From the ''SELinux type'', we now get into the realm of the ''SELinux role''. Remember the context in our example? It had <code>user_r</code> as the SELinux role in the context of the process that was trying to execute a file.

Roles are like caps that a user can put on. A user is always assigned to a role, but can decide to switch roles (of course if allowed to switch to a role). An unprivileged user might only have access to one role (<code>user_r</code>) whereas an administrator might have access to several roles (<code>staff_r</code> for regular operations, and <code>sysadm_r</code> for system administrative tasks). This is also how roles in organizations are used. There are developer roles, system engineer roles, system administrator roles, it architect roles, database administrator roles, etc.

In SELinux, roles decide which types a process context can be in. The <code>user_r</code> role has the right to have processes run in the <code>user_t</code> type. Types for processes are also called '''domains'''. So the role-based access control decides which ''domains'' a role is allowed to have.

Consider a regular user role (<code>user_r</code>) versus database administrator role (<code>dbadm_r</code>). The regular user will not have access to the backup infrastructure, so the <code>backup_t</code> domain is not allowed for the <code>user_r</code> role. Even if the user would somehow be able to run backup software (say from a USB stick) this software will be running in the user domain (<code>user_t</code>) and not the backup domain (<code>backup_t</code>). And as the user domain is not allowed to access database files directly, the user will not be able to backup or restore data.

Unlike the database administrator, whose <code>dbadm_r</code> role is allowed to access <code>backup_t</code>. The database administrator can therefor execute backup software, which (assuming the policies are all correct) run in the <code>backup_t</code> domain, which is allowed to manage database files. As a result, the database administrator can backup and restore databases.

The set of domains that a role has access to can be requested on a SELinux system through the <code>seinfo</code> command:

{{Cmd|seinfo -ruser_r -x|output=<pre>
  user_r
    Types:
      git_session_t
      httpd_user_script_t
      ...
</pre>}}

Security administrators will usually design ''least privilege access'' through the role-based access controls, and then assign the roles to the users on a need-to-have basis. So privileges are not assigned to users individually (as that doesn't scale well) but to the domains, which are assigned to the roles, and users are assigned one or more roles to perform their duties.

=== Used-based access control ===

The first part of a context is the SELinux user. The idea behind the SELinux user is that it has to remain immutable, unlike roles which can be switched on user request.

The SELinux user decides which roles someone is allowed to go to. For instance, the <code>user_u</code> SELinux user specifies that only the <code>user_r</code> role is allowed, whereas the <code>staff_u</code> user specifies that the allowed roles are <code>staff_r</code> and <code>sysadm_r</code>. This can be seen by either <code>seinfo</code> or <code>semanage</code>:

{{RootCmd|seinfo -ustaff_u -x|output=<pre>
  staff_u
    roles:
      staff_r
      sysadm_r
</pre>}}

{{RootCmd|semanage user -l|output=<pre>
SELinux User       SELinux Roles

root               staff_r sysadm_r
staff_u            staff_r sysadm_r
sysadm_u           sysadm_r
system_u           system_r
user_u             user_r
</pre>}}

On SELinux systems, Linux users are ''mapped'' to a SELinux user. This mapping is what decides what a user is allowed to do on a system.

Mappings can be seen (and managed) using <code>semanage login</code>:

{{RootCmd|semanage login -l|output=<pre>
Login Name         SELinux User

__default__        user_u
swift              staff_u
root               root
</pre>}}

This is still part of the role-based access control, but important to know as we can now go to the used-based access control.

On Gentoo, if <code>USE="ubac"</code> is set, User Based Access Control (UBAC) is enabled. This ensures that unprivileged users with a different SELinux user cannot access each others' resources even if the types would allow this. 

Remember the example of one user sharing access to his files to other users? Well, if all users run with the <code>user_t</code> type (which is normal for unprivileged users) and have the files labeled as <code>user_home_t</code> (which is normal for the contents in the user {{Path|/home/*}} locations) then type enforcement would still allow one user to access another users' resources if that user opened up his home directory. After all, SELinux has the following rule to allow users to manage their own files:

{{Code|SELinux rule allowing regular users to manage their files|<pre>
allow user_t user_home_t:dir { read write execute close open ... };
allow user_t user_home_t:file { read write execute close open ... };
</pre>}}

However, we can create SELinux users for each user individually, and map each Linux user to a specific SELinux user. With that in place, the contexts of userA's and userB's files differ:

{{RootCmd|ls -ldZ /home/userA/somefile /home/userB/somefile|output=<pre>
-rwx------. userA userA  userA_u:object_r:user_home_t /home/userA/somefile
-rwxrw-rw-. userB userB  userB_u:object_r:user_home_t /home/userB/somefile
</pre>}}

In the example, ''userB'' has opened up access to his {{Path|/home/userB/somefile}} file (making it world writable). But userA will not be able to access it, as userA will run with the <code>userA_u</code> SELinux user, which is not allowed to access <code>userB_u</code> labeled resources of type <code>user_home_t</code> (UBAC works on a per type basis, not all types are what is called ''ubac-constrained'').

=== Multi-level security ===

== Integration ==
