<languages />

{{Metadata|abstract=LVM permet aux administrateurs de créer des méta-périphériques qui fournissent une couche d'abstraction entre un système de fichiers et le stockage physique sous-jacent.}}

{{InfoBox stack
|{{InfoBox wikipedia|Logical Volume Manager (Linux)|header=true}}
}}

'''LVM''' ('''L'''ogical '''V'''olume '''M'''anager - Gestionnaire de volumes logiques) permet aux administrateurs de créer des méta-périphériques qui fournissent une couche d'abstraction entre un système de fichiers et le stockage physique sous-jacent. Les méta-périphériques (sur lesquels sont placés les systèmes de fichiers) sont des ''volumes logiques'', qui utilisent de l'espace de stockages tiré de pools de stockage appelés ''groupes de volumes''. Un groupe de volumes dispose d'un ou plusieurs ''volumes physiques'' qui représentent les véritables périphériques sur lesquels les données sont stockées.

Les volumes physiques peuvent être des partitions, des disques durs SATA entiers regroupés sous formes de  JBOD  ('''J'''ust a '''B'''unch '''O'''f '''D'''isks - Un simple groupe de disques), des systèmes RAID , iSCSI, un canal de fibre, eSATA etc.

== Installation ==

La configuration de LVM est gérée à la fois par des pilotes au niveau du noyau et des applications de l'espace utilisateur.

=== Noyau ===

Activez les options suivantes du noyau:

{{Kernel||<pre>
Device Drivers  --->
   Multiple devices driver support (RAID and LVM)  --->
       <*> Device mapper support
           <*> Crypt target support
           <*> Snapshot target
           <*> Mirror target
       <*> Multipath target
           <*> I/O Path Selector based on the number of in-flight I/Os
           <*> I/O Path Selector based on the service time
</pre>}}

{{Note|Tout ne doit pas être activé; quelques unes des options ne sont nécessaires  que pour  les [[#LVM2_Snapshots_and_LVM2_Thin_Snapshots|Instantanés LVM2  et les Instantanés  LVM2 parcimonieux]], [[#LVM2_Mirrors|LVM2 Mirrors]], [[#LVM2_RAID_0.2FStripeset|LVM2 RAID 0/Stripeset]]  et le cryptage.}}

=== Logiciel ===

Installez le paquet {{Package|sys-fs/lvm2}}:

{{USEflag|package=sys-fs/lvm2
|clvm
|cman
|lvm1+yes
|readline+yes
|selinux++no
|static
|static-libs
|thin+yes
|udev+yes
}}

{{Emerge|lvm2}}

== Configuration ==

La configuration de  LVM se fait à plusieurs niveaux:
# Gestion de volumes logiques, pool de volumes et groupes de volumes via l'utilitaire de gestion
# Peaufinage du sous-système LVM via les fichiers de configuration
# Gestion du service au niveau de la distribution
# configuration via un disque virtuel de démarrage

La gestion des volumes physiques et logiques,  tout autant que celles des groupes de volumes est traitée dans le chapitre  [[#Usage|Usage]].

=== Fichiers de configuration de LVM  ===

LVM dispose d'un fichier de configuration très étendu, soit {{Path|/etc/lvm/lvm.conf}}. La plupart des utilisateurs n'ont pas besoin de modifier les paramètres de ce fichier pour commencer à utiliser LVM.

=== Gestion du service ===

Gentoo fournit le service LVM pour détecter automatiquement et activer les groupes de volumes et les volumes logiques.

Le service peut être géré via le système ''init''.

==== openrc ====

Pour démarre LVM à la main :

{{RootCmd|/etc/init.d/lvm start}}

Pour démarrer LVM au démarrage de la machine.

{{RootCmd|rc-update add lvm boot}}

==== systemd ====

Pour démarrer lvm à la main

{{RootCmd|systemctl start lvm2-monitor.service}}

Pour démarrer LVM au démarrage de la machine.

{{RootCmd|systemctl enable lvm2-monitor.service}}

=== Utilisation de  LVM dans un disque virtuel de démarrage -- initramfs ===

La plupart des chargeurs d'amorçage ne peuvent pas démarrer depuis LVM directement - Ni GRUB patrimonial, ni LILO ne le peuvent. GRUB2 peut amorcer depuis un volume logique linéaire, un volume logique miroir et possiblement depuis quelques volume logiques RAID. Aucun chargeur d'amorçage ne prend actuellement en charge les volumes logiques parcimonieux. 

Pour cette raison, il est conseillé d'utiliser une partition de démarrage (boot) non LVM et de monter la racine LVM depuis un système de fichiers virtuel de démarrage (initramfs). Un tel système de fichiers virtuel peut être généré automatiquement via [[Genkernel|genkernel]], genkernel-next et [[dracut]]:

*'''genkernel''' ne peut pas amorcer depuis tous les types sauf depuis les volumes parcimonieux (puisqu'il ne compile/construit ni ne copie les binaires des outils thin-provisionning (allocation parcimonieuse) de l'hôte de compilation/construction) et peut-être RAID10 (la prise en charge de RAID10 nécessite LVM2 2.02.98, mais genkernel compile 2.02.89, néanmoins si des binaires statiques sont disponibles, il peut les copier)
*'''genkernel-next''' ne peut pas amorcer depuis tous les types volumes, mais a besoin d'un paquet app-misc/pax-utils suffisamment récent sous peine de voir les binaires ''thin'' (parcimonieux) cassés (voir {{Bug|482504}}) 
*'''dracut''' devrait amorcer tous les types, mais n'inclut que la prise en charge ''thin'' (''parcimonieux'') dans le système de fichiers virtuel de démarrage (initramfs) si l'hôte sur lequel on l'exécute à une racine ''thin'' (''parcimonieuse'').

==== Genkernel/Genkernel-next ====

Installez le paquet {{Package|sys-kernel/genkernel}} ou le paquet {{Package|sys-kernel/genkernel-next}}. L'option ''static'' de la variable  USE doit aussi être activée sur le paquet  {{Package|sys-fs/lvm2}} de façon à ce que genkernel utilise les binaires système (autrement il construirait sa propre copie privée). L'exemple suivant construit seulement un système de fichiers virtuel de démarrage (pas un noyau entier) et active la prise en charge de LVM.

{{RootCmd|genkernel --lvm initramfs}}

La page de manuel de genkernel présente d'autres options qui dépendent des besoins du système.

Le disque virtuel de démarrage (initrd) demande certains paramètres pour savoir démarrer lvm. Ils lui sont fournis de la même manière que les autres paramètres du noyau. Par exemple :

{{File|/etc/default/grub|Ajouter dolvm en tant que paramètre de démarrage du noyau|<pre>
GRUB_CMDLINE_LINUX="dolvm"
</pre>}}

==== Dracut ====

Le paquet {{Package|sys-kernel/dracut}}, qui a été porté depuis le projet RedHat, tient lieu d'outil similaire pour générer un système de fichiers virtuel de démarrage.Comme il est actuellement sous  ~arch pour test, les utilisateurs doivent[[Knowledge_Base:Accepting_a_keyword_for_a_single_package| l'accepter explicitement]] (via  {{Path|/etc/portage/package.accept_keywords}}) avant de l'installer. Avant cela, l'option  <code>DRACUT_MODULES="lvm"</code> doit être déclarée dans  {{Path|/etc/portage/make.conf}}.  D'autres modules peuvent être requis. Reportez-vous à [[Dracut]]. En général, la commande suivante devrait générer un système virtuel de fichiers de démarrage utilisable (initramfs).

{{RootCmd|dracut -a lvm}}

Le disque virtuel de démarrage requiert quelques paramètres pour le renseigner sur l'endroit où démarrer lvm. Ces derniers sont transmis de la même façon que les autres paramètres du noyau. Par exemple :

{{File|/etc/default/grub|Ajouter la prise en charge de  LVM aux paramètres de démarrage du noyau|<pre>
GRUB_CMDLINE_LINUX="rd.lvm.vg=vol00"
</pre>}}

Pour une liste exhaustive des options de lvm avec dracut, reportez-vous à la section concernée du [https://www.kernel.org/pub/linux/utils/boot/dracut/dracut.html#_lvm  manuel de dracut].

== Utilisation ==

LVM organise le stockage sur 3 niveaux différents comme suit :
* disques durs, partitions, systèmes RAID systems ou autres moyens de stockage sont initialisés en tant que volumes physiques (PVs)
* les volumes physiques ('''P'''hysical '''V'''olumes) sont regroupés en groupe de volumes ('''V'''olumes '''G'''roups)
* les volumes logiques ('''L'''ogical '''V'''olumes) sont gérés en groupes de volumes (VG)

=== Volumes physiques ('''P'''ysical '''V'''olumes) ===
Les volumes physiques sont les systèmes physiques réels sur lesquels LVM est construit.

==== Partitionnement ====

{{Note|L'utilisation de partitions séparées pour allouer de l'espace de stockage aux groupes de volumes n'est nécessaire qui si on ne désire pas utiliser le disque entier pour un unique groupe de volumes LVM. Si le disque entier peut être utilisé, sautez cette étape et initialisez le disque dur tout entier en tant que volume physique. }}

Le code du type de partition pour  ''LVM'' est''8e'' (Linux LVM).

Par exemple, pour définir le type, via <code>fdisk</code>, d'une partition  {{Path|/dev/sda}}:

{{RootCmd|fdisk /dev/sda}}

Dans <code>fdisk</code>, ajoutez une partition en tapant  '''n''' (nouvelle) et changez le type de la partition en tapant  '''t''' (type) et en saisissant  ''8e''.

==== Créer un volume physique ====

Les volumes physiques peuvent être créés et initialisés avec la commande <code>pvcreate</code>.

Par exemple, la commande suivante crée un volume physique sur la première partition de {{Path|/dev/sda}} et {{Path|/dev/sdb}}:

{{RootCmd|pvcreate /dev/sd[ab]1}}

==== Lister les volumes physiques ====

La commande <code>pvdisplay</code> retourne une vue d'ensemble de tous les volumes physiques du système.

{{RootCmd|pvdisplay|output=<pre>
 --- Physical volume ---
  PV Name               /dev/sda1
  VG Name               volgrp
  PV Size               160.01 GiB / not usable 2.31 MiB
  Allocatable           yes 
  PE Size               4.00 MiB
  Total PE              40962
  Free PE               4098
  Allocated PE          36864
  PV UUID               3WHAz3-dh4r-RJ0E-5o6T-9Dbs-4xLe-inVwcV
  
 --- Physical volume ---
  PV Name               /dev/sdb1
  VG Name               volgrp
  PV Size               160.01 GiB / not usable 2.31 MiB
  Allocatable           yes 
  PE Size               4.00 MiB
  Total PE              40962
  Free PE               40962
  Allocated PE          0
  PV UUID               b031x0-6rej-BcBu-bE2C-eCXG-jObu-0Boo0x
</pre>}}

Si plus de volumes physiques devraient être affichés, alors la commande <code>pvscan</code> est capable de détecter les volumes physiques inactifs et peut les activer.

{{RootCmd|pvscan|output=<pre>
  PV /dev/sda1  VG volgrp        lvm2 [160.01 GiB / 16.01 GiB free]
  PV /dev/sdb1  VG volgrp        lvm2 [160.01 GiB / 160.01 GiB free]
  Total: 2 [320.02 GB] / in use: 2 [320.02 GiB] / in no VG: 0 [0]
</pre>}}

==== Retirer un volume physique ====

LVM répartit les données automatiquement sur tous les volumes physiques (sauf si on lui demande de procéder différemment) mais dans une démarche linéaire. Si un volume logique requis (dans un groupe de volumes) est plus petit que le volume de l'espace libre sur un unique volume physique, alors tout l'espace de ce volume physique (unique) est alloué à ce volume logique d'une manière contigüe. Ceci vise à optimiser la performance.

S'il est nécessaire de retirer un volume physique d'un groupe de volumes, les données doivent d'abord être déplacées en dehors de ce volume physique. La commande  <code>pvmove</code> permet de déplacer toutes les données d'un volume physique à un autre à l'intérieur d'un même groupe de volumes.

{{RootCmd|pvmove -v /dev/sda1}}

Une telle opération peut prendre beaucoup de temps selon l'importance volumique des données à déplacer. Une fois terminée, il ne devrait rester aucune donnée sur ce périphérique. Vérifiez que le volume physique n'est plus utilisé par un volume logique avec la commande <code>pvdisplay</code>.

L'étape suivante consiste à retirer le volume physique du groupe de volumes. La commande  <code>vgreduce</code> est là pour cela. Après l'avoir utilisée, le volume peut être détaché du groupe de volumes par la commande  <code>pvremove</code>:

{{RootCmd|vgreduce vg0 /dev/sda1 && pvremove /dev/sda1}}

=== Groupe de volumes ('''V'''olum '''G'''roup)  ===

Un groupe de volumes (VG) regroupe un certain nombre de volumes physiques et se présente comme {{Path|/dev/VG_NAME}} dans le système de fichiers. Le nom du groupe de volumes est choisi par l'administrateur.

==== Créer un groupe de volumes ====

La commande suivante crée un groupe de volume appelé ''vg0'' en lui assignant deux volumes physiques {{Path|/dev/sda1}} et {{Path|/dev/sdb1}}.

{{RootCmd|vgcreate vg0 /dev/sd[ab]1}}

==== Lister les groupes de volumes ====

La commande <code>vgdisplay</code> retourne la liste des groupes de volumes actifs:

{{RootCmd|vgdisplay|output=<pre>
  --- Volume group ---
  VG Name               vg0
  System ID             
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  8
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                6
  Open LV               6
  Max PV                0
  Cur PV                1
  Act PV                1
  VG Size               320.02 GiB
  PE Size               4.00 MiB
  Total PE              81924
  Alloc PE / Size       36864 / 144.00 GiB
  Free  PE / Size       45056 /176.01 GiB
  VG UUID               mFPXj3-DdPi-7YJ5-9WKy-KA5Y-Vd4S-Lycxq3
</pre>}}

Si des groupes de volumes n'apparaissent pas, utilisez la commande  <code>vgscan</code> pour les localiser :

{{RootCmd|vgscan|output=<pre>
  Reading all physical volumes.  This may take a while...
  (lecture de tous les volumes physiques. Ceci peut prendre un moment...)
  Found volume group "vg0" using metadata type lvm2
  (Groupe de volumes trouvé ''vg0'' qui utilise la méta-donnée de type lvm2)
</pre>}}

==== Étendre un groupe de volumes ====

Les groupes de volumes regroupent des volumes physiques, permettant ainsi aux administrateurs d'utiliser un pool de stockage pour allouer de l'espace aux systèmes de fichiers. Lorsqu'un groupe de volumes manque de ressources physiques, il est nécessaire de l'étendre en lui ajoutant de nouveaux volumes physiques.

La commande suivante étend le groupe de volumes ''vg0'' en lui ajoutant le volume physique {{Path|/dev/sdc1}}:

{{RootCmd|vgextend vg0 /dev/sdc1}}

N'oubliez pas que le volume physique doit d'abord être initialisé en tant que tel !

==== Réduire un groupe de volumes ====

Si des volumes physiques doivent être retiré d'un groupe de volumes, toutes les données encore utilisées de ce volume physique doivent être déplacées vers d'autres volumes physiques à l'intérieur du groupe de volumes. Comme nous l'avons vu précédemment, on utilise pour cela la commande <code>pvmove</code>. Après cela, le volume physique peut être retiré du groupe en utilisant la commande <code>vgreduce</code> :

{{RootCmd|pvmove -v /dev/sdc1
|vgreduce vg0 /dev/sdc1}}

==== Retirer un groupe de volumes ====

Si un groupe de volumes n'est plus nécessaire (ou en d'autres termes, le pool de stockage qu'il représente n'est plus utilisé et que les volumes physiques qui le composent peuvent être libérés pour une autre utilisation), il peut être retiré avec la commande <code>vgremove</code>. Ceci ne fonctionne que si aucun volume logique n'est défini pour ce groupe de volumes, et que si tous les volumes physiques, à l'exception d'un seul, ont été retirés de ce pool.

{{RootCmd|vgremove vg0}}

=== Volume logique (Logical Volume) ===

Les volumes logiques sont les méta-périphériques finaux mis à la disposition du système, ordinairement pour y placer des systèmes de fichiers. Ils sont créés et gérés en groupes de volumes et apparaissent sous la forme {{Path|/dev/VG_NAME/LV_NAME}}. Comme avec les groupes de volumes, le nom utilisé pour désigner le volume est fixé par l'administrateur.

==== Créer un volume logique  ====

La commande  <code>lvcreate</code> crée un volume logique. Les paramètres passés à la commande sont la taille requise (qui ne peut excéder la taille de l'espace libre dans le groupe de volume), le groupe de volumes à qui l'espace est réclamé et le nom du volume logique à créer.

Dans l'exemple qui suit, un volume logique nommé ''lvol1'' est créé à partir du groupe de volumes nommé ''vg0'' avec une taille de 150MB.

{{RootCmd|lvcreate -L 150M -n lvol1 vg0}}

Il est possible de spécifier à la commande <code>lvcreate</code> d'utiliser tout l'espace libre d'un groupe de volumes. On utilise pour cela le paramètre ''-l'' qui spécifie la taille en nombre d' ''étendues physiques élémentaires'' (''extents'') plutôt qu'une taille (interprétable par un humain).  Les volumes logiques sont éclatés en ''étendues logiques élémentaires'' (''logical extents'') qui représentent des blocs de données dans un groupe de volumes.  Tous les ''étendues physiques élémentaires'' dans un groupe de volumes possèdent la même taille. Via le paramètre ''-l'', on spécifie à la  commande  <code>lvcreate</code>  d'allouer toutes les ''étendues physiques élémentaires'' libres.

{{RootCmd|lvcreate -l 100%FREE -n lvol1 vg0}}

Juste après  ''FREE'' la clé ''VG'' peut être utilisée pour signifier la taille entière du groupe de volumes.

==== Lister les volumes logiques  ====

Pour lister tous les groupes de volumes, utilisez la commande <code>lvdisplay</code>.

{{RootCmd|lvdisplay}}

Si des volumes logiques n'apparaissent pas, on peut utiliser  la commande <code>lvscan</code> pour détecter tous les volumes logiques dans tous les groupes de volumes disponibles.

{{RootCmd|lvscan}}

==== Étendre un volume logique ====

Lorsqu'un volume logique doit être étendu, on peut utiliser la commande <code>lvextend</code>  pour étendre l'espace alloué à ce volume.

Par exemple pour augment la taille du volume logique 'lvol1'' jusqu'à 500 MO :

{{RootCmd|lvextend -L500M /dev/vg0/lvol1}}

On peut aussi utiliser la taille à ajouter plutôt que de spécifier la taille totale.

{{RootCmd|lvextend -L+350MB /dev/vg0/lvol1}}

Un groupe de volumes ne met pas immédiatement un espace de stockage additionnel à la disposition de l'utilisateur. Pour cela, le système de fichiers qui occupe ce groupe de volumes doit être élargi lui aussi. Tous les systèmes de fichiers ne permettent pas le redimensionnement à chaud. Vérifiez la documentation de votre système de fichier pour plus d'information.

À titre d'exemple, pour redimensionner un système de fichiers ext4 pour lui donner une taille de 500 MO :

{{RootCmd|resize2fs /mnt/data 500M}}

==== Réduire un volume logique ====

Si un volume logique doit être réduit en taille, commencez par réduire l'étendue du système de fichier. Tous les systèmes de fichiers ne peuvent être redimensionné système en marche.

Par exemple, ext4 ne peut être redimensionner avec un système qui tourne dessus, il faut d'abord le ''démonter''. Il est également recommandé de vérifier le système de fichiers afin d'être certain qu'il ne comporte pas d'incohérence.

{{RootCmd|umount /mnt/data
|e2fsck -f /dev/vg0/lvol1
|resize2fs /dev/vg0/lvol1 150M}}

 Une fois le système de fichiers réduit, il est possible de réduire le volume logique à son tour.

{{RootCmd|lvreduce -L150M /dev/vg0/lvol1}}

==== Permissions d'un volume logique ====

LVM prend en charge les permissions sur les volumes logiques.

Par exemple, on peut déclarer un volume logique ''en lecture seule'' en utilisant la commande <code>lvchange</code> :

{{RootCmd|lvchange -p r /dev/vg0/lvol1
|mount -o remount /dev/vg0/lvol1}}

Il est nécessaire de remonter le volume car le changement ne peut être pris en compte immédiatement.

Pour marquer le volume logique comme ''inscriptible à nouveau'', utilisez les bits de permission ''rw''

{{RootCmd|lvchange -p rw /dev/vg0/lvol1 && mount -o remount /dev/vg0/lvol1}}

==== Retirer un volume logique ====

Avant de retirer un volume logique, assurez-vous qu'il n'est pas monté.

{{RootCmd|umount /dev/vg0/lvol1}}

Désactivez le volume logique de façon à ce qu'on ne puisse plus y écrire :

{{RootCmd|lvchange -a n /dev/vg0/lvol1}}

Dès lors que le volume logique est démonté et désactivé, on peut le retirer, libérant ainsi les ''étendues élémentaires'' qui lui sont alloués pour les mettre à la disposition des autres volumes logiques dans le groupe de volumes.

{{RootCmd|lvremove /dev/vg0/lvol1}}

== Fonctionnalités ==

LVM offre quelques fonctionnalités intéressantes pour les administrateurs, y compris (mais sans limitation) :
* l'[http://fr.wikipedia.org/wiki/Dynamic_Provisioning allocation parcimonieuse]
* la prise en charge des instantanés
* des types de volumes utilisant des méthodes d'allocation différentes

===  L'allocation parcimonieuse ===

De récentes version de LVM2 (2.02.89) prennent en charge les ''volumes à allocation parcimonieuse'' (''thin volumes'' ou ''volumes parcimonieux''). Les volumes parcimonieux sont aux périphériques de blocs, ce que les ''fichiers parcimonieux'' (''sparse files'') sont aux systèmes de fichiers. En conséquences, un volume logique parcimonieux à l'intérieur d'un pool peut être ''sur-engagé'' : sa taille affichée peut être supérieure à l'espace qui lui est alloué - il peut même être plus volumineux que le pool lui-même. Tout comme un ''fichier parcimonieux'', les ''étendues physiques élémentaires'' sont allouées au fur et à mesure que le périphérique de blocs est peuplé. Si le système de fichiers prend en charge la fonctionnalité ''discard''(rejette), des ''étendues physiques élémentaires'' sont à nouveau libérées dès lors que des fichiers sont retirés, réduisant ainsi l'utilisation d'espace du pool.

Dans LVM, un tel pool parcimonieux est un type de volume logique, qui peut lui-même héberger des volumes logiques.

==== Créer un pool parcimonieux ====

{{Warning|Si un débordement se produit dans les méta-données du pool parcimonieux, alors le pool est corrompu. '''LVM ne peut pas se remettre d'une telle situation'''.}} 

{{Note|Si le pool parcimonieux est épuisé, tout ''process'' qui provoquerait l'allocation par le pool parcimonieux d'''étendues physiques élémentaires'' non disponibles est gelé dans un état de ''sommeil tuable'' jusqu'à ce que le pool soit étendu ou que le ''process'' reçoive un signal SIGKILL. .}}

Chaque ''pool parcimonieux'' possède des méta-données associées, qui augmentent la taille du ''pool parcimonieux''. LVM calcule la taille des méta-données en se basant sur la taille du ''pool parcimonieux'' comme étant le minimum de <tt>pool_chunks * 64 octets</tt> et de <2 MO. L'administrateur peut choisir un taille des méta-données différentes.

Pou créer un ''pool parcimonieux, ajoutez les paramètres''--type thin-pool --thinpool thin_pool'' à  <code>lvcreate</code>:

{{RootCmd|lvcreate -L 150M --type thin-pool --thinpool thin_pool vg0}}

L'exemple précédent crée un ''pool parcimonieux'' appelé ''thin_pool'' qui aura une taille totale de 150 MO. Il s'agit de la taille réelle du ''pool parcimonieux'' (et par conséquent le montant total d'espace de stockage qui peut être utilisé).

Pour requérir explicitement une certaine taille des méta-données, utilisez le paramètre ''--metadatasize'' :

{{RootCmd|lvcreate -L 150M --metadatasize 2M --type thin-pool --thinpool thin_pool vg0}}

À cause des méta-données qui sont ajoutées au ''pool parcimonieux'', la manière intuitive qui consiste à utiliser toute la taille disponible dans un groupe de volume ne fonctionne pas  (voir LVM bug [https://bugzilla.redhat.com/show_bug.cgi?id=812726|812726]):

{{RootCmd|lvcreate -l 100%FREE --type thin-pool --thinpool thin_pool vg0|output=<pre>
Insufficient suitable allocatable extents for logical volume thin_pool: 549 more required
(Nombre d'''étendues physiques élémentaires'' allouables insuffisant pour le ''volume logique parcimonieux'': 549 étendues physiques élémentaires supplémentaires sont nécessaires.)
</pre>}}

Notez que le pool parcimonieux n'a pas de nœud de périphérique associé comme les autres.

==== Créer un volume logique parcimonieux ====

An volume logique parcimonieux (''thin logical volume'') est un volume logique à l'intérieur d'un pool (qui est lui-même un volume logique). Comme les ''volumes logiques parcimonieux'' sont parcimonieux (sparse), une taille virtuelle plutôt que physique est spécifiée à l'aide du paramètre ''-v'' :

{{RootCmd|lvcreate -T vg0/thin_pool -V 300M -n lvol1}}

Dans cet exemple le volume logique parcimonieux (thin) ''lvol1'' est mis à disposition en tant que périphérique de taille 300 MO, bien que le pool sous-jacent ne contienne que 150 MO d'espace mémoire réel alloué.

Il est également possible de créer à la fois le pool parcimonieux et le volume logique à l'intérieur de ce pool en une seule commande :

{{RootCmd|lvcreate -T vg0/thin_pool -V 300M -L150M -n lvol1}}

==== Lister les pools parcimonieux et les volumes logiques parcimonieux ====

Les pools parcimonieux et les volumes logiques parcimonieux sont des types spéciaux de volumes logiques, et, en tant que tels, affichés via la commande <code>lvdisplay</code>. La commande  <code>lvscan</code> détecte également ces volumes logiques.

==== Étendre un pool parcimonieux ====

{{Warning/fr|Depuis  LVM2 2.02.89, la taille des méta-données du pool parcimonieux ne peut pas être étendue, elle est fixée à la création.  }}

Le pool parcimonieux est étendu comme un volume logique non parcimonieux via la commande <code>lvextend</code> . Par exemple :

{{RootCmd|lvextend -L500M vg0/thin_pool}}

==== Étendre un volume logique parcimonieux ====

Un volume logique parcimonieux est étendu de la même manière qu'un volume ordinaire :

{{RootCmd|lvextend -L1G vg0/lvol1}}

Notez que la commande <code>lvextend</code> utilise l'option ''-L'' (ou ''-l'' si les compteurs d'étendues physiques élémentaires sont utilisés) et non pas une option ''taille virtuelle'' telle que celle utilisée lors de la création. 

==== Réduire un pool parcimonieux ====

Au stade actuel, LVM ne sait pas réduire la taille d'un pool parcimonieux. Reportez-vous au rapport de bogue [https://bugzilla.redhat.com/show_bug.cgi?id=812731|812731].

==== Réduire un volume logique parcimonieux ====

Les volumes logiques parcimonieux sont réduits de la même manière que les volumes logiques ordinaires.

For instance:
{{RootCmd|lvreduce -L300M vg0/lvol1l}}

Notez que la commande <code>lvreduce</code> utilise l'option ''-L'' (ou ''-l'' si les compteurs d'étendues physiques élémentaires sont utilisés) et non pas une option ''taille virtuelle'' telle que celle utilisée lors de la création.

==== Retirer des pools parcimonieux ====

Ces pools ne peuvent être retirés que si tous les volumes logiques parcimonieux qu'ils contenaient ont été retirés.

Lorsqu'un pool ne sert plus à aucun volume logique, il peut être retiré via la commande <code>lvremove</code> :

{{RootCmd|lvremove vg0/thin_pool}}

=== Instantanés LVM2 et instantanés parcimonieux ===

Un instantané est un volume logique que agit comme copie d'un autre volume logique. Il affiche l'état du volume logique original au moment de la création de l'instantané.

==== Créer un instantané de volume logique ====

Un volume logique instantané est créé via l'option ''-s'' de la commande <code>lvcreate</code>. Les volumes logiques instantanés reçoivent de l'espace car LVM y enregistre tous les changements apportés au volume logique original. Lorsque l'on s'enquière de l'état de l'instantané, LVM démarre du volume logique original et évalue tous les changements enregistrés, "défaisant'' les changements avant de montrer le résultat à l'utilisateur.

Un volume logique instantané, grossit par conséquence au rythme des changements apportés au volume logique original. Lorsque tout l'espace alloué à l'instantané est épuisé, l'instantané est automatiquement retiré du système.

{{RootCmd|lvcreate -l 10%VG -s -n 20140412_lvol1 /dev/vg0/lvol1}}

L'exemple qui précède crée un volume logique instantané appelé ''20140412_lvol1'', basé sur le volume ''lvol1' du groupe de volumes ''vg0''. Il utilise 10% de l'espace (réellement des étendues physiques élémentaires) alloués au groupe de volumes.

==== Accéder à un volume logique instantané ====

Les volumes logiques instantanés sont montés de la même manière que les volumes logiques ordinaires.  Ils ne sont même pas réduits à des opérations en lecture seule - il est possible de modifier des instantanés et les utiliser ainsi pour des tester des changements avant de les appliquer à un système de fichier de ''production''.

Tant qu'un volume logique instantané existe, le volume logique original ordinaire ne peut être réduit en taille ou supprimer.

==== Les instantanés parcimonieux de LVM  ====

{{Note|Un instantané parcimonieux ne peut être créé que depuis un pool parcimonieux pour un volume logique parcimonieux. La cible de cartographie des périphériques parcimonieux prend en charge  les instantanés parcimonieux  des volumes non parcimonieux en lecture seule, mais l'outillage LVM2 ne prend pas en charge cela. Cependant, il est possible de créer un volume logique instantané ordinaire (non parcimonieux) à partir d'un volume logique parcimonieux. }}

Pour créer un instantané parcimonieux, utilisez la commande <code>lvcreate</code> avec l'option  <code>-s</code> . Il n'est pas nécessaire de communiquer une taille :

{{RootCmd|lvcreate -s -n 20140413_lvol1 /dev/vg0/lvol1}}

Les volumes logiques instantanés parcimonieux ont la même taille que leur volume logique original, et utilisent une allocation physique de 0 tout comme les autres volumes logiques. 

{{Important|Si ''-l'' ou ''-L'' est spécifié, un instantané sera quand même créé, mais l'instantané résultant sera un instantané ordinaire, par un instantané parcimonieux.}}

Il est aussi possible de prendre des instantanés d'instantanés.

{{RootCmd|lvcreate -s -n 1_20140413_lvol1 /dev/vg0/20140413_lvol1}}

Ce type d'instantanés procure plusieurs avantages par rapport aux instantanés ordinaires. Tout d'abord, les instantanés parcimonieux sont indépendants de leur volume logique original une fois créés. Le volume logique original peut être réduit ou supprimé sans que cela n'affecte l'instantané. En second lieu, ce type d'instantanés peut être créé efficacement de manière récursive (instantanés d'instantanés) sans la surcharge due au chaînage des instantanés LVM ordinaires récursifs.

==== Revenir à l'état de l'instantané ====

Pour faire revenir en arrière le volume logique à l'état de l'instantané, utilisez la commande suivante :

{{RootCmd|lvconvert --merge /dev/vg0/20140413_lvol1}}

Ceci peut prendre quelques minutes, selon la taille du volume.

{{Important|L'instantané sera supprimé et ce changement est irréversible.}}

==== Revenir à l'état d'un instantané parcimonieux ====

Pour les volumes parcimonieux, la commande <code>lvconvert --merge</code> ne fonctionne pas. Au lieu de cela, supprimez le volume logique original et renommez l'instantané :

{{RootCmd|umount /dev/vg0/lvol1
|lvremove /dev/vg0/lvol1
|lvrename vg0/20140413_lvol1 lvol1}}

=== Différentes méthodes d'allocation d'espace de stockage ===

LVM prend en charge plusieurs méthodes d'allocation d'espace de stockage:
* les volumes linéaires (qui est la méthode par défaut)
* les volumes réfléchis (mirrored)  (dans une configuration plus ou moins active/standby)
* la segmentation répartie (stripping) (RAID0) 
* les volumes réfléchis (RAID1 - qui est plutôt une configuration active/active )
* la segmentation répartie avec parité (RAID4 et RAID5)
* la segmentation répartie avec double parité (RAID6)
* segmentation répartie et réflexion (RAID10)

==== Les volumes linéaires ====

Les volumes linéaires sont les volumes les plus courants de LVM. LVM essaye d'allouer l'espace au volume logique pour assurer une contiguïté physique aussi grande que possible. S'il existe un volume physique suffisamment grand pour contenir le volume logique tout entier, alors LVM lui allouera cet espace, autrement, il l'éclatera en aussi peu de morceaux que possible.

Les commandes introduites plus haut dans cette page pour la création de volumes logiques créent des volumes logiques linéaires.

Comme les volumes logiques n'ont aucune exigence particulière, ils sont les plus faciles à manipuler et peuvent être redimensionnés et ré-alloués à volonté. Si un volume logique se voit alloué de l'espace de plusieurs volumes physiques, et que l'un de ces volumes physiques devient indisponible, alors le volume logique ne peut plus être démarré et devient inutilisable.

==== Les volumes réfléchis ====

LVM prend en charge les volumes ''réfléchis'' (''mirrored''), qui procure une tolérance aux fautes en cas de panne de disque. À la différence de RAID, il n'y a pas de gain de performance - toutes les lectures et écritures ne se font que sur un seul coté du miroir.

Pour suivre l'état du miroir, LVM a besoin qu'un journal soit tenu. Il est conseillé (et souvent obligatoire) de placer ce journal sur un volume physique qui ne contient aucun des volumes logiques réfléchis. Il y a trois sortes de journaux utilisables avec les miroirs :

# '''Disk''' est le type de journal par défaut. Tous les changements effectués sont inscrits dans les ''étendues physiques élémentaires'' de méta-données supplémentaires, que LVM gère. Si un périphérique tombe en panne, alors les changements sont inscrits dans le journal jusqu'à ce que le miroir soit restauré. 
# Les journaux de type '''Mirror''' sont des journaux de type '''disk''' qui sont eux-même réfléchis. 
# Les journaux '''Core''' mirror enregistre l'état du miroir en mémoire seulement. LVM doit reconstruir le miroir à chaque fois qu'il est activé. Ce type de journal est utile pour les miroirs temporaires.

Pour créer un volume logique avec un miroir unique, passez l'argument  ''-m 1''  (pour sélectionner la réflexion standard ) et optionnellement ''--mirrorlog'' pour sélectionner un type particulier de journal :

{{RootCmd|lvcreate -m 1 --mirrorlog mirror -l 40%VG --nosync -n lvol1 vg0}}

L'option <tt>-m 1</tt> demande à  LVM de créer un miroir  (supplémentaire), requérant ainsi 2 volumes physiques . L'option <tt>--nosync</tt> est une optimisation  - sans elle LVM essaye de synchroniser le miroir en copiant des secteurs vides d'un volume logique à l'autre.

Il est possible de créer un miroir d'un volume physique existant :

{{RootCmd|lvconvert -m 1 -b vg0/lvol1}}

L'option ''-b'' effectue la conversion en arrière plan et cela peut prendre un certain temps.

Pour retirer un miroir, repositionnez le nombre de miroirs à zéro :

{{RootCmd|lvconvert -m0 vg0/lvol1}}

Si une partie du miroir est indisponible (généralement parce que le disque contenant le volume physique est en panne), le groupe de volumes aura besoin d'être restauré dans un mode dégradé :

{{RootCmd|vgchange -ay --partial vg0}}

Dès le première écriture, LVW se rendra compte que le miroir est brisé. La politique par défaut (''remove'' c.à.d. ''retirer'') est de réduire/briser automatiquement le miroir selon le nombre de morceaux disponibles. Un miroir à trois volets avec un volume physique manquant sera réduit à un miroir à deux volets; un miroir à deux volets sera réduit à un volume linéaire ordinaire. Si la panne est seulement transitoire, et que le volume physique redevient disponible après que LVM a cassé le miroir, il faudra recréer le volume logique réfléchi dessus. 

Pour récupérer le miroir, le volume physique en panne doit être retiré du groupe de volumes, et un volume physique de rechange doit être ajouté (ou si le groupe de volume dispose d'un volume physique libre, il peut être recréé sur ce dernier). Alors le miroir peut être recréé avec l'option <tt>lvconvert</tt> permettant ainsi le retrait de l'ancien volume du groupe :

{{RootCmd|vgextend vg0 /dev/sdc1
|lvconvert -b -m 1 --mirrorlog disk vg0/lvol1
|vgreduce --removemissing vg0}}

Il es possible de faire en sorte que LVM recrée le miroir avec des ''étendues physiques élémentaires'' libres sur un volume physique différent si un des coté est en panne. Pour cela définissez  <code>mirror_image_fault_policy</code> à  la valeur ''allocate'' dans {{Path|lvm.conf}}.

==== Miroir parcimonieux ====

Il n'est pas possible actuellement de créer un pool parcimonieux réfléchi ou un volume parcimonieux réfléchi. Il est possible de créer un pool parcimonieux réfléchi en créant un volume logique ordinaire réfléchi et en le convertissant en pool parcimonieux avec la commande <tt>lvconvert</tt>. 2 volumes logiques sont requis: un pour le pool parcimonieux et l'autre pour les méta-données parcimonieuses ; le processus de conversion les fusionnera en un unique volume logique.

{{Warning/fr|LVM 2.02.98 ou postérieur est requis pour que cela fonctionne correctement. Les versions antérieures sont, soit  incapables, soit produiront des erreurs de segmentation et corrompront le groupe de volumes. De plus, la conversion d'un miroir en un pool parcimonieux '''détruit''' toutes les données présentes dans le miroir ! }}

{{RootCmd|lvcreate -m 1 --mirrorlog mirrored -l40%VG -n thin_pool vg0
|lvcreate -m 1 --mirrorlog mirrored -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg0/thin_meta}}

==== Segmentation répartie (RAID0) ====

Au lieu d'un volume linéaire, où de multiples volumes physiques  contigües sont ajoutés, il est possible de créer un volume ''à segmentation répartie'' ou ''RAID 0'' pour améliorer la performance.Ce principe répartit l'allocation d'espace à travers tous les volumes physiques disponibles.

Pour créer un volume à segmentation répartie sur 3 volumes physiques :

{{RootCmd|lvcreate -i 3 -l 20%VG -n lvol1_stripe vg0|output=<pre>
Using default stripesize 64.00 KiB
</pre>}}

L'option -i sur combien de volumes physiques la répartition doit avoir lieu.

Il est possible de réfléchir un volume à segmentation répartie. Les options -i et -m peuvent être combinées pour créer un miroir à segmentation répartie.

{{RootCmd|lvcreate -i 2 -m 1 -l 10%VG vg0}}

Ceci crée 2 volumes à segmentation répartie et les réfléchit sur 2 volumes physiques différents, pour un total de 4 volumes physiques. Un volume à segmentation répartie existant peut être réfléchi via la commande <tt>lvconvert</tt>.

Un pool parcimonieux peut être rendu à segmentation répartie comme tout autre volume logique. Tous les volumes parcimonieux créés à partir du pool héritent de ces réglages - ne les spécifiez pas à la main lorsque vous créez un volume parcimonieux.

Il n'est pas possible de transformer  un volume existant en un volume à segmentation répartie, ni de redéfinir la répartition sur plus ou moins de volumes physiques, ni de le convertir en un volume linéaire de niveau de RAID différent. Un volume à segmentation répartie peut être réfléchi. Il est possible d'étendre un volume à segmentation répartie sur des volumes physiques additionnels, mais ces derniers doivent être ajoutés en multiples de ceux du volume original (ce qui ajoutera linéairement un nouveau volume à segmentation répartie).

==== Réflexion (RAID1) ====

À la différence de RAID 0, qui correspond à la segmentation répartie, RAID 1 correspond à la réflexion, mais mis en œuvre différemment du miroir LVM original. Sous RAID 1, les lectures sont réparties à travers les volumes physiques, améliorant ainsi la performance. Une panne du miroir RAID 1 ne conduit pas à un blocage des entrées/sorties parce que LVM n'a pas besoin de le casser en écriture.

Partout où un miroir LVM peut être utilisé, un miroir RAID 1 peut l'être à sa place. Il est possible de faire que LVM crée implicitement des miroirs RAID 1 au lieu de miroir ordinaires en définissant la variable <tt>mirror_segtype_default</tt> à ''raid1'' dans le fichier {{Path|lvm.conf}}.

Pour créer un volume logique avec un miroir unique :

{{RootCmd|lvcreate -m 1 --type raid1 -l 40%VG --nosync -n lvm_raid1 vg0}}

Notez la différence pour créer un miroir : il n'y a pas de ''mirorlog'' spécifié, parce que les volumes RAID1 n'ont pas de journal miroir explicite - it built-in to the logical volume.

Il est possible de convertir un volume existant en RAID 1 :

{{RootCmd|lvconvert -m 1 --type raid1 -b vg0/lvol1}}

Pour retirer un miroir RAID 1, mettez le nombre de miroirs à 0 :

{{RootCmd|lvconvert -m0 vg0/lvm_raid1}}

Si une partie de RAID1 est indisponible (en général parce qu'un des disques contenant le volume physique est en panne), le groupe de volume doit être mis dans un état dégradé:

{{RootCmd|vgchange -ay --partial vg0}}

Contrairement à un miroir LVM, écrire ne brise pas le miroir. Si la panne est seulement transitoire, et que le volume manquant réapparaît, LVM resynchronise le miroir en recopiant les segments périmés plutôt que le volume logique tout entier. Si la panne est permanente, il faut retirer le volume physique du groupe de volumes, et un volume physique de remplacement doit être ajouté (ou si le groupe de volumes dispose d'un volume physique libre, il peut être créé sur un volume physique différent). Le miroir peut être réparé via la commande ''lvconvert'', et le volume physique en panne peut être retiré du groupe de volumes.

{{RootCmd|vgextend vg0 /dev/sdc1
|lvconvert --repair -b vg0/lvm_raid1
|vgreduce --removemissing vg0}}

==== RAID1 parcimonieux ====

It is not (yet) possible to create a RAID 1 thin pool or thin volume. It is possible to create a RAID 1 thin pool by creating a normal mirrored logical volume and then converting the logical volume to a thin pool with <tt>lvconvert</tt>. 2 logical volumes are required: one for the thin pool and one for the thin metadata; the conversion process will then merge them into a single logical volume.

{{Warning|LVM 2.02.98 or above is required for this to work properly. Prior versions are either not capable or will segfault and corrupt the VG. Also, conversion of a RAID 1 into a thin pool '''destroys''' all existing data in the mirror!}}

{{RootCmd|lvcreate -m 1 --type raid1 -l40%VG -n thin_pool vg0
|lvcreate -m 1 --type raid1 -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg00/thin_meta}}

==== Striping with parity (RAID4 and RAID5) ====

{{Note|Striping with parity requires at least 3 physical volumes.}}

RAID 0 is not fault-tolerant - if any of the physical volumes fail then the logical volume is unusable. By adding a parity stripe to RAID 0 the logical volume can still function if a physical volume is missing. A new physical volume can then be added to restore fault tolerance.

Stripsets with parity come in 2 flavors: RAID 4 and RAID 5. Under RAID 4, all the parity stripes are stored on the same physical volume. This can become a bottleneck because all writes hit that physical volume, and it gets worse the more physical volumes are in the array. With RAID 5, the parity data is distributed evenly across the physical volumes so none of them become a bottleneck. For that reason, RAID 4 is rare and is considered obsolete/historical. In practice, all stripesets with parity are RAID 5.

{{RootCmd|lvcreate --type raid5 -l 20%VG -i 2 -n lvm_raid5 vg0}}

Only the data physical volumes are specified with -i, LVM adds one to it automatically for the parity. So for a 3 physical volume RAID5, ''-i 2'' is passed on and not ''-i 3''.

When a physical volume fails, then the volume group will need to be brought up in degraded mode:

{{RootCmd|vgchange -ay --partial vg0}}

The volume will work normally at this point, however this degrades the array to RAID 0 until a replacement physical volume is added. Performance is unlikely to be affected while the array is degraded - although it does need to recompute its missing data via parity, it only requires simple XOR for the parity block with the remaining data. The overhead is negligible compared to the disk I/O.

To repair the RAID5:

{{RootCmd|lvconvert --repair vg0/lvm_raid5
|vgreduce --removemissing vg0}}

It is possible to replace a still working physical volume in RAID5 as well:

{{RootCmd|lvconvert --replace /dev/sdb1 vg0/lvm_raid5
|vgreduce vg0 /dev/sdb1}}

The same restrictions of stripe sets apply to stripe sets with parity as well: it is not possible to enable striping with parity on an existing volume, nor reshape the stripes with parity across more/less physical volumes, nor to convert to a different RAID level/linear volume. A stripe set with parity can be mirrored. It is possible to extend a stripe set with parity across additional physical volumes, but they must be added in multiples of the original stripe set with parity (which will effectively linearly append a new stripe set with parity).

==== Thin RAID5 logical volumes ====

It is not (yet) possible to create stripe set with parity (RAID5) thin pools or thin logical volumes. It is possible to create a RAID5 thin pool by creating a normal RAID5 logical volume and then converting the logical volume into a thin pool with <tt>lvconvert</tt>. 2 logical volumes are required: one for the thin pool and one for the thin metadata; the conversion process will merge them into a single logical volume.

{{Warning|LVM 2.02.98 or above is required for this to work properly. Prior versions are either not capable or will segfault and corrupt the VG. Also, coversion of a RAID5 LV into a thin pool '''destroys''' all existing data in the LV!}}

{{RootCmd|lvcreate --type raid5 -i 2  -l20%VG -n thin_pool vg0
|lvcreate --type raid5 -i 2 -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg00/thin_meta}}

==== Striping with double parity (RAID6) ====

{{Note|RAID6 requires at least 5 physical volumes.}}

RAID 6 is similar to RAID 5, however RAID 6 can survive up to '''two''' physical volume failures, thus offering more fault tolerance than RAID5 at the expense of extra physical volumes. 

{{RootCmd|lvcreate --type raid6 -l 20%VG -i 3 -n lvm_raid6 vg00}}

Like raid5, the -i option is used to specify the number of physical volumes to stripe, excluding the 2 physical volumes for parity. So for a 5 physical volume RAID6, pass on ''-i 3'' and not ''-i 5''.

Recovery for RAID6 is the same as RAID5.

{{Note|Unlike RAID5 where parity block is cheap to recompute vs disk I/O, this is only half true in RAID6. RAID6 uses 2 parity stripes: One stripe is computed the same way as RAID5 (simple XOR). The second parity stripe is much harder to compute - see [https://www.kernel.org/pub/linux/kernel/people/hpa/raid6.pdf|raid6 (pdf)] for more information.}}

==== Thin RAID6 logical volumes ====

It is not (yet) possible to create a RAID6 thin pool or thin volumes. It is possible to create a RAID6 thin pool by creating a normal RAID6 logical volume and then converting the logical volume into a thin pool with <tt>lvconvert</tt>. 2 logical volumes are required: one for the thin pool and one for the thin metadata; the conversion process will merge them into a single logical volume.

{{Warning|LVM 2.02.98 or above is required for this to work properly. Prior versions are either not capable or will segfault and corrupt the VG. Also, conversion of a RAID6 LV into a thin pool '''destroys''' all existing data in the LV!}}

{{RootCmd|lvcreate --type raid6 -i 2  -l20%VG -n thin_pool vg0
|lvcreate --type raid6 -i 2 -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg0/thin_meta}}

==== LVM RAID10 ====

{{Note|RAID10 requires at least 4 physical volumes. Also LVM syntax requires the number of physical volumes be multiple of the numbers stripes and mirror, even though RAID10 format does not}}

RAID10 is a combination of RAID0 and RAID1. It is more powerful than RAID0+RAID1 as the mirroring is done at the stripe level instead of the logical volume level, and therefore the layout doesn't need to be symmetric. A RAID10 volume can tolerate at least a single missing physical volume, and possibly more.

{{Note|LVM currently limits RAID10 to a single mirror.}}

{{RootCmd|lvcreate --type raid10 -l 1020 -i 2 -m 1 --nosync -n lvm_raid10 vg0}}

Both the ''-i and -m'' options are specified: ''-i'' is the number of stripes and ''-m'' is the number of mirrors. Two stripes and 1 mirror requires 4 physical volumes.

==== Thin RAID10 ====

It is not (yet) possible to create a RAID10 thin pool or thin volumes. It is possible to create a RAID10 thin pool by creating a normal RAID10 logical volume and then converting the logical volume into a thin pool with <code>lvconvert</code>. 2 logical volumes are required: one for the thin pool and one for the thin metadata; the conversion process will merge them into a single logical volume.
 
{{Warning|Conversion of a RAID10 logical volume into a thin pool '''destroys''' all existing data in the logical volume!}}

{{RootCmd|lvcreate -i 2 -m 1 --type raid10 -l 1012 -n thin_pool vg0
|lvcreate -i 2 -m 1 --type raid10 -l 6 -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg0/thin_meta}}

== Experimenting with LVM ==

It is possible to experiment with LVM without using real storage devices. To accomplish this, loopback devices are created.

First make sure to have the loopback module loaded. 

{{RootCmd|modprobe -r loop && modprobe loop max_part{{=}}63}}

{{Note|If loopback support is built into the kernel, then use <code>loop.max_part{{=}}63</code> as boot option.}}

Next configure LVM to not use [[udev]] to scan for devices:

{{File|/etc/lvm/lvm.conf|Disabling udev in LVM config|<pre>
obtain_device_list_from_udev = 0
</pre>}}

{{Important|This is for testing only, make sure to change the setting back when dealing with real devices since it is much faster to use udev!}}

Create some image files which will become the storage devices. The next example uses five files for a total of about ~10GB of real hard drive space:

{{RootCmd|mkdir /var/lib/lvm_img
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm0.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm1.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm2.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm3.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm4.img bs{{=}}1024 seek{{=}}2097152}}

Check which loopback devices are available:

{{RootCmd|losetup -a}}

Assuming all loopback devices are available, next create the devices:

{{RootCmd|losetup /dev/loop0 /var/lib/lvm_img/lvm0.img
|losetup /dev/loop1 /var/lib/lvm_img/lvm1.img
|losetup /dev/loop2 /var/lib/lvm_img/lvm2.img
|losetup /dev/loop3 /var/lib/lvm_img/lvm3.img
|losetup /dev/loop4 /var/lib/lvm_img/lvm4.img}}

The {{Path|/dev/loop[0-4]}} devices are now available to use as any other hard drive in the system (and thus be perfect for physical volumes).

{{Note|On the next reboot, all the loopback devices will be released and the folder {{Path|/var/lib/lvm_img}} can be deleted.}}

== Troubleshooting ==

LVM has a few features that already provide some level of redundancy. However, there are situations where it is possible to restore lost physical volumes or logical volumes.

=== vgcfgrestore utility ===

By default, on any change to a LVM physical volume, volume group, or logical volume, LVM2 create a backup file of the metadata in {{Path|/etc/lvm/archive}}. These files can be used to recover from an accidental change (like deleting the wrong logical volume). LVM also keeps a backup copy of the most recent metadata in {{Path|/etc/lvm/backup}}. These can be used to restore metadata to a replacement disk, or repair corrupted metadata.

To see what states of the volume group are available to be restored (partial output to improve readability):

{{RootCmd|vgcfgrestore --list vg00|output=<pre>
  File:		/etc/lvm/archive/vg0_00042-302371184.vg
  VG name:    	vg0
  Description:	Created *before* executing 'lvremove vg0/lvm_raid1'
  Backup Time:	Sat Jul 13 01:41:32 201
</pre>}}

==== Recovering an accidentally deleted logical volume ====

Assuming the logical volume ''lvm_raid1'' was accidentally removed from volume group ''vg0'', it is possible to recover it as follows:

{{RootCmd|vgcfgrestore -f /etc/lvm/archive/vg0_00042-302371184.vg vg0}}

{{Important|<tt>vgcfgrestore</tt> only restores LVM metadata, ''not'' the data inside the logical volume. However <code>pvremove</code>, <code>vgremove</code>, and <code>lvremove</code> only wipe metadata, leaving any data intact. If <code>issue_discards</code> is set in {{Path|/etc/lvm/lvm.conf}} though, then these command ''are'' destructive to data.}}

==== Replacing a failed physical volume ====

It possible to do a true "replace" and recreate the metadata on the new physical volume to be the same as the old physical volume:

{{RootCmd|vgdisplay --partial --verbose|output=<pre>
  --- Physical volumes ---
  PV Name               /dev/loop0     
  PV UUID               iLdp2U-GX3X-W2PY-aSlX-AVE9-7zVC-Cjr5VU
  PV Status             allocatable
  Total PE / Free PE    511 / 102
  
  PV Name               unknown device     
  PV UUID               T7bUjc-PYoO-bMqI-53vh-uxOV-xHYv-0VejBY
  PV Status             allocatable
  Total PE / Free PE    511 / 102
</pre>}}

The important line here is the UUID "unknown device". 

{{RootCmd|pvcreate --uuid T7bUjc-PYoO-bMqI-53vh-uxOV-xHYv-0VejBY --restorefile /etc/lvm/backup/vg0 /dev/loop1|output=<pre>
  Couldn't find device with uuid T7bUjc-PYoO-bMqI-53vh-uxOV-xHYv-0VejBY.
  Physical volume "/dev/loop1" successfully created</pre>}}

This recreates the physical volume metadata, but not the missing logical volume or volume group data on the physical volume.

{{RootCmd|vgcfgrestore -f /etc/lvm/backup/vg0 vg0|output=<pre>
  Restored volume group vg0
</pre>}}

This now reconstructs all the missing metadata on the physical volume, including the logical volume and volume group data. However it doesn't restore the data, so the mirror is out of sync.

{{RootCmd|vgchange -ay vg0|output=<pre>
  device-mapper: reload ioctl on  failed: Invalid argument
  1 logical volume(s) in volume group "vg0" now active
</pre>}}

{{RootCmd|lvchange --resync vg0/lvm_raid1|output=<pre>
Do you really want to deactivate logical volume lvm_raid1 to resync it? [y/n]: y
</pre>}}

This will resync the mirror. This works with RAID 4,5 and 6 as well. 

=== Deactivating a logical volume ===

It is possible to deactivate a logical volume with the following command:

{{RootCmd|umount /dev/vg0/lvol1
|lvchange -a n /dev/vg0/lvol1}}

It is not possible to mount the logical volume anywhere before it gets reactivated:

{{RootCmd|lvchange -a y /dev/vg0/lvol1}}

== External resources ==

* [http://sourceware.org/lvm2/ LVM2 sourceware.org]
* [http://tldp.org/HOWTO/LVM-HOWTO/ LVM tldp.org]
* [http://sources.redhat.com/lvm2/wiki/ LVM2 Wiki redhat.com]


[[Category:Core system]]
