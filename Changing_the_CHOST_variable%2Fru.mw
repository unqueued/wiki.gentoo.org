<languages />

{{Metadata|abstract=Данный документ объясняет, как изменить переменную CHOST на существующей системе.}}

Данный документ объясняет, как изменить переменную  <var>[[CHOST]]</var> на существующей системе.

== Введение ==

Изменение <var>CHOST</var> может доставить много «головной боли» и серьезно испортить систему. Зачем тогда нужно данное руководство, если это может привести к хаосу? 

Существуют ситуации, когда изменение переменной <var>CHOST</var> необходимо, например, при обновлении библиотеки glibc до версии 2.4, которая поддерживает nptl, пользователь узнается, что текущий <var>CHOST</var> — это i386, что делает использование nptl невозможным. В данном случае не так уж и много возможностей, и изменение <var>CHOST</var> одна из них. 

Проблемы могут возникнуть, даже после выполнения этих инструкций, так что, пожалуйста, внимательно читайте и очень тщательно выполняйте их. В данном примере переменная <var>CHOST</var> изменится с i386 на i686. Пожалуйста, скорректируйте команды в соответствии с персональной ситуацией. 

== Изменение переменной CHOST ==

=== Собираем пакеты ===

Сначала изменим переменную <var>CHOST</var>. Отредактируйте файл {{Path|/etc/portage/make.conf}}, изменив значение <var>CHOST</var> на то, что необходимо. Затем пересоберите пакеты в следующем порядке: 

{{Emerge|binutils gcc glibc|params+=--oneshot}}

{{Important|Пожалуйста, имейте в виду, что мажорное обновление gcc выполнено во время изменения переменной <var>CHOST</var> (например, с gcc 3.3, CHOST i386 на gcc 4.1, CHOST i686) может привести к серьёзным побочным эффектам. Тяжело, наверное предсказать, какие могут возникнуть потенциальные проблемы и почти невозможно документировать их в данном руководстве. Так что, пожалуйста, делайте одну вещь за раз. К примеру, сначала обновите gcc в соответствии с [[Upgrading_GCC/ru|руководством по обновлению gcc]], а после этого измените <var>CHOST</var>. Если в системе установлено <var>CHOST</var> в значение i386, то замаскируйте версии 2.4 и выше библиотеки glibc до завершения обновления gcc, так как они не могут использоваться с i386. Размаскируйте их после полного завершения изменений.}}

{{Note|Перед компиляцией gcc может понадобиться запустить {{c|binutils-config}}.}}

=== Проверяем, что всё работает ===

Пришло время проверить, что настройки {{c|gcc-config}} и {{c|binutils-config}} в порядке, и что нет никакого «мусора» в {{Path|/etc/env.d/}}. 

Вывод {{c|gcc-config}} и {{c|binutils-config}} должен выглядеть следующим образом:

{{Note|Вывод скорее всего будет отличаться в зависимости от версии gcc и настроек <var>CHOST</var>. В примере ниже используется gcc 4.1.1 на i686.}} 

{{RootCmd|gcc-config -l|output=<pre>
 [1] i686-pc-linux-gnu-4.1.1 *</pre>}}

{{RootCmd|gcc-config -c|output=<pre>
i686-pc-linux-gnu-4.1.1</pre>}}

{{RootCmd|binutils-config -l|output=<pre>
 [1] i686-pc-linux-gnu-2.16.1 *
# binutils-config -c
i686-pc-linux-gnu-2.16.1
</pre>
}}

Теперь проверим, остались ли ссылки на старую переменную <var>CHOST</var> в {{Path|/etc/env.d/}}: 

{{RootCmd|cd /etc/env.d/
|grep 386 *|output=<pre>
05gcc-i386-pc-linux-gnu:PATH="/usr/i386-pc-linux-gnu/gcc-bin/4.1.1"
05gcc-i386-pc-linux-gnu:ROOTPATH="/usr/i386-pc-linux-gnu/gcc-bin/4.1.1"
</pre>
}}

{{Note|Обычно этого может не произойти, но в рассматриваемом примере файл {{Path|05gcc-i386-pc-linux-gnu}} содержит ссылку на старое значение <var>CHOST</var>. Ситуация может выглядеть иначе на других системах, в зависимости от того, с какого и на какое значение меняется <var>CHOST</var>. В некоторых случаях не остается никаких упоминаний. Имя файла также может быть {{Path|05gcc-''new_CHOST''-pc-linux-gnu}}.}}

Перед удалением файла проверьте файлы с новым <var>CHOST</var>: 

{{RootCmd|grep 686 *|output=<pre>
05binutils:MANPATH=/usr/share/binutils-data/i686-pc-linux-gnu/2.16.1/man
05binutils:INFOPATH=/usr/share/binutils-data/i686-pc-linux-gnu/2.16.1/info
05binutils:LDPATH=/usr/i686-pc-linux-gnu/lib
05gcc:PATH="/usr/i686-pc-linux-gnu/gcc-bin/4.1.1"
05gcc:ROOTPATH="/usr/i686-pc-linux-gnu/gcc-bin/4.1.1"
05gcc:MANPATH="/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/man"
05gcc:INFOPATH="/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/info"
05gcc:LDPATH="/usr/lib/gcc/i686-pc-linux-gnu/4.1.1"
</pre>
}}

Всё выглядит хорошо, так как для <code>gcc</code> всегда должен быть только один файл в {{Path|/etc/env.d/}} (в этом примере {{Path|05gcc}}), так что удалим файл с ошибочной ссылкой: 

{{RootCmd|rm 05gcc-i386-pc-linux-gnu}}

Аналогично поступим с файлами {{Path|binutils}}: если существует больше одного файла, смотрите, какой является устаревшим и удалите его. Далее, проверьте содержимое {{Path|/etc/env.d/binutils/}}.

{{RootCmd|cd /etc/env.d/binutils/
|ls -la|output=<pre>
total 8
-rw-r--r-- 1 root root  15 Sep  3 13:48 config-i686-pc-linux-gnu
-rw-r--r-- 1 root root 126 Sep  3 13:48 i686-pc-linux-gnu-2.16.1
</pre>}}

{{RootCmd|cat config-i686-pc-linux-gnu|output=<pre>
CURRENT=2.16.1</pre>}}

{{RootCmd|cat i686-pc-linux-gnu-2.16.1|output=<pre>
TARGET="i686-pc-linux-gnu"
VER="2.16.1"
LIBPATH="/usr/lib/binutils/i686-pc-linux-gnu/2.16.1"
FAKE_TARGETS="i686-pc-linux-gnu"
</pre>
}}

Всё хорошо, эти два файла и должны быть тут. Пришло время заглянуть в каталог {{Path|gcc/}}. 

{{RootCmd|cd /etc/env.d/gcc|output=<pre>
# ls -la
total 12
-rw-r--r-- 1 root root  32 Sep  3 16:43 config
-rw-r--r-- 1 root root  32 Aug  3 14:25 config-i386-pc-linux-gnu
-rw-r--r-- 1 root root 292 Sep  3 16:43 i686-pc-linux-gnu-4.1.1
</pre>}}

{{RootCmd|cat config|output=<pre>
CURRENT=i686-pc-linux-gnu-4.1.1</pre>}}

{{RootCmd|cat config-i386-pc-linux-gnu|output=<pre>
CURRENT=i386-pc-linux-gnu-4.1.1</pre>}}

{{RootCmd|cat i686-pc-linux-gnu-4.1.1|output=<pre>
PATH="/usr/i686-pc-linux-gnu/gcc-bin/4.1.1"
ROOTPATH="/usr/i686-pc-linux-gnu/gcc-bin/4.1.1"
LDPATH="/usr/lib/gcc/i686-pc-linux-gnu/4.1.1"
GCCBITS="32"
MANPATH="/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/man"
INFOPATH="/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/info"
STDCXX_INCDIR="g++-v4"
</pre>
}}

Файлы {{Path|config}} и {{Path|i686-pc-linux-gnu-4.1.1}} в порядке, а {{Path|config-i386-pc-linux-gnu}} — «мусор», который нужно удалить. 

{{Note|Опять же файл, содержащий ссылку на старую версию gcc, может иметь другое имя (например, {{Path|config-i686-pc-linux-gnu}}) даже в случае, когда система меняется (в данном случае) на <var>CHOST</var> i686. Важно различать файлы по содержимому, а не только по имени.}}

{{RootCmd|rm config-i386-pc-linux-gnu}}

Теперь запустите следующую команду для обновления переменных среды: 

{{RootCmd|env-update && source /etc/profile}}

Далее проверим, что всё в порядке: 

{{RootCmd|grep -r 386 /etc/env.d/}}

Если все еще находятся файлы, попробуйте отследить их, прежде чем продолжить.

=== Завершение изменений ===

Теперь нужно пересобрать {{Package|sys-devel/libtool}} и запустить {{c|fix_libtool_files.sh}}, который можно найти в {{Path|/usr/share/gcc-data/''$CHOST''/''<gcc-version>''/}}. Убедитесь, что указали правильную версию gcc (текущую выбранную, здесь 4.1.1) и передали старую архитектуру (здесь i386) в качестве аргумента. Замените <code>$CHOST</code> новым значением переменной <var>CHOST</var>, а <code><gcc-version></code> версией gcc. Следующий пример подразумевает <var>CHOST</var> значение i686. 

{{Emerge|libtool|params+=--oneshot}}

{{RootCmd|/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/fix_libtool_files.sh 4.1.1 --oldarch i386-pc-linux-gnu}}

Теперь можно пересобрать все пакеты: 

{{RootCmd|emerge -e world}}

Теоретически это не нужно делать и нет 100% гарантии, что это актуально в данном примере.

Следующие пакеты должны быть пересобраны: 

{{Emerge|python|params+=--oneshot}}

Все пакеты, использующие perl устанавливаются в каталог, связанный с <var>CHOST</var>, а значит, требуют пересборки. В случае, если {{c|qfile}} не установлен в системе еще, то сперва установите {{Package|app-portage/portage-utils}}.

{{Emerge|portage-utils}}

Теперь пересоберите все пакеты, которые имеют файлы установленные в директориях {{Path|/usr/lib/perl*}}

{{RootCmd|emerge -av1 `qfile /usr/lib/perl* -Cq {{!}} sort -u`}}

Если обнаружили пакет, который также требует пересборки, то, пожалуйста, сообщите нам на [[Talk:Changing_the_CHOST_variable|странице обсуждения]] этого руководства.

=== Известные проблемы ===

При обновлении с gcc 3.3 до 4.1 одновременно с изменением переменной <var>CHOST</var> (и всё же, пожалуйста, не делайте этого), пара пользователей сообщала о «битых» пакетах, которые нуждаются в пересборке, таких как  {{Package|sys-apps/groff}} и {{Package|mail-mta/courier}}: 

{{CodeBox|title=Сообщение об ошибке|1=
error while loading shared libraries: libstdc++.so.5: cannot open shared object file: No such file or directory
}}

Это происходит, поскольку процессе обновления <var>CHOST</var> не соответствует <var>CTARGET</var>, из-за чего компилятор считает что в системе используется кросс-компиляция. Как следствие, <var>LDPATH</var> не вносится в {{Path|ld.so.conf}}, что приводит к ошибке. 

Пожалуйста, обратитесь к [[Upgrading_GCC/ru|руководству по обновлению GCC]], чтобы узнать какие пакеты нуждаются в пересборке после обновления GCC. 

В некоторый редких случаях, могут также «сломаться» старые версии python. Это можно исправить, добавив {{Path|/usr/lib/gcc-lib/i386-pc-linux-gnu/3.3.6}} (измените в соответствии со старым <var>CHOST</var> и версией gcc) в {{Path|/etc/ld.so.conf}}, запустите {{c|ldconfig}} и, затем, {{c|emerge libstdc++-v3}}. Однако, как можно увидеть, этих проблем определённо стоит избегать — не изменяйте <var>CHOST</var> и версию gcc одновременно.

=== Обратная связь ===

На этом, должно быть, всё. Отзывы (как в случае, если это сработало, так и в случае неудачи или неожиданных проблем) приветствуются: пожалуйста, используйте [[Talk:Changing_the_CHOST_variable|страницу обсуждения]] или сообщите [https://forums.gentoo.org/viewtopic-t-494147.html в этом треде форума]. Многое в этом руководстве сделано участником vapier, спасибо за помощь!

{{Migrated|originalauthors=Wernfried Haas, {{Dev|vapier}}, Chris White}}
