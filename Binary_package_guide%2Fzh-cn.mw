<languages />
{{Metadata|abstract=Portage 支持构建与安装二进制包。本指南将解释如何创建、安装二进制包，以及如何配置一个二进制包服务器。}}

除了支持通常的 ebuilds 之外， Portage 还支持构建、安装二进制包。
本指南将解释如何创建、安装二进制包，以及如何配置一个二进制包服务器。

== 介绍 ==

有很多原因为什么系统管理员喜欢在 Gentoo 中使用二进制包安装方式。

# 首先，它允许管理员 ''将相似的系统保持最新''。从源代码编译所有东西是很耗费时间的。维护许多相似的系统，可能其中的一些硬件较老，如果一个系统将所有东西从源代码编译好，其他系统重用这些二进制包，工作就会变得轻松。
# 第二个原因是 ''执行安全升级''。对于关键任务系统来说，保持尽可能大的 ''可用性'' 是很重要的。这可以通过一台预备服务器来实现，它首先自己执行所有的更新。一旦预备服务器更新后状态良好，那么更新可以被应用到关键系统上。这种方法的一个变形是在同一个系统的一个 chroot 中执行更新，并且在真正的系统中使用所创建的二进制包。
# 第三个原因是 ''作为一个备份''。通常二进制包是恢复一个受损系统的唯一方法（例如编译器受损）。拥有一台二进制包服务器上的或者本地的预编译二进制包，对于工具链受损的情况有很大的帮助。
# 最后，它也支持 ''更新非常旧的系统''。更新非常旧的系统这项任务可以通过使用二进制包来大大减轻。通常在旧的系统上安装二进制包是有益的，因为它们不需要安装/更新构建时依赖。因为二进制包是预编译的，这也避免了在构建过程中发生失败。

本指南将包括以下话题： 

* 如何创建二进制包；
* 如何将二进制包发布到客户端；
* 如何使用二进制包;
* 如何维护二进制包。

在向导的末尾还包含几个关于二进制包操作的高级话题。

{{Note/zh-cn|除非另行指出，本指南中使用的所有的工具都是 {{Package|sys-apps/portage}} 的组成部分。}}

== 创建二进制包 ==

创建二进制包有三种主要的方法：

# 在一次常规安装后，使用{{c|quickpkg}}程序；
# 在 {{c|emerge}} 操作中显式使用 <code>--buildpkg (-b)</code> 选项；
# 通过使用 Portage 的 <code>buildpkg</code> 特性自动完成。

所有这三种方法都将在 <var>PKGDIR</var> 变量指向的目录创建二进制包（默认为 {{Path|/usr/portage/packages}}）。

=== 使用 quickpkg ===

{{c|quickpkg}} 程序接收一个或多个依赖 atoms （或者包集合）并对所有与那个 atom 匹配的 ''已安装'' 包创建二进制包。

例如，要对所有已安装 GCC 版本创建二进制包：

{{RootCmd|quickpkg sys-devel/gcc}}

要对系统中所有已安装包创建二进制包，使用 <code>*</code> 通配符：

{{RootCmd|quickpkg "*/*"}}

这种方法有一点要注意：它依赖已安装的文件，会在配置文件上发生问题。管理员经常在安装完软件后改变配置文件。因为这可能向包中泄露重要（甚至可能是机密）数据， {{c|quickpkg}} 默认通过 <var>CONFIG_PROTECT</var> 方法保护配置文件''不''被包含在内。要强制包含配置文件，使用 <code>--include-config</code> 或 <code>--include-unmodified-config</code> 选项。

=== 使用 --buildpkg 作为 emerge 选项 ===

当使用 {{c|emerge}} 安装软件时， Portage 可以通过 <code>--buildpkg (-b)</code> 选项被要求创建二进制包：

{{Emerge|params+=--buildpkg|sys-devel/gcc}}

还可以要求 Portage ''只'' 创建二进制包却 ''不'' 在活动系统上安装软件。 这种情况下，使用 <code>--buildpkgonly (-B)</code> 选项：

{{Emerge|params+=--buildpkgonly|sys-devel/gcc}}

后一种方法还是需要构建时的依赖事先已安装。

=== 作为 Portage 特性实现 buildpkg ===

最常用的自动创建二进制包的方式是每当使用 Portage 安装一个包就自动创建二进制包，通过使用 <code>buildpkg</code> 特性来实现，可以在 {{Path|/etc/portage/make.conf}} 中进行设置，例如：

{{FileBox|filename=/etc/portage/make.conf|title=Enabling Portage's buildpkg feature|lang=bash|1=
FEATURES="buildpkg"
}}

开启这项特性后，每次 Portage 安装软件，它将也创建一个二进制包。

=== 排除一些包的创建 ===

告诉 Portage 不要对一些指定的包或分类创建二进制包也是可以的。 这个可以通过向 emerge 传递 <code>--buildpkg-exclude</code> 选项：

{{RootCmd|emerge -uDN @world --buildpkg --buildpkg-exclude "virtual/* sys-kernel/*-sources"}}

这可以对那些不值得创建二进制包的包使用。例如 Linux 内核代码包或上游二进制包（那些以 -bin 结尾如 {{Package|www-client/firefox-bin}}）。

== 配置二进制包主机 ==

Portage 支持多种下载二进制包的协议：FTP、FTPS、HTTP、HTTPS和SSH。这为多种可能的二进制包主机的实现提供了空间。

可是，Portage 并没有提供一个“现成”的方法来分发二进制包。根据需求还需要安装额外的软件。

=== 基于 Web 的二进制包主机 ===

一种常用的分发二进制包的方法是创建一个基于 web 的二进制包主机。

使用一个 web 服务器如 [[lighttpd]] ({{Package|www-servers/lighttpd}}) 并且将其配置为提供对 {{Path|/etc/portage/make.conf}} 中 <var>PKGDIR</var> 位置的读权限。

{{FileBox|filename=/etc/lighttpd/lighttpd.conf|title=lighttpd 配置范例|lang=bash|1=
# add this to the end of the standard configuration
server.modules += ( "mod_alias" )
alias.url = ( "/packages" => "/usr/portage/packages/" )
}}

之后，在客户系统，对应地设置 <var>PORTAGE_BINHOST</var> 变量：

{{FileBox|filename=/etc/portage/make.conf|title=Using a web-based binary package host|lang=bash|1=
PORTAGE_BINHOST="http://binhost.example.com/packages"
}}

=== SSH 二进制包主机 ===

要提供一种更多身份验证的二进制包方法，可是考虑使用 SSH 。

当使用 SSH ，可以使用 Portage Linux 用户的 SSH 密钥 (without passphrase as the installations need to happen in the background) 来连接到远程二进制包主机。

要实现这个，确保 Portage 用户的 SSH 密钥被服务器所接受的。这需要每台通过 SSH 链接到二进制包主机的客户机的 SSH 密钥都是被服务器接受的。

{{RootCmd|cat portage.id_rsa.pub >> /home/binpkguser/.ssh/authorized_keys}}

<var>PORTAGE_BINHOST</var> 看起来如下：

{{FileBox|filename=/etc/portage/make.conf|title=配置PORTAGE_BINHOST用于SSH访问|lang=bash|1=
PORTAGE_BINHOST="ssh://binpkguser@binhostserver/usr/portage/packages"
}}

{{Note|Don't use ssh's config in {{Path|~/.ssh/config}} for setting ports or username as it'll be ignored when portage tries to rsync the packages back onto the client. Instead set all the options correctly in the <var>PORTAGE_BINHOST</var> variable.}}

=== NFS 导出 ===

当在内网中使用二进制包，可以更简单地通过 NFS 导出包并在客户系统进行挂载。

{{Path|/etc/exports}} 文件看起来如下：

{{FileBox|filename=/etc/exports|title=Exporting the packages directory|1=
/usr/portage/packages   2001:db8:81:e2::/48(ro,no_subtree_check,root_squash) 192.168.100.1/24(ro,no_subtree_check,root_squash)
}}

在客户系统，这个位置就可以被挂载。例如 {{Path|/etc/fstab}} 看起来如下：

{{FileBox|filename=/etc/fstab|title=包目录的挂载点|1=
binhost:/usr/portage/packages      /usr/portage/packages    nfs    defaults    0 0
}}

== 使用二进制包 ==

要在其他系统使用二进制包，需要满足一些条件：

* 客户机和服务器的架构以及[[CHOST]]关键字的设置必须是一致的。
* 用来创建二进制包的<var>CFLAGS</var>和<var>CXXFLAGS</var>两个参数的设置必须和所有的客户机兼容。
* 针对处理器特定功能的USE设置（如MMX,SSE,...）要仔细选择，以保证所有的客户机都支持这些功能。

{{Important/zh-cn|Portage不会验证是否满足上述条件，因为维护这些设置是系统管理员的职责。}}

除了这些，Portage将检查创建二进制包时是否用和客户机一样的USE设置。如果二进制包是用不同的USE设置来创建的，Portage将忽略这个二进制包（改为使用基于源代码的方式进行安装）或者提示安装失败，取决于运行{{c|emerge}}命令时所带的选项（参看[[#安装二进制包|安装二进制包]]）。

为了使用二进制包，在客户机上有几个配置需要更改。

=== 安装二进制包 ===

在运行 {{c|emerge}} 命令时有几个选项可以用于告诉 Portage 使用二进制包：

{| class="table table-condensed table-striped"
|-
! scope="col" width="20%" | Option 
! Description
|-
| <code>--usepkg</code> <code>(-k)</code> || Tries to use the binary package(s) in the locally available {{Path|packages}} directory. Useful when using [[NFS]] or [[SSHFS]] mounted binary package hosts. If the binary packages are not found, a regular (source-based) installation will be performed.
|-
| <code>--usepkgonly</code> <code>(-K)</code> || Similar to <code>--usepkg (-k)</code> but fail if the binary package cannot be found. This option is useful if only ''pre-built'' binary packages are to be used.
|-
| <code>--getbinpkg</code> <code>(-g)</code> || Download the binary package(s) from a remote binary package host. If the binary packages are not found, a regular (source-based) installation will be performed.
|-
| <code>--getbinpkgonly</code> <code>(-G)</code> || Similar to <code>--getbinpkg (-g)</code> but will fail if the binary package(s) cannot be downloaded. This option is useful if only ''pre-built'' binary packages are to be used.
|}

为了自动使用二进制包进行安装，可以在<var>EMERGE_DEFAULT_OPTS</var>变量增加适当的选项：

{{FileBox|filename=/etc/portage/make.conf|title=自动下载二进制包，二进制包不存在的时候提示失败|lang=bash|1=
EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --getbinpkgonly"
}}

有一个Portage功能特性可以自动实现和<code>--getbinpkg (-g)</code>一样的功能，而不用更改<var>EMERGE_DEFAULT_OPTS</var>变量: <code>getbinpkg</code>.

{{FileBox|filename=/etc/portage/make.conf|title=Enabling getbinpkg as Portage feature|lang=bash|1=
FEATURES="getbinpkg"
}}

=== 从二进制包主机下载包 ===

当使用二进制包主机时，客户机需要配置<var>PORTAGE_BINHOST</var>变量。不然，客户机不知道二进制包的存放位置将导致Portage无法获取二进制包。

{{FileBox|filename=/etc/portage/make.conf|title=Setting PORTAGE_BINHOST|lang=bash|1=
PORTAGE_BINHOST="http://binhost.example.com/packages"
}}

<var>PORTAGE_BINHOST</var>变量使用一个用空格进行分割的URI列表。这可以让管理员可以同时使用不同的二进制包主机。URI地址应该总是指向{{Path|Packages}}文件所在的目录。

{{Note/zh-cn|对于多个二进制包服务器的支持还不是很完整。如果几个服务器提供同一个版本的二进制包，那么只会使用第一个。当这些二进制包的USE变量配置不一样，而且后面的二进制包的USE变量配置是适合当前系统配置的情况下会产生问题。}}

===重安装修改过的二进制包===

传递 <code>--rebuilt-binaries</code> 选项给 {{c|emerge}} 将重新安装所有重建过的二进制包。这常用于二进制包服务器运行过象 {{c|revdep-rebuild}} 或者 {{c|python-updater}} 这种重建工具的场景。

一个相关的选项是<code>--rebuilt-binaries-timestamp</code>。它将使emerge不会重新安装那些在给定的时间标签之前已经建立的二进制包。如果二进制包服务器不得不从头开始重建而又要使用<code>--rebuilt-binaries</code>选项，这对于避免重新安装所有的包来说是很有用。

===额外的客户端设置===

跟着 <code>getbinpkg</code> 功能特性，Portage还接受 <code>binpkg-logs</code> 这个功能特性。这个特性控制是否保留二进制包成功安装记录的日志文件。它只有在设置了<var>PORT_LOGDIR</var>变量的情况下才会生效，默认为启用。

和从特定的包集合或分类中排除一些二进制包类似，客户机可以配置为从特定的包集合或分类中排除一些二进制包的安装。

用<code>--usepkg-exclude</code>选项来实现这一功能：

{{RootCmd|emerge -uDNg @world --usepkg-exclude "sys-kernel/gentoo-sources virtual/*"}}

To enable such additional settings for each emerge command, add the options to the <code>EMERGE_DEFAULT_OPTS</code> variable in the {{Path|make.conf}} file:

{{FileBox|title=Enabling emerge settings on every invocation|filename=/etc/portage/make.conf|1=
EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --usepkg-exclude 'sys-kernel/gentoo-sources virtual/*'"
}}

== 维护二进制包 ==

如果二进制包列表不积极维护，导出和分发二进制包只会白白浪费存储空间。

=== 删除过期的二进制包 ===

{{Package|app-portage/gentoolkit}} 包提供了一个叫 {{c|eclean}}  的应用。它可以用来维护Portage相关的一系列文件，如下载的源代码文件和二进制包。

以下命令将删除所有没有对应ebuild文件的二进制包：

{{RootCmd|eclean packages}}

请阅读[[Eclean]]的相关文章以了解更多细节。

另外一个可用的工具是 {{Package|app-portage/portage-utils}} 包所提供的 {{c|qpkg}} 工具。不过，这个工具的可配置性稍微差些。

清理“无用”的二进制包（应用于存放二进制包的服务器上）：

{{RootCmd|qpkg -c}}

=== 维护包文件 ===

在存放二进制包的目录里有一个叫 {{Path|Packages}} 的文件存在，这个文件缓存了包目录里所有二进制包的元数据。每当 Portage 添加一个二进制包到目录里去的时候就会更新这个文件。类似的，当 {{c|eclean}} 删除二进制包的时候也会更新它。

当出于某些原因要简单地删除二进制包或将它们复制到包目录里去的时侯；或者  {{Path|Packages}} 文件损坏或被删除了的时候，那么就必须重建这个文件。通过使用 {{c|emaint}} 命令来完成这个工作：

{{RootCmd|emaint binhost --fix}}

== 高级主题 ==

=== 建立二进制包目录的快照 ===

当需要分发二进制包给大量的客户机系统的时候，建立包目录的快照可能会比较划算。客户机系统就不是直接使用包目录，而是使用快照所提供的二进制包。

可以使用 {{Path|/usr/lib64/portage/python2.7/binhost-snapshot}} 或者 {{Path|/usr/lib64/portage/python3.3/binhost-snapshot}} 工具来创建快照。它需要四个参数：

# 一个源目录（包目录的路径）。
# 一个目标目录（目录必须不存在）。
# 一个URI地址。
# 一个二进制包服务器目录。

将包目录的文件复制到目标目录，然后在URI地址所指向的二进制包服务器的目录（第四个参数）里创建一个{{Path|Packages}}文件。

客户系统需要使用一个指向二进制包服务器的 URI 地址。然后他们将会被重定向到被传递给 {{c|binhost-snapshot}} 的快照URI地址。这个快照 URI 地址必须指向目标目录。

=== 理解二进制包的格式 ===

Portage 所创建的二进制包的文件名以 {{Path|tbz2}} 结尾，这种文件由两部分构成：

# 一个 {{Path|.tar.bz2}} 的归档文件，包含了将会安装到系统中的文件；
# 一个 {{Path|xpak}} 的归档文件包含了包的元数据，ebuild 和环境文件。

查看 {{c|man xpak}} 来了解格式描述。

在 {{Package|app-portage/portage-utils}} 中有一些工具能分解或创建 {{Path|tbz2}} 和 {{Path|xpak}} 文件。

下列命令可以将 {{Path|tbz2}} 文件分解成一个 {{Path|.tar.bz2}} 和一个 {{Path|.xpak}} 文件：

{{Cmd|qtbz2 -s <package>.tbz2}}

{{Path|.xpak}} 文件可以用 {{c|qxpak}} 工具来检查。

列出其内容：

{{Cmd|qxpak -l <package>.xpak}}

下一条命令将生成一个叫 {{Path|USE}} 的文件，文件包含了这个包所使用的 USE 设置:

{{Cmd|qxpak -x package-manager-0.xpak USE}}

=== PKGDIR的布局 ===

目前使用的布局（版本2）如下：

{{CodeBox|title=包目录布局 (版本2)|1=
PKGDIR
`+- Packages
 +- app-accessibility/
 {{!}}  +- pkg1-version.tbz2
 {{!}}  `- pkgN-version.tbz2
 +- app-admin/
 {{!}}  `- ...
 `- ...
}}

{{Path|Packages}} 文件是在第一个二进制包目录布局（版本1）之上最主要的改进（同时也是让 Portage 知道二进制包目录使用版本2的触发器）。在版本1中，所有二进制包都被放在一个叫 {{Path|All/}} 的目录里，而分类目录只是指向 {{Path|All/}} 目录中二进制包的符号链接。

=== 用 quickunpkg 来解包 ===

Zoobab 编写了一个叫 [https://github.com/zoobab/quickunpkg quickunpkg] 的简单脚本程序来快速解包 {{Path|tbz2}} 文件。


[[Category:Portage]]
