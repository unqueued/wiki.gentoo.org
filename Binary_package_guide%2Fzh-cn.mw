<languages />
{{Metadata|abstract=Portage 支持构建与安装二进制包。本指南将解释如何创建、安装二进制包，以及如何配置一个二进制包服务器。}}

除了支持通常的 ebuilds 之外， Portage 还支持构建、安装二进制包。
本指南将解释如何创建、安装二进制包，以及如何配置一个二进制包服务器。

== 介绍 ==

有很多原因为什么系统管理员喜欢在 Gentoo 中使用二进制包安装方式。

# 首先，它允许管理员 ''将相似的系统保持最新''。从源代码编译所有东西是很耗费时间的。维护许多相似的系统，可能其中的一些硬件较老，如果一个系统将所有东西从源代码编译好，其他系统重用这些二进制包，工作就会变得轻松。
# 第二个原因是 ''执行安全升级''。对于关键任务系统来说，保持尽可能大的 ''可用性'' 是很重要的。这可以通过一台预备服务器来实现，它首先自己执行所有的更新。一旦预备服务器更新后状态良好，那么更新可以被应用到关键系统上。这种方法的一个变形是在同一个系统的一个 chroot 中执行更新，并且在真正的系统中使用所创建的二进制包。
# 第三个原因是 ''作为一个备份''。通常二进制包是恢复一个受损系统的唯一方法（例如编译器受损）。拥有一台二进制包服务器上的或者本地的预编译二进制包，对于工具链受损的情况有很大的帮助。
# 最后，它也支持 ''更新非常旧的系统''。更新非常旧的系统这项任务可以通过使用二进制包来大大减轻。通常在旧的系统上安装二进制包是有益的，因为它们不需要安装/更新构建时依赖。因为二进制包是预编译的，这也避免了在构建过程中发生失败。

本指南将包括以下话题： 

* 如何创建二进制包；
* 如何将二进制包发布到客户端；
* 如何使用二进制包;
* 如何维护二进制包。

在向导的末尾还包含几个关于二进制包操作的高级话题。

{{Note/zh-cn|除非另行指出，本指南中使用的所有的工具都是 {{Package|sys-apps/portage}} 的组成部分。}}

== 创建二进制包 ==

创建二进制包有三种主要的方法：

# 在一次常规安装后，使用{{c|quickpkg}}程序；
# 在 emerge 操作中显式使用 <code>--buildpkg (-b)</code> 选项；
# 通过使用 Portage 的 <code>buildpkg</code> 特性自动完成。

所有这三种方法都将在 <code>PKGDIR</code> 变量指向的目录创建二进制包（默认为 {{Path|/usr/portage/packages}}）。

=== 使用 quickpkg ===

{{c|quickpkg}} 程序接收一个或多个依赖 atoms （或者包集合）并对所有与那个 atom 匹配的 ''已安装'' 包创建二进制包。

例如，要对所有已安装 GCC 版本创建二进制包：

{{RootCmd|quickpkg sys-devel/gcc}}

要对系统中所有已安装包创建二进制包，使用 <code>*</code> 通配符：

{{RootCmd|quickpkg "*/*"}}

这种方法有一点要注意：它依赖已安装的文件，会在配置文件上发生问题。管理员经常在安装完软件后改变配置文件。因为这可能向包中泄露重要（甚至可能是机密）数据， {{c|quickpkg}} 默认通过 <code>CONFIG_PROTECT</code> 方法保护配置文件''不''被包含在内。要强制包含配置文件，使用 <code>--include-config</code> 或 <code>--include-unmodified-config</code> 选项。

=== 使用 --buildpkg 作为 emerge 选项 ===

当使用 {{c|emerge}} 安装软件时， Portage 可以通过 <code>--buildpkg (-b)</code> 选项被要求创建二进制包：

{{Emerge|params+=--buildpkg|sys-devel/gcc}}

还可以要求 Portage ''只'' 创建二进制包却 ''不'' 在活动系统上安装软件。 这种情况下，使用 <code>--buildpkgonly (-B)</code> 选项：

{{Emerge|params+=--buildpkgonly|sys-devel/gcc}}

后一种方法还是需要构建时的依赖事先已安装。

=== 作为 Portage 特性实现 buildpkg ===

最常用的自动创建二进制包的方式是每当使用 Portage 安装一个包就自动创建二进制包，通过使用 <code>buildpkg</code> 特性来实现，可以在 {{Path|/etc/portage/make.conf}} 中进行设置，例如：

{{FileBox|filename=/etc/portage/make.conf|title=打开Portage的二进制包创建功能|lang=bash|1=
FEATURES="${FEATURES} buildpkg"
}}

开启这项特性后，每次 Portage 安装软件，它将也创建一个二进制包。

=== 排除一些包的创建 ===

告诉 Portage 不要对一些指定的包或分类创建二进制包也是可以的。 这个可以通过向 emerge 传递 <code>--buildpkg-exclude</code> 选项：

{{RootCmd|emerge -uDN @world --buildpkg --buildpkg-exclude "virtual/* sys-kernel/*-sources"}}

这可以对那些不值得创建二进制包的包使用。例如 Linux 内核代码包或上游二进制包（那些以 -bin 结尾如 {{Package|www-client/firefox-bin}}）。

== 配置二进制包主机 ==

Portage 支持多种下载二进制包的协议：FTP、FTPS、HTTP、HTTPS和SSH。这为多种可能的二进制包主机的实现提供了空间。

可是，Portage 并没有提供一个“现成”的方法来分发二进制包。根据需求还需要安装额外的软件。

=== 基于 Web 的二进制包主机 ===

一种常用的分发二进制包的方法是创建一个基于 web 的二进制包主机。

使用一个 web 服务器如 [[lighttpd]] ({{Package|www-servers/lighttpd}}) 并且将其配置为提供对 {{Path|/etc/portage/make.conf}} 中 <code>PKGDIR</code> 位置的读权限。

{{FileBox|filename=/etc/lighttpd/lighttpd.conf|title=lighttpd 配置范例|lang=bash|1=
# add this to the end of the standard configuration
server.modules += ( "mod_alias" )
alias.url = ( "/packages" => "/usr/portage/packages/" )
}}

之后，在客户系统，对应地设置 <code>PORTAGE_BINHOST</code> 变量：

{{FileBox|filename=/etc/portage/make.conf|title=使用基于Web的二进制包主机|lang=bash|1=
PORTAGE_BINHOST="http://binhost.genfic.com/Packages"
}}

=== SSH 二进制包主机 ===

要提供一种更多身份验证的二进制包方法，可是考虑使用 SSH 。

当使用 SSH ，可以使用 Portage Linux 用户的 SSH 密钥 (without passphraze as the installations need to happen in the background) 来连接到远程二进制包主机。

To accomplish this, make sure that the Portage user's SSH key is allowed on the server. This will need to happen for each machine that will connect to the SSH capable binary host:

{{RootCmd|cat portage.id_rsa.pub >> /home/binpkguser/.ssh/authorized_keys}}

<code>PORTAGE_BINHOST</code> 看起来如下：

{{FileBox|filename=/etc/portage/make.conf|title=配置PORTAGE_BINHOST用于SSH访问|lang=bash|1=
PORTAGE_BINHOST="ssh://binpkguser@binhostserver/usr/portage/packages"
}}

{{Note/zh-cn|1=不要使用 ssh 配置文件 {{Path|~/.ssh/config}} 中设置的端口号和用户名，因为当 portage 在试图同步包的时候会忽略这些配置。正确的方式是在 <code>PORTAGE_BINHOST=</code> 变量中设置。}}

=== NFS 导出 ===

当在内网中使用二进制包，可以更简单地通过 NFS 导出包并在客户系统进行挂载。

{{Path|/etc/exports}} 文件看起来如下：

{{FileBox|filename=/etc/exports|title=导出包目录|1=
/usr/portage/packages                            2001:db8:81:e2::/48(ro,no_subtree_check,root_squash) 192.168.100.1/24(ro,no_subtree_check,root_squash)
}}

在客户系统，这个位置就可以被挂载。例如 {{Path|/etc/fstab}} 看起来如下：

{{FileBox|filename=/etc/fstab|title=包目录的挂载点|1=
binhost:/usr/portage/packages      /usr/portage/packages    nfs    defaults    0 0
}}

== 使用二进制包 ==

要在其他系统使用二进制包，需要满足一些条件：
*客户机和服务器的架构以及[[CHOST]]关键字的设置必须是一致的。
*用来创建二进制包的<code>CFLAGS</code>和<code>CXXFLAGS</code>两个参数的设置必须和所有的客户机兼容。
*针对处理器特定功能的USE设置（如MMX,SSE,...）要仔细选择，以保证所有的客户机都支持这些功能。

{{Important/zh-cn|Portage不会验证是否满足上述条件，因为维护这些设置是系统管理员的职责。}}

除了这些，Portage将检查创建二进制包时是否用和客户机一样的USE设置。如果二进制包是用不同的USE设置来创建的，Portage将忽略这个二进制包（改为使用基于源代码的方式进行安装）或者提示安装失败，取决于运行emerge命令时所带的选项（参看[[#安装二进制包|安装二进制包]]）。

为了使用二进制包，在客户机上有几个配置需要更改。

=== 安装二进制包 ===

There are a few options that can be passed on to the {{c|emerge}} command that inform Portage about using binary packages:

{| class="table"
|-
! Option !! Description
|-
| <code>--usepkg</code> <br> <code>(-k)</code> || Tries to use the binary package(s) in the locally available {{Path|packages}} directory. Useful when using [[NFS]] or [[SSHFS]] mounted binary package hosts. If the binary packages are not found, a regular (source-based) installation will be performed.
|-
| <code>--usepkgonly</code> <br> <code>(-K)</code> || Similar to <code>--usepkg (-k)</code> but fail if the binary package cannot be found. This option is useful if only ''pre-built'' binary packages are to be used.
|-
| <code>--getbinpkg</code> <br> <code>(-g)</code> || Download the binary package(s) from a remote binary package host. If the binary packages are not found, a regular (source-based) installation will be performed.
|-
| <code>--getbinpkgonly</code> <br> <code>(-G)</code> || Similar to <code>--getbinpkg (-g)</code> but will fail if the binary package(s) cannot be downloaded. This option is useful if only ''pre-built'' binary packages are to be used.
|}

为了自动使用二进制包进行安装，可以在<code>EMERGE_DEFAULT_OPTS</code>变量增加适当的选项：

{{FileBox|filename=/etc/portage/make.conf|title=自动下载二进制包，二进制包不存在的时候提示失败|lang=bash|1=
EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --getbinpkgonly"
}}

有一个Portage功能特性可以自动实现和<code>--getbinpkg (-g)</code>一样的功能，而不用更改<code>EMERGE_DEFAULT_OPTS</code>变量: ''getbinpkg''.

{{FileBox|filename=/etc/portage/make.conf|title=打开Portage的getbinpkg功能特性|lang=bash|1=
FEATURES="${FEATURES} getbinpkg"
}}

=== 从二进制包主机下载包 ===

当使用二进制包主机时，客户机需要配置<code>PORTAGE_BINHOST</code>变量。不然，客户机不知道二进制包的存放位置将导致Portage无法获取二进制包。

{{FileBox|filename=/etc/portage/make.conf|title=设置 PORTAGE_BINHOST|lang=bash|1=
PORTAGE_BINHOST="http://binhost.genfic.com/packages"
}}

<code>PORTAGE_BINHOST</code>变量使用一个用空格进行分割的URI列表。这可以让管理员可以同时使用不同的二进制包主机。URI地址应该总是指向{{Path|Packages}}文件所在的目录。

{{Note/zh-cn|对于多个二进制包服务器的支持还不是很完整。如果几个服务器提供同一个版本的二进制包，那么只会使用第一个。当这些二进制包的<code>USE</code>配置不一样，而且后面的二进制包的<code>USE</code>配置是适合当前系统配置的情况下会产生问题。}}

===重安装修改过的二进制包===

Passing the <code>--rebuilt-binaries</code> option to emerge will reinstall every binary that has been rebuilt since the package was installed. This is useful in case rebuilding tools like {{c|revdep-rebuild}} or {{c|python-updater}} are run on the binary package server.

一个相关的选项是<code>--rebuilt-binaries-timestamp</code>。它将使emerge不会重新安装那些在给定的时间标签之前已经建立的二进制包。如果二进制包服务器不得不从头开始重建而又要使用<code>--rebuilt-binaries</code>选项，这对于避免重新安装所有的包来说是很有用。

===额外的客户端设置===

跟着 ''getbinpkg'' 功能特性，Portage还接受 ''binpkg-logs'' 这个功能特性。这个特性控制是否保留二进制包成功安装记录的日志文件。它只有在设置了<code>PORT_LOGDIR</code>变量的情况下才会生效，默认为启用。

和从特定的包集合或分类中排除一些二进制包类似，客户机可以配置为从特定的包集合或分类中排除一些二进制包的安装。

用<code>--usepkg-exclude</code>选项来实现这一功能：

{{RootCmd|emerge -uDNg @world --usepkg-exclude "sys-kernel/gentoo-sources virtual/*"}}

== 维护二进制包 ==

如果二进制包列表不积极维护，导出和分发二进制包只会白白浪费存储空间。

=== 删除过期的二进制包 ===

In the {{Package|app-portage/gentoolkit}} package an application called {{c|eclean}} is provided. It allows for maintaining Portage-related variable files, such as downloaded source code files, but also binary packages.

以下命令将删除所有没有对应ebuild文件的二进制包：

{{RootCmd|eclean packages}}

请阅读[[Eclean]]的相关文章以了解更多细节。

Another tool that can be used is the {{c|qpkg}} tool from the {{Package|app-portage/portage-utils}} package. However, this tool is a bit less configurable.

清理“无用”的二进制包（应用于存放二进制包的服务器上）：

{{RootCmd|qpkg -c}}

=== 维护包文件 ===

Inside the packages directory, a file called {{Path|Packages}} exists. This file acts as a cache for the metadata of all binary packages in the packages directory. The file is updated whenever Portage adds a binary package to the directory. Similarly, {{c|eclean}} updates it when it removes binary packages.

If for some reason binary packages are simply deleted or copied into the packages directory, or the {{Path|Packages}} file gets corrupted or deleted, then it must be recreated. This is done using {{c|emaint}} command:

{{RootCmd|emaint binhost --fix}}

== 高级主题 ==

=== 建立二进制包目录的快照 ===

当需要分发二进制包给大量的客户机系统的时候，建立包目录的快照可能会比较划算。客户机系统就不是直接使用包目录，而是使用快照所提供的二进制包。

Snapshots can be created using the {{Path|/usr/lib64/portage/python2.7/binhost-snapshot}} or {{Path|/usr/lib64/portage/python3.3/binhost-snapshot}} tool. It takes four arguments:

# A source directory (the path to the packages directory).
# A target directory (that must not exist).
# A URI.
# A binary package server directory.

将包目录的文件复制到目标目录，然后在URI地址所指向的二进制包服务器的目录（第四个参数）里创建一个{{Path|Packages}}文件。

Client systems need to use an URI that points to the binary package server directory. From there they will be redirected to the URI that was given to {{c|binhost-snapshot}}. This URI has to refer to the target directory.

=== 理解二进制包的格式 ===

Binary packages created by Portage have the file name ending with {{Path|.tbz2}}. These files consist of two parts:

# A {{Path|.tar.bz2}} archive containing the files that will be installed on the system.
# A {{Path|xpak}} archive containing package metadata, the ebuild, and the environment file.

See {{c|man xpak}} for a description of the format.

In {{Package|app-portage/portage-utils}} some tools exists that are able to split or create {{Path|tbz2}} and {{Path|xpak}} files.

The following command will split the {{Path|tbz2}} into a {{Path|.tar.bz2}} and an {{Path|.xpak}} file:

{{Cmd|qtbz2 -s <package>.tbz2}}

The xpak file can be examined using the {{c|qxpak}} utility.

列出其内容：

{{Cmd|qxpak -l <package>.xpak}}

下一条命令将生成一个叫 {{Path|USE}} 的文件，文件包含了这个包所使用的 USE 设置:

{{Cmd|qxpak -x package-manager-0.xpak USE}}

=== PKGDIR的布局 ===

目前使用的布局（版本2）如下：

{{CodeBox|title=包目录布局 (版本2)|1=
PKGDIR
`+- Packages
 +- app-accessibility/
 {{!}}  +- pkg1-version.tbz2
 {{!}}  `- pkgN-version.tbz2
 +- app-admin/
 {{!}}  `- ...
 `- ...
}}

{{Path|Packages}} 文件是在第一个二进制包目录布局（版本1）之上最主要的改进（同时也是让 Portage 知道二进制包目录使用版本2的触发器）。在版本1中，所有二进制包都被放在一个叫 {{Path|All/}} 的目录里，而分类目录只是指向 {{Path|All/}} 目录中二进制包的符号链接。

=== 用 quickunpkg 来解包 ===

Zoobab wrote a simple shell tool named [https://github.com/zoobab/quickunpkg quickunpkg] to quickly unpack {{Path|tbz2}} files.


[[Category:Portage]]
