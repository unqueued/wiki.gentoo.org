<languages />

{{Dated|date=March 12th, 2015}}

{{Metadata|abstract=이 안내서는 DVB와 VDR을 젠투 리눅스에서 준비하는 방법을 설명합니다.}}

이 안내서에서는 DVB와 VDR을 젠투 리눅스에서 준비하는 방법을 설명합니다.

== DVB 일반 정보 ==

=== DVB란 무엇인가요? ===

''DVB''는 ''Digital Video Broadcasting''의 약어입니다. DVB는 TV, 라디오, MHP, EPG, 텔레텍스트 같은 대화식 서비스의 디지털 데이터를 전송하는 방법입니다. HDTV에 대해 MPEG-2 또는 H-264로 데이터를 압축하여 같은 주파수에서도 다양한 채널로 데이터를 전송할 수 있습니다. 데이터를 좀 더 압축하여 더 많은 채널을 전송할 수 있지만, 화질이나 음질이 깨질 수 있습니다. 

DVB는 다양한 방법으로 전송할 수 있습니다. 마지막에 붙은 문자가 전송 방식을 구분하는데 DVB-''T''는 지상 전송 방식을 의미합니다. 이 말고도 몇가지 방식이 또 있습니다: 

* DVB-S 는 위성 전송 방식입니다
* DVB-C 는 물리 회선 전송 방식입니다
* DVB-H 모바일 장치 전송 (지상) 방식입니다
* DVB-IPI 는 IP 기반 네트워크 전송 방식입니다 예:인터넷
* DVB-RC(S/C/T) 는 데이터 서비스 전송 채널을 반환합니다. 예: 광대역 인터넷

=== 형식과 필요한 DVB 카드 ===

DVB 스트림을 받으려 제각각의 방식이 있기 전에 내용 출력 방식에 따라 카드를 구분합니다. {{Path|/dev/video}} 장치에서 스트림에 직접 접근하는 방식을 제공하는 디코더 구현체 카드가 있습니다. 이런 카드는 ''완벽한 기능을 갖춘 카드'' 입니다. 다른 카드는 자체 구현 인코더가 없으며 컴퓨터의 소프트웨어 디코더가 필요하고 이런 카드를 ''버짓 카드''라고 합니다. 이 경우 상당한 수준의 시스템 사양이 필요함을 암시합니다. 여러분의 컴퓨터에 붙은 CPU는 최소한 600MHz에 256MB 용량의 RAM이 있어야 합니다. 카드를 확인하는데는 [http://linuxtv.org/wiki/index.php/DVB_Card_Venders 이 목록]이 제격입니다. 

== 시스템 준비 ==

=== 커널 설정하기 ===

먼저 커널에서 DVB와 DVB 장치를 지원하는지 확인해야 합니다. 2.6 커널부터는 필요한 드라이버가 있습니다. 커널 설정을 확인하고, 다음 옵션을 정적 드라이버 또는 모듈로 선택했는지 확인하십시오. 

{{KernelBox|title=필요한 커널 옵션|1=
Input Device Support --->
* Event Interface
Device Drivers --->
<M> Multimedia Support --->
  [*] Digital TV support
   M  [Enable driver(s)]
}}

추가적으로 하드웨어에 대산 적당한 드라이버를 선정해야 합니다. 카드에 대한 올바른 모듈을 찾는 방법은, 모든 드라이버를 모듈로 지정하는 것입니다. PCI 카드를 보유하고 있고, {{Package|sys-apps/pciutils}} 가 없다면 이 꾸러미를 설치하십시오. 이 꾸러미에는 {{c|lspci}} 라는 쓸만한 도구가 있습니다. 내장 드라이버는 있는데 PCI 카드를 가지고 있지 않다면, 이 과정을 건너뛰고 [[#.EC.BB.A4.EB.84.90_.EC.B6.9C.EB.A0.A5_.ED.99.95.EC.9D.B8|커널 출력 확인]]으로 계속 진행하셔도 됩니다. 

{{Emerge|sys-apps/pciutils}}

After booting from the new kernel, run <tt>pcimodules</tt> to list the required modules:

{{RootCmd|pcimodules|output=<pre>
ohci-hcd
ehci-hcd
sis900
snd-emu10k1
b2c2-flexcop-pci
nvidia
nvidiafb
</pre>
}}

In this case the module <code>b2c2-flexcop-pci</code> needs to be loaded. Add the module's name to the {{Path|/etc/conf.d/modules}} file: 

{{FileBox|filename=/etc/conf.d/modules|1=
modules="b2c2-flexcop-pci"
}}

=== 커널 출력 확인 ===

It is recommended to mark every driver as module, so that the required module can be added dynamically, especially if it is unclear at first which module should be added. If the module name is known then select the driver as a built-in driver. Compile the kernel, install the modules, and boot the new kernel. Verify the kernel has successfully detected the PCI card by using the <tt>dmesg</tt> utility. 

If the system has a TerraTec Cinergy T2 card the output might look something like the following:

{{RootCmd|dmesg {{!}} grep DVB|output=<pre>
DVB: registering new adaptor (TerraTec/qanu USB2.0 Highspeed DVB-T Receiver).
input: TerraTec/qanu USB2.0 Highspeed DVB-T Receiver remote control as /class/input/input2
</pre>
}}

== VDR 설치 ==

To install VDR simply emerge it:

{{Emerge|media-video/vdr}} 

== 원격 조종기(리모콘) 설치 ==

적외선 원격 조종기를 통해 VDR을 조정하는 최소한 두가지의 방법이 있습니다. TV 카드에 보드 내장 적외선 수신 모듈이 붙어있다면, {{Package|media-plugins/vdr-remote}}를 사용할 수 있습니다. 그렇지 않으면 LIRC를 사용해야 할 지도 모릅니다. 

=== vdr-remote 설치 ===

우선 {{c|emerge}}로 플러그인을 설치하십시오: 

{{Emerge|media-plugins/vdr-remote}}
{{RootCmd|eselect vdr-plugin enable remote}}

When using the remote plugin for the IR port on a DVB card everything should be fine with the default configuration. It automatically uses the input device which has "dvb" in its name. For more advanced uses take a look at {{Path|/etc/conf.d/vdr.remote}} file.

=== 대안: LIRC 설치 ===

If the card can be remotely controlled but managing it via <code>vdr-remote</code> is not desired, then LIRC should be configured. LIRC interprets the pressed keys and returns a name for each one. A program that supports LIRC waits for key events and runs the action configured in the configuration file, mostly stored in the configuration directory of the executing program (e.g. <tt>mplayer</tt> loads the file {{Path|~/.mplayer/lircrc}}). Before LIRC is installed add <code>lirc</code> as a USE flag and add a special variable called <code>LIRC_DEVICES</code> to {{Path|/etc/portage/make.conf}} Use [http://www.lirc.org/html/table.html this list] to find the proper arguments for the new {{Path|make.conf}} variable. 

{{FileBox|filename=/etc/portage/make.conf|lang=bash|1=
# (Replace "devinput" with the proper driver)
LIRC_DEVICES="devinput"
USE="lirc"}}

{{Emerge|app-misc/lirc}}

At start each key code must be defined with a name. Most supported remote controls are configured already, so take a look at the [http://lirc.sourceforge.net/remotes/ remote list]. Download the required file and save it as {{Path|/etc/lircd.conf}}. Now find out where to access the remote control. Run the following command to get a list of the current input devices (make sure the device is running). 

{{RootCmd|cat /proc/bus/input/devices|output=<pre>
I: Bus=0000 Vendor=0000 Product=0000 Version=0000
N: Name="TerraTec/qanu USB2.0 Highspeed DVB-T Receiver remote control"
P: Phys=usb-0000:00:1d.7-1/input0
S: Sysfs=/class/input/input2
H: Handlers=kbd event1
B: EV=100003
B: KEY=108fc210 2043 0 0 0 0 8000 2080 1 9e1680 0 0 ffc
</pre>
}}

In this case the Terratec Cinergy T2 device plugged in, so the device can be accessed over {{Path|/dev/input/<event1>}}. Replace <code><event1></code> with the matching device listed in the output. 

<tt>lircd</tt> needs to know the device to use. Add the following line to the {{Path|/etc/conf.d/lircd}} file. Remember to replace <code><devinput></code> with the name of the driver and <code><event1></code> with the actual device:

{{FileBox|filename=/etc/conf.d/lircd|lang=bash|1=
LIRCD_OPTS="-H <devinput> -d /dev/input/<event1>"
}}

It is time to start <tt>lircd</tt>: 

{{RootCmd|/etc/init.d/lircd start}}

Now it should be possible to watch <tt>lircd</tt> capturing and decoding key presses. Run the <tt>irw</tt> command. Stop it by pressing {{Key|Ctrl}}+{{Key|C}} when enough keys have been pressed. 

{{RootCmd|irw|output=<pre>
0000000000001aa2 00 Exit Technisat_TTS35AI.conf
0000000000001a8d 00 Mute Technisat_TTS35AI.conf
0000000000000a97 00 OK Technisat_TTS35AI.conf
0000000000000a97 01 OK Technisat_TTS35AI.conf
0000000000000a92 00 Menu Technisat_TTS35AI.conf
</pre>
}}

Next, add it to the default runlevel so that it starts automatically at boot time:

{{RootCmd|rc-update add lircd default}}

To be able to use the remote control, LIRC support must be enabled in VDR. Add the following line to the {{Path|/etc/conf.d/vdr}} file: 

{{FileBox|filename=/etc/conf.d/vdr|lang=bash|1=
IR_CTRL="lirc"
}}

== 동영상 출력 방식 ==

Now decide on one (and only one) of the following video output devices which show the picture and the overlayed On Screen Display (OSD). 

=== 하드웨어 디코드: 완전한 기능을 갖춘 DVB 카드 ===

Install {{Package|media-plugins/vdr-dvbhddevice}} when using an TechnoTrend Premium S2-6400 Twin HD, or general hardware decoding for SDTV and HDTV (MPEG2 and MPEG4 AVC/H.264):

{{Emerge|media-plugins/vdr-dvbhddevice}}

For Fujitsu_Siemens, Hauppage WinTV and TechnoTrend Premium S2300 and cards based on this reference design, or general hardware decoding for SDTV (MPEG1 and MPEG2): 

{{Emerge|vdr-dvbsddevice}}

=== 하드웨어 디코드: DXR3/Hollywood+ cards ===

To use a DXR3 card for VDR output the <code>vdr-dxr3</code> plugin is needed: 

{{Emerge|vdr-dxr3}}

{{FileBox|filename=/etc/conf.d/modules|lang=bash|1=
modules="em8300"
}}

em8300 모듈은 카드의 정확한 리비전에 따라 추가 설정이 필요합니다. 

=== 하드웨어 디코드: PVR350 카드 ===

Since PVR350 cards have an onboard MPEG-Decoder chip it should be used to its full potential. In order for this to happen the <code>vdr-pvr350</code> plugin is needed. If <code>ivtv-driver</code> is not yet installed emerge should automatically install it. To have the <code>ivtv</code> module loaded at boot time add it to the {{Path|/etc/conf.d/modules}} list: 

{{Emerge|media-plugins/vdr-pvr350}}

{{FileBox|filename=/etc/conf.d/modules|lang=bash|1=
modules="ivtv"
}}

=== 소프트웨어 디코드: vdr-xineliboutput ===

Some people prefer to use <code>vdr-xineliboutput</code>, because it can work remotely. Follow the next set of instructions to configure <code>vdr-xineliboutput</code> on a host and client. First, the host setup: 

{{Emerge|media-plugins/vdr-xineliboutput}}

{{RootCmd|eselect vdr-plugin enable xineliboutput}}

Adding command line options at this point is crucial for xineliboutput to work. For more options, see <tt>vdr --help</tt>. 

{{FileBox|filename=/etc/conf.d/vdr.xineliboutput|lang=bash|1=
_EXTRAOPTS="--local=none --remote=37890"
}}

다음 단계에서는 {{Path|/etc/vdr/svdrphosts.conf}}를 편집합니다. 이 파일에는 호스트 시스템에서 실행중인 동영상 디스크 레코더의 SVDRP 포트로 어떤 호스트 주소를 연결할지에 대한 내용이 있습니다. 

{{FileBox|filename=/etc/vdr/svdrphosts.conf|lang=bash|1=
# (The proper syntax is: IP-Address[/Netmask])
127.0.0.1             (always accept localhost)
192.168.1.0/24        (any host on the local net)
#204.152.189.113      (a specific host)
#0.0.0.0/0            (any host on any net - USE THIS WITH CARE!)
}}

When using <code>vdr-xineliboutput</code> to view the picture on the same computer as the one running VDR it is now possible to continue with [[#creating the channel list]]. 

Otherwise, simply <tt>emerge</tt> {{Package|media-plugins/vdr-xineliboutput}} on the client: 

{{Emerge|media-plugins/vdr-xineliboutput}}

Later (after having started VDR) the <tt>vdr-sxfe xvdr://hostname</tt> command can be used to connect to the VDR and view its picture and OSD. 

{{Note|There is also a plugin which simulates the existence of a real output device (<code>vdr-dummydevice</code>) for some fancy uses like record-only servers, but that is more advanced than a normal VDR setup.}}

== 채널 목록 만들기 ==

To make VDR really useful an appropriate channel list must be created. There is more than one way to get a working list of channels (besides downloading one). The channel list installed by default is for DVB-S reception on Astra on 19.2° E. 

=== linuxtv-dvb-apps의 dvbscan 활용 ===

{{Emerge|media-tv/linuxtv-dvb-apps}}

Find the correct frequency list for region and type of reception of interest. These files are stored under {{Path|/usr/share/dvb}}. For reception with DVB-T in Germany, Berlin {{Path|/usr/share/dvb/dvb-t/de-Berlin}} should be used:

{{Cmd|dvbscan -o vdr /usr/share/dvb/dvb-t/de-Berlin > /etc/vdr/channels.conf}}

=== vdr-reelchannelscan 활용하기 ===

First, delete the contents of the existing channel list:

{{RootCmd|rm /etc/vdr/channels.conf}}

{{Emerge|vdr-reelchannelscan}}

{{RootCmd|eselect vdr-plugin enable reelchannelscan}}

=== vdr-analogtv를 활용하여 시스템 채널 찾기 ===

It is a good idea to configure channels at this point. The VDR project provides users with some examples which can be found at {{Path|/usr/share/doc/vdr-analogtv-$version/examples/}}, as long as <code>media-plugins/vdr-analogtv-1.0.00-r1</code> and up has been installed. 

== VDR 시작 ==

After having all basic software parts ready on the system the VDR with its OSD must be configured. 

If a hardware decoder for picture output is used, then the connected TV should be turned on. When using software output the client for this must be started after VDR. 

First, learn the key definitions; that is, connecting keys on the remote control to VDR's internal commands. 

{{Note|To edit the keyboard configuration, or (more likely) to delete it to go back to learning the keys the special configuration file can be modified. VDR stores its key-definitions in {{Path|/etc/vdr/remote.conf}}.}}

VDR을 시작할 차례입니다: 

{{RootCmd|/etc/init.d/vdr start|output=<pre>
* Preparing start of vdr:
*   config files ...                                        [ ok ]
*   Waiting for prerequisites (devices nodes etc.) ...      [ ok ]
* Starting vdr ...                                          [ ok ]
* First start of vdr: No check for running vdr possible
* until control device (remote/keyboard) keys are learnt!
</pre>
}}

{{Note|소프트웨어 디코더 사용자는 TV 화면과 OSD를 표시하려 창을 따로 여는 클라이언트 프로그램을 시작해야합니다.}}

vdr-softdevice 사용자라면:

{{RootCmd|ShmClient}}

vdr-xineliboutput 사용자에 대해:

{{RootCmd|vdr-sxfe xvdr://hostname}}

VDR에서 쓸모있는 대부분의 키는 다음과 같습니다: 

* 커서 키(좌/우/상/하)
* 메뉴/나가기/확인
* 색상(적/녹/황/청)
* 숫자 키(0-9)

{{Important|If not many keys exist on the remote be sure to assign these. Some remotes have Play/Pause/etc. on the same keys as the colors, so use them for the colors.}}

Now that the basic installation is over it is time to configure VDR. Switch to the output screen and follow the on-screen instructions. VDR asks the user to press various keys on the remote control so it can learn the correct key codes. If a remote control is not present, then the keyboard can be used as an alternative. 

Now add the VDR init script to the default runlevel to get it started each time the computer boots:

{{RootCmd|rc-update add vdr default}}

== 문제 해결 ==

If help is needed feel free to ask someone in [http://www.gentoo.org/irc://irc.gentoo.org/gentoo-vdr #gentoo-vdr], or look around on the [http://forums.gentoo.org/ Gentoo forums]
{{Migrated|originalauthors=Norman Golisz, Dimitry Bradt, Matthias Schwarzott, Joshua Saddler}}
