<languages />

{{Lowercase title}}
{{InfoBox stack
|{{InfoBox homepage|http://www.sudo.ws/|header=true}}
|{{InfoBox wikipedia|sudo}}
}}

La commande '''sudo''' procure un moyen sûr et simple de configurer une escalade de privilèges, par exemple, permettre à des utilisateurs normaux d'exécuter certaines (ou toutes les) commandes en tant que ''root'' ou au nom d'un autre utilisateur, sans qu'ils aient à connaitre le mot de passe de l'utilisateur auquel ils se substituent.

Lorsque vous voulez que certaines personnes accomplissent certaines tâches administratives sans leur donner un accès total en tant que ''root'', utiliser ''sudo'' est votre meilleure option. Avec ''sudo'' vous pouvez contrôler qui peut faire quoi. Ce guide est une petite introduction à ce merveilleux outil.

== À propos de Sudo ==

=== Accorder des autorisations ===

Le paquet <code>app-admin/sudo</code> permet à l'administrateur du système d'accorder des autorisations à d'autres utilisateurs pour exécuter une ou plusieurs applications qu'ils n'auraient normalement pas le droit d'exécuter. À la différence de l'utilisation du bit ''setuid'' sur ces applications, <code>sudo</code> permet un contrôle plus fin sur ''qui'' peut exécuter une certaine commande et sur ''quand'' il peut le faire. 

Avec <code>sudo</code> vous pouvez établir une liste claire de ''qui'' peut exécuter une application donnée. Si vous utilisiez le bit ''setuid'', n'importe quel utilisateur ( ou n'importe quel utilisateur d'un groupe donné, selon l'autorisation accordée) serait capable d'exécuter cette application. Vous pouvez (et devriez probablement) demander à l'utilisateur de fournir un mot de passe lorsqu'il désire exécuter l'application concernée. 

=== Journalisation ===

Un avantage supplémentaire de <code>sudo</code>, c'est qu'elle peut tenir un journal de toutes les tentatives (réussies ou pas) d'exécution d'une application. Ceci est très utile si vous voulez garder la trace de qui a commis l'erreur fatale qui vous a demandé 10 heures à réparer. 

=== Configurer sudo ===

La configuration de <code>sudo</code> est gérée par le fichier {{Path|/etc/sudoers}}. Ce fichier ne devrait jamais être édité via <code>nano /etc/sudoers</code> ou <code>vim /etc/sudoers</code> ou n'importe quel autre éditeur. Lorsque vous désirez changer ce fichier, vous devriez utiliser <code>visudo</code> . 

Cet outil garantit que deux administrateurs ne sont pas en train d'éditer ce fichier au même moment, conserve les autorisations sur ce fichier et assure une vérification de la syntaxe pour être certain que vous n'avez pas laissé d'erreur fatale dedans. 

=== À propos de ce guide ===

Ce guide ne prétend être qu'une introduction rapide. Le paquet <code>sudo</code> est beaucoup plus puissant que ce que nous décrivons ici. Il possède des fonctionnalités spéciales pour éditer des fichiers en tant qu'un autre utilisateur (<code>sudoedit</code> ), depuis un script (de telle manière qu'il puisse fonctionner en arrière-plan, lire le mot de passe depuis l'entrée standard plutôt que du clavier,...), etc. 

Reportez-vous aux pages de manuel de  <code>sudo</code> et de <code>sudoers</code> pour une information plus complète. 

== Syntaxe de sudoers ==

=== Syntaxe de base ===

La partie la plus difficile de <code>sudo</code», 
 c'est la syntaxe de {{Path|/etc/sudoers}}. La syntaxe de base ressemble à ceci : 

{{Code|Syntaxe de base de /etc/sudoers |<pre>
user  host = commands
</pre>
}}

Cette syntaxe indique à <code>sudo</code> que l'utilisateur, identifié par ''user'' et connecté au système ''host'' peut exécuter n'importe quelle commande litée dans ''commands'' en tant qu'utilisateur ''root''. Un exemple plus réel pourrait rendre cela plus clair : autorise l'utilisateur ''swift'' à exécuter <code>emerge</code> s'il est connecté à l'hôte local : 

{{Code|Exemple réaliste de /etc/sudoers |<pre>
swift  localhost = /usr/bin/emerge
</pre>
}}

{{Note|Le nom d'hôte doit corresponde à ce que retourne la commande <code>hostname</code>.}}

Un gros '''avertissement''' est cependant de mise : n'autorisez pas un utilisateur à exécuter une application  qui lui permette d'élever ses autorisations. Par exemple, autoriser des utilisateurs à exécuter <code>emerge</code>  en tant que ''root'' peut en effet leur donner un accès complet au système en tant que ''root'' parce que <code>emerge</code> peut être manipulé pour changer le système de fichier actif à l'avantage de l'utilisateur. Si vous ne faites pas confiance à vos utilisateurs de  <code>sudo</code>, ne leur donnez aucune autorisation. 

Le nom d'utilisateur peut aussi être remplacé par un nom de groupe. Dans ce cas, vous devriez commencer le nom du groupe avec un signe <code>%</code>. Par exemple, pour autoriser n'importe quel utilisateur du groupe <code>wheel</code> à exécuter <code>emerge</code> : 

{{Code|Autoriser les membres du groupe wheel à éxecuter emerge|<pre>
%wheel  localhost = /usr/bin/emerge
</pre>
}}

Vous pouvez étendre la ligne pour autoriser plusieurs commandes (au lieu de faire une entrée simple pour chacune des commandes). Par exemple, pour autoriser le même utilisateur à exécuter, pas seulement  <code>emerge</code> ,mais aussi <code>ebuild </code> et  <code>emerge-webrsync</code>  en tant que ''root'' : 

{{Code|Commandes multiples |<pre>
swift  localhost = /usr/bin/emerge, /usr/bin/ebuild, /usr/sbin/emerge-webrsync
</pre>
}}

Vous pouvez aussi spécifier une commande précise et pas seulement un outil. Ceci est utile pour restreindre l'utilisation d'un outil donné à un certain jeu d'options de commande. L'outil <code>sudo</code>  autorise les passe-partout du style shell (aussi connu sous le nom de meta charactère ou de caractère glob) à être utilisé dans les noms de fichiers ou dans les arguments de la ligne de 
commande dans le fichier ''sudoers''. Notez qu'il ne s'agit ''pas'' d'expressions régulières. 

Testons cela : 

{{Cmd|sudo emerge -uDN world|output=<pre>
We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:
  
    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.
  
Password: ## (Enter the user password, not root!)
</pre>
}}

Le mot de passe requis par  <code>sudo</code> est le propre mot de passe de l'utilisateur, pas celui de ''root''. Ceci garantit qu'aucun terminal que vous avez laissé accidentellement ouvert aux autres ne pourra être utilisé par des gens malintentionnés. 

You should know that <code>sudo</code> does not alter the <code>${PATH}</code> variable: any command you place after <code>sudo</code> is treated from ''your'' environment. If you want the user to run a tool in for instance {{Path|/sbin}} he should provide the full path to <code>sudo</code> , like so: 

{{Cmd|sudo /usr/sbin/emerge-webrsync}}

=== Using Aliases ===

In larger environments having to enter all users over and over again (or hosts, or commands) can be a daunting task. To ease the administration of {{Path|/etc/sudoers}} you can define ''aliases'' . The format to declare aliases is quite simple: 

{{Code|Declaring aliases in /etc/sudoers|<pre>
Host_Alias hostalias = hostname1, hostname2, ...
User_Alias useralias = user1, user2, ...
Cmnd_Alias cmndalias = command1, command2, ...
</pre>
}}

One alias that always works, for any position, is the <code>ALL</code> alias (to make a good distinction between aliases and non-aliases it is recommended to use capital letters for aliases). As you might undoubtedly have guessed, the <code>ALL</code> alias is an alias to all possible settings. 

A sample use of the <code>ALL</code> alias to allow ''any'' user to execute the <code>shutdown</code> command if he is logged on locally is: 

{{Code|Allowing any user to execute shutdown|<pre>
ALL  localhost = /sbin/shutdown
</pre>
}}

Another example is to allow the user <code>swift</code> to execute the <code>emerge</code> command as root, regardless of where he is logged in from: 

{{Code|Allowing a user to run an application regardless of his location|<pre>
swift   ALL = /usr/bin/emerge
</pre>
}}

More interesting is to define a set of users who can run software administrative applications (such as <code>emerge</code> and <code>ebuild</code> ) on the system and a group of administrators who can change the password of any user, except root! 

{{Code|Using aliases for users and commands|<pre>
User_Alias  SOFTWAREMAINTAINERS = swift, john, danny
User_Alias  PASSWORDMAINTAINERS = swift, sysop
Cmnd_Alias  SOFTWARECOMMANDS    = /usr/bin/emerge, /usr/bin/ebuild
Cmnd_Alias  PASSWORDCOMMANDS    = /usr/bin/passwd [a-zA-Z0-9_-]*, !/usr/bin/passwd root
  
SOFTWAREMAINTAINERS  localhost = SOFTWARECOMMANDS
PASSWORDMAINTAINERS  localhost = PASSWORDCOMMANDS
</pre>
}}

=== Non-Root Execution ===

It is also possible to have a user run an application as a different, non-root user. This can be very interesting if you run applications as a different user (for instance <code>apache</code> for the web server) and want to allow certain users to perform administrative steps as that user (like killing zombie processes). 

Inside {{Path|/etc/sudoers}} you list the user(s) in between <code>(</code> and <code>)</code> before the command listing: 

{{Code|Non-root execution syntax|<pre>
users  hosts = (run-as) commands
</pre>
}}

For instance, to allow <code>swift</code> to run the <code>kill</code> tool as the <code>apache</code> or <code>gorg</code> user: 

{{Code|Non-root execution example|<pre>
Cmnd_Alias KILL = /bin/kill, /usr/bin/pkill
  
swift   ALL = (apache, gorg) KILL
</pre>
}}

With this set, the user can run <code>sudo -u</code> to select the user he wants to run the application as: 

{{Cmd|sudo -u apache pkill apache}}

You can set an alias for the user to run an application as using the <code>Runas_Alias</code> directive. Its use is identical to the other <code>_Alias</code> directives we have seen before. 

=== Passwords and Default Settings ===

By default, <code>sudo</code> asks the user to identify himself using his own password. Once a password is entered, <code>sudo</code> remembers it for 5 minutes, allowing the user to focus on his tasks and not repeatedly re-entering his password. 

Of course, this behavior can be changed: you can set the <code>Defaults:</code> directive in {{Path|/etc/sudoers}} to change the default behavior for a user. 

For instance, to change the default 5 minutes to 0 (never remember): 

{{Code|Changing the timeout value|<pre>
Defaults:swift  timestamp_timeout=0
</pre>
}}

A setting of <code>-1</code> would remember the password indefinitely (until the system reboots). 

A different setting would be to require the password of the user that the command should be run as and not the users' personal password. This is accomplished using <code>runaspw</code> . In the following example we also set the number of retries (how many times the user can re-enter a password before <code>sudo</code> fails) to <code>2</code> instead of the default 3: 

{{Code|Requiring the root password instead of the user's password|<pre>
Defaults:john   runaspw, passwd_tries=2
</pre>
}}

Another interesting feature is to keep the <code>DISPLAY</code> variable set so that you can execute graphical tools: 

{{Code|Keeping the DISPLAY variable alive|<pre>
Defaults:john env_keep=DISPLAY
</pre>
}}

You can change dozens of default settings using the <code>Defaults:</code> directive. Fire up the <code>sudo</code> manual page and search for <code>Defaults</code> . 

If you however want to allow a user to run a certain set of commands without providing any password whatsoever, you need to start the commands with <code>NOPASSWD:</code> , like so: 

{{Code|Allowing emerge to be ran as root without asking for a password|<pre>
swift     localhost = NOPASSWD: /usr/bin/emerge
</pre>
}}

== Using Sudo ==

=== Listing Privileges ===

To inform yourself what your capabilities are, run <code>sudo -l</code> : 

{{Cmd|sudo -l|output=<pre>
User swift may run the following commands on this host:
    (root)   /usr/libexec/xfsm-shutdown-helper
    (root)   /usr/bin/emerge
    (root)   /usr/bin/passwd [a-zA-Z0-9_-]*
    (root)   !/usr/bin/passwd root
    (apache) /usr/bin/pkill
    (apache) /bin/kill
</pre>
}}

If you have any command in {{Path|/etc/sudoers}} that does not require you to enter a password, it will not require a password to list the entries either. Otherwise you might be asked for your password if it isn't remembered. 

=== Prolonging the Password Timeout ===

By default, if a user has entered his password to authenticate himself to <code>sudo</code> , it is remembered for 5 minutes. If the user wants to prolong this period, he can run <code>sudo -v</code> to reset the time stamp so that it will take another 5 minutes before <code>sudo</code> asks for the password again. 

{{Cmd|sudo -v}}

The inverse is to kill the time stamp using <code>sudo -k</code> . 

== Sudo enhancements ==

=== Bash Completion ===

Users that want bash completion with sudo need to run this once.

{{Cmd|sudo echo "complete -cf sudo" >> $HOME/.bashrc}}


[[Category:Software]]
