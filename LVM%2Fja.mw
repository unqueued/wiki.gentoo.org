<languages />

{{Metadata|abstract=LVMによって管理者はファイルシステムと物理ストレージの間に抽象レイヤを提供するメタデバイスをつくることができます。}}

{{InfoBox stack
|{{InfoBox wikipedia|Logical Volume Manager (Linux)|header=true}}
}}

'''LVM''' ('''L'''ogical '''V'''olume '''M'''anager)によって管理者はファイルシステムと具体的物理ストレージの間に抽象レイヤを提供するメタデバイスをつくることができます。 メタデバイス (その上にファイルシステムが構成される) は ''論理ボリューム(logical volumes)''と呼ばれ, それが''ボリュームグループ(volume groups)''と呼ばれるストレージのプールから領域を使います。 ボリュームグループは1つまたは2つ以上の''物理ディスク(physical volume)''から成っており、それがデータが保存される本当のデバイスです。

物理ディスクはパーティション、JBOD('''J'''ust a '''B'''unch '''O'''f '''D'''isks)によってグループ化されたSATAハードドライブ全体、RAID、iSCSI、ファイバーチャンネル、eSATAなどがあり得ます。

== インストール ==

LVMはデバイスドライバとユーザー空間のアプリケーション双方によって処理され、LVMの設定は行われます。

=== カーネル ===

次のカーネルオプションを有効化してください

{{KernelBox|<pre>
Device Drivers  --->
   Multiple devices driver support (RAID and LVM)  --->
       <*> Device mapper support
           <*> Crypt target support
           <*> Snapshot target
           <*> Mirror target
       <*> Multipath target
           <*> I/O Path Selector based on the number of in-flight I/Os
           <*> I/O Path Selector based on the service time
</pre>}}

{{Note|すべてを有効化する必要はありません。いくつかのオプションは[[LVM#LVM2_snapshots_and_thin_snapshots|LVM2 Snapshots と LVM2 Thin Snapshots]], [[LVM#Mirrored_volumes|LVM2 Mirrors]], [[LVM#Striping_.28RAID0.29|LVM2 RAID 0/Stripeset]] と暗号化にのみ必要です。}}

=== ソフトウェア ===

Install {{Package|sys-fs/lvm2}}:

{{USEflag|package=sys-fs/lvm2}}

{{Emerge|lvm2}}

== 設定 ==

LVMの設定はいくつかのレベルにおいて行われます:
# 専用ユーティリティでのLV, PV と VG設定;
# 設定ファイルによるLVMサブシステムの微調整;
# ディストリビューションレベルのサービスの設定;
# initramfs時のセットアップ.

論理ボリュームや物理ディスク、ボリュームグループの扱いは[[#Usage|Usage]] の章にて取り上げます。

=== LVM設定ファイル ===

LVMは{{Path|/etc/lvm/lvm.conf}}に大きな設定ファイルを用意しています。ほとんどのユーザーはLVMを使い始めるにあたってこのファイルの設定を修正する必要はないでしょう。

=== サービス管理 ===

Gentooは自動的に検出し、ボリュームグループと論理ボリュームをアクティブにする、LVMのサービスを提供しています。

サービスは、初期化システムを介して管理することができます。

==== OpenRC ====

LVMを手動で起動するには:

{{RootCmd|/etc/init.d/lvm start}}

ブート時にLVMを起動するには:

{{RootCmd|rc-update add lvm boot}}

==== systemd ====

LVMを手動で起動するには:

{{RootCmd|systemctl start lvm2-monitor.service}}

ブート時にLVMを起動するには:

{{RootCmd|systemctl enable lvm2-monitor.service}}

=== initramfsの中でLVMを使う ===

ほとんどのブートローダは直接LVMから起動することはできません - GRUBレガシーもLILOもです。 Grub2は、LVMリニア論理ボリューム、ミラー化論理ボリュームとおそらくいくつかの種類のRAID論理ボリュームから起動することができます。ブートローダーは現在、シンプロビジョニングされた論理ボリュームをサポートしていません。 

それにより、LVMでない/bootパーティションを使いLVMのルートパーティションをinitramfsからマウントすることが推奨されています。そのようなinitramfsは[[Genkernel|genkernel]], {{Package|sys-kernel/genkernel-next}}と[[dracut]]:を通して自動的に生成されます。

* {{c|genkernel}}は全てのタイプからブート可能です。ただしシンプロビジョニングされたボリュームは除き(それがビルドホストからの{{Package|thin-provisioning-tools}} バイナリのビルドもコピーもしてなければ)、また、おそらくRAID10も除かれます。(RAID10サポートはLVM2 2.02.98が必要ですがgenkernelは2.02.89をビルドします。しかし、スタティックバイナリがあればそれらがコピーされます);
* {{c|genkernel-next}}は全てのタイプのボリュームからブート可能ですが、十分に新しい{{Package|app-misc/pax-utils}}を必要とし、さもなければシンプロビジョニングバイナリの破壊に至ります({{Bug|482504}});
* {{c|dracut}}は全てのタイプでブートするはずですが、もしホストがシンプロビジョニングルート上で動いている場合、シンプロビジョニングサポートがinitramfsにて必要です。

==== Genkernel/Genkernel-next ====

{{Package|sys-kernel/genkernel}}か{{Package|sys-kernel/genkernel-next}}のいずれかをインストールしてください。genkernelがシステムバイナリを使うよう(でなければそのプライベートコピーがビルドされます)、静的USEフラグもパッケージ{{Package|sys-fs/lvm2}}で有効化されます。次の例はinitramfs(カーネル全体ではなく)をビルドし、LVMサポートを有効化します。

{{RootCmd|genkernel --lvm initramfs}}

genkernelのmanpageは、システム要件に応じて他のオプションの概要を説明します。

initrdはどのようにLVMを開始するか、パラメータを必要とします。そして彼らは他のカーネルパラメータと同じように提供されます。例えば:

{{FileBox|filename=/etc/default/grub|title=dolvmをカーネルパラメータとして追加|lang=bash|1=
GRUB_CMDLINE_LINUX="dolvm"
}}

==== Dracut ====

{{Package|sys-kernel/dracut}}パッケージはRedHatプロジェクトから移植され、initramfsを生成する類似ツールを提供します。現在それはテストのため~archにありますが、ユーザーはそれをインストールするためには[[Knowledge_Base:Accepting_a_keyword_for_a_single_package|許可する]]必要があるでしょう({{Path|/etc/portage/package.accept_keywords}}を通して)。それをする前に、変数<code>DRACUT_MODULES="lvm"</code>は{{Path|/etc/portage/make.conf}}に追加されるべきです。他のモジュールが必要とされるでしょう。[[Dracut]]を参照してください。一般に、次のコマンドは有効なデフォルトinitramfsを生成します。

{{RootCmd|dracut -a lvm}}

initrdはどのようにLVMを開始するか、パラメータを必要とします。そして彼らは他のカーネルパラメータと同じように提供されます。例えば:

{{FileBox|filename=/etc/default/grub|title=カーネルパラメータへのLVMサポートの追加|lang=bash|1=
GRUB_CMDLINE_LINUX="rd.lvm.vg=vol00"
}}

{{c|dracut}}についてのLVMオプションの包括的リストは[https://www.kernel.org/pub/linux/utils/boot/dracut/dracut.html#_lvm Dracut Manual]の一節をご覧ください。

== 使い方 ==

LVMは次に示す3つの異なるレベルでストレージを構成します:
* ハードドライブ、パーティション、RAID、物理ディスク(PV)として初期化される他の種類のストレージ
* 物理ディスク(PV)はボリュームグループ(VG)中にグループ化される
* 論理ボリューム(LV)はボリュームグループ(VG)中に管理される

=== PV（物理ボリューム）===
物理ボリュームはLVMが構成される実際のハードウェアやストレージシステムやストレージです。

=== パーティショニング ===

{{Note|別々のパーティションをストレージのためにボリュームグループで使うことはディスク全体を単一LVMボリュームグループとして使うことが望まれてない場合に限り必要です。もしディスク全体を使うとなると、これをスキップしディスク全体を物理ディスクとして設定してください。}}

"LVM"のパーティションタイプは"8e"(Linux LVM)です。

例えば、{{c|fdisk}}で{{Path|/dev/sda}}のパーティションのタイプを設定するには:

{{RootCmd|fdisk /dev/sda}}

{{c|fdisk}}では、{{Key|n}}キーを使ってパーティションをつくり、それから{{Key|t}}キーでパーティションタイプを"8e"に変更してください。

==== PVを作成 ====

物理ディスクは{{c|pvcreate}}コマンドによって作成あるいは初期化されます。

例えば、次のコマンドは{{Path|/dev/sda}}と{{Path|/dev/sdb}}の先頭パーティションに物理ディスクをつくります:

{{RootCmd|pvcreate /dev/sd[ab]1}}

==== PVの一覧 ====

{{c|pvdisplay}}コマンドによってシステムのアクティブな全ての物理ボリュームを得ることができます。

{{RootCmd|pvdisplay|output=<pre>
 --- Physical volume ---
  PV Name               /dev/sda1
  VG Name               volgrp
  PV Size               160.01 GiB / not usable 2.31 MiB
  Allocatable           yes 
  PE Size               4.00 MiB
  Total PE              40962
  Free PE               4098
  Allocated PE          36864
  PV UUID               3WHAz3-dh4r-RJ0E-5o6T-9Dbs-4xLe-inVwcV
  
 --- Physical volume ---
  PV Name               /dev/sdb1
  VG Name               volgrp
  PV Size               160.01 GiB / not usable 2.31 MiB
  Allocatable           yes 
  PE Size               4.00 MiB
  Total PE              40962
  Free PE               40962
  Allocated PE          0
  PV UUID               b031x0-6rej-BcBu-bE2C-eCXG-jObu-0Boo0x
</pre>}}

より多くの物理ボリュームについて表示したければ、{{c|pvscan}}は非アクティブの物理ボリュームを検知し、有効化します。

{{RootCmd|pvscan|output=<pre>
  PV /dev/sda1  VG volgrp        lvm2 [160.01 GiB / 16.01 GiB free]
  PV /dev/sdb1  VG volgrp        lvm2 [160.01 GiB / 160.01 GiB free]
  Total: 2 [320.02 GB] / in use: 2 [320.02 GiB] / in no VG: 0 [0]
</pre>}}

==== PVを削除する ====

LVMは自動的に(そうしないよう指示しない限り)全ての有効なボリュームへデータを順に送ります。もし(ボリュームグループ内の)該当する論理ボリュームがある単一物理ボリュームのフリースペースの量より小さければ、その論理ボリューム用の全てのスペースがその(単一)物理ボリューム上に連続して確保されます。これはパフォーマンス上の理由です。

物理ボリュームがボリュームグループより削除される必要があるのであれば、データがまず物理ボリュームから除去される必要があります。{{c|pvmove}}コマンドで物理ボリューム上の全てのデータが同一ボリュームグループの物理ボリュームに移されます。

{{RootCmd|pvmove -v /dev/sda1}}

このような動作は移動する必要があるデータの量に応じて時間がかかります。完了したらデバイス上に残されたデータはないはずです。pvdisplayによってどの論理ボリュームからも物理ボリュームがもはや使われていないことを確認してください。

次のステップは、pvremoveを使って物理ボリュームが"deselected"になった後に物理ボリュームをボリュームグループから{{c|vgreduce}}で削除することです。

{{RootCmd|vgreduce vg0 /dev/sda1 && pvremove /dev/sda1}}

=== VG (Volume Group) ===

ボリュームグループ(VG)は多くの物理ボリュームをまとめ、デバイスファイルシステムに{{Path|/dev/VG_NAME}}として表示します。ボリュームグループの名前は管理者によって決定されます。

==== VGを作成 ====

次のコマンドはボリュームグループ"vg0"を{{Path|/dev/sda1}}と{{Path|/dev/sdb1}}として割り当てられた2つの物理ボリュームからつくります。

{{RootCmd|vgcreate vg0 /dev/sd[ab]1}}

==== VGの一覧 ====

全てのアクティブなボリュームグループを表示するには{{c|vgdisplay}}コマンドを使ってください。

{{RootCmd|vgdisplay|output=<pre>
  --- Volume group ---
  VG Name               vg0
  System ID             
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  8
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                6
  Open LV               6
  Max PV                0
  Cur PV                1
  Act PV                1
  VG Size               320.02 GiB
  PE Size               4.00 MiB
  Total PE              81924
  Alloc PE / Size       36864 / 144.00 GiB
  Free  PE / Size       45056 /176.01 GiB
  VG UUID               mFPXj3-DdPi-7YJ5-9WKy-KA5Y-Vd4S-Lycxq3
</pre>}}

ボリュームグループが見つからなければ{{c|vgscan}}コマンドを使ってください。

{{RootCmd|vgscan|output=<pre>
  Reading all physical volumes.  This may take a while...
  Found volume group "vg0" using metadata type lvm2
</pre>}}

==== VGを拡張 ====

管理者がストレージ・リソースのプールを使用できるようにボリューム・グループグループの物理ボリュームは、ファイルシステムに割り当てることができます。ボリュームグループが十分な記憶リソースを保持していない場合には、追加の物理ボリュームにボリュームグループを拡張する必要があります。

次の例はボリュームグループ "vg0"を物理ボリューム{{Path|/dev/sdc1}}で拡張します。

{{RootCmd|vgextend vg0 /dev/sdc1}}

物理ボリュームを最初のように初期化する必要があることを忘れないでください！

==== VGの縮小====

物理ボリュームをボリュームグループから削除する必要があるときは物理ボリューム上のまだ使われている全てのデータはそのボリュームグループ内の他の物理ボリュームに移動される必要があります。見てきたように、これは{{c|pvmove}}コマンドによって行われ、その後物理ボリュームはvgrduceを使うことでボリュームグループから削除されます。

{{RootCmd|pvmove -v /dev/sdc1
|vgreduce vg0 /dev/sdc1}}

==== VGの削除 ====

ボリュームグループがもはや必要でない(あるいは、言い換えれば、それが表すストレージプールがもはや使われてなく、その中の物理ボリュームが他の目的で解放される必要がある)なら、ボリュームグループはvgremoveで削除されます。これは論理ボリュームがボリュームグループに存在しない場合と、プールからすでに除去された物理ボリューム以外の全てにのみ有効です。

{{RootCmd|vgremove vg0}}

=== LV (Logical Volume) ===

論理ボリュームはシステムを利用可能にする最後のメタデバイスであり、通常、そこにファイルシステムを作成します。論理ボリュームはボリュームグループ中に作成・管理され、{{Path|/dev/VG_NAME/LV_NAME}}として表示されます。ボリュームグループのように、論理ボリュームに使われる名前は管理者によって決定されます。

==== LVの作成 ====

論理ボリュームをつくるためには、{{c|lvcreate}}コマンドが使われます。コマンドへのパラメータは論理ボリュームの要求サイズ(ただしボリュームグループ中の空き量量より大きくすることはできません)から成り、それによりボリュームグループ中にスペースが確保され、論理ボリュームの名前がつくられます。

次の例では、論理ボリューム"lvol1"はボリュームグループ"vg0"から150MBのサイズでつくられます。

{{RootCmd|lvcreate -L 150M -n lvol1 vg0}}

{{c|lvcreate}}にボリュームグループ内の全ての空き容量を使うよう指示することが可能です。これは(人間に可読の)サイズではなく"エクステント"の量を指示する<code>-l</code>オプションによって行われます。論理ボリュームはボリュームグループ内のデータの塊である"論理エクステント"に分割されます。ボリュームグループ内の全てのエクステントは同じサイズです。<code>-l</code>オプションで{{c|lvcreate}}に全ての未使用エクステントに割り当てるよう指示できます。

{{RootCmd|lvcreate -l 100%FREE -n lvol1 vg0}}

"FREE"の次の"VG"キーワードはボリュームグループ全体のサイズを示すために使われます。

==== LVの表示 ====

全てのアクティブな論理ボリュームを表示するには{{c|lvdisplay}}コマンドを使ってください。

{{RootCmd|lvdisplay}}

論理ボリュームがない場合、{{c|lvscan}}コマンドが全ての優子なボリュームグループ上の論理ボリュームをスキャンするのに使えます。

{{RootCmd|lvscan}}

==== LVを拡張 ====

論理ボリュームを拡張する必要がある場合、{{c|lvextend}}コマンドは論理ボリュームの確保済みスペースを広げるのに使うことが出来ます。

例えば、論理ボリューム"lvol1"を計500MBに拡張するには:

{{RootCmd|lvextend -L500M /dev/vg0/lvol1}}

トータルサイズではなく追加サイズを指定することも可能です。

{{RootCmd|lvextend -L+350MB /dev/vg0/lvol1}}

拡張されたボリュームグループは直ちに追加のストレージをユーザーに提供するわけではありません。そのためには、ボリュームグループ上のファイルシステムを必要サイズだけ拡張する必要があります。もしファイルシステムがオンラインリサイズを許可しないばあい、問題のファイルシステムについてドキュメントを調べてください。

例えば、ext4ファイルシステムを500MBになるように拡張するには:

{{RootCmd|resize2fs /dev/vg0/lvol1 500M}}

==== LVの縮小====

論理ボリュームのサイズを縮小するには、まずファイルシステムそれ自体を縮小してください。。全てのファイルシステムがオンライン縮小をサポートしているわけではありません。

例えば、ext4はオンライン縮小をサポートしていないのでファイルシステムはまずアンマウントされる必要があります。問題を排除するためファイルシステムチェックを行うことが推奨されています。

{{RootCmd|umount /mnt/data
|e2fsck -f /dev/vg0/lvol1
|resize2fs /dev/vg0/lvol1 150M}}

縮小済みファイルシステムのもと、論理ボリュームを縮小することが可能です。

{{RootCmd|lvreduce -L150M /dev/vg0/lvol1}}

==== LV権限 ====

LVMは論理ボリューム上での権限付与をサポートしています。

例えば、論理ボリュームは{{c|lvchange}}コマンドにより"read only"にすることが可能です。

{{RootCmd|lvchange -p r /dev/vg0/lvol1
|mount -o remount /dev/vg0/lvol1}}

変更が直ちに実行されるために再マウントが必要です。

To mark the logical volume as writable again, use the ''rw'' permission bit:

{{RootCmd|lvchange -p rw /dev/vg0/lvol1 && mount -o remount /dev/vg0/lvol1}}

==== Remove LV ====

Before removing a logical volume, make sure it is no longer mounted:

{{RootCmd|umount /dev/vg0/lvol1}}

Deactivate the logical volume so that no further write activity can take place:

{{RootCmd|lvchange -a n /dev/vg0/lvol1}}

With the volume unmounted and deactivated, it can now be removed, freeing the extents allocated to it for use by other logical volumes in the volume group:

{{RootCmd|lvremove /dev/vg0/lvol1}}

== 機能 ==

LVM provides quite a few interesting features for storage administrators, including (but not limited to)
* thin provisioning (over-committing storage)
* snapshot support
* volume types with different storage allocation methods

=== Thin provisioning ===

Recent versions of LVM2 (2.02.89) support "thin" volumes. Thin volumes are to block devices what [[Wikipedia:Sparse_file|sparse files]] are to file systems. Thus, a thin logical volume within a pool can be "over-committed": its presented size can be larger than the allocated size - it can even be larger than the pool itself. Just like a sparse file, the extents are allocated as the block device gets populated. If the file system has ''discard'' support extents are freed again as files are removed, reducing space utilization of the pool.

Within LVM, such a thin pool is a special type of logical volume, which itself can host logical volumes.

==== Creating a thin pool ====

{{Warning|If an overflow occurs within the thin pool metadata, then the pool will be corrupted. '''LVM cannot recover from this'''.}} 

{{Note|If the thin pool gets exhausted, any process that would cause the thin pool to allocate more (unavailable) extents will be stuck in "killable sleep" state until either the thin pool is extended or the process recieves SIGKILL.}}

Each thin pool has metadata associated with it, which is added to the thin pool size. LVM will compute the size of the metadata based on the size of the thin pool as the minimum of ''pool_chunks * 64 bytes'' or 2MiB, whichever is larger. The administrator can select a different metadata size as well.

To create a thin pool, add the <code>--type thin-pool --thinpool thin_pool</code> options to {{c|lvcreate}}:

{{RootCmd|lvcreate -L 150M --type thin-pool --thinpool thin_pool vg0}}

The above example creates a thin pool called ''thin_pool'' with a total size of 150 MB. This is the real allocated size for the thin pool (and thus the total amount of actual storage that can be used).

To explicitly ask for a certain metadata size, use the <code>--metadatasize</code> option:

{{RootCmd|lvcreate -L 150M --poolmetadatasize 2M --type thin-pool --thinpool thin_pool vg0}}

Due to the metadata that is added to the thin pool, the intuitive way of using all available size in a volume group for a logical volume does not work (see LVM bug [https://bugzilla.redhat.com/show_bug.cgi?id=812726|812726]):

{{RootCmd|lvcreate -l 100%FREE --type thin-pool --thinpool thin_pool vg0|output=<pre>
Insufficient suitable allocatable extents for logical volume thin_pool: 549 more required
</pre>}}

Note the thin pool does not have an associated device node like other LV's.

==== Creating a thin logical volume ====

A ''thin logical volume'' is a logical volume inside the thin pool (which itself is a logical volume). As thin logical volumes are ''sparse'', a virtual size instead of a physical size is specified using the <code>-V</code> option:

{{RootCmd|lvcreate -T vg0/thin_pool -V 300M -n lvol1}}

In this example, the (thin) logical volume ''lvol1'' is exposed as a 300MB-sized device, even though the underlying pool only holds 150MB of real allocated storage.

It is also possible to create both the thin pool as well as the logical volume inside the thin pool in one command:

{{RootCmd|lvcreate -T vg0/thin_pool -V 300M -L150M -n lvol1}}

==== Listing thin pools and thin logical volumes ====

Thin pools and thin logical volumes are special types of logical volumes, and as such as displayed through the {{c|lvdisplay}} command. The {{c|lvscan}} command will also detect these logical volumes.

==== Extending a thin pool ====

{{Warning|As of LVM2 2.02.89, the metadata size of the thin pool cannot be expanded, it is fixed at creation}}

The thin pool is expanded like a non-thin logical volume using {{c|lvextend}}. For instance:

{{RootCmd|lvextend -L500M vg0/thin_pool}}

==== Extending a thin logical volume ====

A thin logical volume is expanded just like a regular one:

{{RootCmd|lvextend -L1G vg0/lvol1}}

Note that the {{c|lvextend}} command uses the <code>-L</code> option (or <code>-l</code> if extent counts are used) and not a "virtual size" option as was used during the creation. 

==== Reducing a thin pool ====

Currently, LVM cannot reduce the size of the thin pool. See LVM bug [https://bugzilla.redhat.com/show_bug.cgi?id=812731|812731].

==== Reducing a thin logical volume ====

Thin logical volumes are reduced just like regular logical volumes.

For instance:
{{RootCmd|lvreduce -L300M vg0/lvol1l}}

Note that the {{c|lvreduce}} command uses the <code>-L</code> option (or <code>-l</code> if extent counts are used) and not a "virtual size" option as was used during the creation.

==== Removing thin pools ====

Thin pools cannot be removed until all the thin logical volumes inside it are removed.

When a thin pool no longer services any thin logical volume, it can be removed through the {{c|lvremove}} command:

{{RootCmd|lvremove vg0/thin_pool}}

=== LVM2 snapshots and thin snapshots ===

A snapshot is a logical volume that acts as copy of another logical volume. It displays the state of the original logical volume at the time of snapshot creation.

{{Warning|Since the logical snapshot volume also gets the same filesystem ''LABEL'' and ''UUID'', be sure the {{Path|/etc/fstab}} file or initramfs '''does not''' contain entries for these filesystems using the <code>LABEL{{=}}</code> or <code>UUID{{=}}</code> syntax. Otherwise you might end up with the snapshot being mounted instead of the (intended) original logical volume.}}

==== Creating a snapshot logical volume ====

A snapshot logical volume is created using the <code>-s</code> option to {{c|lvcreate}}. Snapshot logical volumes are still given allocated storage as LVM "registers" all changes made to the original logical volume and stores these changes in the allocated storage for the snapshot. When querying the snapshot state, LVM will start from the original logical volume and then check all changes registered, "undoing" the changes before showing the result to the user.

A snapshot logical volume henceforth "growths" at the rate that changes are made on the original logical volume. When the allocated storage for the snapshot is completely used, then the snapshot will be removed automatically from the system.

{{RootCmd|lvcreate -l 10%VG -s -n 20140412_lvol1 /dev/vg0/lvol1}}

The above example creates a snapshot logical volume called ''20140412_lvol1'', based on the logical volume ''lvol1'' in volume group ''vg0''. It uses 10% of the space (extents actually) allocated to the volume group.

==== Accessing a snapshot logical volume ====

Snapshot logical volumes can be mounted like regular logical volumes. They are even not restricted to read-only operations - it is possible to modify snapshots and thus use it for things such as testing changes before doing these on a "production" file system.

As long as snapshot logical volumes exist, the regular/original logical volume cannot be reduced in size or removed.

==== LVM thin snapshots ====

{{Note|A thin snapshot can only be taken on a thin pool for a thin logical volume. The thin device mapper target supports thin snapshots of read-only non-thin logical volumes, but the LVM2 tooling does not support this. However, it is possible to create a regular (non-thin) snapshot logical volume of a thin logical volume.}}

To create a thin snapshot, the {{c|lvcreate}} command is used with the <code>-s</code> option. No size declaration needs to be passed on:

{{RootCmd|lvcreate -s -n 20140413_lvol1 /dev/vg0/lvol1}}

Thin logical volume snapshots have the same size as their original thin logical volume, and use a physical allocation of 0 just like all other thin logical volumes. 

{{Important|If ''-l'' or ''-L'' is specified, a snapshot will still be created, but the resulting snapshot will be a regular snapshot, not a thin snapshot.}}

It is also possible to take snapshots of snapshots:

{{RootCmd|lvcreate -s -n 1_20140413_lvol1 /dev/vg0/20140413_lvol1}}

Thin snapshots have several advantages over regular snapshots. First, thin snapshots are independent of their original logical volume once created. The original logical volume can be shrunk or deleted without affecting the snapshot. Second, thin snapshots can be efficiently created recursively (snapshots of snapshots) without the "chaining" overhead of regular recursive LVM snapshots.

==== Rolling back to snapshot state ====

To rollback the logical volume to the version of the snapshot, use the following command:

{{RootCmd|lvconvert --merge /dev/vg0/20140413_lvol1}}

This might take a couple of minutes, depending on the size of the volume. Please note that the rollback will only happen once the parent logical volume is offline. Hence a reboot might be required.

{{Important|The snapshot will disappear and this change is not revertible}}

==== Rolling back thin snapshots ====

For thin volumes, {{c|lvconvert --merge}} does not work. Instead, delete the original logical volume and rename the snapshot:

{{RootCmd|umount /dev/vg0/lvol1
|lvremove /dev/vg0/lvol1
|lvrename vg0/20140413_lvol1 lvol1}}

=== Different storage allocation methods ===

LVM supports different allocation methods for storage:
* Linear volumes (which is the default);
* Mirrored volumes (in a more-or-less active/standby setup);
* Striping (RAID0);
* Mirrored volumes (RAID1 - which is more an active/active setup);
* Striping with parity (RAID4 and RAID5);
* Striping with double parity (RAID6);
* Striping and mirroring (RAID10).

==== Linear volumes ====

Linear volumes are the most common kind of LVM volumes. LVM will attempt to allocate the logical volume to be as physically contiguous as possible. If there is a physical volume large enough to hold the entire logical volume, then LVM will allocate it there, otherwise it will split it up into as few pieces as possible.

The commands introduced earlier on to create volume groups and logical volumes create linear volumes.

Because linear volumes have no special requirements, they are the easiest to manipulate and can be resized and relocated at will. If a logical volume is allocated across multiple physical volumes, and any of the physical volumes become unavailable, then that logical volume cannot be started anymore and will be unusable.

==== Mirrored volumes ====

LVM supports ''mirrored'' volumes, which provide fault tolerance in the event of drive failure. Unlike RAID1, there is no performance benefit - all reads and writes are delivered to a single side of the mirror.

To keep track of the mirror state, LVM requires a ''log'' to be kept. It is recommended (and often even mandatory) to position this log on a physical volume that does not contain any of the mirrored logical volumes. There are three kind of logs that can be used for mirrors:

# '''Disk''' is the default log type. All changes made are logged into extra metadata extents, which LVM manages. If a device fails, then the changes are kept in the log until the mirror can be restored again.
# '''Mirror''' logs are '''disk''' logs that are themselves mirrored. 
# '''Core''' mirror logs record the state of the mirror in memory only. LVM will have to rebuild the mirror every time it is activated. This type is useful for temporary mirrors.

To create a logical volume with a single mirror, pass the ''-m 1'' argument (to select standard mirroring) with optionally <code>--mirrorlog</code> to select a particular log type:

{{RootCmd|lvcreate -m 1 --mirrorlog mirror -l 40%VG --nosync -n lvol1 vg0}}

The ''-m 1'' tells LVM to create one (additional) mirror, so requiring 2 physical volumes. The <code>--nosync</code> option is an optimization - without it LVM will try synchronize the mirror by copying empty sectors from one logical volume to another.

It is possible to create a mirror of an existing logical volume:

{{RootCmd|lvconvert -m 1 -b vg0/lvol1}}

The <code>-b</code> option does the conversion in the background as this can take quite a while.

To remove a mirror, set the number of mirrors (back) to 0:

{{RootCmd|lvconvert -m0 vg0/lvol1}}

If part of the mirror is unavailable (usually because the disk containing the physical volume has failed), the volume group will need to be brought up in degraded mode:

{{RootCmd|vgchange -ay --partial vg0}}

On the first write, LVM will notice the mirror is broken. The default policy ("remove") is to automatically reduce/break the mirror according to the number of pieces available. A 3-way mirror with a missing physical volume will be reduced to 2-way mirror; a 2-way mirror will be reduced to a regular linear volume. If the failure is only transient, and the missing physical volume returns after LVM has broken the mirror, the mirrored logical volume will need to be recreated on it. 

To recover the mirror, the failed physical volume needs to be removed from the volume group, and a replacement physical volume needs to be added (or if the volume group has a free physical volume, it can be created on that one). Then the mirror can be recreated with {{c|lvconvert}} at which point the old physical volume can be removed from the volume group:

{{RootCmd|vgextend vg0 /dev/sdc1
|lvconvert -b -m 1 --mirrorlog disk vg0/lvol1
|vgreduce --removemissing vg0}}

It is possible to have LVM recreate the mirror with free extents on a different physical volume if one side fails. To accomplish that, set <code>mirror_image_fault_policy</code> to ''allocate'' in {{Path|lvm.conf}}.

==== Thin mirrors ====

It is not (yet) possible to create a mirrored thin pool or thin volume. It is possible to create a mirrored thin pool by creating a normal mirrored logical volume and then converting the logical volume to a thin pool with {{c|lvconvert}}. 2 logical volumes are required: one for the thin pool and one for the thin metadata; the conversion process will merge them into a single logical volume.

{{Warning|LVM 2.02.98 or above is required for this to work properly. Prior versions are either not capable or will segfault and corrupt the volume group. Also, conversion of a mirror into a thin pool '''destroys''' all existing data in the mirror!}}

{{RootCmd|lvcreate -m 1 --mirrorlog mirrored -l40%VG -n thin_pool vg0
|lvcreate -m 1 --mirrorlog mirrored -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg0/thin_meta}}

==== Striping (RAID0) ====

Instead of a linear volume, where multiple contiguous physical volumes are appended, it possible to create a ''striped'' or ''RAID0'' volume for better performance. This will alternate storage allocations across the available physical volumes.

To create a striped volume over three physical volumes:

{{RootCmd|lvcreate -i 3 -l 20%VG -n lvol1_stripe vg0|output=<pre>
Using default stripesize 64.00 KiB
</pre>}}

The <code>-i</code> option indicates over how many physical volumes the striping should be done.

It is possible to mirror a stripe set. The <code>-i</code> and <code>-m</code> options can be combined to create a striped mirror:

{{RootCmd|lvcreate -i 2 -m 1 -l 10%VG vg0}}

This creates a 2 physical volume stripe set and mirrors it on 2 different physical volumes, for a total of 4 physical volumes. An existing stripe set can be mirrored with {{c|lvconvert}}.

A thin pool can be striped like any other logical volume. All the thin volumes created from the pool inherit that settings - do not specify it manually when creating a thin volume.

It is not possible to stripe an existing volume, nor reshape the stripes across more/less physical volumes, nor to convert to a different RAID level/linear volume. A stripe set can be mirrored. It is possible to extend a stripe set across additional physical volumes, but they must be added in multiples of the original stripe set (which will effectively linearly append a new stripe set).

==== Mirroring (RAID1) ====

Unlike RAID0, which is striping, RAID1 is mirroring, but implemented differently than the original LVM mirror. Under RAID1, reads are spread out across physical volumes, improving performance. RAID1 mirror failures do not cause I/O to block because LVM does not need to break it on write.

Any place where an LVM mirror could be used, a RAID1 mirror can be used in its place. It is possible to have LVM create RAID1 mirrors instead of regular mirrors implicitly by setting ''mirror_segtype_default'' to ''raid1'' in {{Path|lvm.conf}}.

{{Warning|LVM RAID1 mirroring is not yet supported by GRUB. If you apply this to the LVM volume that holds your kernel/initramfs (your 'boot' volume), you will render your system unbootable. (A fix will appear in the next version of GRUB. See GRUB bug [http://savannah.gnu.org/bugs/?44534 #44534] for details.)}}

To create a logical volume with a single mirror:

{{RootCmd|lvcreate -m 1 --type raid1 -l 40%VG --nosync -n lvm_raid1 vg0}}

Note the difference for creating a mirror: There is no ''mirrorlog'' specified, because RAID1 logical volumes do not have an explicit mirror log - it built-in to the logical volume.

It is possible to convert an existing logical volume to RAID1:

{{RootCmd|lvconvert -m 1 --type raid1 -b vg0/lvol1}}

To remove a RAID1 mirror, set the number of mirrors to 0:

{{RootCmd|lvconvert -m0 vg0/lvm_raid1}}

If part of the RAID1 is unavailable (usually because the disk containing the physical volume has failed), the volume group will need to be brought up in degraded mode:

{{RootCmd|vgchange -ay --partial vg0}}

Unlike an LVM mirror, writing does NOT break the mirroring. If the failure is only transient, and the missing physical volume returns, LVM will resync the mirror by copying cover the out-of-date segments instead of the entire logical volume. If the failure is permanent, then the failed physical volume needs to be removed from the volume group, and a replacement physical volume needs to be added (or if the volume group has a free physical volume, it can be created on a different PV). The mirror can then be repaired with {{c|lvconvert}}, and the old physical volume can be removed from the volume group:

{{RootCmd|vgextend vg0 /dev/sdc1
|lvconvert --repair -b vg0/lvm_raid1
|vgreduce --removemissing vg0}}

==== Thin RAID1 ====

It is not (yet) possible to create a RAID1 thin pool or thin volume. It is possible to create a RAID1 thin pool by creating a normal mirrored logical volume and then converting the logical volume to a thin pool with {{c|lvconvert}}. 2 logical volumes are required: one for the thin pool and one for the thin metadata; the conversion process will then merge them into a single logical volume.

{{Warning|LVM 2.02.98 or above is required for this to work properly. Prior versions are either not capable or will segfault and corrupt the VG. Also, conversion of a RAID1 into a thin pool '''destroys''' all existing data in the mirror!}}

{{RootCmd|lvcreate -m 1 --type raid1 -l40%VG -n thin_pool vg0
|lvcreate -m 1 --type raid1 -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg00/thin_meta}}

==== Striping with parity (RAID4 and RAID5) ====

{{Note|Striping with parity requires at least 3 physical volumes.}}

RAID0 is not fault-tolerant - if any of the physical volumes fail then the logical volume is unusable. By adding a parity stripe to RAID0 the logical volume can still function if a physical volume is missing. A new physical volume can then be added to restore fault tolerance.

Stripsets with parity come in 2 flavors: RAID4 and RAID5. Under RAID4, all the parity stripes are stored on the same physical volume. This can become a bottleneck because all writes hit that physical volume, and it gets worse the more physical volumes are in the array. With RAID5, the parity data is distributed evenly across the physical volumes so none of them become a bottleneck. For that reason, RAID4 is rare and is considered obsolete/historical. In practice, all stripesets with parity are RAID5.

{{RootCmd|lvcreate --type raid5 -l 20%VG -i 2 -n lvm_raid5 vg0}}

Only the data physical volumes are specified with -i, LVM adds one to it automatically for the parity. So for a 3 physical volume RAID5, ''-i 2'' is passed on and not ''-i 3''.

When a physical volume fails, then the volume group will need to be brought up in degraded mode:

{{RootCmd|vgchange -ay --partial vg0}}

The volume will work normally at this point, however this degrades the array to RAID0 until a replacement physical volume is added. Performance is unlikely to be affected while the array is degraded - although it does need to recompute its missing data via parity, it only requires simple XOR for the parity block with the remaining data. The overhead is negligible compared to the disk I/O.

To repair the RAID5:

{{RootCmd|lvconvert --repair vg0/lvm_raid5
|vgreduce --removemissing vg0}}

It is possible to replace a still working physical volume in RAID5 as well:

{{RootCmd|lvconvert --replace /dev/sdb1 vg0/lvm_raid5
|vgreduce vg0 /dev/sdb1}}

The same restrictions of stripe sets apply to stripe sets with parity as well: it is not possible to enable striping with parity on an existing volume, nor reshape the stripes with parity across more/less physical volumes, nor to convert to a different RAID level/linear volume. A stripe set with parity can be mirrored. It is possible to extend a stripe set with parity across additional physical volumes, but they must be added in multiples of the original stripe set with parity (which will effectively linearly append a new stripe set with parity).

==== Thin RAID5 logical volumes ====

It is not (yet) possible to create stripe set with parity (RAID5) thin pools or thin logical volumes. It is possible to create a RAID5 thin pool by creating a normal RAID5 logical volume and then converting the logical volume into a thin pool with {{c|lvconvert}}. 2 logical volumes are required: one for the thin pool and one for the thin metadata; the conversion process will merge them into a single logical volume.

{{Warning|LVM 2.02.98 or above is required for this to work properly. Prior versions are either not capable or will segfault and corrupt the VG. Also, coversion of a RAID5 LV into a thin pool '''destroys''' all existing data in the LV!}}

{{RootCmd|lvcreate --type raid5 -i 2  -l20%VG -n thin_pool vg0
|lvcreate --type raid5 -i 2 -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg00/thin_meta}}

==== Striping with double parity (RAID6) ====

{{Note|RAID6 requires at least 5 physical volumes.}}

RAID6 is similar to RAID5, however RAID6 can survive up to '''two''' physical volume failures, thus offering more fault tolerance than RAID5 at the expense of extra physical volumes. 

{{RootCmd|lvcreate --type raid6 -l 20%VG -i 3 -n lvm_raid6 vg00}}

Like RAID5, the <code>-i</code> option is used to specify the number of physical volumes to stripe, excluding the 2 physical volumes for parity. So for a 5 physical volume RAID6, pass on <code>-i 3</code> and not <code>-i 5</code>.

Recovery for RAID6 is the same as RAID5.

{{Note|Unlike RAID5 where parity block is cheap to recompute vs disk I/O, this is only half true in RAID6. RAID6 uses 2 parity stripes: One stripe is computed the same way as RAID5 (simple XOR). The second parity stripe is much harder to compute - see [https://www.kernel.org/pub/linux/kernel/people/hpa/raid6.pdf|raid6 (pdf)] for more information.}}

==== Thin RAID6 logical volumes ====

It is not (yet) possible to create a RAID6 thin pool or thin volumes. It is possible to create a RAID6 thin pool by creating a normal RAID6 logical volume and then converting the logical volume into a thin pool with {{c|lvconvert}}. 2 logical volumes are required: one for the thin pool and one for the thin metadata; the conversion process will merge them into a single logical volume.

{{Warning|LVM 2.02.98 or above is required for this to work properly. Prior versions are either not capable or will segfault and corrupt the VG. Also, conversion of a RAID6 LV into a thin pool '''destroys''' all existing data in the LV!}}

{{RootCmd|lvcreate --type raid6 -i 2  -l20%VG -n thin_pool vg0
|lvcreate --type raid6 -i 2 -L4MB -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg0/thin_meta}}

==== LVM RAID10 ====

{{Note|RAID10 requires at least 4 physical volumes. Also LVM syntax requires the number of physical volumes be multiple of the numbers stripes and mirror, even though RAID10 format does not}}

RAID10 is a combination of RAID0 and RAID1. It is more powerful than RAID0+RAID1 as the mirroring is done at the stripe level instead of the logical volume level, and therefore the layout doesn't need to be symmetric. A RAID10 volume can tolerate at least a single missing physical volume, and possibly more.

{{Note|LVM currently limits RAID10 to a single mirror.}}

{{RootCmd|lvcreate --type raid10 -l 1020 -i 2 -m 1 --nosync -n lvm_raid10 vg0}}

Both the <code>-i</code> and <code>-m</code> options are specified: <code>-i</code> is the number of stripes and <code>-m</code> is the number of mirrors. Two stripes and 1 mirror requires 4 physical volumes.

==== Thin RAID10 ====

It is not (yet) possible to create a RAID10 thin pool or thin volumes. It is possible to create a RAID10 thin pool by creating a normal RAID10 logical volume and then converting the logical volume into a thin pool with {{c|lvconvert}}. 2 logical volumes are required: one for the thin pool and one for the thin metadata; the conversion process will merge them into a single logical volume.
 
{{Warning|Conversion of a RAID10 logical volume into a thin pool '''destroys''' all existing data in the logical volume!}}

{{RootCmd|lvcreate -i 2 -m 1 --type raid10 -l 1012 -n thin_pool vg0
|lvcreate -i 2 -m 1 --type raid10 -l 6 -n thin_meta vg0
|lvconvert --thinpool vg0/thin_pool --poolmetadata vg0/thin_meta}}

== Experimenting with LVM ==

It is possible to experiment with LVM without using real storage devices. To accomplish this, loopback devices are created.

First make sure to have the loopback module loaded. 

{{RootCmd|modprobe -r loop && modprobe loop max_part{{=}}63}}

{{Note|If loopback support is built into the kernel, then use <code>loop.max_part{{=}}63</code> as boot option.}}

Next configure LVM to not use [[udev]] to scan for devices:

{{FileBox|filename=/etc/lvm/lvm.conf|title=Disabling udev in LVM config|lang=ini|1=
obtain_device_list_from_udev = 0
}}

{{Important|This is for testing only, make sure to change the setting back when dealing with real devices since it is much faster to use udev!}}

Create some image files which will become the storage devices. The next example uses five files for a total of about ~10GB of real hard drive space:

{{RootCmd|mkdir /var/lib/lvm_img
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm0.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm1.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm2.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm3.img bs{{=}}1024 seek{{=}}2097152
|dd if{{=}}/dev/null of{{=}}/var/lib/lvm_img/lvm4.img bs{{=}}1024 seek{{=}}2097152}}

Check which loopback devices are available:

{{RootCmd|losetup -a}}

Assuming all loopback devices are available, next create the devices:

{{RootCmd|losetup /dev/loop0 /var/lib/lvm_img/lvm0.img
|losetup /dev/loop1 /var/lib/lvm_img/lvm1.img
|losetup /dev/loop2 /var/lib/lvm_img/lvm2.img
|losetup /dev/loop3 /var/lib/lvm_img/lvm3.img
|losetup /dev/loop4 /var/lib/lvm_img/lvm4.img}}

The {{Path|/dev/loop[0-4]}} devices are now available to use as any other hard drive in the system (and thus be perfect for physical volumes).

{{Note|On the next reboot, all the loopback devices will be released and the folder {{Path|/var/lib/lvm_img}} can be deleted.}}

== Troubleshooting ==

LVM は、既にいくつかのレベルの冗長性を提供するいくつかの機能です。しかし、状況が失われる物理ボリュームまたは論理ボリュームを復元することがあります。

=== vgcfgrestore utility ===

By default, on any change to a LVM physical volume, volume group, or logical volume, LVM2 create a backup file of the metadata in {{Path|/etc/lvm/archive}}. These files can be used to recover from an accidental change (like deleting the wrong logical volume). LVM also keeps a backup copy of the most recent metadata in {{Path|/etc/lvm/backup}}. These can be used to restore metadata to a replacement disk, or repair corrupted metadata.

To see what states of the volume group are available to be restored (partial output to improve readability):

{{RootCmd|vgcfgrestore --list vg00|output=<pre>
  File:		/etc/lvm/archive/vg0_00042-302371184.vg
  VG name:    	vg0
  Description:	Created *before* executing 'lvremove vg0/lvm_raid1'
  Backup Time:	Sat Jul 13 01:41:32 201
</pre>}}

==== Recovering an accidentally deleted logical volume ====

Assuming the logical volume ''lvm_raid1'' was accidentally removed from volume group ''vg0'', it is possible to recover it as follows:

{{RootCmd|vgcfgrestore -f /etc/lvm/archive/vg0_00042-302371184.vg vg0}}

{{Important|vgcfgrestore only restores LVM metadata, ''not'' the data inside the logical volume. However pvremove, vgremove, and lvremove only wipe metadata, leaving any data intact. If <code>issue_discards</code> is set in {{Path|/etc/lvm/lvm.conf}} though, then these command ''are'' destructive to data.}}

==== Replacing a failed physical volume ====

It possible to do a true "replace" and recreate the metadata on the new physical volume to be the same as the old physical volume:

{{RootCmd|vgdisplay --partial --verbose|output=<pre>
  --- Physical volumes ---
  PV Name               /dev/loop0     
  PV UUID               iLdp2U-GX3X-W2PY-aSlX-AVE9-7zVC-Cjr5VU
  PV Status             allocatable
  Total PE / Free PE    511 / 102
  
  PV Name               unknown device     
  PV UUID               T7bUjc-PYoO-bMqI-53vh-uxOV-xHYv-0VejBY
  PV Status             allocatable
  Total PE / Free PE    511 / 102
</pre>}}

The important line here is the UUID "unknown device". 

{{RootCmd|pvcreate --uuid T7bUjc-PYoO-bMqI-53vh-uxOV-xHYv-0VejBY --restorefile /etc/lvm/backup/vg0 /dev/loop1|output=<pre>
  Couldn't find device with uuid T7bUjc-PYoO-bMqI-53vh-uxOV-xHYv-0VejBY.
  Physical volume "/dev/loop1" successfully created</pre>}}

This recreates the physical volume metadata, but not the missing logical volume or volume group data on the physical volume.

{{RootCmd|vgcfgrestore -f /etc/lvm/backup/vg0 vg0|output=<pre>
  Restored volume group vg0
</pre>}}

This now reconstructs all the missing metadata on the physical volume, including the logical volume and volume group data. However it doesn't restore the data, so the mirror is out of sync.

{{RootCmd|vgchange -ay vg0|output=<pre>
  device-mapper: reload ioctl on  failed: Invalid argument
  1 logical volume(s) in volume group "vg0" now active
</pre>}}

{{RootCmd|lvchange --resync vg0/lvm_raid1|output=<pre>
Do you really want to deactivate logical volume lvm_raid1 to resync it? [y/n]: y
</pre>}}

This will resync the mirror. This works with RAID 4,5 and 6 as well.

=== Deactivating a logical volume ===

It is possible to deactivate a logical volume with the following command:

{{RootCmd|umount /dev/vg0/lvol1
|lvchange -a n /dev/vg0/lvol1}}

It is not possible to mount the logical volume anywhere before it gets reactivated:

{{RootCmd|lvchange -a y /dev/vg0/lvol1}}

== 外部の情報 ==

* [http://sourceware.org/lvm2/ LVM2 sourceware.org]
* [http://tldp.org/HOWTO/LVM-HOWTO/ LVM tldp.org]
* [http://sources.redhat.com/lvm2/wiki/ LVM2 Wiki redhat.com]


[[Category:Core system]]
