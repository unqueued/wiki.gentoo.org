{{InfoBox stack
|{{InfoBox todo|[[#Encryption|Encryption]]|[[#Permissions|Permissions]]|[[#Backups|Backups]]|header=true}}
}}

Good security is like an onion, it has many layers. The [[filesystem|file system]] is just another layer in the proverbial onion. While there are numerous file systems in existence, this guide tries to remain agnostic and focus more on the hierarchy itself rather than an individual implementation.

== Partitioning ==

Partitioning is a key part of implementing security at the file system level:
* It limits the impact of disk failure
* It simplifies the process of creating backups
* It allows administrators to add restrictions such as quotas and read-only permissions more effectively 

=== File System Hierarchy ===

To better understand how to divide the file system across partitions and apply various restrictions, we need to understand a little about the function of the file system hierarchy and its major directories.
Unix-like operating systems, such as Gentoo, based on GNU/Linux, or OpenBSD, borrow their directory structure from the traditional Unix file system hierarchy. This hierarchy was designed in a time when many physical disks where needed to span the whole system. In modern times, with larger storage media being commonplace, average users need not worry about partitioning their file system hierarchy too much. On a server, however, we need to have finer-grained control over the system so we can manipulate it to our will.

Some of the more common directories include:
* '''{{Path|/}}'''        Pronounced as "root", this is the top level of the hierarchy. All other file systems are mounted somewhere below this one.
* '''{{Path|/root}}'''    Is the home directory of the root user. Typically email from daemons such as [[cron]] will be sent here.
* '''{{Path|/boot}}'''    Typically holds the bootloader and its configuration, as well as kernel binaries.
* '''{{Path|/etc}}'''     On modern systems like GNU/Linux and FreeBSD, this holds system wide configuration information and is a good target for regular backups.
* '''{{Path|/bin}}'''     Essential system binaries  for use by all users are located here, including tools like {{c|grep}}, {{c|ls}}, and {{c|tar}}.
* '''{{Path|/sbin}}'''    Root-only system binaries are located here; for example, the initialization daemon and utilities to mount and create file systems.
* '''{{Path|/lib}}'''     System libraries are located here. On most 64bit systems {{Path|/lib}} is usually just a symlink and separate '''{{Path|/lib32}}''' and '''{{Path|/lib64}}''' directories will exist.
* '''{{Path|/dev}}'''     Special [[device file]]s are located here. This is one of the most important directories as its contents are how Unix-like systems interface with hardware from all but the lowest level: the drivers themselves.
* '''{{Path|/home}}'''    This directory is where the home directory of a typical system user goes. It usually isn't a good idea to have network shares mounted here as users' home directories.
* '''{{Path|/opt}}'''     Is a place for non-default software. A good generalization is: if the software didn't come from Portage or another Gentoo maintained source, it should probably go here. Troublesome software that doesn't cleanly follow the Unix File Hierarchy should be located here to avoid disturbing the rest of the file system.
* '''{{Path|/tmp}}'''     This is for caches and temporary files and is typically overwritten on a reboot.
* '''{{Path|/var}}'''     This directory contains data files that change a lot, from system logs to PID files to the Portage world set.
* '''{{Path|/var/tmp}}''' This is the temporary space within {{Path|/var}}. It deserves its own listing because Portage uses this as an area to unpack and build distfiles.
* '''{{Path|/usr}}'''     This is where "shareable, read-only data" is kept. It holds data like binaries ({{Path|/usr/bin}}), program data like man pages, fonts and icons ({{Path|/usr/share}} and documentation ({{Path|/usr/share/doc}}) for user software, and shouldn't be writable by unprivileged users.
* '''{{Path|/proc}}'''    [[Procfs]] is a virtual file system that allows privileged users to monitor and modify kernel settings and configurations at run time. It has been superseded by [[Sysfs]].
* '''{{Path|/sys}}'''     [[Sysfs]] is a virtual file system used to interface with the kernel. It is like {{Path|/proc}}, but in a format easier for programs to parse.

External resources:
* [http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/ Linux Filesystem Hierarchy]
* [http://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html Filesystem Hierarchy Standard, LSB Workgroup, The Linux Foundation, Version 3.0]
* [https://man.openbsd.org/hier OpenBSD hier(7) man page]
<br />

The original Unix filesystem hierarchy was designed to involve multiple disks. Using partitions, we can emulate this and segregate some of these directories for the aforementioned reasons of security and backup simplicity.<br />
It's worth noting that {{Path|/etc}}, {{Path|/bin}}, {{Path|/sbin}}, {{Path|/dev}} and {{Path|/lib}} '''MUST''' reside on the same partition as {{Path|/}} as they are needed during the boot process.

=== Sizing ===

It is rather difficult to judge what size a partition should be. It takes a bit of experience but after thinking about the machine's intended purpose, one can usually get a reasonably good idea of sizing needs. For example, a computer used on a typical client machine would benefit from a large {{Path|/home}} directory, while, on a server, {{Path|/home}} should be considerably smaller.

=== Mount options ===

On Unix-like systems mount points are typically defined in [[fstab]]:
{{FileBox|filename=/etc/fstab|1=
# <fs>                  <mountpoint>                   <type>          <opts>                                  <dump/pass>
/dev/sda1               /boot                           ext4            noauto,nouser,noatime,ro                   1 2
/dev/sda3               /                               ext4            noatime,nouser,ro                          0 1
/dev/sda2               none                            swap            sw                                         0 0
/dev/sda5               /usr                            ext4            nodev,nouser,noatime,ro                    0 3
/dev/sda6               /opt                            ext4            nodev,nouser,noatime,ro                    0 3
/dev/sda7               /var                            ext4            nodev,nouser,noexec                        0 3
/dev/sda8               /tmp                            ext4            nodev,nouser,noatime,noexec                0 3
/dev/sda9               /var/tmp                        ext4            nodev,nouser,noatime                       0 3
/dev/sda10              /var/cache/distfiles            ext4            nodev,nouser,noatime                       0 3
/dev/sda11              /var/cache/binpkgs              ext4            nodev,nouser,noatime,noexec                0 3
/dev/sda12              /home                           ext4            nodev,nouser,noatime,noexec                0 3

/dev/md0               /srv                             ext4            nodev,nouser,noatime,noexec                0 3
}}
<br />

{{Note|In this example, {{Path|/usr}} is on its own partition. For most home users this is overkill; however, for server administrators or those interested in a higher level of security, this is a requirement. Be aware that some Unix systems such as Fedora are moving away from having {{Path|/bin}} and {{Path|/sbin}} on the root file system and instead are replacing them with symlinks to {{Path|/usr/bin}} and {{Path|/usr/sbin}}. To continue gaining the benefits of {{Path|/usr}} on a separate partition without hampering {{c|init}} while bootstrapping user space in a setup such as this, an [http://en.gentoo-wiki.com/wiki/Initramfs initramfs] will be needed with a script that mounts {{Path|/usr}} before calling {{Path|/sbin/init}}.}}

This is an example of a recently created fstab on a home server. In the fourth column, mount options are listed.<br />
The options we are currently focused on include:
* '''ro'''/'''rw''': Certain partitions, such as {{Path|/usr}} and {{Path|/boot}}, can be safely mounted with the '''ro''' flag which makes them read-only, as opposed to '''rw''', or read/write. This lowers the impact of rogue software or user mistakes and eliminates the need to use fsck on the partition after a power interruption or system crash. It does, however, require a user to remount those partitions when they want to install programs or upgrade their kernel. For files that need to be written to such as {{Path|/etc/resolv.conf}}, they can be moved to a different directory and a symlink can be created that points to them from their original location.
* '''suid'''/'''nosuid''': '''nosuid''' disables the use of SUID and SGID bits in file permissions for the partition. This makes privilege escalation attacks harder but isn't recommended for {{Path|/usr}}, as some commands vital for users such as {{c|sudo}}, {{c|passwd}} and {{c|chsh}} exist here.
* '''dev'''/'''nodev''': Mounting a partition with the '''nodev''' flag disables the use of [[device file]]s on that partition. These files, in anywhere but {{Path|/dev}}, can let an attacker break out of a {{c|chroot}} and bypass other restrictions, as these device files interface with the hardware.
* '''exec'''/'''noexec''': '''noexec''' makes all files on the partition ignore their execute bits. This is great for partitions like {{Path|/tmp}}, but, on Gentoo, {{Path|/var/tmp}} is used to extract distfiles and requires executable permissions. It is recommended, from a security standpoint, to have the '''noexec''' flag set on the {{Path|/var}} partition, but on Gentoo this requires {{Path|/var/tmp}} to be on a separate partition with the '''noexec''' flag not set.
* '''user'''('''s''')/'''nouser''': '''nouser''' permits only root to mount the partition; this is the default. '''user''' allows ordinary users to mount the partition, with only the user that mounts the partition being allowed to unmount it. This implies '''noexec''', '''nosuid''' and '''nodev''' unless explicitly overridden by subsequent options. '''users''' is like '''user''' but permits anyone to unmount a partition mounted by other users.
* '''auto'''/'''noauto''': '''auto''' causes the partition to be mounted at boot. It is desired to mount {{Path|/boot}} with the '''noauto''' flag because, in the event of a power outage or system crash, {{Path|/boot} will not be mounted and thus won't be uncleanly unmounted. This keeps the kernel image safe, along with other recovery tools such as a statically compiled busybox.
* '''defaults''': This typically enables the following flags: '''rw''', '''suid''', '''dev''', '''exec''', '''auto''', '''nouser''', '''async'''.

External resources:
* Arch Linux has a fairly in-depth overview of fstab at their wiki: [https://wiki.archlinux.org/index.php/Fstab fstab - ArchWiki]

== Chroot ==

What is {{c|chroot}} exactly? <br />
{{c|chroot}} comes as both a shell utility and a system call. What {{c|chroot}} does is quite simple: it changes the way programs see the root file system. For example, running this command:<br />
{{RootCmd|chroot /mnt/foo/}}
will make {{Path|/mnt/foo}} the new {{Path|/}} within the shell process that ran the {{c|chroot}} command. Essentially {{c|chroot}} is a primitive sandbox that is quick and easy to set up.<br /><br />
Why would anyone want to do this to the file system? <br />
Traditionally, as a security measure, daemons have been run within {{c|chroot}}s so that, if they are compromised, no damage can be done to the outside of this {{c|chroot}}. Nowadays, people use things like Linux kernel cgroups or docker containers that provide more complete sandboxing.
Nevertheless, {{c|chroot}} is quick, easy to set up, and often has configure script support in some more popular daemons such as [[BIND]] and [[Apache]]. We can easily use {{c|chroot}} to provide a safe build environment. {{c|chroot}}ing into an extracted Stage3 tarball offers the user an easy way to set up, strip down, and rebuild the environment to build and test new technologies without risking the destruction of their current workstation.

== File System Check ==
''The second letter was originally different.'' -Dennis Ritchie on {{c|fsck}}<br />
<br />
{{c|fsck}} is a utility that can be run on a partition to check it for errors and automatically fix them. With modern journaled file systems, {{c|fsck}} is not only much quicker but typically has a higher success rate when recovering from corruption. There are quite a few options one could pass to the {{c|fsck}} command, including some gotchas, so reading over the [[man page]] is highly recommended. A basic {{c|fsck}} command might look like this:<br />
{{RootCmd|fsck -y /dev/sda8}}
This will run a consistency check on the 8th partition of the first SATA/SCSI disk and automatically repair any issues, if the file system supports that option.<br />
Some important things to remember when using {{c|fsck}}:
* '''Never''' run {{c|fsck}} on a mounted partition
* {{Path|lost+found}} is where orphaned files go
* rebooting after {{c|fsck}}ing is usually healthy

Filesystems are automatically checked on boot in most setups. The 5th column in an fstab entry contains 2 numbers; the second number, '''fs passno''' according to '''fstab(5)''', has the order in which file systems should be checked during init. It is recommended to have the root partition as 1 and the rest of the partitions as 2. Setting this number to 0 disables filesystem checks on this partition. Virtual file systems and the swap partition can be left un-{{c|fsck}}ed.

== RAID ==

RAID technologies are pretty straightforward, take a few hard drives and string them together. RAIDs are defined by their ''level''. For example RAID 0 is a system where two or more disks are combined so that there is additional storage and a disk I/O performance bonus. This documentation will discuss RAID level 5 and RAID level 6 which both offer some security.

=== RAID controller ===

What ties a RAID system all together is known as a RAID controller. RAID controllers can exist in software or hardware. The primary difference is that hardware RAID controllers off load processing to the RAID controller itself rather then on the central processing unit, which in some high performance environments can be beneficial. However in home systems or small businesses, often a software RAID controller is enough.
<br />
Oftentimes a hardware RAID controller will have its own special configuration method so be sure to read the documentation provided. However in the Linux world a tool called mdadm is used for software RAID setups. mdadm is preferred over the older raidtools package, but it is worth looking into if you are using an older system or have special needs.
To install mdadm on Gentoo Linux simply run:<br />
{{Emerge|mdadm}}

=== Creating a software RAID ===
Quickly before proceeding to the meat and potatoes, lets talk about the difference between RAID 5 and RAID 6. RAID 5 requires a minimum of three physical disks, and is able to withstand the loss of one of those disks, but will take a performance hit until the failed disk is replaced and the RAID is synchronized. RAID 6 requires a minimum of four physical disks and can withstand the loss of two disks, and will only see a noticeable performance hit if two drives fail at the same time. Just like RAID 5, failed drives should be replaced and the RAID should be synchronized.
<br />
When deciding between RAID 5 and RAID 6, it is important to note that RAID 6 is favored. RAID 5 has a ''write hole'', essentially under certain circumstances the RAID will fail to preserve data because a flaw in the RAID 5 algorithm. For that reason the following example will detail RAID 6.
<br />
First you need support in your kernel for RAID systems:<br />
{{KernelBox|title=.config 3.2.11-hardened|
Device Drivers --->
    [*] Multiple devices driver support (RAID and LVM) --->
        <*> RAID support
        [*]   Autodetect RAID arrays during kernel boot
        <*>   RAID-4/RAID-5/RAID-6 mode
        <*> Device mapper support
        <*>   Mirror target
        <*> Zero target
}}
Next our disks need to be partitioned, assume we have four disks: {{Path|sda}}, {{Path|sdb}}, {{Path|sdc}}, and {{Path|sdd}}. Use your favorite partitioning tool to format the drives and create empty partition tables on them. Then allocate all the space in to a single partition.
Finally we actually create the RAID:
{{RootCmd|mdadm --create /dev/md0 --level{{=}}6 --raid-devices{{=}}4 /dev/sda1 /dev/sdb1 /dev/sdc1 /dev/sdd1}}
You should now have a new [[device file]], {{Path|/dev/md0}} which can be manipulated just like any other disk [[device file]], however {{Path|md0}} represents the RAID that was just created.
<br />
The array needs to do an initial sync which will take a while to finish. This will take upwards of several hours, depending on multiple factors including disk size. I was able to get relatively better performance by issuing the following command:
{{RootCmd|echo 8192 > /sys/block/md0/md/stripe_cache_size}} <br />
We aren't quite done yet. The mdadm tool uses a configuration file located at {{Path|/etc/mdadm.conf}} and while this is an optional step, editing this configuration file is a recommended step.
Instead of manually filling out this file, lets be lazy and run a couple commands instead:
{{RootCmd|echo "DEVICE /dev/sda1 /dev/sdb1 /dev/sdc1 /dev/sdd1 > /etc/mdadm.conf
|mdadm --detail --scan >> /etc/mdadm.conf}}
This configuration file serves two purposes, first it helps to document the RAID which is very important when it comes time to replace a disk. And second it helps the kernel activate the RAID during boot instead of a user doing it manually.
You are also encouraged to explore the monitor feature of mdadm, this sends mail warnings to administrators as issues with the RAID are encountered. Along with the monitor feature, a MAILADDR variable can be specified in {{Path|/etc/mdadm.conf}} to give mdadm a mail address to send warnings to.

=== Maintaining a software RAID===
There are a few commands and kernel data structures with which administrators dealing with a software RAID should be familiar.<br />
To get details about the RAID run:
{{RootCmd|cat /proc/mdstat}}
Here you will also see the progress of a RAID recovery or sync.<br />
Occasionally, you will need to do a check for bad blocks on the RAID, reallocate the data stored on them, and then sync the RAID. To do this run:
{{RootCmd|echo check >> /sys/block/md0/md/sync_action}}
To cleanly halt a RAID sync:
{{RootCmd|echo idle >> /sys/block/md0/md/sync_action}}
For troubleshooting and configuration purposes, there is an option to simulate a disk failure:
{{RootCmd|mdadm /dev/md0 -f /dev/sda1}}

==== Replacing failed disks ====
In our simulation, the disk at {{Path|/dev/sda1}} failed. To fix it, all we have to do is remove it from the RAID logically and readd it to the RAID. When real hardware fails in reality the process is similar, except the additional step of replacing the failed hardware.
<br />
First logically remove the drive from the RAID:
{{RootCmd|mdadm /dev/md0 -r /dev/sda1}}
At this point, in a real failure situation we would need to swap the failed disk. Depending on the hardware configuration we might have to power the system down all the way to accomplish this.<br />
{{Note|If you are following this example, you should have created disks with a single partition on them. When a disk fails and this method was used, simply repeating the formatting process on any disk will allow it to be added to the RAID without issue. If RAW disks were used instead of partitions, then a replacement disk must be exactly the same model as the other disks in the RAID.}}
To add a disk into the RAID as a replacement run this:
{{RootCmd|mdadm /dev/md0 -a /dev/sda1}}
Once a new disk is added, the RAID should automatically begin rebuilding itself.

== Quotas ==
Quotas are an important tool for administrators of multi-user systems. They allow you to prevent a group, user, or process (through group and user restrictions) from filling up disk space. This is particularly useful on for example a server that hosts a network share.
Gentoo documentation already covers this topic in depth in their
[[Security_Handbook/User_and_group_limitations|user and group limitations]] guide.

== Encryption ==
Under construction

== Permissions ==
Under construction

=== The Traditional Unix Way ===
In Unix, everything is a file.  As such, permissions revolve around a series of file attributes.  In a nutshell, these attributes relate to a read-bit, write-bit, executable-bit, setuid-bit, setgid-bit, sticky-bit, and information about owner, group, and world.

Example output of the ls command:

{{Cmd|ls -la /etc/rsyncd.conf|output=<pre>
-rw-r--r-- 1 root root 405 Apr  1 14:49 /etc/rsyncd.conf
</pre>}}

The very first column shows various information about the file in question, including the permissions set on it: the first dash indicates this is a file, not a directory (which would be marked by a ''d'').  An ''s'' would mean it's a socket file, and an ''l'' would make it a link.  The next three spaces show whether the read-bit (r), write-bit (w), or executable-bit (x) is set for the owner of the file.  The next three denote the same permission bits, but for the group instead of the user.  The third group of three bits denote permissions for the world, or everyone else on the system.  This is the basic Unix permissions model.

In the third column, the user 'root' can be seen as the owner of the file, while the fourth column shows the group, also named 'root' in the example.

Looking into permissions deeper, the 'setuid' and 'setgid' bits are somewhat less commonly used, especially by the common user, also being considerably more dangerous if used incorrectly.  If used correctly, setuid and setgid bits can make system management much easier by making permissions more flexible.  Essentially, the setuid (set user id) bit, when activated, will allow the file to be executed with the permissions of its owner by anyone.  Likewise, setgid (set group id) will allow any user to execute a file with the permissions of its group.

One way of making use of these, is for administrators to give users access to particular programs that would otherwise require the root password.  With the ls command, the ''x'' denoting user executable permission will be replaced by an ''s'' if the setuid-bit is set.  This means that in the group permission section, an ''s'' will replace the ''x'' if the setgid-bit is set.

The sticky-bit can be confusing: while traditionally, it had a very clear use, it has evolved over time and different Unix environments have different uses for it.  On Linux, the sticky bit can be set on directories, and as a consequence, any files under those directories can be deleted (or unlinked) only by the owner.  If the sticky-bit is set, a ''t'' will be displayed at the far right of the user-group-world permissions listing in the ls output.

==== Managing permission bits, bit wrangling ====
Being able to wrangle all these permissions bits is very important for the system administrator(s).  The tools of the trade are; chmod, chown, chgrp, and umask.

Further still, understanding the hex values that activate and deactivate various bits is just as important:

* 0 - no permissions are set
* 1 - execute only
* 2 - write only
* 3 - write and execute
* 4 - read only
* 5 - read and execute
* 6 - read and write
* 7 - read, write, and execute

The setuid, setgid, and sticky bits are separated from the other permissions bits so their values can be repeated:

* 0 - clears any previously set bit in this category
* 1 - stickybit
* 2 - setgid
* 4 - setuid

One of the most useful tools for changing permissions is [http://linux.die.net/man/1/chmod chmod], which simply modifies the state of the permission bits on a file or directory.  For example, to set a file as writeable by the owner, but only readable by everyone else, one would use the following command:

{{Cmd| chmod 644 /path/to/file}}

To add the setuid bit to that file, a fourth column is used.  This is the column where setgid, setuid, and stickybit are specified:

{{Cmd| chmod 4644 /path/to/file}}

Another useful tool is [http://linux.die.net/man/1/chown chown], which changes ownership of files and directories.  Its basic usage is fairly straightforward:

{{Cmd| chown user:group /path/to/file}}

Yet another useful tool, [http://linux.die.net/man/1/chgrp chgrp], might not be that often used on workstations, but is more useful for servers and mainframes.  It allows one to to change only the group ownership of files and directories, while leaving the user ownership intact.

This might be useful for a shared directory:

{{Cmd| chgrp group /path/to/file}}

The umask shows the current default file creation bit mask, and allows for a different mask to be set so that all new files created in the current working directory will have those permissions bits activated by default.  Because it is a mask, the way the permissions are represented is different from chmod:

* 0 - read, write, and execute
* 1 - read and write
* 2 - read and execute
* 3 - read only
* 4 - write and execute
* 5 - write only
* 6 - execute only
* 7 - no permissions are set

Example of setting a directory to have full permissions for the owner, but 'read only' for everyone else:

{{Cmd| cd /my/directory}}
{{Cmd| umask 033}}

=== Access Control Lists ===

== Backups ==
Under construction, lightly discuss, link to existing Gentoo wikis

[[Category:Filesystems]]
[[Category:Security]]
