<languages />


{{Metadata|abstract=이 문서는 사용자를 GCC 업그레이드 과정으로 안내합니다.}}

이 문서는 사용자를 GCC 업그레이드 과정으로 안내합니다.

== 빠른 시작 ==

== 도입부 ==

GCC "업그레이드"에 대한 내용입니다. GCC를 다운그레이드 하면 원치 않는 부작용이 생길 수 있습니다. 일반적으로 보고된 문제에 대한 문제 해결 섹션을 참고하십시오. 

다음 섹션에서는 GCC 업그레이드(그리고 이게 얼마나 쉬운가!)에 대한 간단한 핵심 내용을 전달하겠습니다. GCC 업그레이드 전에 장황한 핑계(?)를 읽어보려 한다면, [[#.EC.9E.90.EC.84.B8.ED.95.9C_.EB.82.B4.EC.9A.A9.EC.9D.98_GCC_.EC.97.85.EA.B7.B8.EB.A0.88.EC.9D.B4.EB.93.9C|자세한 내용의 GCC 업그레이드]]편으로 계속 진행하십시오.

=== 간단한 버전 ===

GCC를 업그레이드 한다면 컴파일러 버전을 바꾸고 libtool을 다시 빌드하는것 이외에는 필요한 일이 없습니다: 

{{RootCmd|emerge -u sys-devel/gcc
|gcc-config -l|output=<pre>
[1] i686-pc-linux-gnu-4.4.5 *
[2] i686-pc-linux-gnu-4.5.3
</pre>}}

{{RootCmd|gcc-config 2
|env-update && source /etc/profile
|emerge --oneshot libtool}}

If you upgrade GCC from a version earlier than 3.4.0 (for the 3.x series) or 4.1, you will need to run <tt>revdep-rebuild</tt> as well: 

{{RootCmd|revdep-rebuild --library libstdc++.so.5}}

현재 버전을 확인하고 이전 버전을 삭제하십시오
{{RootCmd|gcc --version |emerge -C &#61;sys-devel/gcc-4.4.5}}

다 됐습니다. 컴파일러 자아알~ 쓰세요! 

== GCC upgrading explained ==

== 도입부 ==

GCC upgrading has always been mystified, with suggestions ranging from "You do not need to do anything" up to "You will need to rebuild your entire system twice". Most of this FUD comes from the confusion surrounding ABI incompatibility. But first a quick pointer towards <tt>libtool</tt>.

=== libtool과 fix_libtool_files.sh ===

젠투에서 예전에 설치하던 GCC는 <code>fix_libtool_files.sh</code> 명령을 실행해야 했습니다. 얼마전에 이 명령의 실행을 패키지 배포 자신에 넣어(eclass 툴체인을 통해), 더이상 사용자가 이 명령을 불러올 필요가 없습니다. 

The reason we need to rebuild libtool after the upgrade of <tt>gcc</tt> versions is because of its main purpose: ''libtool'' is a toolset that aggregates platform-specific code in a generic interface, allowing applications to build against shared libraries without needing to deal with the platform specific aspects of shared libraries. To fulfill its function properly, the <tt>libtool</tt> script uses various library locations that have hard-coded <tt>gcc</tt> version information in them.

=== ABI changes ===

An ABI, or [https://en.wikipedia.org/wiki/Application_binary_interface ''Application Binary Interface''], is a set of conventions used by all tools that deal with binary representation of programs, including compilers, assemblers, linkers and language runtime support (source: [http://gcc.gnu.org/onlinedocs/gcc/Compatibility.html GCC Binary Compatibility]). When the ABI used for binary applications and libraries is changed, you will risk getting linker errors or malfunctioning programs unless you rebuild all libraries that use C++ code. 

Yes, C++, since most incompatibilities occur within the C++ ABI. If you are upgrading to GCC 4.1, or GCC 5.1, you would probably encounter ABI issues. This is also why we use the <tt>revdep-rebuild</tt> command against the {{Path|libstdc++.so.5}} (from GCC 3 to GCC 4.1), or {{Path|libstdc++.so.6}} (from GCC 4 to GCC 5.1).

{{RootCmd|revdep-rebuild --library "libstdc\+\+\.so\.6"}}

So why is this only needed up to GCC 3.4.0/4.1/5.1? That's because from that version onward, GCC uses a forward compatible ABI, which removes the need for rebuilding applications and libraries. Of course, guarantees can never be given indefinitely, but when an incompatibility occurs again, we'll definitely document it here. In that case, the version of the {{Path|libstdc++.so}} library will probably be increased.

=== Rebuilding everything ===

어떤 사람들은 새 GCC 버전이 동작하게 하려면 시스템의 모든 단일 꾸러미를 다시 빌드해야 한다고 주장합니다. 물론, 딱히 문제가 되는건 아니고, 어쨌듵 빌드 및 설치 과정에서 GCC를 사용하지 않는 프로그램이 많이 있기 때문에, 이런 바뀐 상황에 영향을 주진 않습니다. 

그러나 이러한 주장은 확실히 잘못됐습니다: 새 GCC 버전은 일부 프로그램의 동작을 더 좋게 하는 프로세서 명령 셋을 종종 더 많이 지원합니다. 이런 개선사항이 잉여스러운 것으로 기대되지만, 어떤 경우에는(특히 CPU를 중점적으로 다루는 프로그램) 주목할만한 성능 향상을 보일 때도 있습니다. 

There are also known cases where packages need to be built with the same compiler. Although these packages are usually bumped by Gentoo simultaneously (so that they are always built with the same GCC version) cherry-picking re-installs on these packages might prove to be troublesome. The various {{Path|qt-*}} packages are a nice example on this matter. 

== 문제 해결 ==

=== libstdc++.so.6: `GLIBCXX_3.4.15' 버전을 찾을 수 없음 ===

업데이트 하는 동안 다음과 같은 오류를 만날 수 있습니다: 

{{CodeBox|title=GLIBCXX_x.y.z not found|1=
cmake_bootstrap_28021_test: /usr/lib/gcc/i486-pc-linux-gnu/4.1.2/libstdc++.so.6:
version `GLIBCXX_3.4.11' not found 
}}

이는 빌드한 의존 라이브러리보다 "오래된" GCC 버전으로 패키지를 빌드하려 함을 의미합니다. 차기 호환성이 있는 C++ ABI를 호출했음을 기억하십니까? 맞는 말이긴 한데, 프로그램을 빌드하고 라이브러리에 연결(이들 라이브러리를 빌드할때 사용한 GCC 버전과 비교했을 때)할 때는 "더 높은" GCC버전에 대해서만 동작이 보장됩니다.

다음 배시 스크립트를 실행하여 libstdc++에 의존하는 모든 꾸러미를 빌드할 수 있습니다.

{{CodeBox|title=Script to rebuild libstdc++ dependent packages|lang=bash|1=
#!/bin/bash
 
IFS=: read -ra pathComponents <<<"$PATH"
while IFS= read -rd '' x; do
    ldd -r -- "$x" {{!}} grep -q libstdc++ && bins+=("$x")
done < <(find "${pathComponents[@]}" -type f -executable -print0)
 
typeset -A pkgs
while read -r x; do
    : ${x:+"${pkgs[=${x}]=}"}
done < <(equery -q b "${bins[@]}")
emerge -av1 "${!pkgs[@]}"
}}

=== 리빌드 해야 한다고 알려진 꾸러미는 무엇인지요? ===

다음 테이블에서 ''설치했을 경우'' 꾸러미 이름과 왜 리빌드해야 하는지를 보여줍니다. 

{| class="table" style="text-align: left;" 
|- 
! Package
! Rebuild needed because ...
|- 
| {{Package|sys-devel/libtool}}
| libtool application has hardcoded paths towards GCC internal libraries
|-
|}

== See also ==

*  [https://wiki.gentoo.org/wiki/Upgrade_GCC_up_to_4.1 GCC Upgrading up to 4.1], the previous version of this document


[[Category:Core system]]
