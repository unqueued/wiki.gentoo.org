<languages />

== El directorio /dev ==

<onlyinclude>
Cuando los usuarios de Linux hablan sobre el hardware de sus sistemas con gente que puede llegar a pensar que Linux es algún tipo de virus o marca de café, el uso de términos como "barra dev barra algo" provocará, sin dudas, miradas raras. Pero para el usuario afortunado (y esto incluye al lector de este artículo) el usar {{Path|/dev/sda1}} es solo una forma rápida de referenciar a la primera partición del disco primer disco SATA. Eso es muy fácil ¿no? 

La mayoría de los usuarios de Linux saben lo que es un [[device file|archivo de dispositivo]]. Algunos incluso saben porqué los archivos de dispositivo tienen asociados números especiales. Eche un vistazo a la lista de dispositivos cuando se lanza {{c|ls -l}} en el directorio {{Path|/dev}}. Lo que asumen los usuarios es que el primer disco SATA se referencia como {{Path|/dev/sda}}. Sin embargo algunos usuarios puede que no lo vean de esta forma. 

Piense en los dispositivos que se enchufan en caliente como los USB, IEEE 1394, tarjetas PCI que se cambian en caliente, etc. ¿Cuál es el primer dispositivo? ¿Y por cuánto tiempo? ¿Cómo se llamarán los demás dispositivos cuando el primero desaparezca? ¿Cómo afectará ésto a las transacciones en curso? ¿No sería divertido que un trabajo de impresión se cambiase de repente desde su flamante impresora láser nueva a una moribunda impresora de matriz solo porque la madre de alguien decidió desenchufar la impresora láser que era la primera impresora? 

Introducir {{c|udev}}. Los objetivos de este gestor de dispositivos son:

* Corre en espacio de usuario
* Crea y borra [[device file|archivos de dispositivo]] dinámicamente
* Ofrece un nombrado consistente
* Ofrece un interfaz de aplicación (API) en el espacio de usuario

Every time a change happens within the device structure, the kernel emits a ''uevent'' which gets picked up by {{c|udev}}. {{c|udev}} then follows the rules as declared in the {{Path|/etc/udev/rules.d}}, {{Path|/run/udev/rules.d}} and {{Path|/lib/udev/rules.d}} directories. Based on the information contained within the uevent, it finds the rule or rules it needs to trigger and performs the required actions. These actions can be creating or deleting device files, but can also trigger the loading of particular firmware files into kernel memory.</onlyinclude>
