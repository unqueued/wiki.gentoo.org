<languages/>
{{InfoBox stack
|{{InfoBox github|rhinstaller/efibootmgr|header=true}}
}}

{{Metadata|abstract=efibootmgr 프로그램은 시스템의 UEFI 펌웨어와 함께 동작하며, 리눅스(또는 다른 운영체제)를 부팅할 수 있게 하는 부팅 항목을 만들고 관리하려 EFI 설정을 다루는 잘 알려진 도구입니다.}}

The {{c|efibootmgr}} application interacts with the UEFI firmware on the system. It is a popular tool for manipulating the EFI settings in order to create and manage boot entries capable of booting Linux (or any other EFI operating system).

The {{Package|sys-boot/efibootmgr}} application is '''not''' a bootloader. It is a tool that interacts with the EFI firmware of the system, which itself is acting as a bootloader. Using {{c|efibootmgr}} boot entries can be created, reshuffled, edited, and removed.

== 설치 ==

=== Kernel ===

In order to boot directly from UEFI, the kernel needs to have <var>CONFIG_EFI</var>, <var>CONFIG_EFI_STUB</var>, and <var>CONFIG_EFI_VARS</var> support enabled:

{{KernelBox|title=Enable EFI stub support|1=
Processor type and features  --->
    [*] EFI runtime service support 
    [*]   EFI stub support
Firmware Drivers  --->
   EFI (Extensible Firmware Interface) Support  --->
       <*> EFI Variable Support via sysfs
}}

=== Emerge ===

{{Package|sys-boot/efibootmgr}} 꾸러미는 어떤 USE 플래그도 필요 없습니다. 단지 설치하기만 하면 됩니다:

{{Emerge|sys-boot/efibootmgr}}

== Configuration ==

=== EFI 변수 ===

In order to successfully use {{c|efibootmgr}} the EFI variables filesystem must be accessible. This requires that the system has been booted in EFI mode (and not through the firmware's MBR mode) as otherwise the EFI variables themselves cannot be accessed. If the system is in MBR mode, reboot and do what is necessary in order to tell the system firmware to boot in EFI mode. Usually this involved either changing an option in the firmware's settings or selecting an EFI boot entry in the system's boot menu.

When the system is in EFI mode, run the following command to check for the existence of efivarfs:

{{RootCmd|mount {{!}} grep efivars|output=<pre>
efivarfs on /sys/firmware/efi/efivars type efivarfs (rw,nosuid,nodev,noexec,relatime)
</pre>}}

If it is not mounted (it should be mounted through the {{Path|sysfs}} init script), it is possible to manually mount it using the following command:

{{RootCmd|mount -t efivars efivars /sys/firmware/efi/efivars}}

=== Managing EFI boot entries ===

==== Listing boot entries ====

To list the current boot entries by using the <code>--verbose (-v)</code> option:

{{RootCmd|efibootmgr -v|output=<pre>
BootCurrent: 0002
Timeout: 3 seconds
BootOrder: 0003,0003,0002,0000,0004
Boot0000* CD/DVD Drive  BIOS(3,0,00)
Boot0001* Hard Drive    BIOS(2,0,00)
Boot0002* Gentoo        HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d)File(\EFI\boot\bootx64.efi)
Boot0003* Hard Drive    BIOS(2,0,00)P0: ST1500DM003-9YN16G
</pre>}}

==== Creating a boot entry ====

To create an EFI boot entry, a couple of arguments are passed to {{c|efibootmgr}}:

* <code>--create (-c)</code> 로 새 항목을 만듭니다.
* <code>--part (-p)</code> 다음에 EFI 시스템 파티션을 제공할 파티션 번호를 붙입니다
* <code>--disk (-d)</code> 다음에 EFI 시스템 파티션을 제공할 디스크 장치를 언급합니다
* <code>--label (-L)</code> 다음에 부팅 항목에서 사용할 레이블을 붙입니다
* <code>--loader (-l)</code> 다음에 부팅할 EFI 이미지 경로를 붙입니다

{{Important|부팅할 EFI 이미지 경로 구분시 {{Key|/}}(슬래시)가 아닌 {{Key|\}}(역슬래시) 를 사용''해야''합니다.}}

예를 들자면:

{{RootCmd|efibootmgr -c -d /dev/sda -p 2 -L "Gentoo" -l "\efi\boot\bootx64.efi"}}

==== Deleting a boot entry ====

항목을 삭제하기 전에 항목의 ID를 우선 확인하십시오.

To delete the Gentoo entry as shown above (which has ''Boot0002'' as the identifier), ask {{c|efibootmgr}} to delete the entry with id 2, passing the arguments <code>--bootnum (-b)</code> with the identifier, and <code>--delete-bootnum (-B)</code> to delete the entry:

{{RootCmd|efibootmgr -b 2 -B}}

== Removal ==

=== Unmerge ===

{{Unmerge|sys-boot/efibootmgr}}

== 추가 참조 ==

* [[EFI_stub_kernel|EFI stub kernel]] explains how to configure the Linux kernel to be able to be booted from EFI directly
* [[Handbook:AMD64/Installation/Bootloader#Alternative:_Using_efibootmgr|Alternative: Using efibootmgr]] in the Gentoo Handbook
