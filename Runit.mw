{{lowercase title}}
{{InfoBox stack
|{{InfoBox homepage|http://smarden.org/runit/|header=true}}
|{{InfoBox wikipedia}}
|{{InfoBox package|sys-process/runit}}
|{{InfoBox ohloh}}
}}

Runit is [[Article description::a [[daemontools|daemontools-inspired]] process supervision suite that also provides a program suitable for running as process 1]]. It can be used as alternative to [https://packages.gentoo.org/packages/sys-apps/sysvinit sysvinit] or [[systemd]], either by itself or in conjunction with [[OpenRC]]. It can also be used as a helper for supervising OpenRC services.

== Installation ==

=== USE flags ===

{{USEflag|package=sys-process/runit}}

=== Emerge ===

{{Emerge|sys-process/runit}}

{{Note|<code>>{{=}}sys-process/runit-2.1.2</code> is currently on the testing branch. The above command will install runit version 2.1.1 for systems on the stable branch; users who want a more recent version will need to add the package to {{Path|/etc/portage/package.accept_keywords}} (if using Portage). While it is generally not advised to mix packages of stable and testing branches, this package only depends on the libc, so in this case it should be safe}}

== Configuration ==

=== Environment variables ===

* <var>SVDIR</var> - Directory {{C|sv}} will search for the services specified as arguments.
* <var>SVWAIT</var> - Time {{C|sv}} will wait for a service to reach its desired state before timing out or killing it with a <code>SIGKILL</code> signal.

=== Files ===

* {{Path|/service}} - Directory {{C|sv}} will search for the services specified as arguments if <var>SVDIR</var> is empty of unset.
* {{Path|/etc/runit/1}} - File {{C|runit}} will execute when the machine boots.
* {{Path|/etc/runit/2}} - File {{C|runit}} will execute and supervise when {{Path|/etc/runit/1}} exits.
* {{Path|/etc/runit/3}} - File {{C|runit}} will execute when the machine shuts down.
* {{Path|/etc/runit/ctrlaltdel}} - File {{C|runit}} will execute when receiving a <code>SIGINT</code> signal.
* {{Path|/etc/runit/stopit}} - Used by {{C|runit}} to decide whether it should initiate machine shutdown when receiving a <code>SIGCONT</code> signal or not.
* {{Path|/etc/runit/reboot}} - Used by {{C|runit}} to decide whether it should halt or reboot the machine.
* {{Path|/etc/runit/runsvdir/current}} - Symbolic link set by {{C|runsvchdir}} to {{C|runsvdir}}'s current scan directory.
* {{Path|/etc/runit/runsvdir/previous}} - Symbolic link set by {{C|runsvchdir}} to {{C|runsvdir}}'s previous scan directory.
* {{Path|/etc/runit/runsvdir/default}} - {{C|runsvdir}}'s initial scan directory when using <code><sys-process/runit-2.1.2</code>.
* {{Path|/etc/runit/runsvdir/all}} - Service directory repository when using <code><sys-process/runit-2.1.2</code>.
* {{Path|/etc/service}} - {{C|runsvdir}}'s scan directory when using <code>>=sys-process/runit-2.1.2</code>.
* {{Path|/etc/sv}} - Service directory repository when using <code>>=sys-process/runit-2.1.2</code>.
* {{Path|/run/openrc/sv}} - {{C|runsvdir}}'s scan directory when using OpenRC's [[#runitintegration|runit integration feature]].
* {{Path|/var/service}} - Symbolic link to {{C|runsvdir}}'s scan directory when using <code><sys-process/runit-2.1.2</code>.

=== Service ===

==== OpenRC ====

See [[#openrclaunch|here]].

== Usage ==

=== Process supervision ===

For more in-depth information about the process supervision aspects of runit, see [[daemontools-encore#Usage|daemontools-encore]]. A summary follows.

{| style="border:solid medium"
! style="border:solid thin;text-align:center;" | runit program !! style="border-bottom:solid thin" | daemontools program with similar functionality
|-
| <code>runsv</code> || style="border-left:solid thin" | <code>supervise</code>
|-
| <code>runsvdir</code> || style="border-left:solid thin" | <code>svscan</code> plus <code>readproctitle</code> functionality
|-
| <code>svlogd</code> || style="border-left:solid thin" | <code>multilog</code>
|-
| <code>sv down</code> || style="border-left:solid thin" | <code>svc -d</code>
|-
| <code>sv up</code> || style="border-left:solid thin" | <code>svc -u</code>
|-
| <code>sv once</code> || style="border-left:solid thin" | <code>svc -o</code>
|-
| <code>sv exit</code> || style="border-left:solid thin" | <code>svc -dx</code>
|-
| <code>sv status</code> || style="border-left:solid thin" | <code>svstat</code>
|-
| <code>chpst -e</code> || style="border-left:solid thin" | <code>envdir</code>
|-
| <code>chpst -U</code> || style="border-left:solid thin" | <code>envuidgid</code>
|-
| <code>chpst -P</code> || style="border-left:solid thin" | <code>pgrphack</code>
|-
| <code>chpst -l</code> || style="border-left:solid thin" | <code>setlock -N</code> ({{C|setlock}}'s default behaviour)
|-
| <code>chpst -L</code> || style="border-left:solid thin" | <code>setlock -n</code>
|-
| <code>chpst -u</code> || style="border-left:solid thin" | <code>setuidgid</code>
|-
| <code>chpst -m</code> || style="border-left:solid thin" | <code>softlimit -m</code>
|-
| <code>chpst -d</code> || style="border-left:solid thin" | <code>softlimit -d</code>
|-
| <code>chpst -o</code> || style="border-left:solid thin" | <code>softlimit -o</code>
|-
| <code>chpst -p</code> || style="border-left:solid thin" | <code>softlimit -p</code>
|-
| <code>chpst -f</code> || style="border-left:solid thin" | <code>softlimit -f</code>
|-
| <code>chpst -c</code> || style="border-left:solid thin" | <code>softlimit -c</code>
|-
| <code>chpst -r</code> || style="border-left:solid thin" | <code>softlimit -r</code>
|}


The program that implements the supervisor features in runit is {{C|runsv}}, and just like daemontools' {{C|supervise}}, it takes the (absolute or relative to the working directory) pathname of a ''service directory'' (or ''servicedir'') as an argument. A runit service directory must contain at least an executable file named {{Path|run}}, and can contain an optional, regular file named {{Path|down}}, and an optional subdirectory or symbolic link to directory named {{Path|log}}, all of which work like their daemontools counterparts. Unlike daemontools's {{C|supervise}}, if there is a {{Path|log}} subdirectory, the same {{C|runsv}} process supervises both the {{C|run}} and {{C|log/run}} processes, and holds the reading and writing ends of the pipe that connects them itself. So if a service directory '''S''' is configured with a {{Path|log}} subdirectory to set up a logger for the 'main' supervised process, the output of {{C|ps}} would show a <kbd>runsv S</kbd> process with ''two'' children. The logger is still controlled with {{C|sv}} (see later) by specifying an {{Path|S/log}} pathname.

The service directory can also contain an optional, executable file named {{Path|finish}}, that can be used to perfom cleanup actions each time the supervised process stops, possibly depending on its exit status information. {{C|runsv}} calls {{Path|finish}} with two arguments: the first one is {{Path|run}}'s exit code, or -1 if {{Path|run}} didn't exit normally, and the second one is the least significant byte of the exit status as determined by POSIX <code>waitpid()</code>. For instance, the second argument is 0 if {{Path|run}} exited normally, and the signal number if {{Path|run}} was terminated by a signal. {{C|runsv}} waits 1 second before starting {{Path|finish}} or restarting {{Path|run}}, so that it does not loop too quickly if the processes exit immediately. A supervised process will run in its {{C|runsv}} parent's session; making it a session leader requires using the {{C|chpst}} program with a <code>-P</code> option inside {{Path|run}}. If {{C|runsv}} receives a <code>SIGTERM</code> signal, it behaves as if an <kbd>sv exit</kbd> command naming the corresponding service directory had been used (see later).

Just like daemontools' {{C|supervise}}, {{C|runsv}} keeps control files in a subdirectory of the servicedir, named {{Path|supervise}}, and if it finds a simbolic link to directory with that name, {{C|runsv}} will follow it and use the linked-to directory for its control files. Unlike daemontools, {{C|runsv}} also keeps human-readable files in the {{Path|supervise}} directory, named {{Path|stat}} and {{Path|pid}}, containing the process ID and status information about the supervised process. For further information please consult the {{C|runsv}} man page.

The {{C|runsvdir}} program allows supervising a set of processes running in parallel using a ''scan directory'' (or ''scandir''), just like daemontools' {{C|svscan}}, so it will be the supervision tree's root. It also checks at least every 5 seconds the time of last modification, the inode, or the device, of the scandir, and performs a ''scan'' if any of them has changed, launching {{C|runsv}} child processes for each new servicedir it finds, or old servicedir for which it finds its {{C|runsv}} process has exited, and sending a <code>SIGTERM</code> signal to all {{C|runsv}} children for which their corresponding servicedir is no longer present. Unlike daemontools' {{C|svscan}}, {{C|runsvdir}} accepts a second argument after the scan directory's pathname, that must be at least seven characters long, and works like daemontools {{C|readproctitle}}'s last argument: it sets the number of characters of an automatically rotated log that {{C|runsvdir}} keeps in memory, and can be seen in the output of the {{C|ps}} utility. The first 5 characters will remain as specified in the argument, the rest will shift to the left as new messages are sent to {{C|runsvdir}}'s standard error. Unlike {{C|readproctitle}}, {{C|runsvdir}} also writes a dot to the log every 15 minutes so that old messages expire. If a <code>-P</code> option is passed as an argument, {{C|runsvdir}} makes its {{C|runsv}} children leaders of new sessions using the POSIX <code>setsid()</code> call. If {{C|runsvdir}} receives a <code>SIGHUP</code> signal, it sends a <code>SIGTERM</code> signal to each of its {{C|runsv}} children before exiting, making them exit too. For further information please consult the {{C|runsvdir}} man page.

{{C|svlogd}} is the logger program provided by the runit package. It supports automatically rotated ''logging directories'' (or ''logdirs'') in the same way daemontool's {{C|multilog}} program does, but its user interface is quite different. Logging directory pathnames are supplied as arguments and don't need to start with a dot ('.') or slash ('/'). To prepend a timestamp in [https://cr.yp.to/libtai/tai64.html external TAI64N format] to logged lines, {{C|svlogd}} must be invoked with a <code>-t</code> option. A <code>-tt</code> option prepends a UTC timestamp of the form ''YYYY-MM-DD_HH:MM:SS.xxxxx'', and a <code>-ttt</code> option prepends a UTC timestamp of the form ''YYYY-MM-DDTHH:MM:SS.xxxxx''. Other actions to be performed by {{C|svlogd}} on logged lines can be specified in a file inside the logging directory, named {{Path|config}}. Empty lines in this file or lines that start with '#' are ignored, every other line specifies a single action. Actions are carried out sequentially in line order. Actions starting with '''s''', '''n''', '''!''', '''+''' and '''-''' behave like their daemontools' {{C|multilog}} counterparts. Patterns in '''+''' and '''-''' actions have the same syntax as those from Bernstein daemontools' {{C|multilog}}, except that {{C|svlogd}} also accepts a plus sign ('+') as a special character that matches the next character in the pattern one or more times, and that prepended timestamps are not considered for matching against the patterns. {{C|svlogd}} can be forced to perform a rotation if it receives a <code>SIGALRM</code> signal, and rereads the {{Path|config}} files in the logdirs (after closing and reopening all logs) if it receives a <code>SIGHUP</code> signal. For the full description of {{C|svlogd}}'s functionality please consult the respective man page.

{{C|chpst}} is a [[daemontools-encore#changingstate|chain loading]] program that can be used to modify a supervised process' execution state. It accepts a set of options that specify what to do; some of them work like daemontools' {{C|envdir}}, {{C|envuidgid}}, {{C|pgrphack}}, {{C|setloc}}, {{C|setuidgid}} and {{C|softlimit}}, and others are runit-specific. For example, <kbd>chpst -n</kbd> increments or decrements the nice value of the process (using POSIX <code>nice()</code>), <kbd>chpst -/</kbd> changes the root directory before executing the next program in the chain (using Linux <code>chroot()</code> on Gentoo), and <kbd>chpst -b newname</kbd> executes the next 
program in the chain as if it was invoked with the name ''newname'' (i.e. performs <code>argv[0]</code> substitution). This is useful for programs that have different behaviours depending on the name they are invoked with. If {{C|chpst}} itself is invoked with the names {{C|envdir}}, {{C|envuidgid}}, {{C|pgrphack}}, {{C|setloc}}, {{C|setuidgid}} or {{C|softlimit}}, it behaves as those daemontools programs. For the full description of {{C|chpst}}'s functionality please consult its respective man page.

{{C|sv}} is runit's program for controlling supervised processes and querying status information about them. It accepts a ''subcommand'' and a set of service directory pathnames as arguments. Unless a pathname starts with a dot ('.') or slash ('/'), or ends with a slash, it is asumed to be relative to the directory specified as the value of the <var>SVDIR</var> environment variable, or to {{Path|/service}} if <var>SVDIR</var> is empty or unset. The subcommand tells {{C|sv}} what to do. The '''up''', '''down''', '''once''' and '''exit''' subcommands behave like daemontools' <kbd>svc -u</kbd> <kbd>svc -d</kbd> <kbd>svc -o</kbd> and <kbd>svc -dx</kbd> commands, respectively. The '''status''' subcommand is similar to daemontools' {{C|svstat}}, it displays whether the supervised process is running ('run') or not ('down'), or if its {{Path|finish}} file is currently running ('finish'), whether it is transitioning to the desired state or already there ('want up' or 'want down'), its process ID (PID) if it is up (or {{Path|finish}}'s PID if it is currently running), how long it has been in the current state, and whether its current up or down status matches the presence or absence of a {{Path|down}} file in the servicedir ('normally up' or 'normally down'). If also shows if the supervised process is paused ('paused') because of a <code>SIGSTOP</code> signal, or has been sent a <code>SIGTERM</code> signal ('got TERM') and {{C|runsv}} is waiting for its effect. Other {{C|sv}} subcommands allow reliably sending signals to the supervised process. In particular, <kbd>sv alarm</kbd> can be used to send a <code>SIGALRM</code> signal to a supervised {{C|svlogd}} process to force it to perform a rotation, and <kbd>sv hup</kbd> can be used to send it a <code>SIGHUP</code> signal to make it reread the logging directories' {{Path|config}} files. For the full description of {{C|sv}}'s functionality please consult the respective man page.

Example runit scan directory with {{Path|down}} and {{Path|finish}} files, as well as a {{Path|log}} subdirectory and a symbolic link to a {{Path|supervise}} directory elsewhere:
{{Cmd|ls -l *|
output=<pre>test-service1:
total 8
drwxr-xr-x 2 user user 4096 Sep 15 12:00 log
-rwxr-xr-x 1 user user   32 Sep 15 12:00 run
lrwxrwxrwx 1 user user   24 Sep 15 12:00 supervise -> ../../external-supervise

test-service2:
total 8
-rw-r--r-- 1 user user  0 Sep 15 12:00 down
-rwxr-xr-x 1 user user 78 Sep 15 12:00 finish
-rwxr-xr-x 1 user user 56 Sep 15 12:00 run</pre>}}

{{FileBox|lang=bash|filename=test-service1/run|
1=#!/bin/sh
exec test-daemon 2>&1}}

{{Cmd|ls -l test-service1/log|
output=<pre>total 4
-rwxr-xr-x 1 user user 42 Sep 15 12:00 run</pre>}}

{{FileBox|lang=bash|filename=test-service1/log/run|
1=#!/bin/sh
exec svlogd -tt ../../../logdir}}

Service directory {{Path|test-service1}} sets up process supervision for a hypothetical {{C|test-daemon}} program. Messages sent by the program to its standard error are collected by an also supervised {{C|svlogd}} process; a redirection of standard error to standard output (i.e. <code>2>&1</code>) is needed so that the pipe set up by {{C|runsv}} between those processes is used. A logging directory named {{Path|logdir}} and placed in the same directory as the scan directory is used. UTC timestamps are prepended to logged messages.
{{Cmd|ls -l ../logdir|
output=<pre>total 4
-rw-r--r-- 1 user user 3 Sep 15 12:00 config</pre>}}

{{FileBox|filename=../logdir/config|1=n1}}

The <code>n1</code> action in the {{Path|config}} file sets the number of old log files {{C|svlogd}} should maintain to 1.
{{FileBox|lang=bash|filename=test-service2/run|
1=#!/bin/sh
echo Starting test-service2/run
exec sleep 10}}

{{FileBox|lang=bash|filename=test-service2/finish|
1=#!/bin/sh
echo Executing test-service2/finish with arguments $@
exec sleep 10}}

Resulting supervision tree when {{C|runsvdir}} is run as a background process in an interactive shell using this scan directory, assuming it is the working directory (i.e. launched with <kbd>runsvdir . &</kbd>):
{{Cmd|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre> PID  PPID  PGRP EUSER    COMMAND
...
1524  1517  1524 user     -bash
2116  1524  2116 user      \_ runsvdir .
2117  2116  2116 user          \_ runsv test-service1
2119  2117  2116 user          |   \_ svlogd -tt ../../../logdir
2120  2117  2116 user          |   \_ test-daemon
2118  2116  2116 user          \_ runsv test-service2
...</pre>}}

{{Important|Since processes in a supervision tree are created using the POSIX <code>fork()</code> call, all of them will inherit {{C|runsvdir}}'s enviroment, which, in the context of this example, is the user's login shell environment. If {{C|runsvdir}} is launched in some other way (see later), the environment will likely be completely different. This must be taken into account when trying to debug a supervision tree with an interactive shell.}}

This shows that both the {{C|test-daemon}} and {{C|svlogd}} processes are supervised by the same {{C|runsv}} process. {{Path|supervise}} subdirectory contents:
{{Cmd|ls -l */supervise|
output=<pre>lrwxrwxrwx 1 user user 24 Sep 15 12:00 test-service1/supervise -> ../../external-supervise

test-service2/supervise:
total 8
prw------- 1 user user  0 Sep 15 12:05 control
-rw------- 1 user user  0 Sep 15 12:05 lock
prw------- 1 user user  0 Sep 15 12:05 ok
-rw-r--r-- 1 user user  0 Sep 15 12:05 pid
-rw-r--r-- 1 user user  5 Sep 15 12:05 stat
-rw-r--r-- 1 user user 20 Sep 15 12:05 status</pre>}}

{{Cmd|ls -l ../external-supervise|
output=<pre>total 12
prw------- 1 user user  0 Sep 15 12:05 control
-rw------- 1 user user  0 Sep 15 12:05 lock
prw------- 1 user user  0 Sep 15 12:05 ok
-rw-r--r-- 1 user user  5 Sep 15 12:05 pid
-rw-r--r-- 1 user user  4 Sep 15 12:05 stat
-rw-r--r-- 1 user user 20 Sep 15 12:05 status</pre>}}

{{Cmd|ls -l test-service1/log/supervise|
output=<pre>total 12
prw------- 1 user user  0 Sep 15 12:05 control
-rw------- 1 user user  0 Sep 15 12:05 lock
prw------- 1 user user  0 Sep 15 12:05 ok
-rw-r--r-- 1 user user  5 Sep 15 12:05 pid
-rw-r--r-- 1 user user  4 Sep 15 12:05 stat
-rw-r--r-- 1 user user 20 Sep 15 12:05 status</pre>}}

Contents of the log directory and current log file:
{{Cmd|ls -l ../logdir|
output=<pre>total 8
-rw-r--r-- 1 user user   3 Sep 15 12:00 config
-rw-r--r-- 1 user user 308 Sep 15 12:35 current
-rw------- 1 user user   0 Sep 15 12:05 lock</pre>}}

{{Cmd|cat ../logdir/current|
output=<pre>2018-09-15_15:34:26.40056 Logged message #1
2018-09-15_15:34:31.40295 Logged message #2
2018-09-15_15:34:36.40484 Logged message #3
2018-09-15_15:35:04.89572 Logged message #4
2018-09-15_15:35:09.89814 Logged message #5
2018-09-15_15:35:14.89977 Logged message #6
2018-09-15_15:35:19.90165 Logged message #7</pre>}}

The timestamp is in UTC, and the computer's operating system is assumed to be set to a UTC-3 timezone. Forcing {{C|svlogd}} to perform a rotation:
{{Cmd|sv alarm ./test-service1/log|ls -l ../logdir|
output=<pre>total 8
-rwxr--r-- 1 user user 308 Sep 15 12:41 @400000005b9d2888221699c4.s
-rw-r--r-- 1 user user   3 Sep 15 12:00 config
-rw-r--r-- 1 user user   0 Sep 15 12:42 current
-rw------- 1 user user   0 Sep 15 12:05 lock</pre>}}

This shows that a log file with a name containing a [https://cr.yp.to/libtai/tai64.html TAI64N timestamp] and ending in '''.s''' (meaning 'completely processed log file') was created, and that {{Path|current}} was truncated. Messages sent by {{Path|test-service2}}'s {{C|run}} process to {{C|runsvdir}}'s standard output when manually started:
{{Cmd|export SVDIR{{=}}"$(pwd)"|sv up test-service2|
output=<pre>Starting test-service2/run
Executing test-service2/finish with arguments 0 0
Starting test-service2/run
Executing test-service2/finish with arguments 0 0
Starting test-service2/run
...</pre>}}

As shown by the output of {{Path|test-service2/finish}}, the {{C|run}} process exits each time with an exit code of 0. Resulting supervision tree:
{{Cmd|ps xf -o pid,ppid,pgrp,euser,args|
output=<pre> PID  PPID  PGRP EUSER    COMMAND
...
1524  1517  1524 user     -bash
2116  1524  2116 user      \_ runsvdir .
2117  2116  2116 user          \_ runsv test-service1
2119  2117  2116 user          |   \_ svlogd -tt ../../../logdir
2120  2117  2116 user          |   \_ test-daemon
2118  2116  2116 user          \_ runsv test-service2
2146  2118  2116 user              \_ sleep 10
...</pre>}}

{{Cmd|sv status *|
output=<pre>run: test-service1: (pid 2120) 220s; run: log: (pid 2119) 220s
run: test-service2: (pid 2146) 7s, normally down</pre>}}

This shows that because {{Path|test-service1}} has a {{Path|log}} subdirectory, <kbd>sv status</kbd> shows the status of the {{C|svlogd}} process too, after {{C|test-daemon}}'s status ("run: log:"). After enough seconds have elapsed:
{{Cmd|sv status *|
output=<pre>run: test-service1: (pid 2120) 230s; run: log: (pid 2119) 230s
finish: test-service2: (pid 2150) 17s, normally down</pre>}}

This shows that {{C|runsv}} is currently executing {{Path|test-service2}}'s {{Path|finish}} file ("finish:"). Reliably sending a <code>SIGSTOP</code> signal to {{Path|test-service2}}'s {{C|run}} process:
{{Cmd|sv pause test-service2|sv status test-service2|
output=<pre>run: test-service2: (pid 2169) 17s, normally down, paused</pre>}}

This confirms that {{C|run}} is stopped ("paused"). Reliably sending a <code>SIGTERM</code> signal afterwards:
{{Cmd|sv term test-service2|sv status test-service2|
output=<pre>run: test-service2: (pid 2169) 52s, normally down, paused, got TERM</pre>}}

This confirms that {{C|run}} received a <code>SIGTERM</code> signal ("got TERM"), but it doesn't have any efect yet because the process is stopped. To resume it a <code>SIGCONT</code> signal is needed:
{{Cmd|sv cont test-service2|
output=<pre>Executing test-service2/finish with arguments -1 15
Starting test-service2/run
Executing test-service2/finish with arguments 0 0
Starting test-service2/run</pre>}}

The output of {{Path|test-service2/finish}} shows that after resuming execution, {{C|run}} was killed by the <code>SIGTERM</code> signal that was awaiting delivery (signal 15), and because the process is supervised, {{C|runsv}} first executes {{Path|test-service2/finish}}, and then reexecutes {{Path|test-service2/run}}. Messages sent by {{Path|test-service2}}'s {{C|run}} process to {{C|runsvdir}}'s standard output when manually stopped:
{{Cmd|sv down test-service2|
output=<pre>Executing test-service2/finish with arguments -1 15</pre>}}

{{Cmd|sv status *|
output=<pre>run: test-service1: (pid 2120) 506s; run: log: (pid 2119) 506s
finish: test-service2: (pid 2172) 17s, normally down, want down</pre>}}

As shown by {{Path|test-service2/finish}}, {{C|runsv}} stopped the {{C|run}} process by killing it with a <code>SIGTERM</code> signal (signal 15). The output of <kbd>sv status</kbd> shows that {{C|runsv}} is executing the {{Path|test-service2/finish}} script, and that when it exits, the service will stay down ("want down").
{{anchor|svcheck}}
==== The check file ====

The {{C|sv}} program accepts a <code>-v</code> option ('verbose') that makes it wait for the action requested by the specified subcommand to be completed, and then prints the resulting process' status, as if an <kbd>sv status</kbd> command had been used. The wait period's duration is the value of the <var>SVWAIT</var> environment variable (in seconds), or 7 seconds if <var>SVWAIT</var> is empty or unset. It can also be specified with a <code>-w</code> option passed to {{C|sv}}, which overrides the value of <var>SVWAIT</var>. If the requested action completes before the expiry of the wait period, the status line is prepended with 'ok:' followed by a space. Otherwise, the {{C|sv}} command exits with a nonzero code and the status line is prepended with 'timeout:' followed by a space.

For the <kbd>sv -v up</kbd> command, and, if the supervised process is wanted up after the action (i.e. no <kbd>sv once</kbd> command was used before), the <kbd>sv -v term</kbd> and <kbd>sv -v kill</kbd> commands, the action is considered complete if {{C|runsv}} considers the supervised process to be in 'run' state (i.e. <kbd>sv status</kbd> would print 'run:'). However, when the supervised process is executing a server program for example, it might not be ''ready'' to provide its service immediately after startup. Programs might do initialization work that could take some noticeable time before they are actually ready to serve, but it is impossible for the supervisor to know exactly how much. If there is some program-specific way to infer that it is ready, runit is able to take advantage of it by including an executable file named {{Path|check}} in the service directory. When using one of the aforementioned subcommands, after {{C|sv}} determines that the supervised process is in 'run' state (via the {{Path|supervise/status}} file), it executes the {{Path|check}} file if present, and waits for it to exit. This file is assumed to contain code that ''polls for readiness'', and must exit with a 0 code if it considers the supervised process to be ready, and with a nonzero code otherwise. Just like {{Path|run}} or {{Path|finish}}, the {{Path|check}} file can have any format the kernel knows how to execute, and is normally a shell script. If {{Path|check}} determines that the process is ready, {{C|sv}} will print an 'ok' status line and exit, otherwise it reexecutes {{Path|check}} after waiting 420 milliseconds. In other words, during the wait period {{C|sv}} will periodically poll for readiness using {{Path|check}}; if its exit code is never 0, on expiry of the wait period {{C|sv}} will print a 'timeout' status line and exit.

In addition, the <kbd>sv check</kbd> command can be used to poll for readiness (periodically during a wait period) by executing the {{Path|check}} file, without changing the supervised process' state. The <kbd>sv status</kbd> command does not use the {{Path|check}} file. For the full description of the {{C|sv}} program please consult the respective man page.

Example service directory with a {{Path|check}} file:
{{Cmd|ls -l test-service|
output=<pre>total 8
-rwxr-xr-x 1 user user 71 Sep 16 12:00 check
-rw-r--r-- 1 user user  0 Sep 16 12:00 down
-rwxr-xr-x 1 user user 27 Sep 16 12:00 run</pre>}}

{{FileBox|lang=bash|filename=test-service/run|
1=#!/bin/sh
exec test-daemon}}

{{FileBox|lang=bash|filename=test-service/check|
1=#!/bin/sh
echo Polling test-daemon 1>&2
sleep 1
exec test-daemon-check}}

This service directory sets up process supervision for a hypothetical {{C|test-daemon}} program. It is assumed that the program can be polled for readiness using another program named {{C|test-daemon-check}}. For demonstration purposes, the {{C|sleep}} utility is used so that {{Path|check}} does not exit too quickly. Using the <kbd>sv check</kbd> command after launching the supervision tree, assuming that the scan directory is the working directory:
{{Cmd|export SVDIR{{=}}"$(pwd)"|sv check test-service|
output=<pre>ok: down: test-service: 85s</pre>}}

Because of the {{Path|down}} file, {{C|runsv}} does not launch {{C|test-daemon}}, so it considers its supervised process to be in 'down' state, so <kbd>sv check</kbd> exited immediately with an 'ok' status and without executing {{Path|check}}. Starting the supervised process using {{C|sv}}'s <code>-v</code> option:
{{Cmd|sv -v up test-service|
output=<pre>Polling test-daemon
Polling test-daemon
Polling test-daemon
Polling test-daemon
Polling test-daemon
Polling test-daemon
timeout: run: test-service: (pid 1908) 8s, normally down</pre>}}

This shows that a {{C|test-daemon}} process was spawned ("run: test-service:"), but the {{C|test-daemon-check}} program determined that it was not ready. The {{Path|check}} was executed 6 times before the expiery of the default 7 seconds wait period, so {{C|sv}} finally gave up with a 'timeout' status. Polling {{C|test-daemon}} again:
{{Cmd|sv check test-service|
output=<pre>Polling test-daemon
ok: run: test-service: (pid 1908) 29s, normally down</pre>}}

Between both {{C|sv}} commands {{C|test-daemon}} became ready, so this time the (single) poll was successful, and {{C|sv}} exited immediately with an 'ok' status. Reliably sending {{C|test-daemon}} a <code>SIGTERM</code> signal using {{C|sv}}'s <code>-v</code> option and a longer wait period:
{{Cmd|sv -v -w 10 term test-service|
output=<pre>Polling test-daemon
Polling test-daemon
Polling test-daemon
Polling test-daemon
Polling test-daemon
Polling test-daemon
Polling test-daemon
Polling test-daemon
ok: run: test-service: (pid 1930) 10s, normally down</pre>}}

This shows that a {{C|test-daemon}} process was killed and then restarted (because it is supervised), but 8 polls were necessary until the {{C|test-daemon-check}} program determined that it was ready. Because the process became ready during the wait period, {{C|sv}} exited with an 'ok' status. Stopping the {{C|test-daemon}} process using {{C|sv}}'s <code>-v</code> option:
{{Cmd|sv -v down test-service|
output=<pre>ok: down: test-service: 0s</pre>}}

Making {{C|runsv}} stop and exit using {{C|sv}}'s <code>-v</code> option, assuming its supervising {{C|runsvdir}} parent process was already killed:
{{Cmd|sv -v exit test-service|
output=<pre>ok: test-service: runsv not running</pre>}}

==== The sv program's LSB-like interface ====

{{C|sv}} also accepts a set of subcommands resembling LSB init script actions <ref>Linux Standard Base Core Specification 5.0.0, Generic Part, Chapter 22, "System Initialization", [https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html 22.2, "Init Script Actions"]. Retrieved on June 4th, 2017.</ref>:

* The <kbd>sv start</kbd>, <kbd>sv stop</kbd> and <kbd>sv shutdown</kbd> commands are equivalent to <kbd>sv -v up</kbd>, <kbd>sv -v down</kbd> and <kbd>sv -v exit</kbd>, respectively.
* The <kbd>sv force-stop</kbd> and <kbd>sv force-shutdown</kbd> commands, or equivalently, <kbd>sv Down</kbd> and <kbd>sv Exit</kbd> (with capital 'D' and 'E'), behave like <kbd>sv stop</kbd> and <kbd>sv shutdown</kbd>, respectively, except that if the action requested by the specified subcommand does not complete during the wait period, the supervised process is sent a <code>SIGKILL</code> signal on its expiry, as if an <kbd>sv kill</kbd> command had been used. The status line printed by {{C|sv}} is prepended with 'kill:' followed by a space in that case.
* The <kbd>sv reload</kbd> and <kbd>sv try-restart</kbd> commands are equivalent to <kbd>sv -v hup</kbd>, <kbd>sv -v term</kbd> respectively, except that the latter also sends a <code>SIGCONT</code> signal to the supervised process after the <code>SIGTERM</code> signal, as if an <kbd>sv cont</kbd> command had been used.
* The <kbd>sv restart</kbd> command is equivalent to <kbd>sv term</kbd> followed by <kbd>sv cont</kbd> followed by <kbd>sv -v up</kbd>. Therefore, unlike <kbd>sv try-restart</kbd>, <kbd>sv restart</kbd> cancels the 'do not restart' effect of any previous <kbd>sv once</kbd> command.
* The <kbd>sv force-reload</kbd> and <kbd>sv force-restart</kbd> commands behave like <kbd>sv try-restart</kbd> and <kbd>sv restart</kbd>, respectively, except that if the action requested by the specified subcommand does not complete during the wait period, the supervised process is sent a <code>SIGKILL</code> signal on its expiry, just like what happens with <kbd>sv force-stop</kbd> and <kbd>sv force-shutdown</kbd>. The <kbd>sv Term</kbd> command (with capital 'T') is equivalent to <kbd>sv force-reload</kbd>.

As noted in section [[#svcheck|"The check file"]], the equivalences stated above imply that the <code>start</code>, <code>try-restart</code>, <code>restart</code>, <code>force-reload</code> and <code>force-restart</code> subcommands make {{C|sv}} execute the {{Path|check}} file in the named service directories, if present, to poll for readiness.

The {{C|sv}} program can be invoked with the name of a service directory (with any <code>argv[0]</code> substitution mechanism), in that case, also its exit code tries to comply with the LSB specification: it is '''2''' for usage errors and '''151''' (in the "reserved for application use" range) for fatal errors, instead of 100 in both cases, it is '''0''', '''3''' or '''4''', as appropriate, if the subcommand is <code>status</code>, and it is '''1''' on error (other than fatal errors) for other subcommands. This is useful if a symbolic link to {{C|sv}} representing a 'service name' is placed in directory {{Path|/etc/init.d}}, resembling an LSB initialization script: executing this 'initialization script' with an action argument results in actually executing {{C|sv}} with a runit service directory of that name as an argument (e.g. <kbd>/etc/init.d/foo try-restart</kbd> will result in <kbd>sv try-restart foo</kbd>).

For the full description of {{C|sv}}'s functionality please consult the respective man page.

Example service directory for a hypothetical {{C|test-daemon}} program with a setup similar to that of section [[#svcheck|"The check file"]]:
{{Cmd|ls -l test-service|
output=<pre>total 12
-rwxr-xr-x 1 user user 71 Sep 16 12:00 check
-rw-r--r-- 1 user user  0 Sep 16 12:00 down
-rwxr-xr-x 1 user user 65 Sep 16 12:00 finish
-rwxr-xr-x 1 user user 41 Sep 16 12:00 run</pre>}}

{{FileBox|lang=bash|filename=test-service/run|
1=#!/bin/sh
exec test-daemon --ignore-term}}

{{FileBox|lang=bash|filename=test-service/check|
1=#!/bin/sh
echo Polling test-daemon 1>&2
sleep 5
exec test-daemon-check}}

{{FileBox|lang=bash|filename=test-service/finish|
1=#!/bin/sh
[ "$1" != -1 ] {{!}}{{!}} echo test-daemon killed by signal $2}}

It is assumed that {{C|test-daemon}} supports an <code>--ignore-term</code> option that makes it ignore the <code>SIGTERM</code> signal. Starting the supervised process using {{C|sv}}'s LSB-like interface:
{{Cmd|export SVDIR{{=}}"$(pwd)"|sv -w 10 start test-service|
output=<pre>Polling test-daemon
Polling test-daemon
ok: run: test-service: (pid 1870) 6s, normally down</pre>}}

This shows that <kbd>sv start</kbd>, being equivalent to <kbd>sv -v up</kbd>, also uses the {{Path|check}} file. The {{C|test-daemon-check}} program was used to poll twice for readiness, and succeeded before the expiry of the 10 seconds wait period. Stopping the {{C|test-daemon}} process using {{C|sv}}'s LSB-like interface:
{{Cmd|sv stop test-service|
output=<pre>timeout: run: test-service: (pid 1870) 41s, normally down, want down, got TERM</pre>}}

This shows that <kbd>sv stop</kbd>, being equivalent to <kbd>sv -v down</kbd>, tried to stop the supervised process by sending it a <code>SIGTERM</code> signal. Because {{C|test-daemon}} ignores the signal, the stop action didn't complete before the expiry of the wait period, so {{C|sv}} gives up with a "timeout" status. The status line confirms that the wanted supervised process's state is 'down' ("wanted down"), and that a <code>SIGTERM</code> signal was sent ("got TERM"). Stopping the {{C|test-daemon}} process using {{C|sv}}'s <code>force-stop</code> subcommand:
{{Cmd|sv force-stop test-service|
output=<pre>kill: run: test-service: (pid 1870) 76s, normally down, want down, got TERM
test-daemon killed by signal 9</pre>}}

This shows that, again, the stop action didn't complete before the expiry of the wait period, but this time a <code>SIGKILL</code> signal was sent to the supervised process on expiry of the wait period. The {{Path|finish}} file is then executed by {{C|runsv}}, and its message confirms that {{C|test-daemon}} got killed by a <code>SIGKILL</code> signal (signal 9).

==== Custom process control ====

The {{C|runsv}} program allows the customization of the effect of some {{C|sv}} subcommands to some degree. This is done by providing executable files in a subdirectory of the service directory named {{Path|control}}. The executable files must have single character names that map to an {{C|sv}} subcommand, the {{C|runsv}} man page details this mapping (it corresponds to the character that is written by {{C|sv}} to {{C|runsv}}'s {{Path|supervise/control}} FIFO). The subcommands that can be customized this way are:

* The ones that send signals to the supervised process (<code>term</code>, <code>hup</code>, <code>quit</code>, etc.). In particular, if present, the control file that corresponds to customized <kbd>sv term</kbd>, {{Path|control/t}}, is also used by the <kbd>sv down</kbd> and <kbd>sv exit</kbd> commands. {{C|runsv}} executes the file, waits for it to finish, and then checks its exit code. If it is a nonzero code, {{C|runsv}} additionaly sends the corresponding signal to the supervised process. If it is 0, no signal is sent.
* The <code>up</code> and <code>once</code> subcommands. A single control file, {{Path|control/u}}, is used for both subcommands. {{C|runsv}} executes the file and waits for it to exit, before executing the {{C|run}} file. The control file is also executed after {{Path|finish}} and before reexecution of {{Path|run}} if the spuervised process unexpectedly stops running and gets restarted by {{C|runsv}}, and is ignored for the <kbd>sv once</kbd> command if {{Path|run}} or {{Path|finish}} are running. The control file's exit code is ignored.
* The <code>down</code> and <code>exit</code> subcommands. {{C|runsv}} executes the control file, {{Path|control/d}} and {{Path|control/x}}, respectively, ''after'' sending the supervised process the <code>SIGTERM</code> signal, or executing {{Path|control/t}} if appropriate, and after sending the subsequent <code>SIGCONT</code> signal, ''ignoring'' {{Path|control/c}} if present (the control file for <kbd>sv cont</kbd>), and waits for it to exit. The control file's exit code is ignored. For <kbd>sv exit</kbd>, {{C|runsv}} exits after {{Path|control/x}} exits.

Just like {{Path|run}} or {{Path|finish}}, the files in the {{Path|control}} subdirectory can have any format the kernel knows how to execute, and are normally shell scripts. In particular, {{Path|control/t}} should contain code that can stop the supervised process, and is useful if there is an alternative (and preferred) way to do so without sending a <code>SIGTERM</code> signal. For further details about customizing the the effect of {{C|sv}}, please consult {{C|runsv}}'s man page.

{{Note|Because {{C|runsv}} waits for the control file to exit, it its execution takes too long, {{C|runsv}} might become unresponsive.}}

Example service directory with a {{Path|control}} subdirectory for customized control:
{{Cmd|ls -l test-service|
output=<pre>total 16
drwxr-xr-x 2 user user 4096 Sep 16 12:00 control
drwxr-xr-x 2 user user 4096 Sep 16 12:00 env
drwxr-xr-x 2 user user 4096 Sep 16 12:00 log
-rwxr-xr-x 1 user user   64 Sep 16 12:00 run
</pre>}}

{{FileBox|lang=bash|filename=test-service/run|
1=#!/bin/sh
echo '(Re)starting test-daemon'
exec test-daemon 2>&1}}

{{Cmd|ls -l test-service/log|
output=<pre>total 4
-rwxr-xr-x 1 user user 38 Sep 16 12:00 run
</pre>}}

{{FileBox|lang=bash|filename=test-service/log/run|
1=#!/bin/sh
exec svlogd ../../../logdir}}

This service directory sets up process supervision for a hypothetical {{C|test-daemon}} program. Messages sent by the program to its standard error are collected by an also supervised {{C|svlogd}} process; a redirection of standard error to standard output (i.e. <code>2>&1</code>) is needed so that the pipe set up by {{C|runsv}} between those processes is used. A logging directory named {{Path|logdir}} and placed in the same directory as the scan directory is used.

{{Cmd|ls -l test-service/control|
output=<pre>total 16
-rwxr-xr-x 1 user user 53 Sep 16 12:00 d
-rwxr-xr-x 1 user user 95 Sep 16 12:00 h
-rwxr-xr-x 1 user user 96 Sep 16 12:00 t
-rwxr-xr-x 1 user user 51 Sep 16 12:00 u</pre>}}

{{FileBox|lang=bash|filename=test-service/control/d|
1=#!/bin/sh
echo 'control/d: Executing custom sv down'}}

{{FileBox|lang=bash|filename=test-service/control/u|
1=#!/bin/sh
echo 'control/u: Executing custom sv up'}}

This control files do nothing but print a message for logging purposes.

{{FileBox|lang=bash|filename=test-service/control/h|
1=#!/bin/sh
chpst -e env \
sh -c 'echo control/h: Executing custom sv hup...; exit $EXIT_STATUS'}}

This control file is executed when an <kbd>sv hup</kbd> command is used. It is assumed that {{C|test-daemon}} prints a message of the form 'Message #N' each time it receives a <code>SIGHUP</code> signal, where '''N''' is an increasing integer.

{{FileBox|lang=bash|filename=test-service/control/t|
1=#!/bin/sh
chpst -e env \
sh -c 'echo control/t: Executing custom sv term...; exit $EXIT_STATUS'}}

This is a deliberate misuse of the {{Path|test-service/control/t}} file, for demonstration purposes, because it doesn't actually stop {{C|test-daemon}}. Both {{Path|test-service/control/t}} and {{Path|test-service/control/h}} exit with a code that is the value of environment variable <var>EXIT_STATUS</var>. A <kbd>chpst -e</kbd> command is used each time these control files are executed, to modify the environment according to [[daemontools-encore#changingstate|environment directory]] {{Path|env}}:
{{Cmd|ls -l test-service/env|
output=<pre>total 4
-rw-r--r-- 1 user user 2 Sep 16 12:00 EXIT_STATUS</pre>}}

{{FileBox|lang=bash|filename=test-service/env/EXIT_STATUS|1=1}}

When <kbd>chpst -e</kbd> is executed, the value of <var>EXIT_STATUS</var> will be 1.

{{Cmd|ls -l ../logdir|
output=<pre>total 4
-rw-r--r-- 1 user user 26 Sep 16 12:00 config</pre>}}

{{FileBox|lang=bash|filename=../logdir/config|
1=-control/h:*
econtrol/h:*}}

The {{Path|config}} file in the logging directory deselects messages that start with 'control/h:' for logging to the {{Path|current}} file ('-' action), and selects them for logging to {{C|runsv}}'s standard error ('e' action), which in this example is the interactive shell's controlling terminal. These would be the messages printed by the {{Path|test-service/control/h}} file. Contents of the {{Path|current}} file in the logging directory when the supervision tree is launched, assuming that the scan directory is the working directory:
{{Cmd|cat ../logdir/current|
output=<pre>control/u: Executing custom sv up
(Re)starting test-daemon</pre>}}

This shows that {{Path|test-service/control/u}} was executed before {{Path|test-service/run}}. Using the <kbd>sv hup</kbd> command:
{{Cmd|export SVDIR{{=}}"$(pwd)"|for i in 1 2 3; do sv hup test-service; done|
output=<pre>control/h: Executing custom sv hup...
control/h: Executing custom sv hup...
control/h: Executing custom sv hup...</pre>}}

This shows that {{Path|test-service/control/h}} was executed.
{{Cmd|cat ../logdir/current|
output=<pre>control/u: Executing custom sv up
(Re)starting test-daemon
Message #1
Message #2
Message #3</pre>}}

This confirms that, because <var>EXIT_STATUS</var> is 1, {{Path|test-service/control/h}} exits with a nonzero code, so a <code>SIGHUP</code> signal was also sent to {{C|test-daemon}}, causing it to print messages to its standard error. Using the <kbd>sv -v term</kbd> command:
{{Cmd|sv -v term test-service|
output=<pre>ok: run: test-service: (pid 1897) 0s</pre>}}

{{Cmd|cat ../logdir/current|
output=<pre>control/u: Executing custom sv up
(Re)starting test-daemon
Message #1
Message #2
Message #3
control/t: Executing custom sv term...
control/u: Executing custom sv up
(Re)starting test-daemon</pre>}}

This shows that {{Path|test-service/control/t}} was executed, and because its exit code is 1, a <code>SIGTERM</code> signal was also sent to {{C|test-daemon}}. The signal killed the process, and because it is supervised, {{Path|test-service/run}} is reexecuted. And because there is also a {{Path|test-service/control/u}} file, it was executed as well, before {{Path|test-service/run}}. Using the <kbd>sv -v down</kbd> command:
{{Cmd|sv -v down test-service|
output=<pre>ok: down: test-service: 0s, normally up</pre>}}

The command shows an "ok" status and a "down" state, so it successfully stopped {{C|test-daemon}}.
{{Cmd|cat ../logdir/current|
output=<pre>control/u: Executing custom sv up
(Re)starting test-daemon
Message #1
Message #2
Message #3
control/t: Executing custom sv term...
control/u: Executing custom sv up
(Re)starting test-daemon
control/t: Executing custom sv term...
control/d: Executing custom sv down</pre>}}

This shows that both {{Path|test-service/control/t}} and {{Path|test-service/control/d}} were executed, in that order. Starting {{C|test-daemon}} again with a modified environment directory, assuming the logging directory has been rotated with an <kbd>sv alarm test-service/log</kbd> command:
{{Cmd|echo 0 >test-service/env/EXIT_STATUS|sv -v up test-service|
output=<pre>ok: run: test-service: (pid 1926) 0s</pre>}}

Repeating the <kbd>sv hup</kbd> commands:
{{Cmd|for i in 4 5 6; do sv hup test-service; done|
output=<pre>control/h: Executing custom sv hup...
control/h: Executing custom sv hup...
control/h: Executing custom sv hup...</pre>}}

{{Cmd|cat ../logdir/current|
output=<pre>control/u: Executing custom sv up
(Re)starting test-daemon</pre>}}

This shows that, again, {{Path|test-service/control/h}} was executed, but this time, because <var>EXIT_STATUS</var> is now 0, the script exits with a 0 code, so no <code>SIGHUP</code> signal was sent to {{C|test-daemon}}. This is confirmed by the absence of logged messages from the process. Stopping {{C|test-daemon}} with the <kbd>sv -v down</kbd> command:
{{Cmd|sv -v down test-service|
output=<pre>timeout: run: test-service: (pid 1926) 64s, want down</pre>}}

{{Cmd|sv status test-service|
output=<pre>run: test-service: (pid 1926) 70s, want down; run: log: (pid 1890) 70s</pre>}}

This shows that, because {{Path|test-service/control/t}} contains no code to stop {{C|test-daemon}}, and because its exit code is now 0, {{C|sv}} times out ("timeout") and the supervised process' state is still "run". Stopping {{C|test-daemon}} with the <kbd>sv force-stop</kbd> command:
{{Cmd|sv force-stop test-service|
output=<pre>kill: run: test-service: (pid 1926) 93s, want down</pre>}}

This shows that because {{C|test-daemon}} doesn't get stopped, {{C|sv}} sends a <code>SIGKILL</code> signal to the supervised process on expiry of the wait period, and exits with a "kill" status.

{{Cmd|cat ../logdir/current|
output=<pre>control/u: Executing custom sv up
(Re)starting test-daemon
control/t: Executing custom sv term...
control/d: Executing custom sv down
control/t: Executing custom sv term...
control/d: Executing custom sv down</pre>}}

{{Cmd|sv status test-service|
output=<pre>down: test-service: 4s, normally up; run: log: (pid 1890) 106s</pre>}}

This confirms that {{C|test-daemon}} is now in "down" state, and that, again, both {{C|sv}} commands executed {{Path|test-service/control/t}} and then {{Path|test-service/control/d}}.

=== Starting the supervision tree ===
{{anchor|openrclaunch}}
==== From OpenRC ====

As of version 0.22, [[OpenRC]] provides a service script that can launch {{C|runsvdir}} with {{C|readproctitle}}-style logging, also named {{Path|runsvdir}}. On Gentoo, the scan directory will be {{Path|/run/openrc/sv}}. This script exists to support the [[#runitintegration|OpenRC-runit integration]] feature, but can be used to just launch a runit supervision tree when the machine boots by adding it to an OpenRC runlevel using {{C|rc-update}}:
{{RootCmd|rc-update add runsvdir default}}

Or it can also be started manually:
{{RootCmd|rc-service runsvdir start}}

{{Note|The service script launches {{C|runsvdir}} using OpenRC's {{C|start-stop-daemon}} program, so it will run unsupervised. Also, its standard input and output will be redirected to {{Path|/dev/null}}. Its standard error will be redirected to the {{C|readproctitle}}-style log, though.}}

Because the service script calls {{C|runsvdir}} using absolute path {{Path|/usr/bin/runsvdir}}, a symlink to the correct path must be created if using <code>>=sys-process/runit-2.1.2</code>:
{{RootCmd|ln -s /bin/runsvdir /usr/bin/runsvdir}}

And because {{Path|/run}} is a tmpfs, and therefore volatile, servicedir symlinks must be created in the scan directory each time the machine boots, before {{C|runsvdir}} starts. The [https://www.freedesktop.org/software/systemd/man/tmpfiles.d.html tmpfiles.d] interface, which is supported by OpenRC using [https://packages.gentoo.org/packages/sys-apps/opentmpfiles package opentmpfiles], can be used for this:

{{FileBox|filename=/etc/tmpfiles.d/runsvdir.conf|1=#Type Path Mode UID GID Age Argument
d /run/openrc/sv
L /run/openrc/sv/service1 - - - - /path/to/servicedir1
L /run/openrc/sv/service2 - - - - /path/to/servicedir2
L /run/openrc/sv/service3 - - - - /path/to/servicedir3
...}}

Alternatively, OpenRC's {{C|local}} service could be used to start the supervision tree when entering OpenRC's 'default' runlevel, by placing '.start' and '.stop' files in {{Path|/etc/local.d}} (please read {{Path|/etc/local.d/README}} for more details) that perform actions similar to those of the {{Path|runsvdir}} service script:
{{FileBox|filename=/etc/local.d/runsvdir.start|lang=bash|1=
#!/bin/sh
# Remember to add --user if you don't want to run as root
# Remember to change /usr/bin/runsvdir to /bin/runsvdir if using >=sys-process/runit-2.1.2
start-stop-daemon --start --background --make-pidfile \
   --pidfile /run/runsvdir.pid \
   --exec /usr/bin/runsvdir -- -P /path/to/scandir readproctitle-like-log-argument
}}

{{FileBox|filename=/etc/local.d/runsvdir.stop|lang=bash|1=
#!/bin/sh
start-stop-daemon --stop --retry SIGHUP/5 --pidfile /run/runsvdir.pid
}}

The <code>SIGHUP</code> signal makes {{C|runsvdir}} send a <code>SIGTERM</code> signal to all its {{C|runsv}} children before exiting, which, in turn, makes them stop their supervised processes and exit. The <code>SIGTERM</code> signal that {{C|start-stop-daemon}} sends by default would just make {{C|runsvdir}} exit.

==== From sysvinit ====

Following upstream's suggestion <ref>[http://smarden.org/runit/useinit.html#sysv Using runit with sysvinit and inittab]. Retrieved on May 28th, 2017.</ref>, Gentoo's packaging of runit provides a {{Path|/sbin/runsvdir-start}} symbolic link to {{Path|/etc/runit/2}}, that allows {{C|runsvdir}} to be launched and supervised by [https://packages.gentoo.org/packages/sys-apps/sysvinit sysvinit] by adding a 'respawn' line for it in {{Path|/etc/inittab}}. Used in this way, the supervision tree becomes rooted in process 1, which cannot die without crashing the machine.

Gentoo users wanting to use {{C|runsvdir-start}} in this way will need to manually edit {{Path|/etc/inittab}}, and then call {{C|telinit}}:
{{FileBox|filename=/etc/inittab|1=SV:12345:respawn:/sbin/runsvdir-start}}

{{RootCmd|telinit q}}

This will make sysvinit launch and supervise {{C|runsvdir}} when entering runlevels 1 to 5.

=== The logging chain ===

A supervision tree where all leaf processes have a logger can be arranged into what the author of [[s6]] calls ''the logging chain'' <ref>Laurent Bercot, [https://www.skarnet.org/software/s6/s6-log.html#loggingchain the logging chain], Retrieved on May 1st, 2017.</ref>, which he considers to be technically superior to the traditional syslog-based centralized approach <ref>Laurent Bercot, [https://www.skarnet.org/software/s6/s6-log.html#diesyslogdiedie on the syslog design], Retrieved on May 1st, 2017.</ref>.

Since processes in a supervision tree are created using the POSIX <code>fork()</code> call, each of them will inherit {{C|runsvidir}}'s standard input, output and error. A logging chain arrangement using runit is as follows:

* Leaf processes should normally have a logger, so their standard output and error connect to their logger's standard input. Therefore, all their messages are collected and stored in dedicated, per-service logs by their logger. Some programs might need to be invoked with special options to make them send messages to their standard error, and redirection of standard error to standard output (i.e. '''2>&1''' in a shell script) must be performed in the servicedir's {{Path|run}} file.
* Leaf processes with a controlling terminal are an exception: their standard input, output and error connect to the terminal.
* {{C|runsv}}, the loggers, and leaf processes that exceptionally don't have logger for some reason, inherit their standard input, output and error from {{C|runsvdir}}, so their messages are sent wherever the ones from {{C|runsvdir}} are.
* Leaf processes that still unavoidably report their messages using <code>syslog()</code> have them collected and logged by a (possibly supervised) syslog server.

If runit [[#runitinit|is used as the init system]], and {{C|runsvdir}} was invoked with no second argument, its standard input, output and error will be redirected to {{Path|/dev/console}}. If {{C|runsvdir}} was invoked with a second argument, {{C|readproctitle}}-like logging is turned on and messages sent to {{C|runsvdir}}'s standard error will go to the log and can be seen using {{C|ps}}.
{{anchor|runitinit}}
=== Runit as the init system ===

{{Warning|While Gentoo does offer a runit package in its official repository, it is not completely supported as an init system. Gentoo users wanting to use runit as their machine's init system might need to use [[Ebuild_repository|alternative ebuild repositories]] and/or do some local tweaking. See [[#External_resources|"External resources"]]}}

The runit package provides a program capable of running as process 1, also called {{C|runit}}, and a helper program, {{C|runit-init}}. If {{C|runit-init}} detects it is running as process 1, it replaces itself with {{C|runit}} using the POSIX <code>execve()</code> call. Therefore, to use {{C|runit}} as the system's init, a <code>init=/sbin/runit-init</code> parameter can be added to kernel's command line using the [[Bootloader|bootloader's]] available mechanisms (e.g. a {{C|linux}} command in some 'Gentoo with runit' menu entry for [[GRUB2]]). It is possible to go back to sysvinit + OpenRC at any time by reverting the change.

When the machine starts booting (if an [[initramfs]] is being used, after it passes control to the 'main' init), {{C|runit}} executes the {{Path|/etc/runit/1}} file as a child process, in a foreground process group with {{Path|/dev/console}} as the controlling terminal, and waits for it to finish. This file is usually a shell script, and is expected to perform all one time initialization tasks needed to bring the machine to its stable, normal 'up and running' state. Gentoo's {{Path|/etc/runit/1}} file is quite minimal, it only calls the {{C|openrc}} program to enter OpenRC's '''sysinit''' runlevel, and then its '''boot''' runlevel, emulating Gentoo's sysvinit setup.
{{Note|This setup means that any long-lived processes launched by a service script upon entering OpenRC's 'sysinit' and 'boot' runlevels won't be supervised}}

When {{Path|/etc/runit/1}} exits, {{C|runit}} then executes the {{Path|/etc/runit/2}} file as a child process, makes it a session leader with the POSIX <code>setsid()</code> call, and ''supervises'' it: if {{Path|/etc/runit/2}} is killed by a signal or its exit code is '''111''', then {{C|runit}} will restart it, after sending a <code>SIGKILL</code> signal to every remaining process in its process group. Gentoo's {{Path|/etc/runit/2}} file is upstream's suggested one with minimal modifications. It is a shell script that uses the {{C|exec}} builtin utility to replace itself with {{C|runsvdir}}, so this creates a supervision tree rooted in process 1. The scan directory will be {{Path|/var/service}} for <code><sys-process/runit-2.1.2</code>, and {{Path|/etc/service}} for <code>>=sys-process/runit-2.1.2</code>. The enviroment will be empty, except for the <var>PATH</var> variable, set to a known value in the script. {{C|runsvdir}} will use {{C|readproctitle}}-like logging, and, for <code>>=sys-process/runit-2.1.2</code>, is also passed the <code>-P</code> option.

Gentoo's packaging of runit expects {{Path|/etc/runit/runsvdir/all}} for <code><sys-process/runit-2.1.2</code>, or {{Path|/etc/sv}} for <code>>=sys-process/runit-2.1.2</code>, to be a repository of service directories. Services that need to be started when the machine boots require a symbolic link in the scan directory to the corresponding servicedir in that repository. Gentoo only provides service directories for 6 parallel supervised {{C|agetty}} processes (with their symlinks in the scan directory); this allow users to get to a text console login, like with Gentoo's sysvinit setup. Service directories for anything else must be created by the administrator, either from scratch or taken from somewhere else (e.g. alternative ebuild repositories).

If {{C|runit}} receives a <code>SIGCONT</code> signal, and the file {{Path|/etc/runit/stopit}} exists and has the execute by owner permission set, it will kill {{Path|/etc/runit/2}} (first by sending it a <code>SIGTERM</code> signal and waiting, then by sending it a <code>SIGKILL</code> signal) and then execute the {{Path|/etc/runit/3}} file. This file is usually a shell script, and is expected to perform all tasks needed to shut the machine down. If {{Path|/etc/runit/1}} is killed by a signal or its exit code is '''100''', {{C|runit}} skips execution of {{Path|/etc/runit/2}} and executes {{Path|/etc/runit/3}}. {{C|runit}} will also execute {{Path|/etc/runit/3}} if {{Path|/etc/runit/2}} exits (with an exit code other than 111). If {{Path|/etc/runit/3}} exits, {{C|runit}} will send a <code>SIGKILL</code> signal to all remaining processes, and then check the file {{Path|/etc/runit/reboot}} to decide what to do next. If the file exists and has the execute by owner permission set, it reboots the machine. In any other case, it will power off the machine, or halt it if it can't power it off.

Gentoo's {{Path|/etc/runit/3}} file performs an <kbd>sv shutdown</kbd> for <code><sys-process/runit-2.1.2</code>, or an <kbd>sv force-shutdown</kbd> for <code>>=sys-process/runit-2.1.2</code>, on every servicedir of {{C|runsvdir}}'s scan directory, and then calls the {{C|openrc}} program to enter OpenRC's '''shutdown''' or '''reboot''' runlevels, depending on whether a poweroff or reboot operation was requested to {{C|runit}} via {{Path|/etc/runit/reboot}}.

If {{C|runit}} receives a <code>SIGINT</code> signal (which is usually configured to happen when key combination {{Key|Ctrl}}+{{Key|Alt}}+{{Key|Del}} is pressed), and the file {{Path|/etc/runit/ctrlaltdel}} exists and has the execute by owner permission set, it will execute it as a child process, and when it exits, behave as if it had received a <code>SIGCONT</code> signal. Gentoo's {{Path|/etc/runit/ctrlaltdel}} prints a "''System is going down in 14 seconds...''" message using the {{C|wall}} utility, makes sure file {{Path|/etc/runit/stopit}} exists and has the execute by owner permission set, waits 14 seconds and then exits. The result being that <code>SIGINT</code> will either halt or reboot the machine after 14 seconds, depending on {{Path|/etc/runit/reboot}}.

All {{C|runit}}'s children run with their standard input, output and error initially redirected to {{Path|/dev/console}}.

==== Reboot and shutdown ====

The {{C|runit-init}} program can be used to shut the machine down. Unless it is running as process 1, it accepts one argument, which can be either '''0''' or '''6''':
* If it is 0, {{C|runit-init}} will create the {{Path|/etc/runit/stopit}} and {{Path|/etc/runit/reboot}} files if any of them does not exist, set the execute by owner permission for the former, unset it for the latter, and send a <code>SIGCONT</code> signal to process 1.
* If it is 6, {{C|runit-init}} will create the {{Path|/etc/runit/stopit}} and {{Path|/etc/runit/reboot}} files if any of them does not exist, set the execute by owner permission for both of them, and send a <code>SIGCONT</code> signal to process 1.

Therefore, if process 1 is {{C|runit}}, then <kbd>runit-init 0</kbd> will power off the machine, and <kbd>runit-init 6</kbd> will reboot it.

This means that {{C|runit}} is not directly compatible with sysvinit's {{c|telinit}}, {{c|halt}}, {{c|poweroff}}, {{c|reboot}}, and {{c|shutdown}} commands. However, many programs (e.g. desktop environments) expect to be able to call programs with those names during operation, so if such thing is needed, it is possible to use compatibility shell scripts:
{{FileBox|filename=$PATH/shutdown|lang=bash|1=
#!/bin/sh
runit-init 0
}}

{{FileBox|filename=$PATH/reboot|lang=bash|1=
#!/bin/sh
runit-init 6
}}

==== The runsvchdir program ====

Runit doesn't directly support any runlevel-like concept, but if the machine contains a set of directories, each one with a scan directory structure, then it is possible to have a behaviour similar to 'changing runlevels' if the scan directory argument of runsvdir is actually a symbolic link. The software package's author proposes<ref>[http://smarden.org/runit/runlevels.html runit - runlevels]. Retrieved on June 10th, 2017.</ref> creating a symbolic link to directory pointing to one of the aforementioned directories, which then becomes the current scan directory. Runit provides a {{C|runsvchdir}} program that can atomically modify this symlink, thereby switching the current scan directory used by {{C|runsvdir}}. As a result, on {{C|runsvdir}}'s next periodic scan, new supervised processes can be started, and some supervised processes can be stopped: new {{C|runsv}} processes will be spawned for service directories present in the new scan directory but not in the old one, and running {{C|runsv}} processes will be sent <code>SIGTERM</code> signals (resulting in the equivalent of an <kbd>sv exit</kbd> command) if their corresponding service directories are present in the old scan directory but not in the new one. Supervised processes that have service directories with the same name in both the old and new scan directory remain unaffected.

Using {{C|runsvchdir}} requires that the scan directory be specified to {{C|runvsdir}} as pathname {{Path|/etc/runit/runsvdir/current}}, or a symbolic link that resolves to that pathname. This means that {{C|runsvchdir}} can affect only a single {{C|runsvdir}} process, which is normally the one started by {{Path|/etc/runit/2}} and supervised by process 1. {{C|runsvchdir}} accepts a pathname specifying the new scan directory as an argument, that must not start with a dot ('.'); it creates a symlink named {{Path|/etc/runit/runsvdir/current.new}} that points to this pathname, renames {{Path|/etc/runit/runsvdir/current}} to {{Path|/etc/runit/runsvdir/previous}}, and then renames {{Path|/etc/runit/runsvdir/current.new}} to {{Path|/etc/runit/runsvdir/current}}. This means that if the supplied pathname does not start with a slash ('/'), it will be interpreted as relative to {{Path|/etc/runit/runsvdir}}. Therefore, if {{Path|/etc/runit/runsvdir/runlevelA}} and {{Path|/etc/runit/runsvdir/runlevelB}} are runit scan directories, and {{Path|/etc/runit/runsvdir/current}} is currently a symbolic link to {{Path|/etc/runit/runsvdir/runlevelA}}, then command <kbd>runsvchdir runlevelB</kbd> performs a 'runlevel change' to ''runlevelB''. For further details on {{C|runsvchdir}}, please consult the respective man page.

Gentoo's packaging of runit version 2.1.1 supports this model: runsvdir's scan directory is {{Path|/var/service}}, a symbolic link to {{Path|/etc/runit/runsvdir/current}}. After package installation, a directory named {{Path|/etc/runit/runsvdir/default}} is created, emulating a 'default runlevel', and initially {{Path|/etc/runit/runsvdir/current}} points to {{Path|/etc/runit/runsvdir/default}}. Directory {{Path|/etc/runit/runsvdir/default}} contains initially symbolic links to the 6 service directories for {{C|agetty}} processes installed in the servicedir repository ({{Path|/etc/runit/runsvdir/all}}).

Gentoo's packaging of runit version 2.1.2 does away with this runlevel-like setup.

Examples of {{C|runsvchdir}} usage (with a setup more similar to that of [https://voidlinux.org Void Linux] rather than Gentoo's):
{{Cmd|ls -l /etc/runit/runsvdir/current|
output=<pre>lrwxrwxrwx 1 root root 7 Sep 23  2017 /etc/runit/runsvdir/current -> default</pre>}}

{{RootCmd|runsvchdir default|
output=<pre>runsvchdir: default: current.</pre>}}

This shows that using {{C|runsvchdir}} with a pathname that {{Path|/etc/runit/runsvdir/current}} already points to has no effect.
{{RootCmd|runsvchdir /home/user/custom-scandir|
output=<pre>runsvchdir: /home/user/custom-scandir: now current.</pre>}}

{{Cmd|ls -l /etc/runit/runsvdir|
output=<pre>total 8
lrwxrwxrwx 1 root root   25 Sep 17 12:00 current -> /home/user/custom-scandir
drwxr-xr-x 2 root root 4096 Sep 23  2017 default
lrwxrwxrwx 1 root root    7 Sep 17 12:00 previous -> default
drwxr-xr-x 2 root root 4096 Sep 23  2017 single</pre>}}

This shows that {{C|runsvchdir}} also updated symbolic link {{Path|/etc/runit/runsvdir/previous}}.
{{RootCmd|runsvchdir single|
output=<pre>runsvchdir: single: now current.</pre>}}

{{Cmd|ls -l /etc/runit/runsvdir|
output=<pre>total 8
lrwxrwxrwx 1 root root    6 Sep 17 12:10 current -> single
drwxr-xr-x 2 root root 4096 Sep 23  2017 default
lrwxrwxrwx 1 root root   25 Sep 17 12:10 previous -> /home/user/custom-scandir
drwxr-xr-x 2 root root 4096 Sep 23  2017 single</pre>}}
{{anchor|servicemgmt}}
==== Runit and service management ====

Runit doesn't have service manager features, i.e. it does not provide mechanisms for specifiying dependencies, service ordering constraits, etc. like OpenRC does using <code>depend()</code> functions in service scripts. If such things are needed, the desired behaviour must be explicitly enforced in the code of {{Path|run}} files; the software package's author provides some tips on how to do that <ref>[http://smarden.org/runit/dependencies.html runit - service dependencies]. Retrieved on June 10th, 2017.</ref>. Sometimes, just doing nothing ''might'' be enough: if {{Path|run}} simply exits with an error status when there is an unmet required condition, and, perhaps with help from a {{Path|finish}} files that analyzes the exit code, the state the machine was in before {{Path|run}} was executed is restored, the supervisor would just keep restarting the service until, after some convergence period, all its required conditions are met. The author of [[nosh]] calls this "''the thundering herd solution''" <ref>Jonathan de Boyne Pollard, the nosh Guide, [https://jdebp.eu/Softwares/nosh/guide/introduction.html Introduction], section "Differentiation from other systems", bullet "No daemontools-style thundering herds". Retrieved on June 10th, 2017.</ref>.

Nevertheless, OpenRC and runit do not interfere with each other, so it is possible to use OpenRC-managed services on a machine where the init system is runit. In particular, once the supervision tree rooted in process 1 is launched, it is still possible to manually start individual OpenRC services using {{C|rc-service}}, or even entering OpenRC's 'default' runlevel manually:
{{RootCmd|openrc default}}

Services from OpenRC's 'default' runlevel could be started automatically on boot using the existing {{C|local}} service, moving it to the 'boot' runlevel:
{{FileBox|filename=/etc/local.d/rc-default.start|title=Enter OpenRC's 'default' runlevel|lang=bash|1=
#!/bin/sh
openrc default}}

{{RootCmd|rc-update del local default|rc-update add local boot}}

Alternatively, {{Path|/etc/runit/1}} can be modified to add the corresponding {{C|openrc}} invocation:
{{FileBox|filename=/etc/runit/1|1=RUNLEVEL{{=}}S /sbin/openrc default}}

Note however that OpenRC services will not be supervised by runit.

Runit can be used without OpenRC's service management, but this requires alternative implementation of the functionality of its service scripts, especially those executed upon entering the 'sysinit', 'boot' and 'shutdown' runlevels, and replacing the Gentoo-provided {{Path|/etc/runit/1}} and {{Path|/etc/runit/3}} files with custom ones, since they call the {{C|openrc}} program. It can be be useful to study those from runit-based distributions (e.g. see Void Linux's ones in [https://github.com/void-linux/void-runit their void-runit package sources]).
{{anchor|runitintegration}}
=== OpenRC's runit integration feature ===

Starting with version 0.22, OpenRC can launch supervised long-lived processes using the runit package as a helper <ref>[https://github.com/OpenRC/openrc/blob/master/runit-guide.md Using runit with OpenRC]. Retrieved on June 15th, 2017.</ref>. This is an alternative to 'classic' unsupervised long-lived processes launched using the {{C|start-stop-daemon}} program. It should be noted that service scripts that don't contain <code>start()</code> and <code>stop()</code> functions implicitly use {{C|start-stop-daemon}}.

OpenRC services that want to use runit supervision need both a service script in {{Path|/etc/init.d}} and a runit service directory. The service script must contain a <code>supervisor=runit</code> variable assignment to turn the feature on, and must have a 'need' dependency on the {{C|runsvdir}} service in its <code>depend()</code> function, to make sure the {{C|runsvdir}} program is launched (see [[#openrclaunch|here]]). It can contain neither a <code>start()</code> function, nor a <code>stop()</code> function (but their <code>_pre()</code> and <code>_post()</code> variants are OK), nor a <code>status()</code> function; OpenRC internally invokes {{C|sv}} when the service script is called with a 'start', 'stop' or 'status' argument.

The runit service directory can be placed anywhere in the filesystem, and have any name, as long as the service script (or the service-specific configuration file in {{Path|/etc/conf.d}}) assigns the servicedir's absolute path to the <var>runit_service</var> variable. If <var>runit_service</var> is not assigned to, the runit servicedir must have the same name as the OpenRC service script, and will be searched in the >=sys-process/runit-2.1.2 service directory repository, {{Path|/etc/sv}}. The scan directory when using this feature is {{Path|/run/openrc/sv}}, and OpenRC will create a symlink to the service directory when the service is started, and delete it when the service is stopped.

{{Warning|OpenRC does not integrate as expected when runit is [[#runitinit|used as the init system]], since there will be two {{C|runsvdir}} processes: the one supervised by {{C|runit}} with {{Path|/etc/service}} or {{Path|/var/service}} as the scan directory, and the unsupervised one launched by OpenRC with {{Path|/run/openrc/sv}} as the scan directory. So the result will be two independent supervision trees.}}

Example setup for a hypothetical supervised ''test-daemon'' service, with and without a dedicated logger.
{{FileBox|lang=bash|filename=/etc/init.d/test-service|title=OpenRC service script|1=#!/sbin/openrc-run
description="A supervised test service"
supervisor=runit
runit_service=/home/user/test/svc-repo/test-service

depend() {
   need localmount runsvdir
} }}

{{Cmd|/sbin/rc-service test-service describe|
output=<pre>* A supervised test service
* cgroup_cleanup: Kill all processes in the cgroup</pre>}}

{{FileBox|lang=bash|filename=/etc/init.d/test-service-logged|title=OpenRC service script|1=#!/sbin/openrc-run
description="A supervised test service with a logger"
supervisor=runit
runit_service=/home/user/test/svc-repo/test-service-logged

depend() {
   need localmount runsvdir
} }}

{{Cmd|/sbin/rc-service test-service-logged describe|
output=<pre>* A supervised test service with a logger
* cgroup_cleanup: Kill all processes in the cgroup</pre>}}

The service directories:
{{Cmd|ls -l /home/user/test/svc-repo/test-service* /home/user/test/svc-repo/test-service*/log|
output=<pre>test-service:
total 4
-rwxr-xr-x 1 user user 96 Jun 17 12:00 run

test-service-logged:
total 8
drwxr-xr-x 2 user user 4096 Jun 17 12:00 log
-rwxr-xr-x 1 user user  101 Jun 17 12:00 run

test-service-logged/log:
total 4
-rwxr-xr-x 1 user user 62 Jun 17 12:00 run</pre>}}

{{FileBox|lang=bash|filename=test-service/run|1=#!/bin/sh
exec \
chpst -o 5 \
chpst -u daemon \
/home/user/test/test-daemon}}

This launches program {{C|test-daemon}} with effective user ''daemon'' and the maximum number of open file descriptors set to 5. This is the same as if {{C|test-daemon}} performed a <code>setrlimit(RLIMIT_NOFILE, &rl)</code> call itself with <code>rl.rlim_cur</code> set to 5, provided that value does not exceed the corresponding hard limit. The program also periodically sends a message of the form "''Logged message #N''" to its standard error.
{{FileBox|lang=bash|filename=test-service-logged/run|1=#!/bin/sh
exec \
chpst -o 5 \
chpst -u daemon \
/home/user/test/test-daemon 2>&1}}

{{FileBox|lang=bash|filename=test-service-logged/log/run|1=#!/bin/sh
exec \
chpst -u user \
svlogd -tt /home/user/test/logdir}}

The redirection of {{C|test-daemon}}'s standard error to standard output allows logging its messages using runit's {{C|svlogd}}. An automatically rotated logging directory named ''logdir'' will be used, and messages will have a UTC timestamp prepended to them.

Manually starting {{C|test-service-logged}}:
{{RootCmd|rc-service test-service-logged start|
output=<pre>* /run/openrc/sv: creating directory
* Starting runsvdir ...                       [ ok ]
* Starting test-service-logged ...
* Failed to start test-service-logged         [ !! ]
* ERROR: test-service-logged failed to start</pre>}}

{{Warning|There's currently a bug in the implementation of service startup; OpenRC calls <kbd>sv start</kbd> immediately after creating the servicedir symlink in the scan directory, instead of waiting for {{C|runsvdir}}'s next periodic scan. Because no {{C|runsv}} process has been launched yet, <kbd>sv start</kbd> will fail. However, if there is no {{Path|down}} file in the service directory, after the next scan the service will go up regardless, when the corresponding {{C|runsv}} process is launched.}}

{{RootCmd|rc-service test-service-logged status|output=<pre>run: /run/openrc/sv/test-service-logged: (pid 2155) 24s; run: log: (pid 2154) 24s</pre>}}

Make OpenRC's notion of the service's state catch up:
{{RootCmd|rc-service test-service-logged start|output=<pre>* Starting test-service-logged ...            [ ok ]</pre>}}

The resulting supervision tree so far:
{{Cmd|ps axf -o pid,ppid,pgrp,euser,args|
output=<pre>  PID  PPID  PGRP EUSER    COMMAND
 ...
 1931     1  1931 root     /usr/bin/runsvdir -P /run/openrc/sv log: ...................................................
 2153  1931  2153 root      \_ runsv test-service-logged
 2154  2153  2153 user          \_ svlogd -tt /home/user/test/logdir
 2155  2153  2153 daemon        \_ /home/user/test/test-daemon
 ...</pre>}}

Messages from the {{C|test-daemon}} process with PID 2155 go to the logging directory:
{{Cmd|ls -l /home/user/test/logdir|
output=<pre>total 12
-rwxr--r-- 1 user user 441 Jun 17 12:19 @4000000059454877288a41fc.s
-rwxr--r-- 1 user user 264 Jun 17 12:19 @400000005945489513993834.s
-rw-r--r-- 1 user user 706 Jun 17 12:20 current
-rw------- 1 user user   0 Jun 17 12:04 lock</pre>}}

{{Cmd|cat /home/user/test/logdir/current|
output=<pre>2017-06-17_12:19:42.20404 Logged message #1
2017-06-17_12:19:47.20759 Logged message #2
2017-06-17_12:19:52.21598 Logged message #3
2017-06-17_12:19:57.21806 Logged message #4
2017-06-17_12:20:02.22180 Logged message #5
2017-06-17_12:20:07.22399 Logged message #6</pre>}}

Manually starting {{C|test-service}}:
{{RootCmd|rc-service test-service start|
output=<pre>
* Starting test-service ...
* Failed to start test-service                [ !! ]
* ERROR: test-service failed to start
</pre>}}

Make OpenRC's notion of the service's state catch up because of the service startup bug:
{{RootCmd|rc-service test-service start|output=<pre>* Starting test-service ...                   [ ok ]</pre>}}

{{Cmd|rc-status|
output=<pre>Runlevel: default
...
Dynamic Runlevel: needed/wanted
runsvdir                                      [  started  ]
...
Dynamic Runlevel: manual
test-service-logged                           [  started  ]
test-service                                  [  started  ]</pre>}}

The scan directory:
{{Cmd|ls -l /run/openrc/sv|
output=<pre>total 0
lrwxrwxrwx 1 root root 46 Jun 17 12:25 test-service -> /home/user/test/svc-repo/test-service
lrwxrwxrwx 1 root root 53 Jun 17 12:12 test-service-logged -> /home/user/test/svc-repo/test-service-logged</pre>}}

Final supervision tree:
{{Cmd|ps axf -o pid,ppid,pgrp,euser,args|
output=<pre>  PID  PPID  PGRP EUSER    COMMAND
 ...
 1931     1  1931 root     /usr/bin/runsvdir -P /run/openrc/sv log: ged message #8 Logged message #9 Logged message #10
 2153  1931  2153 root      \_ runsv test-service-logged
 2154  2153  2153 user      |   \_ svlogd -tt /home/user/test/logdir
 2155  2153  2153 daemon    |   \_ /home/user/test/test-daemon
 2249  1931  2249 root      \_ runsv test-service
 2250  2249  2249 daemon        \_ /home/user/test/test-daemon
 ...</pre>}}

Since the {{C|test-daemon}} process with PID 2250 doesn't have a dedicated logger, its messages go to {{C|runsvdir}}'s standard error, are logged {{C|readproctitle}}-style, and show up in {{C|ps}}' output (for process 1931 in this case).

== Removal ==

=== Unmerge ===

{{Unmerge|sys-process/runit}}

Service directories, additional scan directories, the {{Path|/usr/bin/runsvdir}} symlink to {{Path|/bin/runsvdir}}, etc. must be manually deleted if no longer wanted after removing the package. Also, all modifications to sysvinit's {{Path|/etc/inittab}} must be manually reverted: lines for {{C|runsvdir-start}} must be deleted, and a <kbd>telinit q</kbd> command must be used afterwards. And obviously, if runit is being used as the init system, an alternative one must be installed in parallel, and the machine rebooted to use it (possibly by reconfiguring the bootloader), before the package is removed, or otherwise the machine will become unbootable.

== See also ==

* {{See also|s6}}
* {{See also|Comparison of init systems}}

== External resources ==

* [https://wiki.voidlinux.eu/Runit Runit article on the Void Linux Wiki] (a runit-based GNU/Linux distribution).
* [https://wiki.archlinux.org/index.php/runit Runit article on the Arch Linux Wiki].
* [https://forums.gentoo.org/viewtopic-p-7605220.html A thread about runit on the Gentoo Forums].
* [https://gitlab.com/flussence/overlay The flussence ebuild repository], providing an alternative runit packaging, and accompanying [https://gitlab.com/flussence/runit-scripts runit-scripts repository].
* [https://github.com/powerman/powerman-overlay The powerman ebuild repository], providing an alternative runit packaging, service directory {{Path|run}} files for many services, and runit boot scripts.
* [https://bitbucket.org/avery_payne/supervision-scripts Avery Payne's supervision-scripts project], compatible with runit.

== References ==

{{reflist}}

[[Category:Init systems]]
[[Category:Process Supervision]]
[[Category:Daemons]]
