<languages />

{{Metadata|abstract=Это руководство предлагает введение в оптимизацию компилируемого кода используя безопасные, разумные флаги CFLAGS и CXXFLAGS. Оно также описывает в общих чертах теорию оптимизации.}}

Это руководство предлагает [[Article description::введение в оптимизацию компилируемого кода используя безопасные, разумные флаги <var>CFLAGS</var> и <var>CXXFLAGS</var>.]] Оно также описывает теорию оптимизации в общих чертах.

== Введение ==

=== Что такое CFLAGS и CXXFLAGS? ===

Переменные <var>CFLAGS</var> и <var>CXXFLAGS</var> входят в число переменных окружения, традиционно используемых для указания системе сборки параметров компилятора при сборке кода C и C++. Хотя эти переменные не стандартизованы, они используются повсеместно и любой грамотно написанный сборочный файл должен их понимать для того чтобы иметь возможность передавать дополнительные или индивидуальные параметры компилятору при его запуске. Info-страница [https://www.gnu.org/software/make/manual/make.html#Implicit-Variables GNU make] содержит перечень некоторых наиболее широко используемых переменных из этой категории.

Поскольку большое количество пакетов, составляющих большинство систем Gentoo, написано на C и C++, администраторам следует правильно установить эти две переменные, так как они оказывают большое влияние на сборку системы.

Они могут быть использованы для уменьшения количества отладочных сообщений программы, увеличения уровня сообщений об ошибках, и, конечно же, оптимизации производимого кода. [https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC manual] поддерживает полный список доступных параметров и их предназначений.

=== Как они используются? ===

Как правило, переменные <var>CFLAGS</var> и <var>CXXFLAGS</var> устанавливаются в окружении при вызове скрипта configure или с помощью файла make-файлов, созданных программой {{c|automake}}. В системах на базе Gentoo эти переменные устанавливаются в файле {{Path|/etc/portage/make.conf}}. Переменные, установленные в этом файле, экспортируются в окружение программ, запускаемых portage — таким образом, все пакеты собираются, используя эти параметры в качестве основы.

{{CodeBox|title=Настройка CFLAGS в /etc/portage/make.conf|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important|Хоть и можно записать '''USE'''-флаги в несколько строк, запись в несколько строк переменной <var>CFLAGS</var>  ''может'' привести к ошибкам в некоторых программах, например, в {{c|cmake}}. Убедитесь, что <var>CFLAGS</var> записаны в одну строку и с короткими пробелам, во избежании лишних проблем. Посмотрите {{Bug|500034}} например.}}

В примере выше переменная <var>CXXFLAGS</var> установлена таким образом, что она использует все параметры, установленные в переменной <var>CFLAGS</var>. Почти все системы следует настраивать таким образом. Дополнительные параметры для переменной <var>CXXFLAGS</var> менее распространены и, как правило, используются недостаточно широко для того, чтобы имело смысл устанавливать их глобально.

{{Tip|Статья [[Safe_CFLAGS|Safe CFLAGS]] может помочь новичкам начать оптимизацию их систем.}}

=== Заблуждения ===

Хотя оптимизации компилятора, включенные с помощью различных параметров переменной <var>CFLAGS</var>, могут являться эффективным средством для создания меньших по размеру и/или более быстрых исполняемых файлов, они также могут ухудшить функциональность кода, увеличить его размер, замедлить его выполнение или привести к ошибке сборки. Неправильное использование переменной <var>CFLAGS</var> может довольно быстро привести к ухудшению производительности. Не устанавливайте эти параметры произвольно.

Параметры глобальной переменной <var>CFLAGS</var>, установленной в файле {{Path|/etc/portage/make.conf}}, применяются ко всем пакетам в системе, поэтому обычно администраторы устанавливают в этой переменной только наиболее общие, широко используемые параметры. Отдельные пакеты могут изменять эти параметры либо в файле ebuild либо в самой системе сборки, создавая окончательный набор флагов, подаваемых компилятору.

=== Готовы? ===

Теперь, зная о некоторых рисках, давайте посмотрим на некоторые из разумных, безопасных оптимизаций. Они окажут большую пользу и расположат разработчиков в следующий раз, когда будете сообщать о проблеме на [https://bugs.gentoo.org/ Bugzilla]. (Разработчики обычно просят пользователей перекомпилировать пакет с минимальным количеством переменных <var>CFLAGS</var> для того, чтобы определить, продолжает ли проблема существовать. Запомните: агрессивные флаги могут разрушить код!) 

== Оптимизация ==

=== Основы ===

Целью использования <var>CFLAGS</var> и <var>CXXFLAGS</var> является создание кода, приспособленного под систему; он должен отлично функционировать, будучи легковесным и быстрым, если это возможно. Иногда это взаимоисключающие условия, поэтому это руководство будет придерживаться комбинаций, о которых известно, что они работают хорошо. В идеале, они являются легко доступными на любой архитектуре CPU. Для ознакомления агрессивное использование флага будет рассмотрено позднее. Не будет описываться каждый параметр из руководства GCC (их очень много), но опишем основные, наиболее часто используемые флаги. 

{{Note|Если не уверены что делает флаг, проконсультируйтесь с соответствующей главой [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC руководства]. Если после просмотра руководства все еще не уверены, то попробуйте поискать в интернете, или в [https://gcc.gnu.org/lists.html списках рассылок GCC].}}

=== -march ===

<div class="mw-translate-fuzzy">
Самым первым и наиболее важным параметром является <code>-march</code>. Он сообщает компилятору, какой код генерировать для [https://en.wikipedia.org/wiki/Microarchitecture архитектуры процессора] (соответствующие английские термины: “architecture” или “arch”. — Прим. пер.); он сообщает GCC компилятору, что тот должен генерировать код для определенного типа CPU. Разные типы CPU имеют разные возможности, поддерживают различные наборы команд и обладают разными способами исполнения кода. Флаг <code>-march</code> проинструктирует компилятор генерировать специфичный код для архитектуры CPU, со всеми доступными возможностями, особенностями, наборами команд, интересными функциями и так далее.
</div>

<code>-march=</code> is an ISA selection option; it tells the compiler that it may use the instructions from the [[Wikipedia:Instruction_set_architecture|ISA]]. On an Intel/AMD64 platform with <code>-march=native -O2</code> or lower OPT level, the code will likely end up with AVX instructions used but using shorter SSE XMM registers. To take full advantage of AVX YMM registers, the <code>-ftree-vectorize</code>, <code>-O3</code> or <code>-Ofast</code> options should be used as well<ref>GNU GCC Bugzilla, [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57952#c8 AVX/AVX2 no ymm registers used in a trivial reduction]. Retrieved on 2017/07/18.</ref>.

<code>-ftree-vectorize</code> is an optimization option (default at <code>-O3</code> and <code>-Ofast</code>), which attempts to vectorize loops using the selected ISA if possible.  The reason it isn't enabled at <code>-O2</code> is that it doesn't always improve code, it can make code slower as well, and usually makes the code larger; it really depends on the loop etc. 

Хотя переменная <var>CHOST</var> в {{Path|/etc/portage/make.conf}} и указывает основную используемую архитектуру, параметр <code>-march</code> все еще должен использоваться, так чтобы программы были оптимизированы для конкретного процессора. Процессоры x86 и x86-64 (в числе других) должны использовать флаг <code>-march</code>. 

Какой вид CPU имеется в системе? Чтобы это узнать, введите следующую команду: 

{{Cmd|cat /proc/cpuinfo}}

or even install {{Package|app-portage/cpuid2cpuflags}} and add the available CPU-specific options to the {{Path|/etc/portage/package.use/00cpuflags}} file, which the tool does through e.g. the [[CPU FLAGS X86|CPU_FLAGS_X86]] variable:

{{Cmd|cpuid2cpuflags|output=<pre>
CPU_FLAGS_X86: aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3</pre>}}

<div class="mw-translate-fuzzy">
{{RootCmd|echo "CPU_FLAGS_X86{{=}}'aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3'" >> /etc/portage/make.conf}}
</div>

Чтобы получить более детальную информацию, включая значения <code>march</code> и <code>mtune</code> можно использовать две команды.

* Первая команда говорит компилятору не производить линковку (<code>-c</code>), и вместо того, чтобы интерпретировать опцию <code>--help</code> для уточнения параметров командной строки, показывает какие опции включены или отключены (<code>-Q</code>). В этом случае показаны те опции, которые были включены для выбранной цели:
: {{Cmd|gcc -c -Q -march{{=}}native --help{{=}}target}}

* Вторая команда покажет директивы компилятора для построения заголовочного файла, но без фактического выполнения, а результат работы выведет на экран (<code>-###</code>). Вывод содержит все параметры оптимизации, а также выбранную архитектуру:
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

Давайте теперь рассмотрим <code>-march</code> в действии. Этот пример приведен для более старого чипа Pentium III: 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium III example|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

А это другой пример для 64-разрядного AMD CPU: 

{{FileBox|filename=/etc/portage/make.conf|title=пример для AMD64|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

Если тип процессора все еще нее определен, либо не знаете какую настройку выбрать, то можно воспользоваться параметром <code>-march=native</code>. Когда используется этот флаг, GCC попытается распознать процессор и автоматически установит для него подходящие флаги. '''Однако, не нужно его использовать, если собираетесь компилировать пакеты для разных CPU!''' 

{{Warning|'''Не''' используйте <code>-march{{=}}native</code> или <code>-mtune{{=}}native</code> в переменных <var>CFLAGS</var> или <var>CXXFLAGS</var> файла {{Path|make.conf}} при компиляции с помощью {{c|[[Distcc/ru#-march.3Dnative|distcc]]}}.}}

При сборке пакетов на одном компьютере с целью их запуска на другом (например, при сборке на более быстром компьютере с целью запуска на более старом и медленном) ''не'' используйте параметр <code>-march=native</code>. "Native" означает, что полученный код может запускаться ''только'' на этом типе CPU. Приложения, собранные с параметром <code>-march=native</code> на AMD Athlon 64 CPU '''не будут''' работать на VIA C3 CPU. 

Также, доступны флаги <code>-mtune</code> и <code>-mcpu</code>. Эти флаги обычно используются только тогда, когда нет доступного параметра <code>-march</code>; определенные архитектуры процессоров могут требовать <code>-mtune</code> или даже <code>-mcpu</code>. К сожалению, поведение GCC не совсем предсказуемо для того, как эти флаги ведут себя при переходе от одной архитектуры к другой. 

На процессорах x86 и x86-64, параметр <code>-march</code> будет генерировать код, предназначенный специально для этих типов процессоров, используя все доступные наборы команд и корректный двоичный интерфейс приложений; он не будет обладать обратной совместимостью с более старыми/другими типами процессоров. Рассмотрите возможность использования <code>-mtune</code>, когда необходимо сгенерировать код для более старых процессоров, таких как i386 и i486. Параметр <code>-mtune</code> производит более общий код, чем <code>-march</code>; хотя он и настроит код под определенный процессор, он не будет рассматривать доступные наборы команд и двоичный интерфейс приложений. Не используйте <code>-mcpu</code> на системах с x86 или x86-64, так как это не рекомендуется для этих архитектур. 

Только не x86/x86-64 процессоры (такие как SPARC, Alpha, и PowerPC) могут потребовать параметры <code>-mtune</code> или <code>-mcpu</code> вместо <code>-march</code>. На этих архитектурах, <code>-mtune</code>/<code>-mcpu</code> иногда будут вести себя как <code>-march</code> (на x86/x86-64), но с другим именем флага. Опять же, поведение GCC и именование флагов не является единообразным на каждой из архитектур, поэтому удостоверьтесь, что проконсультировались с GCC [https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual], для того чтобы определить какой из них должен быть использован. 

{{Note|Для большего количества предполагаемых настроек <code>-march</code>/<code>-mtune</code>/<code>-mcpu</code>, пожалуйста, прочитайте главу 5 подходящей [[HandBook:Main_Page/ru|настольной книги Gentoo]] для архитектуры. Также, прочтите список руководств по [https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options архитектурно-зависимым параметрам] GCC, наряду с более подробным объяснением различий между <code>-march</code>, <code>-mcpu</code>, и <code>-mtune</code>.}}

=== -O ===

{{Warning|Using <code>-O3</code> or <code>-Ofast</code> may cause some packages to break during the compilation.}}

{{Note|Для отображения всех пакетов, которые были скомпилированы с определенным <var>CFLAGS</var>/<var>CXXFLAGS</var>, можно использовать следующую команду: <code>grep Ofast /var/db/pkg/*/*/CFLAGS</code>}}

Следующая по списку - переменная <code>-O</code>. Она управляет всем уровнем оптимизации. Изменение этой переменной приводит к тому, что компиляция кода занимает больше времени, и сможет занять гораздо больше памяти, особенно когда уровень оптимизации увеличен. 

Существует семь видов настроек переменной <code>-O</code>: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code> и <code>-Ofast</code>. Используйте только одну из них в {{Path|/etc/portage/make.conf}}.

За исключением <code>-O0</code>, каждая из настроек с префиксом <code>-O</code> активирует несколько дополнительных флагов, поэтому удостоверьтесь, что Вы прочитали главу руководства GCC по [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options параметрам оптимизации] для изучения того, какие флаги активируются на каждом уровне с приставкой <code>-O</code>, также как и некоторые из объяснений того, что они делают. 

Давайте исследуем каждый уровень оптимизации: 

* <code>-O0</code>: Этот уровень (буква "O" и ноль за ней) отключает оптимизацию полностью и является уровнем по умолчанию, если никакого уровня с префиксом <code>-O</code> не указано в переменных <var>CFLAGS</var> или <var>CXXFLAGS</var>. Это сокращает время компиляции и может улучшить данные для отладки, но некоторые приложения не будут работать должным образом без оптимизации. Эта опция не рекомендуется, за исключением использования в целях отладки.

* <code>-O1</code>: Это наиболее простой уровень оптимизации. Компилятор попытается сгенерировать быстрый, занимающий меньше объема код, без затрачивания наибольшего времени компиляции. Он достаточно простой, но должен всегда выполнять свою работу.

* <code>-O2</code>: Шаг вперед от <code>-O1</code>. ''Рекомендуемый'' уровень оптимизации, до тех пор пока не понадобится что-то особенное. <code>-O2</code> активирует несколько дополнительных флагов вдобавок к флагам, активированных <code>-O1</code>. С параметром <code>-O2</code>, компилятор попытается увеличить производительность кода без нарушения размера, и без затрачивания большого количества времени компиляции. На этом уровне могут быть использованы SSE и AVX, но YMM-регистры не будут использоваться пока не будет включена опция <code>-ftree-vectorize</code>.

<div class="mw-translate-fuzzy">
* <code>-O3</code>: Это наибольший возможный уровень оптимизации. Включает оптимизации, являющейся дорогостоящей с точки зрения времени компиляции и потребления памяти. Компиляция с <code>-O3</code> не является гарантированным способом повышения производительности, и на самом деле во многих случаях может привести к замедлению системы из-за больших двоичных файлов и увеличения потребления памяти. <code>-O3</code> известен также тем, что ломает несколько пакетов. Использование <code>-O3</code> не рекомендуется.
</div>

* <code>-Os</code>: На этом уровне код будет оптимизирован по объему. Он активирует все параметры <code>-O2</code>, которые не приводят к увеличению размера генерируемого кода. Он может быть полезным на компьютерах, которые обладают чрезвычайно ограниченным пространством жесткого диска и/или процессоры с небольшим размером кэша.

* <code>-Og</code>: В GCC 4.8 был введен новый общий уровень оптимизации -Og. Он удовлетворяет потребность в быстрой компиляции и имеет превосходные возможности для отладки, обеспечивая при этом приемлемый уровень производительности во время выполнения. Общий опыт разработки должен быть лучше, чем с уровнем оптимизации по умолчанию -O0. Обратите внимание, что -Og не означает -g, он просто отключает оптимизацию кода, которая может помешать отладке.

* <code>-Ofast</code>: Новое в GCC 4.7, состоит из <code>-O3</code> плюс <code>-ffast-math</code>, <code>-fno-protect-parens</code>, и <code>-fstack-arrays</code>. Этот параметр нарушает строгое соответствие стандарту, и не рекомендуется для использования.

Как упомянуто ранее, параметр <code>-O2</code> - рекомендуемый уровень оптимизации. Если компиляция пакета выдает сообщение об ошибке и не используется параметр <code>-O2</code>, то попробуйте перекопилировать с этой опцией. В качестве выхода, попробуйте установить переменные <var>CFLAGS</var> и <var>CXXFLAGS</var> на наименьший уровень оптимизации, такой как <code>-O1</code>, или даже <code>-O0 -g2 -ggdb</code> (для сообщения об ошибках и проверки возможных проблем).

=== -pipe ===

Общеупотребительный флаг - <code>-pipe</code>. Этот флаг не влияет на генерируемый код, но ''ускоряет'' процесс компиляции. Он сообщает компилятору, чтобы тот использовал конвейер (pipe) вместо временных файлов в течение разных стадий компиляции, которые используют большее количество памяти. На системах с небольшим количеством памяти, GCC может завершить свою работу. В этих случаях, не используйте этот флаг. 

=== -fomit-frame-pointer ===

Это очень часто используемый флаг, предназначенный для того, чтобы уменьшить размер генерируемого кода. Он включается на всех уровнях с префиксом <code>-O</code> (исключая <code>-O0</code>) на тех архитектурах, где это не затрудняет отладку (таких как x86-64), но его, возможно, необходимо активировать. В этом случае добавьте его к флагам. Хотя руководство по GCC не указывает все архитектуры, но он включается с использованием параметра <code>-O</code>. Также нужно явно активировать <code>-fomit-frame-pointer</code> для x86-32, если GCC версии ниже 4.6, либо при использовании <code>-Os</code> на x86 -32 с любой версией GCC. Однако, использование <code>-fomit-frame-pointer</code> может сделать отладку сложной, или даже невозможной. 

В частности, это делает устранение неполадок в приложениях, написанных на Java и скомпилированных в gcj, намного сложнее, хотя код, написанный на Java - не единственный, который затронут использованием этого флага. Поэтому, в то время как использование этого флага может помочь, оно также затрудняет отладку; трассировка стека, в частности, будет бесполезна. Если не планируется отлаживать программы и нет других переменные <var>CFLAGS</var>, связанные с отладкой, такие как <code>-ggdb</code>, то попробуйте использовать <code>-fomit-frame-pointer</code>. 

{{Important|''Не комбинируйте'' <code>-fomit-frame-pointer</code> с подобным флагом <code>-momit-leaf-frame-pointer</code>. Использование последнего флага не рекомендуется, так как <code>-fomit-frame-pointer</code> уже выполняет всю работу. Кроме того, показано, что <code>-momit-leaf-frame-pointer</code> негативно влияет на производительность кода.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

Эти флаги разрешают наборы команд [[Wikipedia:Streaming|SIMD Extensions]] (SSE), [[Wikipedia:SSE2|SSE2]], [[Wikipedia:SSE3|SSE3]], [[Wikipedia:MMX_(instruction_set) MMX|MMX]], и [[Wikipedia:3DNow!|3DNow!]] для архитектур x86 и x86-64. Они используются в основном в мультимедиа, играх, и других вычислительных задачах с интенсивным использованием плавающей точки, хотя они также включают несколько других математических расширений. Эти наборы команд предоставляются большинством современных процессоров. 

{{Important|Убедитесь, что проверили поддерживает ли процессор эти наборы команд, введя команду {{c|cat /proc/cpuinfo}}. Результат будет включать любые дополнительные наборы команд, которые поддерживаются. Заметьте, что '''pni''' - это просто другое имя для SSE3.}}

Обычно, нет необходимости добавлять какие-либо из этих флагов в {{Path|/etc/portage/make.conf}} пока в системе используется корректный параметр <code>-march</code> (например, <code>-march=nocona</code> подразумевает использование <code>-msse3</code> ). Некоторые заметные исключения - новые процессоры VIA и AMD64, которые поддерживают инструкции, не включаемые параметром <code>-march</code> (такие как SSE3). Для таких процессоров, нужно включить дополнительные флаги, где это необходимо, после проверки {{Path|/proc/cpuinfo}}. 

{{Note|Сверьтесь с [https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html списком флагов, характерных для архитектур x86 и x86-64], чтобы увидеть, какие из этих инструкций активированы соответствующим флагом типа процессора. Если инструкция перечислена, то не нужно ее указывать отдельно; она будет включена с помощью подходящей настройки <code>-march</code>.}}

== FAQ по оптимизации ==

=== Но я получаю лучшую производительность с -funroll-loops -fomg-optimize! ===

Нет, людям только ''кажется'' что они получают лучшую производительность, потому что кто-то их убедил в том, что чем больше флагов, тем лучше. Агрессивные флаги только повредят приложениям при глобальном использовании. Даже GCC [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] говорит, что использование параметров <code>-funroll-loops</code> и <code>-funroll-all-loops</code> может увеличить объем кода и время его исполнения. Хотя, по каким-то причинам, эти два флага, вместе с флагами <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, и им подобными, продолжают пользоваться популярностью среди гонщиков, которые хотят повысить чувство собственной важности. 

Истина в том, что это чрезвычайно агрессивные флаги. Посмотрите по [https://forums.gentoo.org/ форумам Gentoo] и [https://bugs.gentoo.org/ Bugzilla], чтобы увидеть, что эти флаги могут сделать: ничего хорошего! 

Не нужно использовать эти флаги глобально, в переменных <var>CFLAGS</var> и <var>CXXFLAGS</var>. Они только ухудшат производительность. Может показаться, что они сделают систему более высокопроизводительной, работающей по последнему слову техники, но они ничего не делают, кроме раздувания кода и приведут к тому, что ваши сообщения о багах пометят как INVALID или WONTFIX. 

Такие опасные флаги, как эти не нужны. '''Не используйте их'''. Придерживайтесь основ: <code>-march</code>, <code>-O</code>, и <code>-pipe</code>.

=== Что по поводу уровней оптимизации -O больших чем 3? ===

Некоторые пользователи хвалятся даже большей производительностью, достигнутой использованием <code>-O4</code>, <code>-O9</code>, и так далее, но в действительности, уровни <code>-O</code> большие чем 3 не имеют никакого эффекта. Компилятор может принимать переменные <var>CFLAGS</var>, такие как <code>-O4</code>, но, на самом деле, ничего с ними не делает. Он только выполняет оптимизацию до уровня <code>-O3</code>, и ничего больше: 

Нужно больше доказательств? Исследуйте [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup#l381 исходный код]: 

{{CodeBox|title=Исходный код параметра -O|lang=c|1=
   case OPT_LEVELS_3_PLUS:
      enabled = (level >= 3);
      break;
 
 case OPT_LEVELS_3_PLUS_AND_SIZE:
      enabled = (level >= 3 {{!}}{{!}} size);
      break;
}}

Как можно увидеть, любое значение больше тройки рассматривается как <code>-O3</code>.

=== Что насчет компиляции не на целевой машине? ===

Некоторые читатели могут спросить, не приведет ли компиляция не на целевой машине, сильно отличающейся архитектурой процессора или структурой GCC, к плохому качеству оптимизации (по сравнению с нативной компиляцией). Ответ прост: '''Нет'''. Независимо от используемого оборудования, на котором проводится компиляция, и от значения переменной CHOST, с использованием которой был собран GCC, если используются те же аргументы <small>(кроме <code>-march=native</code>)</small> и та же версия GCC <small>(хотя небольшие оптимизации могут отличаться)</small>, результирующий уровень оптимизации останется строго тем же.

Например, если Gentoo установлен на компьютере, на котором переменная CHOST для GCC равна ''i686-pc-linux-gnu'', а сервер [[Distcc]] настроен на другом компьютере, на котором CHOST для GCC равна ''i486-linux-gnu'', то не нужно бояться, что результаты будут менее оптимальны из-за отличающейся архитектуры удаленного компилятора и/или оборудования. Результат будет оптимизирован в той же степени, как и при сборке на целевом компьютере, если, конечно, обоим компиляторам передаются одинаковые параметры (и параметр <code>-march</code> не включает значение <code>native</code>).  В данном конкретном случае целевую архитектуру нужно явно определять, как указано в статье [[Distcc#-march.3Dnative|Distcc и -march=native]].

Единственная разница в поведении между двумя версиями GCC, построенными с использованием разных архитектур в значении параметра <code>-march</code> по умолчанию. Он берется из переменной CHOST для GCC, если он не указан явно в командной строке.

=== А что об избыточных флагах? ===

Часто переменные <var>CFLAGS</var> и <var>CXXFLAGS</var>, которые включаются на разных уровнях <code>-O</code>, указаны избыточно в {{Path|/etc/portage/make.conf}}. Иногда, это сделано по неосведомленности, но также и для того, чтобы избежать отфильтровывание флагов или их замещение. 

Фильтрация/замещение флагов используется во многих ebuild-файлах, находящихся в дереве Portage. Обычно, это делается потому что пакеты не компилируются на определенных уровнях <code>-O</code>, или когда исходный код очень чувствителен к дополнительно используемым флагам. Ebuild-файл или отфильтровывает некоторые или все переменные <var>CFLAGS</var> и <var>CXXFLAGS</var>, или может заменить <code>-O</code> другим уровнем. 

[https://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Руководство разработчика Gentoo] описывает в общих чертах, где и как работает фильтрация/замещение флагов. 

Возможно обойти фильтрацию уровней <code>-O</code>, избыточно перечисляя флаги для определенного уровня, например <code>-O3</code>, делая такие вещи как: 

{{CodeBox|title=Указание избыточных CFLAGS|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

Однако, '''это не самая умная вещь, которую можно сделать'''. <var>CFLAGS</var> отфильтровываются не зря! Когда флаги фильтруются, это означает, что собирать пакет с этими флагами небезопасно. Очевидно, что ''небезопасно'' компилировать всю систему с <code>-O3</code> если некоторые из флагов, включенных на этом уровне, вызовут проблемы с определенными пакетами. Следовательно, не пытайтесь ''обхитрить'' разработчиков, которые поддерживают эти пакеты. ''Доверяйте разработчикам''. Фильтрация флагов и их замена делаются для обеспечения стабильности системы и приложения! Если ebuild-файл указывает альтернативные флаги, то не пытайтесь это обойти. 

Сборка пакетов с недопустимыми флагами скорее всего вызовет проблемы. При создании отчета об ошибке на Bugzilla флаги, установленные в файле {{Path|/etc/portage/make.conf}}, отчетливо видны, и разработчики все равно попросят пересобрать пакет без этих флагов. Чтобы избежать необходимости повторной сборки, не используйте эти флаги изначально. Не стоит автоматически полагать себя более сведущим, чем разработчики.

=== Что по поводу LDFLAGS? ===

Разработчики Gentoo уже установили простые, безопасные <var>LDFLAGS</var> в базовых профилях, поэтому не нужно их изменять.

=== Могу ли я использовать флаги для отдельных пакетов? ===

{{Warning|Использование флагов для отдельных пакетов затрудняет отладку и поддержку. Убедитесь, что упомянули об использовании этой возможности и о сделанных изменениях.}}

Информация об использовании переменных среды для каждого пакета по отдельности (включая <var>CFLAGS</var>) описана в  [[Handbook:AMD64/Portage/Advanced/ru#Per-package_environment_variables|настольной книге Gentoo, "Переменное окружение для отдельных пакетов"]].

== Смотрите также ==

* [[Handbook:AMD64/Installation/Stage/ru#Настройка параметров компиляции|Настройка параметров компиляции]] (AMD64 Handbook)

== Внешние ресурсы ==

Следующие источники могут быть полезными в дальнейшем изучении оптимизации: 

* [https://gcc.gnu.org/onlinedocs/ Онлайн-документация GCC] 

* {{c|man make.conf}}

* [https://en.wikipedia.org/ Wikipedia]

* [https://forums.gentoo.org/ форумы Gentoo]

== Ссылки ==

{{reflist}}

{{Migrated|originalauthors={{Dev|nightmorph}}}}


[[Category:Compilation]]
