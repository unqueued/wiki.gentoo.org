<languages />

Это руководство предлагает введение в оптимизацию компилируемого кода используя безопасные, разумные флаги CFLAGS и CXXFLAGS. Оно также описывает теорию оптимизации в общих чертах.

== Введение ==

=== Что такое CFLAGS и CXXFLAGS? ===

Флаги CFLAGS и CXXFLAGS - это переменные среды, которые используются для сообщения компиляторам GNU Compiler Collection, <code>gcc</code> , какие виды ключей использовать при компиляции исходного кода. CFLAGS используются для кода написанного на C, в то время как флаги CXXLFAGS - для кода написанного на C++. 

Они могут быть использованы для уменьшения количества отладочных сообщений для программы, увеличения уровня сообщений об ошибках, и, конечно же, оптимизации производимого кода. [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Invoking-GCC.html#Invoking-GCC GNU gcc handbook] поддерживает полный список доступных параметров и их предназначений. 

=== Как их использовать? ===

Флаги CFLAGS и CXXFLAGS могут использоваться двумя путями. Во-первых, они могут использоваться на уровне единственной программы с помощью make-файлов, генерируемых утилитой automake. 

Однако, Вы не должны это делать при установке пакетов, находящихся в дереве портежей. Вместо этого, установите Ваши CFLAGS и CXXFLAGS флаги в {{Path|/etc/portage/make.conf}} . Таким образом все пакеты будут скомпилированы с использованием параметров, которые Вы укажете. 

{{Code|Флаги CFLAGS в /etc/portage/make.conf|<pre>
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Как видите, CXXFLAGS настроены на использование всех параметров, присутствующих в CFLAGS. Это то, что Вам потребуется почти безусловно. Вам вовсе не надобно указывать дополнительные параметры в CXXFLAGS. 

=== Заблуждения ===

В то время как CFLAGS и CXXFLAGS могут быть очень эффективными средствами производства менее объемных или более быстрых двоичных файлов из исходного кода, они также могут нарушить функционирование Вашего кода, увеличить его объем, замедлить время исполнения, или вызвать серьезные ошибки компиляции! 

CFLAGS - это не панацея; они не смогут автоматически заставить Вашу систему работать быстрее или двоичные файлы занимать меньше места на диске. Добавление все большего и большего количества флагов в попытке оптимизировать (или "разогнать") систему - верный рецепт для неудачи. Существует точка, в которой Вы достигнете худших результатов. 

Вопреки хвастовству, которое Вы найдете в Интернете, агрессивные флаги компиляции CFLAGS и CXXFLAGS, скорее всего, принесут больше вреда, чем пользы для Ваших программ. Держите в уме, что причина, по которой флаги существуют с самого начала - это потому что они созданы для использования в определенном месте с определенной целью. Просто потому что один отдельный CFLAG хорош для одного участка кода, вовсе не означает что он подходит для компиляции всего, что Вы можете установить на Ваш компьютер! 

=== Готовы? ===

Теперь, когда Вы знаете о некоторых рисках, давайте посмотрим на некоторые из разумных, безопасных оптимизаций для Вашего компьютера. Они окажут Вам большую пользу и расположат к Вам разработчиков в следующий раз, когда Вы будете сообщать о проблеме на [http://bugs.gentoo.org Bugzilla] . (Разработчики обычно просят вас перекомпилировать пакет с минимальным количеством переменных CFLAGS для того, чтобы определить, продолжает ли проблема существовать. Запомните, агрессивные флаги могут разрушить код.) 

== Оптимизация ==

=== Основы ===

Целью использования CFLAGS и CXXFLAGS является создание кода, приспособленного под Вашу систему; он должен отлично функционировать, будучи легковесным и быстрым, если это возможно. Иногда это взаимоисключающие условия, поэтому мы будем придерживаться комбинаций, о которых известно, что они работают хорошо. В идеале, они являются легко доступными на любой архитектуре CPU. Мы упомянем два агрессивных флага позже, так чтобы Вы знали, чего следует остерегаться. Мы  не будем обсуждать каждый параметр, перечисленный в руководстве по <code>gcc</code>, но мы опишем основные, наиболее общие флаги. 

{{Note/ru|Если Вы не уверены что делает тот или иной флаг, проконсультируйтесь с соответствующей главой [http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Optimize-Options.html#Optimize-Options gcc manual] . Если Вы все еще не уверены, попробуйте Google, или посмотрите <code>gcc</code> [http://gcc.gnu.org/lists.html mailing lists] .}}

=== -march ===

Самой первым, и наиболее важным параметром, является <code>-march</code> . Он сообщает компилятору какой код он должен генерировать для Вашего типа процессора [http://en.wikipedia.org/wiki/Microarchitecture architecture] (или ''архитектуры'' ); он сообщает компилятору, что тот должен генерировать код для определенного типа CPU. Разные типы CPU имеют разные возможности, поддерживают различные наборы команд, и обладают разными способами исполнения кода. Флаг <code>-march</code> проинструктирует компилятор генерировать код специально для Вашего типа CPU, со всеми доступными возможностями, особенностями, наборами команд, интересными функциями, и так далее. 

Хотя переменная CHOST в {{Path|/etc/portage/make.conf}} и указывает основную используемую архитектуру, параметр <code>-march</code> все еще должен использоваться, так чтобы программы были оптимизированы для Вашего конкретного процессора. Процессоры x86 и x86-64 (в числе других) должны использовать флаг <code>-march</code>. 

Какой вид CPU Вы имеете? Чтобы это узнать, введите следующую команду: 

{{Cmd|cat /proc/cpuinfo}}

Давайте теперь рассмотрим <code>-march</code> в действии. Этот пример приведен для более старого чипа Pentium III: 

{{Code|/etc/portage/make.conf: Pentium III|<pre>
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>
}}

А это другой пример для 64-разрядного AMD CPU: 

{{Code|/etc/portage/make.conf: AMD64|<pre>
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Если Вы все еще не уверены, каким видом CPU Вы обладаете, вы можете просто использовать параметр <code>-march=native</code> . Когда используется этот флаг, GCC попытается распознать Ваш процессор и автоматически установит для него подходящие флаги. '''Однако, Вы не должны его использовать, если Вы собираетесь компилировать пакеты для другого CPU!''' 

Итак, если вы компилируете пакеты на одном компьютере, но собираетесь запускать их на другом (например, используя сборку на быстром компьютере для более медленного, старого компьютера), тогда ''не используйте'' <code>-march=native</code> . ''Native'' означает, что генерируемый код будет запускаться ''только'' на том типе CPU, на котором он был собран. Приложения скомпилированные с <code>-march=native</code> на процессоре AMD Athlon 64 CPU не смогут запуститься на более старом VIA C3 CPU. 

Также, доступны флаги <code>-mtune</code> и <code>-mcpu</code>. Эти флаги обычно использутся только тогда, когда нет доступного параметра <code>-march</code>; определенные архитектуры процессоров могут требовать <code>-mtune</code> или даже <code>-mcpu</code> . К сожалению, поведение <code>gcc</code> не весьма предсказуемо для того как эти флаги ведут себя при переходе от одной архитектуры к другой. 

On x86 and x86-64 CPUs, <code>-march</code> will generate code specifically for that CPU using all its available instruction sets and the correct ABI; it will have no backwards compatibility for older/different CPUs. If you don't need to execute code on anything other than the system you're running Gentoo on, continue to use <code>-march</code> . You should only consider using <code>-mtune</code> when you need to generate code for older CPUs such as i386 and i486. <code>-mtune</code> produces more generic code than <code>-march</code> ; though it will tune code for a certain CPU, it doesn't take into account available instruction sets and ABI. Don't use <code>-mcpu</code> on x86 or x86-64 systems, as it is deprecated for those arches. 

Only non-x86/x86-64 CPUs (such as Sparc, Alpha, and PowerPC) may require <code>-mtune</code> or <code>-mcpu</code> instead of <code>-march</code> . On these architectures, <code>-mtune</code>/ <code>-mcpu</code> will sometimes behave just like <code>-march</code> (on x86/x86-64) . . . but with a different flag name. Again, <code>gcc</code> 's behavior and flag naming just isn't consistent across architectures, so be sure to check the <code>gcc</code> [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Submodel-Options.html#Submodel-Options manual] to determine which one you should use for your system. 

{{Note|For more suggested <code>-march</code>/ <code>-mtune</code>/ <code>-mcpu</code> settings, please read chapter 5 of the appropriate [http://www.gentoo.org//doc/en/handbook/ Gentoo Installation Handbook] for your arch. Also, read the <code>gcc</code> manual's list of [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Submodel-Options.html#Submodel-Options architecture-specific options] , as well as more detailed explanations about the differences between <code>-march</code> , <code>-mcpu</code> , and <code>-mtune</code> .}}

=== -O ===

Next up is the <code>-O</code> variable. This controls the overall level of optimization. This makes the code compilation take somewhat more time, and can take up much more memory, especially as you increase the level of optimization. 

There are five <code>-O</code> settings: <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , and <code>-Os</code> . You should use only one of them in {{Path|/etc/portage/make.conf}} . 

With the exception of <code>-O0</code> , the <code>-O</code> settings each activate several additional flags, so be sure to read the gcc manual's chapter on [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Optimize-Options.html#Optimize-Options optimization options] to learn which flags are activated at each <code>-O</code> level, as well as some explanations as to what they do. 

Let's examine each optimization level: 

*  <code>-O0</code> : This level (that's the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in CFLAGS or CXXFLAGS. Your code will not be optimized; it's not normally desired.

*  <code>-O1</code> : This is the most basic optimization level. The compiler will try to produce faster, smaller code without taking much compilation time. It's pretty basic, but it should get the job done all the time.

*  <code>-O2</code> : A step up from <code>-O1</code> . This is the ''recommended'' level of optimization unless you have special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code> . With <code>-O2</code> , the compiler will attempt to increase code performance without compromising on size, and without taking too much compilation time.

*  <code>-O3</code> : This is the highest level of optimization possible, and also the riskiest. It will take a longer time to compile your code with this option, and in fact it ''should not be used system-wide with <code>gcc</code> 4.x'' . The behavior of <code>gcc</code> has changed significantly since version 3.x. In 3.x, <code>-O3</code> has been shown to lead to marginally faster execution times over <code>-O2</code> , but this is no longer the case with <code>gcc</code> 4.x. Compiling all your packages with <code>-O3</code> ''will'' result in larger binaries that require more memory, and will significantly increase the odds of compilation failure or unexpected program behavior (including errors). The downsides outweigh the benefits; remember the principle of diminishing returns. '''Using <code>-O3</code> is not recommended for <code>gcc</code> 4.x.''' 

*  <code>-Os</code> : This level will optimize your code for size. It activates all <code>-O2</code> options that don't increase the size of the generated code. It can be useful for machines that have extremely limited disk storage space and/or have CPUs with small cache sizes. However, it can cause quite a few problems, which is why it is filtered out by many of the ebuilds in the tree. Using <code>-Os</code> is not recommended.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilations error out, check to make sure that you aren't using <code>-O3</code> . As a fallback option, try setting your CFLAGS and CXXFLAGS to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems) and recompile the package. 

=== -pipe ===

A common flag is <code>-pipe</code> . This flag actually has no effect on the generated code, but it makes the compilation process faster. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, gcc might get killed. In that case, do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code> ) on architectures where doing so does not interfere with debugging (such as x86-64), but you may need to activate it yourself by adding it to your flags. Though the GNU <code>gcc</code> manual does not specify all architectures it is turned on by using <code>-O</code> , you will need to explicitly activate it on x86. However, using this flag will make debugging hard to impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. However, if you don't plan to do much software debugging and haven't added any other debugging-related CFLAGS such as <code>-ggdb</code> , then you can try using <code>-fomit-frame-pointer</code> . 

{{Important|Do ''not'' combine <code>-fomit-frame-pointer</code> with the similar flag <code>-momit-leaf-frame-pointer</code> . Using the latter flag is discouraged, as <code>-fomit-frame-pointer</code> already does the job properly. Furthermore, <code>-momit-leaf-frame-pointer</code> has been shown to negatively impact code performance.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE] , [http://en.wikipedia.org/wiki/SSE2 SSE2] , [http://en.wikipedia.org/wiki/SSSE3 SSE3] , [http://en.wikipedia.org/wiki/MMX MMX] , and [http://en.wikipedia.org/wiki/3dnow 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to check if your CPU supports these by running <code>cat /proc/cpuinfo</code> . The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

You normally don't need to add any of these flags to {{Path|/etc/portage/make.conf}} as long as you are using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code> ). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these you'll need to enable additional flags where appropriate after checking the output of <code>cat /proc/cpuinfo</code> . 

{{Note|You should check the [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options list] of x86 and x86-64-specific flags to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then you don't need to specify it; it will be turned on by using the proper <code>-march</code> setting.}}

== Optimization FAQs ==

=== But I get better performance with -funroll-loops -fomg-optimize! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt your applications when used system-wide. Even the <code>gcc</code> [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> makes code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code> , <code>-fforce-mem</code> , <code>-fforce-addr</code> , and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

The truth of the matter is that they are dangerously aggressive flags. Take a good look around the [http://forums.gentoo.org Gentoo Forums] and [http://bugs.gentoo.org Bugzilla] to see what those flags do: nothing good! 

You don't need to use those flags globally in CFLAGS or CXXFLAGS. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat your code and get your bugs marked INVALID or WONTFIX. 

You don't need dangerous flags like these. '''Don't use them''' . Stick to the basics: <code>-march</code> , <code>-O</code> , and <code>-pipe</code> . 

=== What about -O levels higher than 3? ===

Some users boast about even better performance obtained by using <code>-O4</code> , <code>-O9</code> , and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept CFLAGS like <code>-O4</code> , but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code> , nothing more. 

Need more proof? Examine the <code>gcc</code> [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup source code] : 

{{Code|-O source code|<pre>
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>
}}

As you can see, any value higher than 3 is treated as just <code>-O3</code> . 

=== What about redundant flags? ===

Oftentimes CFLAGS and CXXFLAGS that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}} . Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all CFLAGS and CXXFLAGS, or it may replace <code>-O</code> with a different level. 

The [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] outlines where and how flag filtering/replacing works. 

It's possible to circumvent <code>-O</code> filtering by redundantly listing the flags for a certain level, such as <code>-O3</code> , by doing things like: 

{{Code|Specifying redundant CFLAGS|<pre>
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>
}}

However,'''this is not a smart thing to do'''. CFLAGS are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers'' . Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

You will most likely continue to run into problems when you build a package with unacceptable flags. When you report your troubles on Bugzilla, the flags you use in {{Path|/etc/portage/make.conf}} will be readily visible and you will be told to recompile without those flags. Save yourself the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume that you know better than the developers. 

=== What about LDFLAGS? ===

The Gentoo developers have already set basic, safe LDFLAGS in the base profiles, so you don't need to change them. 

=== Can I use per-package flags? ===

{{Warning|Using per-package flags complicates debugging and support. Make sure you mention in your bug reports if you make use of this feature and what the changes are you made.}}

Information on how to use per-package environment variables (including CFLAGS) is described in the [http://www.gentoo.org//doc/en/handbook/handbook-amd64.xml?part=3&chap=6#doc_chap2 Gentoo Handbook, "Per-Package Environment Variables"] . 

== Resources ==

The following resources are of some help in further understanding optimization: 

* The [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/ GNU gcc manual] 

* Chapter 5 of the [http://www.gentoo.org//doc/en/handbook/ Gentoo Installation Handbooks] 

* <code>man make.conf</code>

* [http://en.wikipedia.org Wikipedia]

* The [http://forums.gentoo.org Gentoo Forums]

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* nightmorph
