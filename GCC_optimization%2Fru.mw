<languages />

{{Metadata|abstract=Это руководство предлагает введение в оптимизацию компилируемого кода используя безопасные, разумные флаги CFLAGS и CXXFLAGS. Оно также описывает в общих чертах теорию оптимизации.}}

Это руководство предлагает введение в оптимизацию компилируемого кода используя безопасные, разумные флаги CFLAGS и CXXFLAGS. Оно также описывает теорию оптимизации в общих чертах.

== Введение ==

=== Что такое CFLAGS и CXXFLAGS? ===

Флаги CFLAGS и CXXFLAGS - это переменные среды, которые используются для сообщения компиляторам GNU Compiler Collection (<kbd>gcc</kbd>) какие виды ключей использовать при компиляции исходного кода. CFLAGS используются для кода написанного на C, в то время как флаги CXXLFAGS - для кода написанного на C++. 

Они могут быть использованы для уменьшения количества отладочных сообщений программы, увеличения уровня сообщений об ошибках, и, конечно же, оптимизации производимого кода. [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC manual] поддерживает полный список доступных параметров и их предназначений. 

=== Как их использовать? ===

Флаги CFLAGS и CXXFLAGS могут использоваться двумя путями. Во-первых, они могут использоваться на уровне единственной программы с помощью make-файлов, генерируемых утилитой <kbd>automake</kbd>. 

Однако, Вы не должны делать этого при установке пакетов, находящихся в дереве портежей. Вместо этого, установите Ваши CFLAGS и CXXFLAGS флаги в {{Path|/etc/portage/make.conf}} . Таким образом все пакеты будут скомпилированы с использованием параметров, которые Вы укажете. 

{{CodeBox|title=Флаги CFLAGS в /etc/portage/make.conf|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important/ru|Хотя возможно использовать многострочные USE флаги, если вы попытаетесь использовать многострочную переменную CFLAGS, у вас появятся проблемы с некоторыми программами, например, с <kbd>cmake</kbd>. Удостоверьтесь, что ваша переменная CFLAGS определена в одной строке с наименьшим возможным числом пробелов, чтобы избежать этих проблем. Как пример смотрите {{Bug|500034}}.}}

Как видите, CXXFLAGS настроены на использование всех параметров, присутствующих в CFLAGS. Это то, что Вам потребуется почти безусловно. Вам вовсе не надобно указывать дополнительные параметры в CXXFLAGS.

=== Заблуждения ===

В то время как CFLAGS и CXXFLAGS могут быть очень эффективными средствами генерации менее объемных или более быстрых двоичных файлов из исходного кода, они также могут нарушить функционирование Вашего кода, увеличить его объем, замедлить время исполнения, или вызвать серьезные ошибки компиляции! 

CFLAGS - это не панацея; они не смогут автоматически заставить Вашу систему работать быстрее или двоичные файлы занимать меньше места на диске. Добавление все большего и большего количества флагов в попытке оптимизировать (или "разогнать") систему - верный рецепт для неудачи. Существует точка, в которой Вы достигнете худших результатов. 

Вопреки хвастовству, которое Вы найдете в Интернете, агрессивные флаги компиляции CFLAGS и CXXFLAGS, скорее всего, принесут больше вреда, чем пользы для Ваших программ. Держите в уме, что причина, по которой флаги существуют с самого начала - это потому что они созданы для использования в определенном месте с определенной целью. Просто потому что один отдельный CFLAG хорош для одного участка кода, вовсе не означает что он подходит для компиляции всего, что Вы можете установить на Ваш компьютер! 

=== Готовы? ===

Теперь, когда Вы знаете о некоторых рисках, давайте посмотрим на некоторые из разумных, безопасных оптимизаций для Вашего компьютера. Они окажут Вам большую пользу и расположат к Вам разработчиков в следующий раз, когда Вы будете сообщать о проблеме на [http://bugs.gentoo.org Bugzilla] . (Разработчики обычно просят вас перекомпилировать пакет с минимальным количеством переменных CFLAGS для того, чтобы определить, продолжает ли проблема существовать. Запомните, агрессивные флаги могут разрушить код.) 

== Оптимизация ==

=== Основы ===

The goal behind using CFLAGS and CXXFLAGS is to create code tailor-made to your system; it should function perfectly while being lean and fast, if possible. Sometimes these conditions are mutually exclusive, so we'll stick with combinations known to work well. Ideally, they are the best available for any CPU architecture. We'll mention the aggressive flags later so you know what to look out for. We won't discuss every option listed on the <kbd>gcc</kbd> manual (there are hundreds), but we'll cover the basic, most common flags. 

{{Note|Whenever you're not sure what a flag actually does, refer to the relevant chapter of the [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual] . If you're still stumped, try Google, or check out the <kbd>gcc</kbd> [http://gcc.gnu.org/lists.html mailing lists] .}}

=== -march ===

Самым первым и наиболее важным параметром является <code>-march</code>. Он сообщает компилятору, какой код генерировать для [https://en.wikipedia.org/wiki/Microarchitecture архитектуры] (соответствующие английские термины: “architecture” или “arch”. — Прим. пер.) вашего процессора; он сообщает компилятору, что тот должен генерировать код для определенного типа CPU. Разные типы CPU имеют разные возможности, поддерживают различные наборы команд и обладают разными способами исполнения кода. Флаг <code>-march</code> проинструктирует компилятор генерировать код специально для вашего типа CPU, со всеми доступными возможностями, особенностями, наборами команд, интересными функциями и так далее. 

Хотя переменная CHOST в {{Path|/etc/portage/make.conf}} и указывает основную используемую архитектуру, параметр <code>-march</code> все еще должен использоваться, так чтобы программы были оптимизированы для Вашего конкретного процессора. Процессоры x86 и x86-64 (в числе других) должны использовать флаг <code>-march</code>. 

Какой вид CPU Вы имеете? Чтобы это узнать, введите следующую команду: 

{{Cmd|cat /proc/cpuinfo}}

To get more details, including <code>march</code> and <code>mtune</code> values, use:

{{Cmd|<nowiki>gcc -c -Q -march=native --help=target</nowiki>}}

Давайте теперь рассмотрим <code>-march</code> в действии. Этот пример приведен для более старого чипа Pentium III: 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium III|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

А это другой пример для 64-разрядного AMD CPU: 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

Если Вы все еще не уверены, каким видом CPU Вы обладаете, вы можете просто использовать параметр <code>-march=native</code> . Когда используется этот флаг, GCC попытается распознать Ваш процессор и автоматически установит для него подходящие флаги. '''Однако, Вы не должны его использовать, если Вы собираетесь компилировать пакеты для другого CPU!''' 

{{Warning|Do '''not''' use <code>-march{{=}}native</code> or <code>-mtune{{=}}native</code> in the <code>CFLAGS</code> or <code>CXXFLAGS</code> variables of {{Path|make.conf}} when compiling with <tt>[[Distcc#-march.3Dnative|distcc]]</tt>.}}

Итак, если вы компилируете пакеты на одном компьютере, но собираетесь запускать их на другом (например, используя сборку на быстром компьютере для более медленного, старого компьютера), тогда ''не используйте'' <code>-march=native</code> . ''Native'' означает, что генерируемый код будет запускаться ''только'' на том типе CPU, на котором он был собран. Приложения скомпилированные с <code>-march=native</code> на процессоре AMD Athlon 64 CPU не смогут запуститься на более старом VIA C3 CPU. 

Also available are the <code>-mtune</code> and <code>-mcpu</code> flags. These flags are normally only used when there is no available <code>-march</code> option; certain processor architectures may require <code>-mtune</code> or even <code>-mcpu</code>. Unfortunately, <kbd>gcc</kbd>'s behavior isn't very consistent with how each flag behaves from one architecture to the next. 

На процессорах x86 и x86-64, параметр <code>-march</code> будет генерировать код, предназначенный специально для этих типов процессоров, используя все доступные наборы команд и корректный двоичный интерфейс приложений; он не будет обладать обратной совместимостью с более старыми/другими типами процессоров. Если Вам не требуется исполнять код на чем либо другом, кроме системы, на которой работает Gentoo, продолжайте использовать <code>-march</code> . Вы должны рассмотреть использование <code>-mtune</code> только тогда, когда Вам необходимо сгенерировать код для более старых процессоров, таких как i386 и i486. Параметр <code>-mtune</code> производит более общий код, чем <code>-march</code>; хотя он и настроит код под определенный процессор, он не будет рассматривать доступные наборы команд и двоичный интерфейс приложений. Не используйте <code>-mcpu</code> на системах с x86 или x86-64, так как это не рекомендуется для этих архитектур. 

Only non-x86/x86-64 CPUs (such as Sparc, Alpha, and PowerPC) may require <code>-mtune</code> or <code>-mcpu</code> instead of <code>-march</code>. On these architectures, <code>-mtune</code> / <code>-mcpu</code> will sometimes behave just like <code>-march</code> (on x86/x86-64)... but with a different flag name. Again, <kbd>gcc</kbd>'s behavior and flag naming just isn't consistent across architectures, so be sure to check the <kbd>gcc</kbd> [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] to determine which one you should use for your system. 

{{Note|For more suggested <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> settings, please read chapter 5 of the appropriate [[HandBook:Main_Page|Gentoo Installation Handbook]] for your arch. Also, read the <kbd>gcc</kbd> manual's list of [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options], as well as more detailed explanations about the differences between <code>-march</code>, <code>-mcpu</code>, and <code>-mtune</code>.}}

=== -O ===

Следующая по списку - переменная <code>-O</code> . Она управляет всем уровнем оптимизации. Это приводит к тому, что компиляция кода занимает больше времени, и сможет занять гораздо больше памяти, особенно когда  Вы увеличиваете уровень оптимизации. 

Существует семь видов настроек переменной <code>-O</code>: <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , <code>-Os</code>, <code>-Og</code>, и <code>-Ofast</code> . Вы должны использовать только одну из них в {{Path|/etc/portage/make.conf}} . 

За исключением <code>-O0</code>, каждая из настроек с префиксом <code>-O</code> активирует несколько дополнительных флагов, поэтому удостоверьтесь, что Вы прочитали главу руководства GCC по [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options параметрам оптимизации] для изучения того, какие флаги активируются на каждом уровне с приставкой <code>-O</code>, также как и некоторые из объяснений того, что они делают. 

Давайте исследуем каждый уровень оптимизации: 

* <code>-O0</code>: Этот уровень (буква "O" и ноль за ней) отключает оптимизацию полностью и является уровнем по умолчанию, если никакого уровня с префиксом <code>-O</code> не указано в переменных CFLAGS или CXXFLAGS. Это сокращает время компиляции и может улучшить данные для отладки, но некоторые приложения не будут работать должным образом без оптимизации. Эта опция не рекомендуется, за исключением использования в целях отладки.

* <code>-O1</code> : Это наиболее простой уровень оптимизации. Компилятор попытается сгенерировать быстрый, занимающий меньше объема код, без затрачивания наибольшего времени компиляции. Он достаточно простой, но должен всегда выполнять свою работу.

* <code>-O2</code> : Шаг вперед из <code>-O1</code> . Это ''рекомендуемый'' уровень оптимизации, до тех пор пока Вам не понадобится что-то особенное. <code>-O2</code> активирует несколько дополнительных флагов вдобавок к флагам, активированным на <code>-O1</code> . С параметром <code>-O2</code> , компилятор попытается увеличить производительность кода без нарушения размера, и без затрачивания большого количества времени компиляции.

* <code>-O3</code> : Это наибольший возможный уровень оптимизации. Это дает возможность оптимизации, являющейся дорогостоящей с точки зрения времени компиляции и потребления памяти. Компиляция с <code>-O3</code> не является гарантированным способом повышения производительности, и на самом деле во многих случаях может привести к замедлению системы из-за больших двоичных файлов и увеличения потребления памяти. <code>-O3</code> известен также тем, что ломает несколько пакетов. Поэтому, использование <code>-O3</code> не рекомендуется.

* <code>-Os</code> : На этом уровне Ваш код будет оптимизирован по объему. Он активирует все параметры <code>-O2</code>, которые не приводят к увеличению размера генерируемого кода. Он может быть полезным на компьютерах, которые обладают чрезвычайно ограниченным пространством жесткого диска и/или имеют процессоры с небольшим размером кэша.

* <code>-Og</code> : В GCC 4.8 был введен новый общий уровень оптимизации -Og. Он удовлетворяет потребность в быстрой компиляции и имеет превосходные возможности для отладки, обеспечивая при этом приемлемый уровень производительности во время выполнения. Общий опыт разработки должен быть лучше, чем с уровнем оптимизации по умолчанию -O0. Обратите внимание, что -Og не означает -g, он просто отключает оптимизацию кода, которая может помешать отладке.

* <code>-Ofast</code>: Новое в GCC 4.7, состоит из <code>-O3</code> плюс <code>-ffast-math</code>, <code>-fno-protect-parens</code>, и <code>-fstack-arrays</code>. Этот параметр нарушает строгое соответствие стандарту, и не рекомендуется для использования.

Как упомянуто ранее, параметр <code>-O2</code> - рекомендуемый уровень оптимизации. Если компиляция пакета выдает сообщения об ошибках, убедитесь, что Вы используете параметр <code>-O2</code> . В качестве выхода, попробуйте установить Ваши переменные CFLAGS и CXXFLAGS на наименьший уровень оптимизации, такой как <code>-O1</code>, или даже <code>-O0 -g2 -ggdb</code> (для сообщения об ошибках и проверки возможных проблем).

=== -pipe ===

Общеупотребительный флаг - <code>-pipe</code>. Этот флаг не имеет влияния на генерируемый код, но ускоряет процесс компиляции. Он сообщает компилятору, чтобы тот использовал конвейер (pipe) вместо временных файлов в течение разных стадий компиляции, которые используют большее количество памяти. На системах с небольшим количеством памяти, GCC может завершить свою работу. В этом случае, не используйте этот флаг. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but you may need to activate it yourself by adding it to your flags. Though the <kbd>gcc</kbd> manual does not specify all architectures it is turned on by using <code>-O</code>, you will need to explicitly activate it on x86, with <kbd>gcc</kbd> up to version 4.6 or when using <code>-Os</code>. However, using this flag will make debugging hard to impossible. 

В частности, это делает устранение неполадок в Java-приложениях намного сложнее, хотя код, написанный на Java - не единственный, который затронут использованием этого флага. Поэтому, в то время как использование этого флага может помочь, оно также затрудняет отладку; трассировка стека, в частности, будет бесполезна. Однако, если Вы не планируете отлаживать большое количество программ и не добавляли какие-либо другие переменные CFLAGS, связанные с отладкой, такие как <code>-ggdb</code> , то Вы можете попытаться использовать <code>-fomit-frame-pointer</code> . 

{{Important/ru|''Не комбинируйте''<code>-fomit-frame-pointer</code> с подобным флагом <code>-momit-leaf-frame-pointer</code> . Использование последнего флага не рекомендуется, так как <code>-fomit-frame-pointer</code> уже выполняет всю работу. Кроме того, показано, что <code>-momit-leaf-frame-pointer</code> негативно влияет на производительность кода. }}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

Эти флаги разрешают наборы команд [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE] , [http://en.wikipedia.org/wiki/SSE2 SSE2] , [http://en.wikipedia.org/wiki/SSSE3 SSE3] , [http://en.wikipedia.org/wiki/MMX MMX] , и [http://en.wikipedia.org/wiki/3dnow 3DNow!] для архитектур x86 и x86-64. Они используются в основном в мультимедиа, играх, и других вычислительных задачах с интенсивным использованием плавающей точки, хотя они также включают несколько других математических расширений. Эти наборы команд предоставляются большинством современных процессоров. 

{{Important/ru|Убедитесь, что Вы проверили Ваш процессор на их поддержку, введя команду <code>cat /proc/cpuinfo</code> . Результат будет включать любые дополнительные наборы команд, которые поддерживаются Вашим процессором. Заметьте, что '''pni''' - это просто другое имя для SSE3.}}

Обычно, Вы не нуждаетесь в добавлении каких-либо из этих флагов в {{Path|/etc/portage/make.conf}} пока Вы используете корректный параметр <code>-march</code> (например, <code>-march=nocona</code> подразумевает использование <code>-msse3</code> ). Некоторые заметные исключения - новые процессоры VIA и AMD64, которые поддерживают инструкции, не включаемые параметром <code>-march</code> (такие как SSE3). Для таких процессоров, Вам нужно включить дополнительные флаги, где это доступно, после проверки результата работы команды <code>cat /proc/cpuinfo</code> . 

{{Note/ru|Вы должны свериться со [http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86-64-Options.html#i386-and-x86-64-Options списком] флагов, характерных для архитектур x86 и x86-64, чтобы увидеть, какие из этих инструкций активированы соответствующим флагом типа процессора. Если инструкция перечислена, то вам не нужно ее указывать; она будет включена с помощью подходящей настройки <code>-march</code>.}}

== FAQ по оптимизации ==

=== Но я получаю лучшую производительность с -funroll-loops -fomg-optimize! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt your applications when used system-wide. Even the <kbd>gcc</kbd> [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> makes code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

Истина в том, что это чрезвычайно агрессивные флаги. Посмотрите по [https://forums.gentoo.org/ форумам Gentoo] и [https://bugs.gentoo.org/ Bugzilla], чтобы увидеть, что эти флаги могут сделать: ничего хорошего! 

Вам не нужно использовать эти флаги глобально, в переменных CFLAGS и CXXFLAGS. Они только ухудшат производительность. Может показаться, что Вы имеете высокопроизводительную систему, работающую по последнему слову техники, но они не делают ничего, кроме раздувания кода и приводят к тому, что Ваши сообщения о багах помечаются как INVALID или WONTFIX. 

Вам не требуются такие опасные флаги, как эти. '''Не используйте их'''. Придерживайтесь основ: <code>-march</code> , <code>-O</code> , и <code>-pipe</code> .

=== Что по поводу уровней оптимизации -O больших чем 3? ===

Некоторые пользователи хвалятся даже большей производительностью, достигнутой использованием <code>-O4</code> , <code>-O9</code> , и так далее, но в действительности, уровни <code>-O</code> большие чем 3 не имеют никакого эффекта. Компилятор может принимать переменные CFLAGS, такие как <code>-O4</code> , но, на самом деле, ничего с ними не делать. Он только выполняет оптимизацию до уровня <code>-O3</code> , и ничего больше: 

Need more proof? Examine the [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup source code]: 

{{CodeBox|title=-O source code|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

Как видите, любое значение, большее тройки, рассматривается как <code>-O3</code> .

=== Что насчет компиляции не на целевой машине? ===

Некоторые читатели могут спросить, не приведет ли компиляция не на целевой машине, сильно отличающейся архитектурой процессора или структурой GCC, к плохому качеству оптимизации (по сравнению с нативной компиляцией). Ответ прост: '''Нет'''. Независимо от используемого оборудования, на котором проводится компиляция, и от значения переменной CHOST, с использованием которой был собран GCC, если используются те же аргументы <small>(кроме <code>-march=native</code>)</small> и та же версия GCC <small>(хотя небольшие оптимизации могут отличаться)</small>, результирующий уровень оптимизации останется строго тем же.

Например, если Gentoo установлен на компьютере, на котором переменная CHOST для GCC равна ''i686-pc-linux-gnu'', а сервер [[Distcc]] настроен на другом компьютере, на котором CHOST для GCC равна ''i486-linux-gnu'', то не нужно бояться, что результаты будут менее оптимальны из-за отличающейся архитектуры удаленного компилятора и/или оборудования. Результат будет оптимизирован в той же степени, как и при сборке на целевом компьютере, если, конечно, обоим компиляторам передаются одинаковые параметры (и параметр <code>-march</code> не включает значение <code>native</code>).  В данном конкретном случае целевую архитектуру нужно явно определять, как указано в статье [[Distcc#-march.3Dnative|Distcc и -march=native]].

Единственная разница в поведении между двумя версиями GCC, построенными с использованием разных архитектур в значении параметра <code>-march</code> по умолчанию. Он берется из переменной CHOST для GCC, если он не указан явно в командной строке.

=== А что об избыточных флагах? ===

Часто переменные CFLAGS и CXXFLAGS, которые включаются на разных уровнях <code>-O</code>, указаны избыточно в {{Path|/etc/portage/make.conf}} . Иногда, это сделано по неосведомленности, но также и для того, чтобы избежать отфильтровывание флагов или их замещение. 

Фильтрация/замещение флагов используется во многих ebuild-файлах, находящихся в дереве портежей. Обычно, это делается потому что пакеты не компилируются на определенных уровнях <code>-O</code>, или когда исходный код очень чувствителен к дополнительно используемым флагам. Ebuild-файл или отфильтровывает некоторые или все переменные CFLAGS и CXXFLAGS, или может заменить <code>-O</code> другим уровнем. 

[http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Руководство разработчика Gentoo] описывает в общих чертах, где и как работает фильтрация/замещение флагов. 

Возможно обойти фильтрацию уровней <code>-O</code>, избыточно перечисляя флаги для определенного уровня, например <code>-O3</code> , делая такие вещи как: 

{{CodeBox|title=Specifying redundant CFLAGS|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

Однако, '''это не самая умная вещь, которую можно сделать'''. CFLAGS отфильтровываются не зря! Когда флаги фильтруются, это означает, что собирать пакет с этими флагами небезопасно. Очевидно, что ''небезопасно'' компилировать всю Вашу систему с <code>-O3</code> если некоторые из флагов, включенных на этом уровне, вызовут проблемы с определенными пакетами. Следовательно, Вы не должны пытаться ''обхитрить'' разработчиков, которые поддерживают эти пакеты. ''Доверяйте разработчикам''. Фильтрация флагов и их замена делаются для вашей же пользы! Если ebuild-файл указывает альтернативные флаги, то не пытайтесь это обойти. 

Скорее всего, вы продолжите испытывать проблемы, когда Вы собираете пакет с недопустимыми флагами. При сообщении о проблемах на Bugzilla, флаги, которые Вы используете в {{Path|/etc/portage/make.conf}} будут легко видны, и Вам скажут, чтобы Вы перекомпилировали пакет без этих флагов. Сохраните себя от проблем с перекомпиляцией не используя избыточные флаги с самого начала! Не предполагайте автоматически, что Вы знаете больше, чем разработчики.

=== Что по поводу LDFLAGS? ===

Разработчики Gentoo уже установили простые, безопасные LDFLAGS в базовых профилях, поэтому Вам не нужно их изменять. 

=== Могу ли я использовать флаги для отдельных пакетов? ===

{{Warning/ru|Использование флагов для отдельных пакетов затрудняет отладку и поддержку. Удостоверьтесь, что Вы упоминаете в Ваших баг-репортах об использовании этой возможности и об изменениях, которые Вы внесли.}}

Information on how to use per-package environment variables (including CFLAGS) is described in the [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]].

== Источники ==

Следующие источники могут быть полезными в дальнейшем изучении оптимизации: 

* [http://gcc.gnu.org/onlinedocs/ Онлайн-документация GCC] 

* Chapter 5 of the [[Handbook:Main_Page|Gentoo Installation Handbooks]]

* <kbd>man make.conf</kbd>

* [https://en.wikipedia.org/ Wikipedia]

* [https://forums.gentoo.org/ форумы Gentoo]

{{Migrated|originalauthors=nightmorph}}
