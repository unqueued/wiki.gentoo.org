<languages />

{{Metadata|abstract=Это руководство предлагает введение в оптимизацию компилируемого кода используя безопасные, разумные флаги CFLAGS и CXXFLAGS. Оно также описывает в общих чертах теорию оптимизации.}}

Это руководство предлагает введение в оптимизацию компилируемого кода используя безопасные, разумные флаги <var>CFLAGS</var> и <var>CXXFLAGS</var>. Оно также описывает теорию оптимизации в общих чертах.

== Введение ==

=== Что такое CFLAGS и CXXFLAGS? ===

<var>CFLAGS</var> и <var>CXXFLAGS</var> - это переменные среды, которые используются для сообщения компилятору GNU Compiler Collection (GCC) какие виды ключей использовать при компиляции исходного кода. Переменная <var>CFLAGS</var> используются для компиляции кода написанного на C, в то время как переменная <var>CXXLFAGS</var> - для кода написанного на C++. 

Они могут быть использованы для уменьшения количества отладочных сообщений программы, увеличения уровня сообщений об ошибках, и, конечно же, оптимизации производимого кода. [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC manual] поддерживает полный список доступных параметров и их предназначений.

=== Как их использовать? ===

<var>CFLAGS</var> и <var>CXXFLAGS</var> могут использоваться двумя путями. Во-первых, они могут использоваться на уровне единственной программы с помощью make-файлов, генерируемых программой {{c|automake}}. 

Однако, не нужно делать этого при установке пакетов, находящихся в дереве Portage. Вместо этого, установите <var>CFLAGS</var> и <var>CXXFLAGS</var> переменные в {{Path|/etc/portage/make.conf}}. Таким образом все пакеты будут скомпилированы с использованием параметров, которые указаны в {{Path|make.conf}}.

{{CodeBox|title=Настройка CFLAGS в /etc/portage/make.conf|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important|Хотя можно иметь <var>CFLAGS</var> флаги, записанные в несколько строк, это будет приводить к ошибкам в некоторых приложениях, например, в {{c|cmake}}. Убедитесь, что CFLAGS записаны в одну строку и с короткими пробелам, во избежании лишних проблем. Посмотрите {{Bug|500034}} например.}}

Как видно в примере выше, <var>CXXFLAGS</var> настроены на использование всех параметров, присутствующих в <var>CFLAGS</var>. Почти каждая система должна быть настроена таким образом; дополнительные параметры в <var>CXXFLAGS</var> ''крайне редко'' необходимы в некоторых случаях.

=== Заблуждения ===

В то время как <var>CFLAGS</var> и <var>CXXFLAGS</var> могут быть очень эффективными средствами генерации менее объемных или более быстрых двоичных файлов из исходного кода, они также могут нарушить функционирование кода, увеличить его объем, замедлить время исполнения. Неправильная их настройка может вызвать ошибки компиляции! 

<var>CFLAGS</var> - это не панацея; они не смогут автоматически заставить систему работать быстрее или уменьшить размер двоичных файлов на диске. Добавление большего количества флагов в попытке оптимизировать (или "разогнать") систему - верный рецепт для неудачи. Ухудшить разные показатели довольно легко при работе с <var>CFLAGS</var>. 

Вопреки хвастовству, которое можно найти в Интернете, агрессивные флаги компиляции <var>CFLAGS</var> и <var>CXXFLAGS</var>, скорее всего, принесут больше вреда, чем пользы для программ. Держите в уме, что они созданы для использования в ''определенном'' месте с ''определенной'' целью. Несколько флагов работает как задумано глобально.

=== Готовы? ===

Теперь, зная о некоторых рисках, давайте посмотрим на некоторые из разумных, безопасных оптимизаций. Они окажут большую пользу и расположат разработчиков в следующий раз, когда будете сообщать о проблеме на [https://bugs.gentoo.org/ Bugzilla]. (Разработчики обычно просят пользователей перекомпилировать пакет с минимальным количеством переменных <var>CFLAGS</var> для того, чтобы определить, продолжает ли проблема существовать. Запомните: агрессивные флаги могут разрушить код!) 

== Оптимизация ==

=== Основы ===

The goal behind <var>CFLAGS</var> and <var>CXXFLAGS</var> is to create code tailor-made to your system; it should function perfectly while being lean and fast, if possible. Sometimes these conditions are mutually exclusive, so this guide will stick to combinations known to work well. Ideally, they are the best available for any CPU architecture. For informational purposes, aggressive flag use will be covered later. Not every option listed on the GCC manual (there are hundreds) will be discussed, but basic, most common flags will be reviewed. 

{{Note|When unaware of what a flag does refer to the relevant chapter of the [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual]. If still stumped after viewing the manual, try a search engine or check out the [http://gcc.gnu.org/lists.html GCC mailing lists].}}

=== -march ===

The first and most important option is <code>-march</code>. This tells the compiler what code it should produce for the system's [https://en.wikipedia.org/wiki/Microarchitecture processor architecture] (or ''arch''); it tells GCC that it should produce code for a certain kind of CPU. Different CPUs have different capabilities, support different instruction sets, and have different ways of executing code. The <code>-march</code> flag will instruct the compiler to produce specific code for the system's CPU, with all its capabilities, features, instruction sets, quirks, and so on. 

Хотя переменная <code>CHOST</code> в {{Path|/etc/portage/make.conf}} и указывает основную используемую архитектуру, параметр <code>-march</code> все еще должен использоваться, так чтобы программы были оптимизированы для конкретного процессора. Процессоры x86 и x86-64 (в числе других) должны использовать флаг <code>-march</code>. 

Какой вид CPU имеется в системе? Чтобы это узнать, введите следующую команду: 

{{Cmd|cat /proc/cpuinfo}}

Более детальную информацию, включая значения <code>march</code> и <code>mtune</code>, можно получить с помощью следующей команды:

{{Cmd|<nowiki>gcc -c -Q -march=native --help=target</nowiki>}}

Давайте теперь рассмотрим <code>-march</code> в действии. Этот пример приведен для более старого чипа Pentium III: 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium III example|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

А это другой пример для 64-разрядного AMD CPU: 

{{FileBox|filename=/etc/portage/make.conf|title=пример для AMD64|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

If the type of CPU is undetermined, or if the user does not know what setting to choose, it is possible use the <code>-march=native</code> setting. When this flag is used, GCC will attempt to detect the processor and automatically set appropriate flags for it. '''However, this should not be used when intending to compile packages for different CPUs!''' 

{{Warning|'''Не''' используйте <code>-march{{=}}native</code> или <code>-mtune{{=}}native</code> в переменных <var>CFLAGS</var> или <var>CXXFLAGS</var> файла {{Path|make.conf}} при компиляции с помощью {{c|[[Distcc/ru#-march.3Dnative|distcc]]}}.}}

Если компилируете пакеты на одном компьютере, чтобы затем запустить их на другом (например, используя сборку на быстром компьютере для более медленного, старого компьютера), тогда ''не используйте'' <code>-march=native</code> . ''Native'' означает, что генерируемый код будет запускаться ''только'' на том типе CPU, на котором он был собран. Приложения скомпилированные с <code>-march=native</code> на процессоре AMD Athlon 64 CPU '''''не''''' смогут запуститься на более старом VIA C3 CPU. 

Also available are the <code>-mtune</code> and <code>-mcpu</code> flags. These flags are normally only used when there is no available <code>-march</code> option; certain processor architectures may require <code>-mtune</code> or even <code>-mcpu</code>. Unfortunately, GCC's behavior isn't very consistent with how each flag behaves from one architecture to the next. 

On x86 and x86-64 CPUs, <code>-march</code> will generate code specifically for that CPU using its available instruction sets and the correct ABI; it will have no backwards compatibility for older/different CPUs. Consider using <code>-mtune</code> when generating code for older CPUs such as i386 and i486. <code>-mtune</code> produces more generic code than <code>-march</code>; though it will tune code for a certain CPU, it does not take into account available instruction sets and ABI. Do not use <code>-mcpu</code> on x86 or x86-64 systems, as it is deprecated for those arches. 

Only non-x86/x86-64 CPUs (such as Sparc, Alpha, and PowerPC) may require <code>-mtune</code> or <code>-mcpu</code> instead of <code>-march</code>. On these architectures, <code>-mtune</code> / <code>-mcpu</code> will sometimes behave just like <code>-march</code> (on x86/x86-64) but with a different flag name. Again, GCC's behavior and flag naming is not consistent across architectures, so be sure to check the GCC [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] to determine which one should be used. 

{{Note|For more suggested <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> settings, please read chapter 5 of the appropriate [[HandBook:Main_Page|Gentoo Installation Handbook]] for the arch. Also, read the GCC manual's list of [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options], as well as more detailed explanations about the differences between <code>-march</code>, <code>-mcpu</code>, and <code>-mtune</code>.}}

=== -O ===

Next up is the <code>-O</code> variable. This variable controls the overall level of optimization. Changing this value will make the code compilation take more time and will use much more memory, especially as the level of optimization is increased. 

There are seven <code>-O</code> settings: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code>, and <code>-Ofast</code>. Only use one of them in {{Path|/etc/portage/make.conf}}

За исключением <code>-O0</code>, каждая из настроек с префиксом <code>-O</code> активирует несколько дополнительных флагов, поэтому удостоверьтесь, что Вы прочитали главу руководства GCC по [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options параметрам оптимизации] для изучения того, какие флаги активируются на каждом уровне с приставкой <code>-O</code>, также как и некоторые из объяснений того, что они делают. 

Let us examine each optimization level: 

* <code>-O0</code>: Этот уровень (буква "O" и ноль за ней) отключает оптимизацию полностью и является уровнем по умолчанию, если никакого уровня с префиксом <code>-O</code> не указано в переменных <var>CFLAGS</var> или <var>CXXFLAGS</var>. Это сокращает время компиляции и может улучшить данные для отладки, но некоторые приложения не будут работать должным образом без оптимизации. Эта опция не рекомендуется, за исключением использования в целях отладки.

*  <code>-O1</code>: the most basic optimization level. The compiler will try to produce faster, smaller code without taking much compilation time. It is basic, but it should get the job done all the time.

*  <code>-O2</code>: A step up from <code>-O1</code>. The ''recommended'' level of optimization unless the system has special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code>. With <code>-O2</code>, the compiler will attempt to increase code performance without compromising on size, and without taking too much compilation time.

*  <code>-O3</code>: the highest level of optimization possible. It enables optimizations that are expensive in terms of compile time and memory usage.  Compiling with <code>-O3</code> is not a guaranteed way to improve performance, and in fact, in many cases, can slow down a system due to larger binaries and increased memory usage. <code>-O3</code> is also known to break several packages. Using <code>-O3</code> is not recommended.

*  <code>-Os</code>: optimizes code for size. It activates all <code>-O2</code> options that do not increase the size of the generated code. It can be useful for machines that have extremely limited disk storage space and/or CPUs with small cache sizes.

* <code>-Og</code> : В GCC 4.8 был введен новый общий уровень оптимизации -Og. Он удовлетворяет потребность в быстрой компиляции и имеет превосходные возможности для отладки, обеспечивая при этом приемлемый уровень производительности во время выполнения. Общий опыт разработки должен быть лучше, чем с уровнем оптимизации по умолчанию -O0. Обратите внимание, что -Og не означает -g, он просто отключает оптимизацию кода, которая может помешать отладке.

* <code>-Ofast</code>: Новое в GCC 4.7, состоит из <code>-O3</code> плюс <code>-ffast-math</code>, <code>-fno-protect-parens</code>, и <code>-fstack-arrays</code>. Этот параметр нарушает строгое соответствие стандарту, и не рекомендуется для использования.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and while not using <code>-O2</code>, try rebuilding with that option. As a fallback option, try setting the <var>CFLAGS</var> and <var>CXXFLAGS</var> to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).

=== -pipe ===

A common flag is <code>-pipe</code>. This flag has no effect on the generated code, but it makes the compilation process ''faster''. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, GCC might get killed. In those cases do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but it may need to activated. In that case add it to the flags. Though the GCC manual does not specify all architectures, it is turned on by using the <code>-O</code> option. It's still necessary to explicitly enable the <code>-fomit-frame-pointer</code> option, to activate it on x86-32 with GCC up to version 4.6, or when using <code>-Os</code> on x86-32 with any version of GCC. However, using <code>-fomit-frame-pointer</code> will make debugging hard or impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. When not doing software debugging and no other debugging-related <var>CFLAGS</var> such as <code>-ggdb</code> have been used, then try using <code>-fomit-frame-pointer</code>. 

{{Important/ru|''Не комбинируйте''<code>-fomit-frame-pointer</code> с подобным флагом <code>-momit-leaf-frame-pointer</code> . Использование последнего флага не рекомендуется, так как <code>-fomit-frame-pointer</code> уже выполняет всю работу. Кроме того, показано, что <code>-momit-leaf-frame-pointer</code> негативно влияет на производительность кода. }}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extentions] (SSE), [http://en.wikipedia.org/wiki/SSE2 SSE2], [http://en.wikipedia.org/wiki/SSSE3 SSE3], [http://en.wikipedia.org/wiki/MMX_(instruction_set) MMX], and [http://en.wikipedia.org/wiki/3dnow 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to see if the CPU supports these instruction sets by running <kbd>cat /proc/cpuinfo</kbd>. The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

Normally none of these flags need to be added to {{Path|/etc/portage/make.conf}}, as long as the system is using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code>). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these additional flags will need to be enabled where appropriate after checking {{Path|/proc/cpuinfo}}. 

{{Note|Check the [http://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags] to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then it does not need to be separately specified; it will be turned on by using the proper <code>-march</code> setting.}}

== FAQ по оптимизации ==

=== Но я получаю лучшую производительность с -funroll-loops -fomg-optimize! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt applications when used system-wide. Even the GCC [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> will make code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

Истина в том, что это чрезвычайно агрессивные флаги. Посмотрите по [https://forums.gentoo.org/ форумам Gentoo] и [https://bugs.gentoo.org/ Bugzilla], чтобы увидеть, что эти флаги могут сделать: ничего хорошего! 

You do not need to use those flags globally in <var>CFLAGS</var> or <var>CXXFLAGS</var>. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat the code and get your bugs marked INVALID or WONTFIX. 

Вам не требуются такие опасные флаги, как эти. '''Не используйте их'''. Придерживайтесь основ: <code>-march</code> , <code>-O</code> , и <code>-pipe</code> .

=== Что по поводу уровней оптимизации -O больших чем 3? ===

Some users boast about even better performance obtained by using <code>-O4</code>, <code>-O9</code>, and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept <var>CFLAGS</var> like <code>-O4</code>, but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code>, nothing more. 

Нужно больше доказательств? Исследуйте  [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup исходный код]: 

{{CodeBox|title=Исходный код параметра -O|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

Как видите, любое значение, большее тройки, рассматривается как <code>-O3</code> .

=== Что насчет компиляции не на целевой машине? ===

Некоторые читатели могут спросить, не приведет ли компиляция не на целевой машине, сильно отличающейся архитектурой процессора или структурой GCC, к плохому качеству оптимизации (по сравнению с нативной компиляцией). Ответ прост: '''Нет'''. Независимо от используемого оборудования, на котором проводится компиляция, и от значения переменной CHOST, с использованием которой был собран GCC, если используются те же аргументы <small>(кроме <code>-march=native</code>)</small> и та же версия GCC <small>(хотя небольшие оптимизации могут отличаться)</small>, результирующий уровень оптимизации останется строго тем же.

Например, если Gentoo установлен на компьютере, на котором переменная CHOST для GCC равна ''i686-pc-linux-gnu'', а сервер [[Distcc]] настроен на другом компьютере, на котором CHOST для GCC равна ''i486-linux-gnu'', то не нужно бояться, что результаты будут менее оптимальны из-за отличающейся архитектуры удаленного компилятора и/или оборудования. Результат будет оптимизирован в той же степени, как и при сборке на целевом компьютере, если, конечно, обоим компиляторам передаются одинаковые параметры (и параметр <code>-march</code> не включает значение <code>native</code>).  В данном конкретном случае целевую архитектуру нужно явно определять, как указано в статье [[Distcc#-march.3Dnative|Distcc и -march=native]].

Единственная разница в поведении между двумя версиями GCC, построенными с использованием разных архитектур в значении параметра <code>-march</code> по умолчанию. Он берется из переменной CHOST для GCC, если он не указан явно в командной строке.

=== А что об избыточных флагах? ===

Oftentimes <var>CFLAGS</var> and <var>CXXFLAGS</var> that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}}. Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all <var>CFLAGS</var> and <var>CXXFLAGS</var>, or it may replace <code>-O</code> with a different level. 

[http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Руководство разработчика Gentoo] описывает в общих чертах, где и как работает фильтрация/замещение флагов. 

Возможно обойти фильтрацию уровней <code>-O</code>, избыточно перечисляя флаги для определенного уровня, например <code>-O3</code> , делая такие вещи как: 

{{CodeBox|title=Указание избыточных CFLAGS|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

However, '''this is not a smart thing to do'''. <var>CFLAGS</var> are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers''. Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

Скорее всего, вы продолжите испытывать проблемы, когда Вы собираете пакет с недопустимыми флагами. При сообщении о проблемах на Bugzilla, флаги, которые Вы используете в {{Path|/etc/portage/make.conf}} будут легко видны, и Вам скажут, чтобы Вы перекомпилировали пакет без этих флагов. Сохраните себя от проблем с перекомпиляцией не используя избыточные флаги с самого начала! Не предполагайте автоматически, что Вы знаете больше, чем разработчики.

=== Что по поводу LDFLAGS? ===

The Gentoo developers have already set basic, safe <var>LDFLAGS</var> in the base profiles, so they do not need to be changed.

=== Могу ли я использовать флаги для отдельных пакетов? ===

{{Warning/ru|Использование флагов для отдельных пакетов затрудняет отладку и поддержку. Удостоверьтесь, что Вы упоминаете в Ваших баг-репортах об использовании этой возможности и об изменениях, которые Вы внесли.}}

Information on how to use per-package environment variables (including <var>CFLAGS</var>) is described in the [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]].

== Источники ==

Следующие источники могут быть полезными в дальнейшем изучении оптимизации: 

* [http://gcc.gnu.org/onlinedocs/ Онлайн-документация GCC] 

* Глава 5 [[Handbook:Main_Page/ru|настольной книги по установке Gentoo]]

* <kbd>man make.conf</kbd>

* [https://en.wikipedia.org/ Wikipedia]

* [https://forums.gentoo.org/ форумы Gentoo]

{{Migrated|originalauthors=nightmorph}}
