<languages />

{{Metadata|abstract=这篇文章描述了升级到新内核步骤。}}

这篇文章描述了升级到新内核步骤。

== 安装 并且使用一个新内核 ==

当安装新的内核源代码后，升级您的内核或许是一个很棒的主意。当您运行以下命令时，新的内核源代码有时会随着系统的更新而安装。

{{RootCmd|emerge --ask --update --deep --with-bdeps{{=}}y --newuse @world}}

当然，也可以使用下面的命令直接安装内核（如果您使用的是hardened profile，请用“hardened-sources”替换“gentoo-sources”）:

{{RootCmd|emerge --ask --update --deep --with-bdeps{{=}}y --newuse sys-kernel/gentoo-sources}}

安装新的内核源代码并不会给使用者提供一个新的内核。从新内核源代码编译和安装一个新的内核，然后重启系统从而真正的运行新的内核是有必要的。

从新的源代码制作一个新的内核基本上和安装系统时的制作内核是一样的。不同之处在于可以基于旧内核的配置文件来为新内核制作一个配置文件。使用旧的配置文件可以让使用者不从头到尾再做一次内核选项（像 {{c|make menuconfig}} 一样）。

内核的配置文件 {{Path|.config}} 保存在内核源代码的目录下面。一个新的内核或许会有旧内核没有的特性或选项，新内核也有可能没有现存于旧内核的特性或选项。内核配置文件指定了是否开启内核的功能和选项，要么嵌入内核，要么以模块形式构建从而允许在内核运行时被按需加载。因此，新内核的配置文件可能有新的但是旧内核的配置文件没有的选项，同时新内核的配置文件可能没有旧内核的配置文件现有的选项。

要处理配置文件的更改，旧内核的配置文件需要转换为可用于新内核的配置。本文展示了如何通过转换旧内核的配置文件来制作一个新内核。

== 为当前运行内核的配置文件制作一个备份 ==

备份内核配置是明智的，这样以前的配置就不会丢失了。毕竟许多用户花了大量的时间来配置出系统的最佳配置，同时失去内核配置是绝对不会想要的。

制作一个当前内核配置的备份很容易：

{{RootCmd|cd /usr/src/linux |cp .config ~/kernel-config-`uname -r`|}}

在内核源代码的链接被配置正确的情况下，这复制了正在使用的内核的配置文件到了根用户的家目录下，重命名了配置文件变成 {{Path|kernel-config-}} 加上现在正在运行的内核的版本号。

== 设置一个链接到新的内核源代码 ==

符号链接 {{Path|/usr/src/linux}} 应该始终指向正在运行的内核的源代码的目录。下面三种方法中任意一个可以实现这一点：

# 安装内核源代码时使用 <code>USE="symlink"</code>
# 用 eselect 设置链接
# 手动更新符号链接

=== 安装使用 USE Flag 的内核源代码 ===

这将会让 {{Path|/usr/src/linux}} 指向新安装的内核源代码。

如果有必要的话，也可以选择下面两种方法之一来进行稍后修改。

=== 使用 eselect 设置链接 ===

用 {{c|eselect}} 设置链接：

{{RootCmd|eselect kernel list|output=<pre>
Available kernel symlink targets:
[1] linux-3.14.14-gentoo * 
[2] linux-3.16.3-gentoo
</pre>}}

这将输出可用的内核源代码。星号表示已经选择的来源。

要更改内核源，例如选第二个选项：

{{RootCmd|eselect kernel set 2}}

=== 手动更新符号链接 ===

手动设置符号链接：

{{RootCmd|ln -sf /usr/src/linux-3.16.3 /usr/src/linux |ls -l /usr/src/linux|output=<pre>
lrwxrwxrwx 1 root root 19 Oct 4 10:21 /usr/src/linux -> linux-3.16.3-gentoo </pre>}}

== 复制以前的内核配置文件 ==

旧内核的配置需要被复制到新的内核中。它可以在这几个地方找到：

* 如果在当前内核中选项''Enable access to .config through /proc/config.gz''是激活的，配置文件在[[procfs]] 文件系统：
: {{RootCmd|zcat /proc/config.gz > /usr/src/linux/.config}}

* 从老内核中提取。仅当老内核使用CONFIG_IKCONFIG被编译时可用:
:{{RootCmd|/usr/src/linux/scripts/extract-ikconfig /path/to/old/kernel >/usr/src/linux/.config}}

* 从{{Path|/boot}} 目录里获取,如果你把配置文件安装到了这里:
: {{RootCmd|cp /boot/config-3.14.14-gentoo /usr/src/linux/.config}}

* 当前运行的内核的源代码目录：
: {{RootCmd|cp /usr/src/linux-3.14.14-gentoo/.config /usr/src/linux/}}

* In the {{Path|/etc/kernels/}} directory, if <code>SAVE_CONFIG="yes"</code> is set in {{Path|/etc/genkernel.conf}} and {{c|[[genkernel]]}} was previously used:
: {{RootCmd|cp /etc/kernels/kernel-config-x86_64-3.14.14-gentoo /usr/src/linux/.config}}

== 配置新的内核 ==

要使用适用于新内核的旧内核的配置，需要转换旧内核的配置。转换可以通过运行  {{c|make silentoldconfig}} 或者 {{c|make olddefconfig}}。只用其中一个，不要都使用。

=== 制作沉默的旧的配置 (make silentoldconfig) ===

下面的配置是基于类似文本的配置 {{c|make config}} 。 对于新的配置，它提供选择。例如：

{{RootCmd|cd /usr/src/linux
|make silentoldconfig|output=<pre>
Anticipatory I/O scheduler (IOSCHED_AS) [Y/n/m/?] (NEW)
</pre>}}

The string ''(NEW)'' at the end of the line marks this option as new. Left to the string in square brackets are the possible answers: ''Y''es, ''n''o, ''m''odule or ''?'' to show the help. The recommend (i.e. default) answer is capitalized (here ''Y''). The help explains the option or driver.

Unfortunately {{c|make silentoldconfig}} doesn't show a lot more information for each option, such as the context, so it is sometimes difficult to give the right answer. In this case the best way to go is to remember the option name and revise it afterwards through one of the [[Kernel/Configuration#Configuration tools|graphical kernel configuration tools]].

=== 制作旧的配置 (make olddefconfig)===

如果所有的新配置选项都应该被设置成推荐 (也就是default)值就用这条命令 {{c|make olddefconfig}}:

{{RootCmd|cd /usr/src/linux
|make menuconfig}}

make help

Use {{c|make help}} to see other conversion methods available:

{{RootCmd|make help}}

== 编译 ==

{{Important|When external kernel modules are installed (like nvidia or zfs), it may be necessary to run {{c|make modules_prepare}} as described [[Kernel/Upgrade#Reinstall external kernel modules|below]] before building the kernel. Some modules cannot be installed or prepared before the kernel has been built.}}

{{Important|别忘了重新配置 [[Bootloader|bootloader]] 去登记新内核的名称。如果使用了initramfs，请重新制作initramfs}}

这一步请参考 [[Kernel/Configuration#Build|manual configuration]]。

== 重新安装外部内核模块 ==

任何外部的内核模块，像 [[:Category:Binary kernel modules|binary kernel modules]], 需要为新的内核重新编译。如果新内核还没有编译，需要首先为编译外部内核模块做准备：

{{RootCmd|make modules_prepare}}

Packages containing kernel modules can be rebuilt using the <code>@module-rebuild</code> set:

{{Emerge|@module-rebuild}}

== 解决编译的问题 ==

When experiencing build problems while rebuilding the current kernel, it might help to sanitize the kernel sources. Make sure to backup the {{Path|.config}} file first, as the operation will remove it. Make sure not to use a {{Path|.bak}} or {{Path|~}} suffix as backup as {{c|make distclean}} will clean those up as well.

{{RootCmd|cp .config /usr/src/kernel_config_bk
|make distclean
|mv /usr/src/kernel_config_bk .config}}

== 删除旧内核 ==

参考 [[Kernel/Removal|kernel removal|删除旧内核]]。 

== 外部资源 ==

* [http://kernelnewbies.org/LinuxChanges kernel changelog with some explanations of new features]

[[Category:Kernel]]
