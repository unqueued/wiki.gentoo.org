<languages />

{{Metadata|abstract=この文書では、GCC のアップグレード手順を案内しています。}}

この文書では、[[Article description::GCC のアップグレード手順を案内しています。]]

GCC の''ダウングレード''には望まない副作用があるかもしれないことに注意してください。よく報告される問題については[[#トラブルシューティング|トラブルシューティングの節]]を参照してください。

==ショートバージョン==

このセクションは、GCCのアップグレード（とそれらがいかに簡単か）への迅速なプライマーです。より詳しい説明は次の[[#GCC アップグレードの詳説|GCC アップグレードの詳説]]節にあります。

<div class="mw-translate-fuzzy">
GCC をアップグレードしたときには、コンパイラのバージョンを変更することと、libtool を再ビルドすること以外には必要なことはありません：
</div>

{{Emerge|sys-devel/gcc|params+=--oneshot}}

{{RootCmd|gcc-config --list-profiles|output=<pre>
[1] x86_64-pc-linux-gnu-5.4.0 *
[2] x86_64-pc-linux-gnu-6.4.0
</pre>}}

{{RootCmd
|gcc-config 2
|source /etc/profile
}}

{{Emerge|sys-devel/libtool|params+=--oneshot --usepkg=n}}

{{Note|gcc 4.x から gcc 5.x 以降にアップグレードする場合は、追加の説明があてはまります; 分離されている [[Upgrading from gcc-4.x to gcc-5.x]] のページを見てください。}}

現在のバージョン番号を確認してから、旧バージョンをアンインストールしましょう:

{{RootCmd|gcc --version}}

{{Emerge|{{=}}sys-devel/gcc-5.4.0|params+=--depclean}}

それから、revdep-rebuildを実行してシステムの整合性を検証します:
{{RootCmd|revdep-rebuild}}

新しいコンパイラを楽しんでください！

== GCC アップグレードの詳説 ==

GCC のアップグレードはいつも謎めかされてきました。というのも、「ほかには何もしなくていいよ」というものから、「システム全体の再ビルドを2度しなければならないよ」というものまで、言われることに幅があるからです。こうした疑念のおおよそは、今日ではめったに起こらない(そして起こったときにはそれが発表される) ABI の非互換にまつわる混乱からきています。しかしまずは、{{c|libtool}} にまつわることについて軽く指摘しておきます。

=== libtool ===

ではなぜ、 {{c|gcc}} のバージョンをアップグレードした後には libtool を再ビルドする必要があるのでしょうか？　それは、''libtool'' は、プラットフォーム特有のコードを一般化したインターフェイスに集約することで、アプリケーションソフトがプラットフォーム特有の側面を意識することなく共用ライブラリを利用可能にするものだからです。この機能を適切に実現するには、{{c|libtool}} のスクリプトは、様々な場所にある共用ライブラリを見つけ出して、その中にハードコーディングされた {{c|gcc}} のバージョン情報を得なければなりません。

=== ABI の変化 ===

<div class="mw-translate-fuzzy">
ABI、あるいは[https://en.wikipedia.org/wiki/Application_binary_interface ''Application Binary Interface'']は、コンパイラ、アセンブラ、リンカ、そして言語ランタイムサポート(情報源: [https://gcc.gnu.org/onlinedocs/gcc/Compatibility.html GCC Binary Compatibility])を含む、プログラムのバイナリ表現を扱うすべてのツールによって使用される規則の集まりです。バイナリアプリケーションやライブラリに使用されているABIが変更されると、C++のコードを用いているすべてのライブラリをビルドしなおすまで、リンカのエラーやプログラムの誤動作が発生する危険性があります。
</div> 

<div class="mw-translate-fuzzy">
そう、C++です、ほとんどの非互換はC++ ABIの中で生じるためです。もしあなたがGCC 4.1やGCC5.1へアップグレードした場合、おそらくABIの問題に直面することになるでしょう。これは、私達が{{Path|libstdc++.so.5}} (GCC 3からGCC 4.1へのアップグレードの場合)あるいは{{Path|libstdc++.so.6}} (GCC 4からGCC 5.1へのアップグレードの場合)に対して{{c|revdep-rebuild}}を使う理由でもあります。
</div>

<div class="mw-translate-fuzzy">
{{RootCmd|revdep-rebuild --library 'libstdc\+\+.so.6' -- --exclude gcc}}
</div>

<div class="mw-translate-fuzzy">
では、なぜこれはGCC 3.4.0/4.1/5.1までにおいてのみ必要とされるのでしょうか?
それは、それらのバージョン以降、GCCがアプリケーションやライブラリの再ビルドの必要性をなくす前方互換のABIを採用しているからです。もちろん、保証は無期限に与えられるものではありえませんが、非互換が再び生じたら、私たちはそれをここへ確実に文書化します。その場合、おそらく{{Path|libstdc++.so}}ライブラリのバージョンは増加していることでしょう。
</div>

==== C++11 (および C++14) 特有の事象 ====

GCC(より具体的には、libstdc++)は、ABIの安定性を保証するために労を惜しみませんが、この保証はlibstdc++の中のC++のすべての部分に及ぶわけではありません。公式には、3.4以降のバージョンにおいて、GCC/libstdc++はC++98/C++03 ABIの安定性のみを保証し、それ以上ではありません。このことはC++11に依存するパッケージに関しては重大です。GCCはC++11 ABIの安定性の保証をバージョン5.1以降でのみ提供しています。これは、gccのバージョン(マイナーバージョンであっても)の変更(4.7.3 -> 4.7.4など)はC++11のコードからビルドされたバイナリにABI破壊をもたらす、ということを意味しています。

さらなる情報や実例は、以下を見てください：

* {{Bug|513386}}
* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61758
* https://blogs.gentoo.org/blueness/2015/03/10/the-c11-abi-incompatibility-problem-in-gentoo/
* https://stackoverflow.com/questions/16190269/g-always-backward-compatible-with-older-static-libraries/16196475#16196475

=== どのパッケージで再ビルドが必要とされているか? ===

以下の表は、''インストールされていれば''再ビルドが必要なパッケージとその理由を表したものです。 

<div class="mw-translate-fuzzy">
{| class="table" style="text-align: left;" 
|- 
! パッケージ
! 再ビルドが必要な理由 ...
|- 
| {{Package|sys-devel/libtool}}
| libtoolアプリケーションは、GCCの内部ライブラリへのパスをハードコードしています
|- 
| {{Package|sys-devel/llvm}}
| 再ビルドしないと、gccの厳密なバージョンによって、LLVMを利用する他のebuild(例えば {{Package|media-libs/mesa}})でリンクエラーに遭遇することがあります
|}
</div>

{{Emerge|sys-devel/libtool sys-devel/llvm sys-devel/clang|params+=--oneshot --usepkg=n --verbose}}

<div class="mw-translate-fuzzy">
また、同じコンパイラを用いてビルドする必要があるパッケージ群についても、既知の例があります。これらのパッケージについては、通常パッケージメンテナが(それらが常に同じバージョンのGCCでビルドされるように)同時にbumpを行いますが、これらのパッケージからの「つまみ食い」的な再インストールは困難であることがわかっています。さまざまな{{Path|qt-*}}パッケージ群は、この問題の良い例です。
</div>

<div class="mw-translate-fuzzy">
「GCC の新たなバージョンを入れたときには、各パッケージのすべてを再ビルドせねばならない」と心に誓っている人もいます。もちろん、そうする意味はありません。なぜなら、ビルドやインストールに GCC を一切使わないアプリケーションソフトもたくさんあり、そうしたソフトウェアには影響がないからです。
</div> 

<div class="mw-translate-fuzzy">
そうはいっても、彼らが完全に間違えているかというと、そうでもありません： 新しいバージョンの GCC ではしばしば、プロセッサの命令セットのサポートが向上していることがあります。そうすると、より良い性能が得られるアプリケーションソフトもあるかもしれません。そうした性能の向上は一般的にたかが知れている範囲ですが、ときには（特に CPU に大きく頼っているソフトウェアでは）目立った向上が生み出されることもあります。
</div>

Apart from such "benign" benefits, rebuilding everything from scratch may be necessary in some cases to fix problems that don't seem to have any obvious cause.

Some software problems are inherently difficult to diagnose and yet could be solved by simply rebuilding one or more appropriate packages. If such a problem has arisen following a GCC upgrade and persists after using the revdep-rebuild approach described above (and after rebuilding any other obviously relevant packages), a complete system rebuild may be the answer.

The "safest" (but also most time-consuming) way to accomplish this is to use the <code>--emptytree</code> (<code>-e</code>) option of emerge to rebuild the [[System set (Portage)|system set]] and then the [[World set (Portage)|world set]]:

{{Emerge|@system|params+=--emptytree --usepkg=n}}
{{Emerge|@world|params+=--emptytree --usepkg=n}}

Users are urged to try this approach before reporting any bugs that might have been caused by a GCC upgrade.

(Note that the commands above will cause the packages in the "system" set to be rebuilt twice, which is necessary to be ''absolutely certain'' that every package gets built in the same [presumably] "problem-free" environment. Any problems that remain after doing this are due to either "genuine bugs" that should be reported or poor system configuration.)

== トラブルシューティング ==

=== rebuild of boost ===

If {{Package|dev-libs/boost}} needs to be rebuilt, one will get the following error message:

{{RootCmd|emerge ... |output=<pre> 
checking for the Boost _____ library... no
configure: error: cannot find the flags to link with Boost _____
</pre>}} 

One can rebuild with:

{{Emerge|dev-libs/boost|params+=--oneshot --usepkg=n --verbose}}

=== libstdc++.so.6: version `GLIBCXX_3.4.15' not found ===

アップデートの途中、以下のようなエラーに遭遇することがあります: 

{{CodeBox|title=GLIBCXX_x.y.z not found|1=
cmake_bootstrap_28021_test: /usr/lib/gcc/i486-pc-linux-gnu/4.1.2/libstdc++.so.6:
version `GLIBCXX_3.4.11' not found 
}}

<div class="mw-translate-fuzzy">
これは、依存しているライブラリをビルドしたものよりも''古い''バージョンのGCCでパッケージをビルドしようとしていることを表しています。C++ ABIは前方互換であると述べたことを思い出しましたか?
確かにそれは事実なのですが、そのことは、アプリケーションのビルドやライブラリのリンクにあたって、(そのライブラリをビルドしたものに比べて)より''高い''(または同じ)バージョンのGCCが使用できる、ということを保証するに過ぎません。
</div>

<div class="mw-translate-fuzzy">
libstdc++に依存しているすべてのパッケージを再ビルドするには、上のrevdep-rebuildの節を参照してください。
</div>

== 参考 ==

* [[Upgrade GCC up to 4.1]] この文書の以前のバージョン
* [[Upgrading from gcc-4.x to gcc-5.x]]
* [https://fedoraproject.org/wiki/Changes/GCC6 Fedoraの'Changes/GCC6' Wikiページ]

== References ==

{{reflist}}


[[Category:Core system]]
