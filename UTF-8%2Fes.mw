<languages />

{{InfoBox stack
|{{InfoBox wikipedia|header=true}}
}}

{{Metadata|abstract=UTF-8 es una codificación de caracteres de longitud variable, lo que significa en este caso que se utilizan de uno a cuatro bytes para codificar cada símbolo. De esta forma, el primer byte UTF-8 se utiliza para codificar ASCII, dándole a este carácter total compatibilidad regresiva con el sistema de codificación ASCII. UTF-8 indica que los caracteres ASCII y Latin se puede utilizar indistintamente con un pequeño incremento en  el tamaño de los datos, ya que solo se utiliza el primer byte. Los usuarios de alfabetos del este como el japonés, a los que se les ha asignado un mayor rango de bytes no están contentos con esto ya que obtienen cerca de un 50% de redundancia en sus datos.}}

UTF-8 es una codificación de caracteres de longitud variable, lo que implica que utiliza de 1 a 4 bytes para codificar cada símbolo. Por tanto, el primer byte UTF-8 se utiliza para codificar ASCII. UTF-8 significa que los caracteres ASCII y Latín se pueden intercambiar con un pequeño incremento en el tamaño de los datos, ya que únicamente se utiliza el primer byte. Los usuarios de alfabetos del este como el japonés, a los cuales se les ha asignado un rango más alto de los bytes no les gusta mucho esto, ya que esto implica un 50% mayor de redundancia en sus datos. 

== Codificaciones de caracteres ==

=== ¿Qué es la codificación de caracteres? ===

Los ordenadores por si mismos no comprenden el texto impreso como haría un humano. En lugar de esto, cada carácter del texto se representa mediante un número. Tradicionalmente, cada conjunto de números se utilizó para representar alfabetos y caracteres (conocidos como sistema de codificación, codificación o conjunto de caracteres) estuvo limitado en el tamaño debido a limitaciones del hardware de los ordenadores. 

=== La historia de los caracteres de codificación ===

El más común (o al menos el más aceptado) conjunto de caracteres es '''ASCII''' (Código Estándar Americano para el Intercambio de Información). Es ampliamente aceptado de que ASCII es el estándar de software más exitoso jamás creado. El ASCII actual se estandarizó en 1986 (ANSI X3.4, RFC 20, ISO/IEC 646:1991, ECMA-6) por el Instituto Nacional Americano de Estándares. 

ASCII es una codificación estrictamente de siete bits, lo que significa que utiliza patrones representables con siete dígitos binarios, lo que proporciona una gama de 0 a 127 en decimal. Estos incluyen 32 caracteres de control no visibles, la mayoría entre 0 y 31, con el carácter de control final, DEL o de eliminación en el 127. Los caracteres del 32 al 126 son visibles: un espacio, marcas de puntuación, letras latinas y números. 

El octavo bit en ASCII se utilizó originalmente como un bit de paridad para el control de errores. Si no se desea control de errores, se deja a 0. Esto significa que, con ASCII, cada carácter se representa mediante un único byte. 

A pesar de que ASCII era suficiente para comunicarse en inglés moderno, las cosas no eran tan fáciles en otras lenguas europeas que incluyen caracteres acentuados. Los estándares ISO 8859 se desarrollaron para satisfacer estas necesidades. Estos estándares eran compatibles con ASCII, pero en lugar de dejar el octavo bit en blanco, lo utilizaron para permitir otros 127 caracteres en cada codificación. Las limitaciones de los estándares ISO 8859 aparecieron pronto y actualmente hay 15 variantes del estándar ISO 8859 (del 8859-1 al 8859-15). Fuera del rango de bytes compatible con ASCII de estos conjuntos de caracteres hay a menudo conflicto entre las letras representadas por cada byte. Para complicar aún más la interoperabilidad entre las codificaciones de caracteres, en algunas versiones de Windows de Microsoft se utiliza la codificación Windows-1252 en lugar de los idiomas de Europa del oeste. Esto es un superconjunto de la codificación ISO 8859-1. Sin embargo, es diferente en algunos aspectos, estos conjuntos no conservan completamente la compatibilidad con ASCII. 

The necessary development of completely different single-byte encodings for non-Latin alphabets, such as EUC (Extended Unix Coding) which is used for Japanese and Korean (and to a lesser extent Chinese) created more confusion. Other operating systems still used different character sets for the same languages, for example, Shift-JIS and ISO-2022-JP. Users wishing to view cyrillic glyphs had to choose between KOI8-R for Russian and Bulgarian or KOI8-U for Ukrainian, as well as all the other cyrillic encodings such as the unsuccessful ISO 8859-5, and the common Windows-1251 set. All of these character sets broke most compatibility with ASCII. Although it should be mentioned KOI8 encodings place cyrillic characters in Latin order, so in case the eighth bit is stripped, text is still decipherable on an ASCII terminal through case-reversed transliteration. 

All of this has led to mass confusion, and to an almost total inability for multilingual communication; especially across different alphabets. Enter Unicode. 

=== ¿Qué es Unicode? ===

Unicode throws away the traditional single-byte limit of character sets. It uses 17 "planes" of 65,536 code points to describe a maximum of 1,114,112 characters. As the first plane, aka. "Basic Multilingual Plane" or BMP, contains almost everything character a user will ever need. Many have made the wrong assumption that Unicode was a 16-bit character set. 

Unicode has been mapped in many different ways, but the two most common are '''UTF''' (Unicode Transformation Format) and '''UCS''' (Universal Character Set). A number after UTF indicates the number of bits in one unit, while the number after UCS indicates the number of bytes. UTF-8 has become the most widespread means for the interchange of Unicode text as a result of its eight-bit clean nature; it is therefore the subject of this document. 

=== ¿Qué puede hacer unicode? ===

UTF-8 allows users to work in a standards-compliant and internationally accepted multilingual environment, with a comparatively low data redundancy. It is the preferred way for transmitting non-ASCII characters over the Internet, through Email, IRC, or almost any other medium. Despite this, many people regard UTF-8 in online communication as abusive. It is always best to be aware of the attitude towards UTF-8 in a specific channel, mailing list, or Usenet group before using ''non-ASCII'' UTF-8. 

== Configurar UTF-8 en Gentoo Linux ==

=== Buscar o crear localizaciones UTF-8 ===

Now that the principles behind Unicode have been laid out, get ready to start using UTF-8 locally!

For users interested in more knowledge further explanation can be found in the [[Localization/Guide|Gentoo Localization Guide]]. 

Next, the user needs to decide whether a UTF-8 locale is available for the language of choice, or whether one needs to be generated.

{{Cmd|locale -a {{!}} grep 'es_ES'|output=<pre>
es_ES
es_ES.UTF-8
</pre>
}}

From the output of the above command, look for a result with a suffix similar to <code>.UTF-8</code>. If there is no result with a similar suffix a UTF-8 compatible locale must be created. 

{{Note|Ejecute el siguiente listado de código si no tiene una localización UTF-8 disponible en su idioma.}}

Replace "en_GB" with the desired locale setting:
{{RootCmd|localedef -i en_GB -f UTF-8 en_GB.UTF-8}}

Another way to include a UTF-8 locale is to add it to the {{Path|/etc/locale.gen}} file and generate necessary locales using the <tt>locale-gen</tt> command.  Locales will be written to the locale-archive  {{Path|/usr/lib/locale/locale-archive}}.

{{CodeBox|title=Línea en /etc/locale.gen|1=
es_ES.UTF-8 UTF-8
}}

{{RootCmd|locale-gen|output=<pre>
 * Generating 1 locales (this might take a while) with 1 jobs
 *  (1/1) Generating en_GB.UTF-8 ...                            [ ok ]
 * Generation complete
</pre>}}

=== Configurar la localización ===

There is one environment variable that needs to be set in order to use the new UTF-8 locales: <code>LC_CTYPE</code> (optionally modify the <code>LANG</code> variable to change the system language as well). There are also many different ways to set it; some system administrators prefer to only have a UTF-8 environment for a specific user, in which case they set them in their {{Path|~/.profile}} (<tt>/bin/sh</tt> for Bourne shell users), {{Path|~/.bash_profile}} or {{Path|~/.bashrc}} (<tt>/bin/bash</tt> for Bourne again shell users). More details and best practices can be found in the [[Localization/Guide|Localization Guide]]. 

Still others prefer to set the locale globally. One specific circumstance where the author particularly recommends doing this is when {{Path|/etc/init.d/xdm}} is in use, because this init script starts the display manager and desktop before any of the aforementioned shell startup files are sourced. In other words, this is performed before any of the variables are loaded in the environment. 

Setting the locale globally should be done using {{Path|/etc/env.d/02locale}} file. This file should look something like the following: 

{{CodeBox|title=Demonstration /etc/env.d/02locale|lang=bash|1=
## (As always, change "en_GB.UTF-8" to the appropriate locale)
LANG="en_GB.UTF-8"
}}

{{Note|Es posible sustituir <code>LC_CTYPE</code> por <code>LANG</code>. Para más información sobre las categorías afectadas por el uso de <code>LC_CTYPE</code>, lea la [http://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html#Locale-Categories página de localizaciones de GNU].}}

A continuación se debe actualizar el entorno para reflejar el cambio. 

{{RootCmd|env-update|output=<pre>
>>> Regenerating /etc/ld.so.cache...
 * Caching service dependencies ...
</pre>}}
{{RootCmd|source /etc/profile}}

Now, run <tt>locale</tt> with no arguments to see if the correct variables have been loaded in the environment: 

{{RootCmd|locale|output=<pre>
LANG=es_ES.UTF-8
LC_CTYPE="es_ES.UTF-8"
LC_NUMERIC="es_ES.UTF-8"
LC_TIME="es_ES.UTF-8"
LC_COLLATE="es_ES.UTF-8"
LC_MONETARY="es_ES.UTF-8"
LC_MESSAGES="es_ES.UTF-8"
LC_PAPER="es_ES.UTF-8"
LC_NAME="es_ES.UTF-8"
LC_ADDRESS="es_ES.UTF-8"
LC_TELEPHONE="es_ES.UTF-8"
LC_MEASUREMENT="es_ES.UTF-8"
LC_IDENTIFICATION="es_ES.UTF-8"
LC_ALL=
</pre>
}}

=== Usar eselect de forma alternativa para definir localizaciones ===
Aunque es correcto realizar el mantenimiento del sistema tal y como se describe arriba, es posible verificar la localización correcta que se ha configurado mediante la utilidad <tt>eselect</tt>.

Utilice <tt>eselect</tt> para listar las localizaciones disponibles en el sistema:

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX *
  [3] en_GB.utf8
  [ ] (free form)
</pre>
}}

Usar <tt>eselect</tt> para ajustar la localización es tan simple como listarlas todas. Una vez que se ha determinado la localización, invoque:

{{RootCmd|eselect locale set 3 |output=<pre>
Setting LANG to en_GB.utf8 ...
</pre>
}}

Check the result:

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX
  [3] en_GB.utf8 *
  [ ] (free form)
</pre>
}}

In case it is preferred to have {{Path|/etc/env.d/02locale}} with <code>.UTF-8</code> instead of <code>.utf8</code>, run the appropriate <tt>eselect</tt> command:

{{RootCmd|eselect locale set en_GB.UTF-8 |output=<pre>
Setting LANG to en_GB.UTF-8 ...
</pre>
}}

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX
  [3] en_GB.utf8
  [4] en_GB.UTF-8 *
  [ ] (free form)
</pre>
}}

Al lanzar la siguiente orden, se actualizarán las variables en el intérprete de órdenes:

{{RootCmd|env-update && source /etc/profile |output=<pre>
>>> Regenerating /etc/ld.so.cache...
</pre>
}}

Eso es todo. El sistema está ahora utilizando localizaciones UTF-8. El siguiente obstáculo es la configuración de las aplicaciones que se utilizan diariamente.

== Soporte a aplicaciones ==

When Unicode first started gaining momentum in the software world, multibyte character sets were not well suited to languages like C, which is the base language of most commonly used programs. Even today, some programs are not able to handle UTF-8 properly. Fortunately the majority of programs, especially the common ones, are supported. 

=== Nombres de Ficheros, NTFS y FAT ===

There are several NLS options in the Linux kernel configuration menu, but it is important to not become confused. For the most part, the only thing that needs to be done is to build UTF-8 NLS support into the kernel, and change the default NLS option to utf8. 

{{KernelBox|title=Kernel configuration steps for UTF-8 NLS|<pre>
File Systems -->
  Native Language Support -->
    (utf8) Default NLS Option
    <*> NLS UTF8
    ## (Also <*> other character sets that are in use in the system's FAT filesystems or Joilet CD-ROMs.)
</pre>
}}

When planning to mount NTFS partitions, users may need to specify a <code>nls=</code> option with mount. When planning on mounting FAT partitions, users may need to specify a <code>codepage=</code> option with mount. Optionally, users can also set a default codepage for FAT in the kernel configuration.

{{Note|Si se utilizar la opción <code>codepage</code> a través de <tt>mount</tt> se desestimarán los ajustes definidos en el núcleo.}}

{{KernelBox|title=Ajustes FAT en la configuración del núcleo|<pre>
File Systems -->
 DOS/FAT/NT Filesystems -->
  (437) Default codepage for fat
</pre>
}}

Avoid setting <code>Default iocharset for fat</code> to UTF-8; it is not recommended. Instead, pass the <code>utf8=true</code> option when mounting FAT partitions. For further information <tt>man mount</tt> or see the appropriate kernel documentation at {{Path|/usr/src/linux/Documentation/filesystems/vfat.txt}}

Para cambiar la codificación de los nombres de los ficheros, se puede utilizar {{Package|app-text/convmv}}. 

{{Emerge|app-text/convmv}}

The format of the <tt>convmv</tt> command is as follows:

{{RootCmd|convmv -f <codificación-actual> -t utf-8 <nombredefichero>}}

Sustituya iso-8859-1 por el conjunto de caracteres desde el que se está convirtiendo:

{{RootCmd|convmv -f iso-8859-1 -t utf-8 nombre-de-fichero}}

For changing the ''contents'' of files, use the <tt>iconv</tt> utility, it comes bundled with {{Package|sys-libs/glibc}} and should be installed on all Gentoo systems. Substitute iso-8859-1 with the charset being converted from. After running the command be sure to check for sane output:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 nombre-de-fichero}}

Para convertir un fichero, se deberá crear otro fichero:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 nombredefichero > nuevofichero}}

El paquete recode {{Package|app-text/recode}} se puede utilizar también para este propósito.

=== La consola del sistema ===

{{Important|El paquete {{Package|sys-apps/baselayout}}-1.11.9 (o superior) es necesario para tener soporte de Unicode en la consola.}}

To enable UTF-8 on the console edit {{Path|/etc/rc.conf}} Set <code>unicode="yes"</code> and read the comments -- it is important to have a font that has a good range of characters to make the most of Unicode. For this to work make sure the Unicode locale has been properly created. 

La variable <code>keymap</code> definida en {{Path|/etc/conf.d/keymaps}} debería especificar un mapa de teclado Unicode. 

{{CodeBox|title=Example /etc/conf.d/keymaps snippet|lang=bash|1=
## (Change "uk" to the right local layout)
keymap="uk"
}}

=== Ncurses y Slang ===

{{Note|Ignore cualquier mención de Slang en esta sección si no está instalado o no es necesario.}}

It is wise to add <code>unicode</code> to the global USE flags in {{Path|/etc/portage/make.conf}}, and then to re-emerge {{Package|sys-libs/ncurses}} and {{Package|sys-libs/slang}}. Portage will do this automatically if the <code>--changed-use</code> or <code>--newuse</code> options are used. Run the following command to pull in the packages: 

{{RootCmd|emerge --update --deep --newuse world}}

También necesitamos reconstruir los paquetes que enlazan a éstos, ahora se han aplicado los cambios a USE. La herramienta que utilizamos (<code>revdep-rebuild</code>) es parte del paquete {{Package|app-portage/gentoolkit}}. 

{{RootCmd|revdep-rebuild --soname libncurses.so.5 |revdep-rebuild --soname libslang.so.1}}

=== KDE, GNOME y Xfce ===

Todos los entornos de escritorio de mayor uso tienen soporte completo para Unicode y no requieren de configuraciones adicionales que ya se hayan comentado en esta guía. Esto es debido a que las herramientas gráficas (Qt o GTK+2) ya son compatibles con UTF-8. Por tanto, todas las aplicaciones que corran sobre estas herramientas deberían ser compatibles UTF-8. 

On GTK+ based applications, the key sequence for hexadecimal Unicode input is <kbd>Ctrl-Shift-u<hex digit></kbd>.

Las excepciones a esta regla son Xlib y GTK+1. GTK+1 requiere un FontSpec iso-10646-1 en el fichero /.*gtkrc, por ejemplo <code>-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1</code>. También, las aplicaciones que utilizan Xlib o Xaw necesitarán tener un FontSpec similar, de lo contrario no funcionarán. 

{{Note|If an old gnome1 control center version is available, use that instead. Pick any iso10646-1 font from there.}}

{{CodeBox|title=Ejemplo de fichero ~/.gtkrc (para GTK+1) que define una fuente compatible con Unicode|1=
style "user-font"
{
 fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"
}
widget_class "*" style "user-font"
}}

Si una aplicación tiene soporte para las interfaces gráficas Qt y GTK+2, la interfaz gráfica GTK+2 normalmente ofrecerá mejores resultados con Unicode.

=== X11 y fuentes ===

TrueType fonts have support for Unicode, and most of the fonts that ship with Xorg have extensive character support, although, obviously, not every single glyph available in Unicode has been created for that font. 

Also, many font packages in Portage are Unicode aware. See the [[Fontconfig]] page for more information on recommended fonts and configuration.

=== Window managers and terminal emulators ===

Window managers not built on GTK+ or Qt generally have very good Unicode support, as they often use the Xft library for handling fonts. If the window manager does not use Xft for fonts, then it is still possible to use the FontSpec mentioned in the previous section as a Unicode font. 

Los emuladores de terminal que utilicen Xft y tengan soporte unicode son más difíciles de encontrar. Aparte de Konsole y gnome-terminal, las mejores opciones en Portage son  {{Package|x11-terms/rxvt-unicode}}, {{Package|x11-terms/xfce4-terminal}}, {{Package|gnustep-apps/terminal}}, {{Package|x11-terms/mlterm}}, or plain {{Package|x11-terms/xterm}} cuando se construye con la opción USE <code>unicode</code> y se invoca como <code>uxterm</code>. {{Package|app-misc/screen}} también ofrece soporte para UTF-8 cuando se invoca como <code>screen -U</code> o se incluye lo siguiente en el fichero {{Path|~/.screenrc}} : 

{{CodeBox|title=~/.screenrc para UTF-8|1=
defutf8 on
}}

=== Vim, emacs, xemacs and nano ===

[[Vim#Change_file_encoding|Vim]] provides full UTF-8 support, and also has builtin detection of UTF-8 files. For further information in [[Vim#Change_file_encoding|Vim]], use <code>:help mbyte.txt</code> . 

[[GNU Emacs]] Desde la versión 23 y [[XEmacs]] desde la versión 21.5 tiene soporte completo para UTF-8. GNU Emacs 24 también tiene soporte para la edición de texto bidireccional. 

Nano proporciona soporte UTF-8 completo desde la versión 1.3.6.

=== Intérpretes de Comandos ===

Currently, <code>bash</code> provides full Unicode support through the GNU readline library. Z Shell (<tt>zsh</tt>) offers Unicode support with the <code>unicode</code> USE flag. 

The C shell, <tt>tcsh</tt> and <tt>ksh</tt> do not provide UTF-8 support at all.

=== Irssi ===

Irssi ofrece soporte completo de UTF-8, aunque requiere que el usuario active una opción. 

{{Cmd|set term_charset UTF-8|prompt=[irssi] }}

Para canales en los que se intercambian con frecuencia caracteres que no son ASCII mediante conjuntos de caracteres que no son UTF-8, la orden <code>/recode</code> se puede utilizar para convertir caracteres. Teclee <code>/help recode</code> para obtener más información. 

=== Mutt ===

The Mutt mail user agent has very good Unicode support. To use UTF-8 with Mutt, nothing needs to be put in the configuration files. Mutt will work under Unicode environment without modification if all the configuration files (signature included) are UTF-8 encoded. 

{{Note|It is still possible to see '?' in mails read with Mutt. This is a result of people using a mail client which does not indicate the used charset. There is little one can do about this than to ask them to configure their client correctly.}}

Hay más información en el [http://wiki.mutt.org/index.cgi?MuttFaq/Charset Wiki de Mutt]. 

=== Man ===

Man pages are an integral part of any Linux machine. To ensure that any unicode in the man pages render correctly, edit {{Path|/etc/man.conf}} and replace a line as shown below. 

{{CodeBox|title=Cambios en man.conf para soporte Unicode|1=
## (Esta es la línea antigua)
NROFF /usr/bin/nroff -Tascii -c -mandoc
## (Cambie la línea de arriba por esta)
NROFF /usr/bin/nroff -mandoc -c
}}

=== links and elinks ===

These are commonly used text-based browsers, and we shall see how we can enable UTF-8 support on them. On <tt>elinks</tt> and <tt>links</tt>, there are two ways to go about this, one using the Setup option from within the browser or editing the config file. To set the option through the browser, open a site with <tt>elinks</tt> or <tt>links</tt> and then {{Key|Alt}}+{{Key|S}} to enter the Setup Menu then select Terminal options, or press {{Key|T}}. Scroll down and select the last option <code>UTF-8 I/O</code> by pressing {{Key|Enter}}. Then Save and exit the menu. On <tt>links</tt> one may have to do a repeat {{Key|Alt}}+{{Key|S}} and then press {{Key|S}} to save. The config file option, is shown below. 

{{CodeBox|title=Habilitar UTF-8 para elinks o links|1=
## (Para elinks, edite /etc/elinks/elinks.conf o /.elinks/elinks.conf y añada la siguiente línea)
set terminal.linux.utf_8_*io = 1
## (Para links, edite /.links/links.cfg y añada la siguiente línea)
terminal "*xterm" 0 1 0 *es-*ascii *utf-8
}}

## (For links, edit ~/.links/links.cfg and add the following
line)
terminal "xterm" 0 1 0 us-ascii utf-8
}}

=== Samba ===

Samba es una suite de software que implementa el protocolo SMB (Bloque de Mensajes del Servidor) para sistemas UNIX como Macs, Linux y FreeBSD. A este protocolo también se le llama Sistema de Ficheros Común de Internet (CIFS). Samba también incluye el sistema NetBIOS, utilizado para compartir ficheros en redes con sistemas Windows. 

añada lo siguiente bajo la sección [global]: {{RootCmd|nano -w /etc/samba/smb.conf|output=<pre>
dos charset = 1255
unix charset = UTF-8
display charset = UTF-8
</pre>
}}

=== Probarlo todo ===

Hay varios sitios Web de prueba para UTF-8. {{Package|net-www/w3m}}, {{Package|net-www/links}}, {{Package|net-www/elinks}}, {{Package|net-www/lynx}} y todos los navegadores basados en Mozilla (incluyendo Firefox) ofrecen soporta para UTF-8. Konqueror y Opera también ofrecen soporte completo para UTF-8. 

When using one of the text-only web browsers, make absolutely sure a Unicode-aware terminal is used.

If certain characters are displayed as boxes with letters or numbers inside, then the current font does not have a character for the symbol or glyph that the UTF-8 wants. Instead, it displays a box with the hex code of the UTF-8 symbol. 

* [http://unicode-table.com/en/blocks/dingbats/ unicode-table.com]
* [http://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html A W3C UTF-8 Test Page] 
* [http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm A UTF-8 test page provided by the University of Frankfurt]

=== Métodos de entrada ===

''Dead keys'' may be used to input characters in X that are not included on the keyboard. These work by pressing the right {{Key|Alt}} key (or in some countries, {{Key|AltGr}}) and an optional key from the non-alphabetical section of the keyboard to the left of the return key at once, releasing them, and then pressing a letter. The dead key should modify it. Input can be further modified by using the {{Key|Shift}} key at the same time as pressing the {{Key|AltGr}} and modifier. 

To enable dead keys in X, a layout needs to be selected that supports it. Most European layouts already have dead keys with the default variant. However, this is not true of North American layouts. Although there is a degree of inconsistency between layouts, the easiest solution seems to be to use a layout in the form "en_US" rather than "us", for example. The layout is set in {{Path|/etc/X11/xorg.conf}} like so: 

{{CodeBox|title=Fragmento de /etc/X11/xorg.conf|lang=xorg.conf|1=
Section "InputDevice"
 Identifier "Keyboard0"
 Driver "kbd"
 Option "XkbLayout" "en_US" ## # En lugar de solo "us"
 ## (Otras opciones Xkb van aquí)
EndSection
}}

{{Note|The preceding change only needs to be applied when using a North American layout, or another layout where dead keys do not seem to be working. European users should have working dead keys as is.}}

This change will come into effect when the X server is restarted. To apply the change now, use the <tt>setxkbmap</tt> tool, for example, <tt>setxkbmap en_US</tt> . 

It is probably easiest to describe dead keys with examples. Although the results are locale dependent, the concepts should remain the same regardless of locale. The examples contain UTF-8, so to view them tell the browser to view the page as UTF-8, or have a UTF-8 locale already configured. 

Cuando se pulsan las teclas {{Key|AltGr}} y {{Key|&#91;}} al mismo tiempo y se sueltan ambas, y a continuación se presiona {{Key|a}}, se obtiene el carácter 'ä'. Cuando se presionan {{Key|AltGr}} y {{Key|&#91;}} al mismo tiempo y a continuación se presiona {{Key|e}}, se obtiene el carácter 'ë'. Cuando se presionan {{Key|AltGr}} y {{Key|;}} al mismo tiempo, y a continuación se presiona {{Key|a}}, se obtiene el carácter 'á' y cuando se presionan {{Key|AltGr}} y {{Key|;}} al mismo tiempo, se sueltan y se pulsa {{Key|e}}, se obtiene el carácter 'é'. 

Presionando al mismo tiempo {{Key|AltGr}}, {{Key|Mayúsculas}} y {{Key|&#91;}} , soltándolas, y presionando {{Key|a}}, se obtiene el carácter escandinavo 'å'. De modo similar, cuando se presiona {{Key|AltGr}}, {{Key|Mayúsculas}} and {{Key|&#91;}} al mismo tiempo, se suelta "solo" la tecla {{Key|&#91;}} y se presiona de nuevo, se produce el carácter '°'. Aunque parece un solo carácter, éste (U+02DA) no es el mismo que el símbolo utilizado para indicar grados (U+00B0).

Se puede utilizar {{Key|AltGr}} únicamente con teclas alfabéticas. Por ejemplo, {{Key|AltGr}} y {{Key|m}} producen el carácter griego mu minúscula. {{Key|AltGr}} y {{Key|s}}  producen una s scharfes o esszet, etc. Muchos usuarios europeos deberían esperar (porque está marcado en su teclado) que {{Key|AltGr}} y {{Key|4}} (o {{Key|E}} dependiendo de la disposición del teclado) producen el símbolo del Euro, '€'.

=== External resources ===

*  [https://es.wikipedia.org/wiki/unicode La entrada en Wikipedia para Unicode]
*  [https://es.wikipedia.org/wiki/utf-8 La entrada en Wikipedia para *UTF-8]
*  [http://www.unicode.org Unicode.org]
*  [http://www.utf-8.com Utf-8.com]
*  [http://www.ietf.org/rfc/rfc3629.txt RFC 3629]
*  [http://www.ietf.org/rfc/rfc2277.txt RFC 2277]
*  [http://www.tbray.org/ongoing/when/200x/2003/04/26/UTF Caracteres vs. Bytes]
* [http://www.gnu.org/software/libc/manual/html_node/Locales.html Localizaciones e Internacionalización]

== Cuestiones o problemas reportados ==

=== Ficheros de configuración del sistema (en /etc) ===

La mayoría de los ficheros de configuración del sistema (como {{Path|/etc/fstab}}) no ofrecen soporte para UTF-8. Se recomienda ajustarse al conjunto de caracteres ASCII cuando se editen estos ficheros.

[[Category:Localization]] {{Migrated|originalauthors=Thomas Martin, Alexander Simonov, Shyam Mani, nightmorph}}
