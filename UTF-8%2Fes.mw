<languages />

{{InfoBox stack
|{{InfoBox wikipedia|header=true}}
}}

{{Metadata|abstract=UTF-8 es una codificación de caracteres de longitud variable, lo que significa en este caso que se utilizan de uno a cuatro bytes para codificar cada símbolo. De esta forma, el primer byte UTF-8 se utiliza para codificar ASCII, dándole a este carácter total compatibilidad regresiva con el sistema de codificación ASCII. UTF-8 indica que los caracteres ASCII y Latin se puede utilizar indistintamente con un pequeño incremento en  el tamaño de los datos, ya que solo se utiliza el primer byte. Los usuarios de alfabetos del este como el japonés, a los que se les ha asignado un mayor rango de bytes no están contentos con esto ya que obtienen cerca de un 50% de redundancia en sus datos.}}

UTF-8 es una codificación de caracteres de longitud variable, lo que implica que utiliza de 1 a 4 bytes para codificar cada símbolo. Por tanto, el primer byte UTF-8 se utiliza para codificar ASCII. UTF-8 significa que los caracteres ASCII y Latín se pueden intercambiar con un pequeño incremento en el tamaño de los datos, ya que únicamente se utiliza el primer byte. Los usuarios de alfabetos del este como el japonés, a los cuales se les ha asignado un rango más alto de los bytes no les gusta mucho esto, ya que esto implica un 50% mayor de redundancia en sus datos. 

== Codificaciones de caracteres ==

=== ¿Qué es la codificación de caracteres? ===

Los ordenadores por si mismos no comprenden el texto impreso como haría un humano. En lugar de esto, cada carácter del texto se representa mediante un número. Tradicionalmente, cada conjunto de números se utilizó para representar alfabetos y caracteres (conocidos como sistema de codificación, codificación o conjunto de caracteres) estuvo limitado en el tamaño debido a limitaciones del hardware de los ordenadores. 

=== La historia de los caracteres de codificación ===

El más común (o al menos el más aceptado) conjunto de caracteres es '''ASCII''' (Código Estándar Americano para el Intercambio de Información). Es ampliamente aceptado de que ASCII es el estándar de software más exitoso jamás creado. El ASCII actual se estandarizó en 1986 (ANSI X3.4, RFC 20, ISO/IEC 646:1991, ECMA-6) por el Instituto Nacional Americano de Estándares. 

ASCII es una codificación estrictamente de siete bits, lo que significa que utiliza patrones representables con siete dígitos binarios, lo que proporciona una gama de 0 a 127 en decimal. Estos incluyen 32 caracteres de control no visibles, la mayoría entre 0 y 31, con el carácter de control final, DEL o de eliminación en el 127. Los caracteres del 32 al 126 son visibles: un espacio, marcas de puntuación, letras latinas y números. 

El octavo bit en ASCII se utilizó originalmente como un bit de paridad para el control de errores. Si no se desea control de errores, se deja a 0. Esto significa que, con ASCII, cada carácter se representa mediante un único byte. 

A pesar de que ASCII era suficiente para comunicarse en inglés moderno, las cosas no eran tan fáciles en otras lenguas europeas que incluyen caracteres acentuados. Los estándares ISO 8859 se desarrollaron para satisfacer estas necesidades. Estos estándares eran compatibles con ASCII, pero en lugar de dejar el octavo bit en blanco, lo utilizaron para permitir otros 127 caracteres en cada codificación. Las limitaciones de los estándares ISO 8859 aparecieron pronto y actualmente hay 15 variantes del estándar ISO 8859 (del 8859-1 al 8859-15). Fuera del rango de bytes compatible con ASCII de estos conjuntos de caracteres hay a menudo conflicto entre las letras representadas por cada byte. Para complicar aún más la interoperabilidad entre las codificaciones de caracteres, en algunas versiones de Windows de Microsoft se utiliza la codificación Windows-1252 en lugar de los idiomas de Europa del oeste. Esto es un superconjunto de la codificación ISO 8859-1. Sin embargo, es diferente en algunos aspectos, estos conjuntos no conservan completamente la compatibilidad con ASCII. 

El desarrollo necesario de codificaciones de un solo byte completamente diferentes para alfabetos no latinos, como EUC (Codificación de Unix Extendido) que se utiliza para el japonés y el coreano (y en menor medida para el chino) creó aún más confusión. Otros sistemas operativos todavía utilizaban conjuntos de caracteres para los mismos idiomas, por ejemplo, Shift-JIS e ISO-2022-JP. Los usuarios que deseaban ver glifos cirílicos tenían que elegir entre KOI8-R para el ruso y el búlgaro o KOI8-U para el ucraniano, y así para las demás codificaciones cirílicas como el poco exitoso ISO 8859-5 o el común Windows-1251. Todos estos conjuntos de caracteres rompían en mayor o menor medida la compatibilidad con ASCII. Aunque se debe mencionar que las codificaciones KOI8 colocaban los caracteres cirílicos en el orden de los latinos, por lo que en el caso de que se eliminara el octavo bit, es texto se podía mostrar en un terminal ASCII a través de una transliteración inversa de mayúsculas. 

Todo esto ha llevado a grandes confusiones y también a una discapacidad casi total para la comunicación multilingüe, especialmente entre alfabetos diferentes. Entramos en Unicode. 

=== ¿Qué es Unicode? ===

Unicode prescinde de utilizar un solo byte, el límite tradicional de los conjuntos de caracteres. Utiliza 17 "planos" de 65,536 puntos de código para describir un máximo de 1,114,112 caracteres. Como el primer plano, también conocido como "Plano Multilingüe Básico" o BMP, contiene prácticamente todos los caracteres que un usuario necesita. Mucha gente piensa erróneamente que Unicode es un conjunto de caracteres de 16 bits. 

Unicode se ha mapeado de muchas formas diferentes, pero las dos más comunes son '''UTF''' (Formato de Transformación Unicode) y '''UCS''' (Conjunto Universal de Caracteres). El número a continuación de las siglas UTF indica el número de bits en una unidad, por el contrario, el número a continuación de las siglas UCS indica el número de bytes. UTF-8 ha sido la forma más extendida de intercambiar texto Unicode debido a su naturaleza limpia de ocho bits y por tanto es el objeto de este documento.

=== ¿Qué puede hacer unicode? ===

UTF-8 permite trabajar a los usuarios en un entorno que cumple los estándares y que es aceptado internacionalmente, con una redundancia de datos relativamente baja. Es la forma preferida para transmitir caracteres que no son ASCII a través de Internet, mediante correo electrónico, IRC, o casi cualquier otro medio. A pesar de esto, mucha gente piensa que la comunicación en línea de UTF-8 es abusiva. Es mejor conocer la actitud hacia UTF-8 en un canal en particular, en una lista de correo, o en grupo Usenet antes de utilizar UTF-8 ''no ASCII''. 

== Configurar UTF-8 en Gentoo Linux ==

=== Buscar o crear localizaciones UTF-8 ===

Ahora que se han expuesto los principios detrás de Unicode, ¡Prepárese para comenzar a utilizar UTF-8 localmente!

Para aquéllos usuarios interesados en saber más, se pueden encontrar explicaciones más detalladas en la [[Localization/Guide/es|guía de localización de Gentoo]]. 

A continuación, el usuario debe decidir si existe alguna localización UTF-8 para el idioma de su elección o si se necesita generar una nueva.

{{Cmd|locale -a {{!}} grep 'es_ES'|output=<pre>
es_ES
es_ES.utf8
</pre>
}}

De la salida de la orden de arriba se busca un resultado con un sufijo similar a <code>.UTF-8</code>. Si no hay ningún resultado con un sufijo similar a UTF-8 se debe crear una localización compatible. 

{{Note|Ejecute el siguiente listado de código si no tiene una localización UTF-8 disponible en su idioma.}}

Reemplace "es_ES" por el ajuste de localización deseado:
{{RootCmd|localedef -i es_ES -f UTF-8 es_ES.UTF-8}}

Otra forma de incluir una localización UTF-8 es añadirla al fichero {{Path|/etc/locale.gen}} y generar las localizaciones necesarias mediante la orden {{c|locale-gen}}. Las localizaciones se escribirán al archivo de localizaciones en  {{Path|/usr/lib/locale/locale-archive}}.

{{CodeBox|title=Línea en /etc/locale.gen|1=
es_ES.UTF-8 UTF-8
}}

{{RootCmd|locale-gen|output=<pre>
 * Generating 1 locales (this might take a while) with 1 jobs
 *  (1/1) Generating es_ES.UTF-8 ...                            [ ok ]
 * Generation complete
</pre>}}

=== Configurar la localización ===

Hay una variable de entorno que se debe definir para utilizar las nuevas localizaciones UTF-8: <var>LC_CTYPE</var> (opcionalmente también se puede modificar la variable <var>LANG</var> para cambiar el idioma del sistema). Existen igualmente varias formas diferentes de ajustarla: algunos administradores del sistema prefieren tener únicamente un entorno UTF-8 para un usuario en particular, en cuyo caso deben definirla en sus {{Path|~/.profile}} ({{Path|/bin/sh}} para los usuarios del intérprete de órdenes Bourne), {{Path|~/.bash_profile}} o {{Path|~/.bashrc}} ({{Path|/bin/bash}} para usuarios del intérprete de órdenes Bourne Again). Se pueden encontrar más detalles y buenas prácticas en la [[Localization/Guide/es|guía de localización]]. 

Aunque otros prefieren definir la localización de forma global. Una circunstancia específica en la que el autor recomienda hacer esto es cuando se utiliza {{Path|/etc/init.d/xdm}} ya que este guión inicio arranca el gestor de pantalla y el escritorio antes de que ninguno de los ficheros de inicio del intérprete de órdenes anteriormente citados se lancen. En otras palabras esto se realiza antes de que las variables estén definidas en el entorno. 

La localización de forma global se debe definir utilizando el archivo {{Path|/etc/env.d/02locale}}. Este archivo debería tener un aspecto similar al siguiente: 

{{CodeBox|title=/etc/env.d/02locale de demostración|lang=bash|1=
## (Como de costumbre, cambiar "es_ES.utf8" a la localización apropiada, ¡Cada idioma tiene un valor diferente!)
LANG="es_ES.utf8"
}}

{{Note|Es posible sustituir la variable <var>LC_CTYPE</var> por la variable <var>LANG</var>. Para más información sobre las categorías afectadas por el uso de <var>LC_CTYPE</var>, lea la [http://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html#Locale-Categories página de localizaciones de GNU].}}

A continuación se debe actualizar el entorno lanzando la siguiente orden: 

{{RootCmd|env-update|output=<pre>
>>> Regenerating /etc/ld.so.cache...
</pre>}}
{{RootCmd|source /etc/profile}}

Ahora lance {{c|locale}} sin argumentos para comprobar si se han cargado las variables correctas en el entorno: 

{{RootCmd|locale|output=<pre>
LANG=es_ES.utf-8
LC_CTYPE="es_ES.utf-8"
LC_NUMERIC="es_ES.utf-8"
LC_TIME="es_ES.utf-8"
LC_COLLATE="es_ES.utf-8"
LC_MONETARY="es_ES.utf-8"
LC_MESSAGES="es_ES.utf-8"
LC_PAPER="es_ES.utf-8"
LC_NAME="es_ES.utf-8"
LC_ADDRESS="es_ES.utf-8"
LC_TELEPHONE="es_ES.utf-8"
LC_MEASUREMENT="es_ES.utf-8"
LC_IDENTIFICATION="es_ES.utf-8"
LC_ALL=
</pre>
}}

=== Usar eselect de forma alternativa para definir localizaciones ===
Aunque es correcto realizar el mantenimiento del sistema tal y como se describe arriba, es posible verificar la localización correcta que se ha configurado mediante la utilidad {{c|eselect}}.

Utilice {{c|eselect}} para listar las localizaciones disponibles en el sistema:

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX *
  [3] es_ES.utf8
  [ ] (forma libre)
</pre>
}}

Usar {{c|eselect}} para ajustar la localización es tan simple como listarlas todas. Una vez que se ha determinado la localización, invoque:

{{RootCmd|eselect locale set 3 |output=<pre>
Setting LANG to es_ES.utf8 ...
</pre>
}}

Compruebe el resultado:

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX
  [3] es_ES.utf8 *
  [ ] (free form)
</pre>
}}

En el caso en que se prefiera tener {{Path|/etc/env.d/02locale}} con <code>.UTF-8</code> en lugar de <code>.utf8</code>, lance la orden {{c|eselect}} apropiada:

{{RootCmd|eselect locale set es_ES.UTF-8 |output=<pre>
Setting LANG to es_ES.UTF-8 ...
</pre>
}}

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX
  [3] es_ES.utf8
  [4] es_ES.UTF-8 *
  [ ] (forma libre)
</pre>
}}

Al lanzar la siguiente orden, se actualizarán las variables en el intérprete de órdenes:

{{RootCmd|env-update && source /etc/profile |output=<pre>
>>> Regenerating /etc/ld.so.cache...
</pre>
}}

Eso es todo. El sistema está ahora utilizando localizaciones UTF-8. El siguiente obstáculo es la configuración de las aplicaciones que se utilizan diariamente.

== Soporte a aplicaciones ==

Cuando Unicode empezó a ganar adeptos en el mundo del software, los conjuntos de caracteres multibyte no estaban bien adaptados a lenguages como C, que es el lenguage base de la mayoría de los programas de uso cotidiano. Incluso hoy en día, algunos programas no pueden gestionar UTF-8 de forma correcta. Afortunadamente la mayoría de programas, especialmente los utilizados normalmente lo soportan. 

=== Nombres de Ficheros, NTFS y FAT ===

Hay varias opciones NLS en el menú de configuración del núcleo Linux, pero es importante no confundirse. En la mayoría de las situaciones, lo único que se necesita es construir el soporte NLS UTF-8 en el núcleo y cambiar la opción NLS por defecto a utf8. 

{{KernelBox|title=Configuración del núcleo para UTF-8 NLS|<pre>
File Systems -->
 Native Language Support -->
  (utf8) Default NLS Option
  <*> NLS UTF8
  ## (También debe <*> otros conjuntos de caracteres que se utilicen en los sistemas de ficheros FAT o Joilet en los CD-ROMs.)
</pre>
}}

Cunado se planea montar particiones NTFS, los usuarios necesitan especificar una opción <code>nls=</code> con la orden mount. Cuando se planea montar particiones FAT, los usuarios pueden especificar una opción <code>codepage=</code> con la orden mount. De forma opcional, los usuarios también pueden definir una página de códigos (codepage) para FAT por defecto en la configuración del núcleo.

{{Note|Si se utilizar la opción <code>codepage</code> a través de {{c|mount}} se desestimarán los ajustes definidos en el núcleo.}}

{{KernelBox|title=Ajustes FAT en la configuración del núcleo|<pre>
File Systems -->
 DOS/FAT/NT Filesystems -->
  (437) Default codepage for fat
</pre>
}}

Se debe evitar definir <code>Default iocharset for fat</code> (Conjunto de caracteres de E/S por defecto para FAT) a UTF-8, ya que no está recomendado. En lugar de esto, se debe pasar la opción <code>utf8=true</code> cuando se monten las particiones FAT. Para más información, se puede consultar {{c|man mount}} o echar un vistazo a la documentación apropiada del núcleo en {{Path|/usr/src/linux/Documentation/filesystems/vfat.txt}} .

Para cambiar la codificación de los nombres de los ficheros, se puede utilizar {{Package|app-text/convmv}}. 

{{Emerge|app-text/convmv}}

A continuación se muestra el formato de la orden {{c|convmv}}:

{{RootCmd|convmv -f <codificación-actual> -t utf-8 <nombredefichero>}}

Sustituya iso-8859-1 por el conjunto de caracteres desde el que se está convirtiendo:

{{RootCmd|convmv -f iso-8859-1 -t utf-8 nombre-de-fichero}}

Para cambiar el ''contenido'' de ficheros, haga uso de la utilidad {{c|iconv}}, viene integrada con {{Package|sys-libs/glibc}} y debería estar instalada en todos los sistemas Gentoo systems. Substituya iso-8859-1 por el juego de caracteres desde el que se quiere convertir. Después de lanzar la orden asegúrese de comprobar que la salida es limpia:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 nombre-de-fichero}}

Para convertir un fichero, se deberá crear otro fichero:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 nombredefichero > nuevofichero}}

El paquete recode {{Package|app-text/recode}} se puede utilizar también para este propósito.

=== La consola del sistema ===

Para habilitar UTF-8 en la consola, debe editar {{Path|/etc/rc.conf}}. Definir <code>unicode="yes"</code>, y también leer los comentarios en ese fichero. Es importante tener una tipografía que tenga un buen rango de caracteres para obtener el máximo de Unicode. Para que esto funcione, asegúrese de que se ha creado una localización Unicode correctamente. 

La variable <var>keymap</var> definida en {{Path|/etc/conf.d/keymaps}} debería especificar un mapa de teclado Unicode. 

{{CodeBox|title=Fragmento ejemplo de /etc/conf.d/keymaps|lang=bash|1=
## (Cambie "es" por la disposición local adecuada)
keymap="es"
}}

=== Ncurses y Slang ===

{{Note|Ignore cualquier mención de Slang en esta sección si no está instalado o no es necesario.}}

Es sensato añadir [https://packages.gentoo.org/useflags/unicode <code>unicode</code>] a las [[USE flag|opciones USE]] globales en {{Path|[[:/etc/portage/make.conf#USE|/etc/portage/make.conf]]}}, y hacer de nuevo emerge de {{Package|sys-libs/ncurses}} y de {{Package|sys-libs/slang}} si procede. Portage hará esto de forma automática cuando actualice su sistema si se utilizan las opciones <code>--changed-use</code> o <code>--newuse</code>. Lance la siguiente orden para obtener los paquetes: 

{{RootCmd|emerge --update --deep --newuse world}}

También necesitamos reconstruir los paquetes que enlazan a éstos, ahora se han aplicado los cambios a USE. La herramienta que utilizamos ({{c|revdep-rebuild}}) es parte del paquete {{Package|app-portage/gentoolkit}}. 

{{RootCmd|revdep-rebuild --soname libncurses.so.5 |revdep-rebuild --soname libslang.so.1}}

=== KDE, GNOME y Xfce ===

Todos los entornos de escritorio de mayor uso tienen soporte completo para Unicode y no requieren de configuraciones adicionales que ya se hayan comentado en esta guía. Esto es debido a que las herramientas gráficas (Qt o GTK+2) ya son compatibles con UTF-8. Por tanto, todas las aplicaciones que corran sobre estas herramientas deberían ser compatibles UTF-8. 

{{:Input_methods/key_sequence}}

Las excepciones a esta regla son Xlib y GTK+1. GTK+1 requiere un FontSpec iso-10646-1 en el fichero /.*gtkrc, por ejemplo <code>-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1</code>. También, las aplicaciones que utilizan Xlib o Xaw necesitarán tener un FontSpec similar, de lo contrario no funcionarán. 

{{Note|Si dispone de una versión del antigua del centro de control de gnome1, utilícelo en su lugar. Elija cualquier tipografía iso10646-1.}}

{{CodeBox|title=Ejemplo de fichero ~/.gtkrc (para GTK+1) que define una tipografía compatible con Unicode|1=
style "user-font"
{
 fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"
}
widget_class "*" style "user-font"
}}

Si una aplicación tiene soporte para las interfaces gráficas Qt y GTK+2, la interfaz gráfica GTK+2 normalmente ofrecerá mejores resultados con Unicode.

=== X11 y tipografías ===

Las tipografías TrueType tienen soporte para Unicode, y la mayoría de las tipografías que se entregan con XorgShift tienen un soporte de carácter extensivo, aunque, obviamente, no todos los glifos disponibles en Unicode se han creado para todas las tipografías. 

También, muchos paquetes de tipografías presentes en Portage están preparados para Unicode. Lea la página sobre [[Fontconfig/es|Fontconfig]] para obtener más información sobre tipografías recomendadas y su configuración.

=== Gestores de ventanas y emuladores de terminal ===

Los gestores de ventanas que no se han construido con GTK+ o Qt generalmente tienen muy buen soporte para Unicode, ya que a menudo utilizan la biblioteca Xft para el manejo de tipografías. Si el gestor de ventanas no utiliza Xft para las tipografías, entonces todavía se puede utilizar el FontSpec mencionado en la sección anterior como una tipografía Unicode. 

Los emuladores de terminal que utilicen Xft y tengan soporte unicode son más difíciles de encontrar. Aparte de Konsole y gnome-terminal, las mejores opciones en Portage son  {{Package|x11-terms/rxvt-unicode}}, {{Package|x11-terms/xfce4-terminal}}, {{Package|gnustep-apps/terminal}}, {{Package|x11-terms/mlterm}}, or plain {{Package|x11-terms/xterm}} cuando se construye con la opción USE <code>unicode</code> y se invoca como <code>uxterm</code>. {{Package|app-misc/screen}} también ofrece soporte para UTF-8 cuando se invoca como {{c|screen -U}} o se incluye lo siguiente en el fichero {{Path|~/.screenrc}} : 

{{CodeBox|title=~/.screenrc para UTF-8|1=
defutf8 on
}}

=== Vim, emacs, xemacs y nano ===

[[Vim/es#Cambiar_la_codificaci.C3.B3n_del_fichero|Vim]] ofrece soporte completo para UTF-8 y también la detección automática de ficheros codificados con UTF-8. Para más información, dentro de [[Vim/es#Cambiar_la_codificaci.C3.B3n_del_fichero|Vim]] , utilice <code>:help mbyte.txt</code>. 

[[GNU Emacs]] Desde la versión 23 y [[XEmacs]] desde la versión 21.5 tiene soporte completo para UTF-8. GNU Emacs 24 también tiene soporte para la edición de texto bidireccional. 

Nano proporciona soporte UTF-8 completo desde la versión 1.3.6.

=== Intérpretes de Comandos ===

Actualmente {{c|[[bash]]}} ofrece soporte completi Unicode a través de la librería GNU readline. Z Shell ({{c|[[zsh]]}}) ofrece soporte Unicode mediante la opción USE <code>unicode</code>. 

Los interpretes de comandos C, {{c|tcsh}} y {{c|ksh}} no ofrecen ningún tipo de soporte UTF-8.

=== Irssi ===

Irssi ofrece soporte completo de UTF-8, aunque requiere que el usuario active una opción. 

{{Cmd|set term_charset UTF-8|prompt=[irssi] }}

Para canales en los que se intercambian con frecuencia caracteres que no son ASCII mediante conjuntos de caracteres que no son UTF-8, la orden {{c|recode}} se puede utilizar para convertir caracteres. Teclee {{c|/help recode}} para obtener más información.

=== Mutt ===

El agente de correo de usuario Mutt tiene muy buen soporte para Unicode. Para utilizar UTF-8 con Mutt, no se necesita poner nada en el fichero de configuración. Mutt funcionará en un entorno Unicode si ninguna modificación si todos los ficheros de configuración (incluida la firma) están codificados con UTF-8. 

{{Note|Todavía es posible observar '?' en los mensajes de correo electrónico que se leen con Mutt. Esto es debido a que hay personas que utilizan un cliente de correo que no indica el conjunto de caracteres usado. No se puede hacer mucho al respecto más que pedirles que configuren sus clientes de correo correctamente.}}

Hay más información en el [http://wiki.mutt.org/index.cgi?MuttFaq/Charset Wiki de Mutt]. 

=== Man ===

Las páginas del manual (man) son parte integral de una máquina Linux. Para asegurarse de que cualquier unicode en las páginas del manual se muestra correctamente, se debe editar {{Path|/etc/man.conf}} y cambiar la línea que se muestra abajo. 

{{CodeBox|title=Cambios en man.conf para soporte Unicode|1=
## (Esta es la línea antigua)
NROFF /usr/bin/nroff -Tascii -c -mandoc
## (Cambie la línea de arriba por esta)
NROFF /usr/bin/nroff -mandoc -c
}}

=== links y elinks ===

Estos son navegadores en modo texto comúnmente usados, y debemos ver como podemos habilitar el soporte UTF-8 en ellos. En {{c|elinks}} y {{c|links}}, hay dos formas de hacer esto, una es utilizando la opción de configuración dentro del navegador y otra es editar el fichero de configuración. Para activar la opción dentro del navegador, abra un sitio con {{c|elinks}} o {{c|links}} y presione {{Key|Alt}} + {{Key|S}} para entrar en le menú de configuración. A continuación seleccione las opciones del terminal, o presione {{Key|T}}. Desplácese hacia abajo y seleccione la última opción <code>UTF-8 I/O</code> presionando {{Key|Intro}}. Luego guarde y salga del menú. En {{c|links}} puede que se que tenga que repetir {{Key|Alt}} + {{Key|S}} y luego presionar {{Key|S}} para guardar. La opción del fichero de configuración se muestra abajo. 

{{CodeBox|title=Habilitar UTF-8 para elinks o links|1=
## (Para elinks, editar /etc/elinks/elinks.conf o ~/.elinks/elinks.conf y añadir la siguiente línea)
set terminal.linux.utf_8_io = 1
## (Para links, editar ~/.links/links.cfg y añadir la siguiente línea)
terminal "xterm" 0 1 0 us-ascii utf-8
}}

=== Samba ===

Samba es una suite de software que implementa el protocolo SMB (Bloque de Mensajes del Servidor) para sistemas UNIX como Macs, Linux y FreeBSD. A este protocolo también se le llama Sistema de Ficheros Común de Internet (CIFS). Samba también incluye el sistema NetBIOS, utilizado para compartir ficheros en redes con sistemas Windows. 

añada lo siguiente bajo la sección [global]: {{RootCmd|nano -w /etc/samba/smb.conf|output=<pre>
dos charset = 1255
unix charset = UTF-8
display charset = UTF-8
</pre>
}}

=== Probarlo todo ===

Existen muchos sitios web para probar UTF-8 y la mayoría de los [https://packages.gentoo.org/categories/www-client navegadores en Gentoo] más populares ofrecen soporte para completo de UTF-8. 

Cuándo se utiliza un navegador en modo texto, asegúrese bien de que lo está utilizando desde un terminal que es compatible con Unicode.

If certain characters are displayed as boxes with letters or numbers inside, then the current [[fonts|font]] does not have glyphs for those characters. Instead, it displays a box with the hex code of the UTF-8 symbol. 

* [http://unicode-table.com/es/ unicode-table.com]
* [http://www.w3.org/2001/06/utf-8-test/utf-8-demo.html Una página de prueba UTF-8 de W3C]
* [http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm Una página de prueba UTF-8 ofrecida por la Universidad de Fráncfort]

== Cuestiones o problemas reportados ==

=== Ficheros de configuración del sistema (en /etc) ===

La mayoría de los ficheros de configuración del sistema (como {{Path|/etc/fstab}}) no ofrecen soporte para UTF-8. Se recomienda ajustarse al conjunto de caracteres ASCII cuando se editen estos ficheros.

== Recursos externos ==

*  [https://es.wikipedia.org/wiki/unicode La entrada en Wikipedia para Unicode]
*  [https://es.wikipedia.org/wiki/utf-8 La entrada en Wikipedia para *UTF-8]
*  [http://www.unicode.org Unicode.org]
*  [http://www.utf-8.com UTF-8.com]
*  [http://www.ietf.org/rfc/rfc3629.txt RFC 3629]
*  [http://www.ietf.org/rfc/rfc2277.txt RFC 2277]
*  [http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF Caracteres vs. Bytes]
* [http://www.gnu.org/software/libc/manual/html_node/Locales.html La biblioteca GNU: Localizaciones e Internacionalización]
* [http://unifoundry.com/unicode-tutorial Unifoundry.com - Tutorial de Unicode]
* [https://packages.gentoo.org/useflags/unicode Descripción del ajuste USE unicode]

[[Category:Localization]] {{Migrated|originalauthors=Thomas Martin, Alexander Simonov, Shyam Mani, nightmorph}}
