== Commit Policy ==

* atomic commits (one logical change)
* commits may span across multiple ebuilds/directories if it's one logical change
* every commit on the left-most line of the history (that is, all the commits following the first parent of each commit) must be gpg signed by a gentoo dev
* repoman must be run from all related ebuild directories (or related category directories or top-level directory) on the tip of the local master branch (as in: right before you push and also after resolving push-conflicts)

=== Atomicity ===

* commits in git are cheap and local, so use them often
* don't do version bumps and ebuild cleanup in one commit (makes reverting ebuild removals more difficult)

=== Commit Message Format ===

* all lines max 70-75 chars
* first line brief explanation
* second line always empty
* optional detailed multiline explanation must start at the third line
* commits that affect primarily a particular subsystem should prepend the following code to the first line of the commit message:
** single package -> <code>CATEGORY/PN:</code>
** profile directory -> <code>profiles:</code>
** eclass directory -> <code>ECLASSNAME.eclass:</code>
** licenses directory -> <code>licenses:</code>
** metadata directory -> <code>metadata:</code>
** a whole category -> <code>CATEGORY:</code>
* if CATEGORY/PN is very long and you can't reasonable stick to the 75 char limit, just exceed it in that case
* if the change affects multiple directories, but is mostly related to a particular subsystem, then prepend the subsystem which best reflects the intention (e.g. you add a new license, but also modify profiles/license_groups)
* it is also encouraged to use formats such as <code>Acked-by:</code>, <code>Suggested-by:</code> and so on, also see the [https://www.kernel.org/doc/Documentation/SubmittingPatches kernel patch guideline]

==== Example ====

<pre>app-misc/foo: version bump to 0.5

This does also fix the security bug 93829
and introduces the new USE flag 'bar'.

Acked-by: Hans Wurst <hans@gentoo.org>
Reported-by: Alice Wonderland <alice@foo.com>
</pre>

== Branching Model ==

* the primary production-ready branch is master (users will pull from here), there are no non-fast-forward pushes allowed
* there may be developer-specific, task-specific, project-specific branches etc

=== Naming Convention ===

* developer branches: dev/<name>
* project branches: project/<name>
* if in doubt or if the branch could be useful to others, discuss the naming on-list beforehand

=== About Rebasing ===

* primary use case: in case of a non-fast-forward push conflict to remote master, try <code>git pull --rebase=preserve</code> first; if that yields complicated conflicts, abort the rebase and continue with a regular merge (if the conflicts are trivial or even expected, e.g. arch teams keywording/stabilizing stuff, then stick to the rebase)
* to preserve merges during a rebase use <code>git rebase --preserve-merges ...</code> (if appropriate, e.g. for user branches)
* don't use ''--preserve-merges'' if you do an interactive rebase (see BUGS in git-rebase manpage)
* commits that are not on the remote master branch yet may be rewritten/squashed/splitted etc via interactive rebase, however the rebase must never span beyond those commits
* never rebase on already pushed commits
* there are no particular rules for rebasing on non-master remote branches, but be aware that others might base their work on them
* there are no particular rules for rebasing non-remote branches, as long as they don't clutter the history when merged back into master
* don't do complicated rebases to avoid a merge commit at all cost (it may even cause losing information, e.g. user signatures)

=== About Merging ===

* '''do not ever commit implicit merges done by git pull'''. You may want to set <code>git config --local pull.ff only</code> to avoid git implicitly creating those
* if a rebase fails or is too complicated, do a regular merge instead
* do a merge if the information is useful (e.g. pulled from a foreign remote user branch or merged a non-trivial eclass conversion back into master) and force a merge commit (non-fast-forward merge via ''--no-ff'')
* to avoid a merge commit when merging local branches back to master (e.g. information is not useful), you may try to force a fast-forward merge by first rebasing the local branch against master and then merging it into master, see [http://www.kerrybuckley.org/2008/06/18/avoiding-merge-commits-in-git/ here]
* extend merge commit messages with useful information, e.g. how conflicts were solved
* keep in mind that all commits of the first parent of the history must be gpg signed by a gentoo dev, so you may want to force merge commits especially for user branches

== Remote Model ==

We have a main developer repo where developers work & commit (every developer has direct push access). For every push into developer repo, automated magic thingie merges stuff into user sync repo and updates the metadata cache there.

User sync repo is for power users than want to fetch via git. It's quite fast and efficient for frequent updates, and also saves space by being free of ChangeLogs.

On top of user sync repo rsync is propagated. The rsync tree is populated with all old ChangeLogs copied from CVS (stored in 30M git repo), new ChangeLogs are generated from git logs and Manifests are expanded.

== Best Practices ==

* before starting work on your local master, it's good to first pull the latest changeset (if any) from remote master
* it might be a good idea for projects/developers to accumulate changes either in their own branch or a separate repository and only push to remote master in intervals (that decreases the push rate and potential conflicts)

== Repository settings ==

=== Cloning ===
Clone the repository. This will make a shallow clone and speed up clone time: {{Cmd|git clone --depth{{=}}50 git+ssh://git@git.gentoo.org/repo/gentoo.git}}
{{Note|You need at least git-1.9 for shallow clones to work properly, so that you can also push back to the remote dev repository.}}
If you want the full history, just omit ''--depth=50'' from the above command.

=== Configuration ===

All developers should at least have the following configuration settings in their local dev repository. These setting will be written to ''.git/config'' and can also be edited manually. Run these from within the repository you've just cloned in the step above:
{{Cmd
|cd gentoo
|git config --local user.name "Your Full Name"
|git config --local user.email "example@gentoo.org"
|git config --local user.signingkey 0xLONG-GPG-KEY
|git config --local commit.gpgsign 1
|git config --local pull.ff only}}

In addition, you need to tell repoman which key to use, in case you use repoman for committing.

{{FileBox|filename=/etc/portage/make.conf|1=
PORTAGE_GPG_KEY="0xLONG-GPG-KEY"
}}

== Workflow Walkthrough ==

These are just examples and people may choose different local workflows (especially in terms of when to stage/commit) as long as the end result works and is repoman-checked. These examples try to be very safe, but basic.

=== Common Ebuild Work ===

# pull in the latest changeset, before starting your work: {{Cmd|git pull --rebase{{=}}preserve origin master}}
# do the work (including removing files)
# make sure you are in the ebuild directory
# create the manifest {{Cmd|repoman manifest}}
# stage files (including removed ones), if any {{Cmd|git add <new-files> <changed-files> <removed-files>}} {{Note|A shortcut for staging all files in the current dir (and subdirs) would be: {{Cmd|git add -- .}}}}
# check for errors {{Cmd|repoman full}} {{Warning|Repoman checks the files on filesystem level and doesn't really know what changes are staged or committed! So make sure the ebuild directory is clean and there are no unstaged changes or untracked files when running repoman. To check for such changes/files, run: {{Cmd|git status}} To clean up unstaged changes and untracked files run: {{Cmd|git checkout -- .|git clean -i}}}}
## if errors occur, fix them and continue from point 4
# commit the files {{Cmd|repoman commit -m "<message>"}}
# push to the dev repository {{Cmd|git push --signed origin master}}
## if updates were rejected because of non-fast-forward push, try {{Cmd|git pull --rebase{{=}}preserve origin master}} first, then run {{Cmd|repoman full}} and continue from point 8. {{Note|You may skip running repoman another time if you have manually verified that the commits you are missing are totally unrelated to your work (e.g. only affect a package that is not in the dependency chain of yours). You can do so via: {{Cmd|git diff $(git merge-base master remotes/origin/master) remotes/origin/master}}}}
### if the rebase fails, but the conflicts are trivial and don't contain useful information (such as keyword stabilization), fix the conflicts and finish the rebase via {{Cmd|git mergetool|git rebase --continue}} and continue from point 4
### if the rebase fails and the conflicts are complicated or you think the information is useful, continue with a regular merge: {{Cmd|git rebase --abort|git merge remotes/origin/master}}
#### if merge conflicts occur, fix them via {{Cmd|git mergetool}} and continue from point 4 {{Warning|A merge conflict is not to be taken lightly. It could indicate miscommunication in one way or another (e.g. several people working on the same ebuild), so fix that first and try to clarify the situation.}}
#### if no merge conflicts occur, run {{Cmd|repoman full}} and continue from point 8

=== Pull Requests ===

# identify the remote url and the branch to be merged
# add a new remote {{Cmd|git remote add <remote-name> <url>}}
# fetch the changes {{Cmd|git fetch <remote-name> <branch>}}
# you may review the changes manually first {{Cmd|git log master..remotes/<remote-name>/<branch>|git diff master..remotes/<remote-name>/<branch>}}
# checkout the remote branch {{Cmd|git checkout remotes/<remote-name>/<branch>}} (you are now in detached HEAD mode)
# test the ebuilds and run repoman {{Cmd|repoman full}}
# if everything is fine, switch back to master {{Cmd|git checkout master}}
# now merge the changes with an enforced merge commit (both for the info and for gpg signature checking to work) {{Cmd|git merge --no-ff remotes/<remote-name>/<branch>}}
# push to the dev repository (same as in the [[Gentoo_git_workflow#common_ebuild_work|previous section]])

{{Note|Alternatively, you can create a new local branch where you pull in the remote user branch instead of working directly in detached HEAD mode on remotes/<remote-name>/<branch>.}}

== Issues ==

=== repoman: "Malformed CVS Header" warning ===

The former <code># $Header: $</code> header is no more and has been substitued with a <code># $Id$</code> header during the migration. Hence, you'll often run into this warning:

{{Cmd|$ repoman full -d

RepoMan scours the neighborhood...

>>> Creating Manifest for /home/user/gentoo/dev-java/rhino

  ebuild.badheader              3
    dev-java/rhino/rhino-1.6.5.ebuild: Malformed CVS Header on line: 3
    dev-java/rhino/rhino-1.7.2-r2.ebuild: Malformed CVS Header on line: 3
    dev-java/rhino/rhino-1.7.7.ebuild: Malformed CVS Header on line: 3
}}

For the time being, you can safely ignore it and go ahead with your changes. A patch has already been sent out and discussed on the portage-dev mailing list to match the new header and silence this warning. See the full [http://thread.gmane.org/gmane.linux.gentoo.portage.devel/5686 discussion].

== Tips and Tricks ==

Especially staging files can be tedious on the CLI. So you may want to use the graphical clients 'gitk' (for browsing history) and 'git gui' (for staging/unstaging changes etc.). You have to enable the 'tk' USE flag for {{Package|dev-vcs/git}}.

== See Also ==

* [[Git]]
* [https://gitweb.gentoo.org/repo/gentoo.git gentoo gitweb]
* [https://github.com/gentoo/gentoo gentoo github mirror]
* [[Project:Infrastructure/Git_migration]]

== External Resources ==

* [http://www.vogella.com/tutorials/Git/article.html Git Tutorial by Lars Vogel]
* [http://gitready.com/ Tips and Tricks on gitready]
* [https://www.kernel.org/doc/Documentation/SubmittingPatches kernel patch guideline]
