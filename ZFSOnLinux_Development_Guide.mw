This page is a temporary home for documentation intended as a reference for ZFS developers on how ZFSOnLinux development is done. It is a WIP and it is only meant for developers.

= Setting up a development environment =

This is easiest with a Linux environment. It is theoretically possible to use non-Linux environments, but no one does it in practice and anyone trying to use a non-Linux environment will be in new territory.

Once you have a Linux environment, you will want to install and configure git. The [http://git-scm.com/book/en/Getting-Started-First-Time-Git-Setup  "Git book"] is a good resource for this, but the simplest setup is:

{{Cmd|git config --global user.name "John Doe"
|git config --global user.email johndoe@example.com}}

In addition, you will want to setup a github account and configure it so that you can do clones over SSH. Once that is done, clone the repositories:

{{Cmd|mdkir ~/devel
|cd ~/devel
|git clone git@github.com:zfsonlinux/spl.git
|git clone git@github.com:zfsonlinux/zfs.git}}

Also, you will likely want to install and use cscope. Using cscope is easy with the following bash alias.

{{Cmd|alias cscope-init{{=}}'find . -name '*.c' -o -name '*.h' > cscope.files'}}

After running that in your shell, you can run `cscope-init && cscope -d` inside directories to get a nice curses interface for browsing the code.

= Setting up a VM environment =

Virtual machines can save time when running regression tests reveal problems in new code by allowing inspection of the environment from the hypervisor. It is desireable to test module loading and unloading in the virtual environment, so it is best to use a non-ZFS rootfs in the environment running regression tests. The simplest one to use is 9p-virtio, which is a network filesystem whose server is integrated with QEMU and operates over a virtio transport. It also introduces a few quirks of its own, but those can be worked around by compiling in a chroot.

== Gentoo with a 9p-virtio rootfs ==

We pick /guest as a place to store the virtual machines. /guest/gentoo will store the rootfs and we will make clever use of bind mounts to have a chroot at /guest/gentoo-chroot to alow us to operate on the rootfs even while the VM is running.

{{RootCmd|mkdir -p /guest/gentoo{,-chroot}
|cd /guest/gentoo}}

Now we install the current stage3:

{{RootCmd|wget 'ftp://gentoo.osuosl.org/pub/gentoo/releases/amd64/autobuilds/current-stage3-amd64/stage3-amd64-[0-9]*.tar.bz2'
tar -xvjpf stage3-amd64-*.tar.bz2 -C .}}

Setup the bind mounts:

{{RootCmd|mount --bind /guest/gentoo{,-chroot}
|mount -t proc none /guest/gentoo-chroot/proc
|mount --rbind /dev /guest/gentoo-chroot/dev
|mount --rbind /sys /guest/gentoo-chroot/sys}}

Also setup a bind mount to allow the chroot to access code from our development environment:

{{RootCmd|mount --bind /home/richard/devel /guest/gentoo-chroot/mnt/code
|mount -o remount,ro /guest/gentoo-chroot/mnt/code}}

{{Note|You will need to adjust the paths if you had picked different locations.}}
{{Warning|A bug in the Linux kernel prevents us from creating a readonly bind mount that points to a rw location. The bind mount must be created and then remounted as readonly.}}

Copy resolv.conf so that DNS resolution inside our chroot works:

{{RootCmd|cp /etc/resolv.conf /guest/gentoo-chroot/etc/}}

Now enter the chroot for additional setup:

{{RootCmd|chroot /guest/gentoo-chroot /bin/bash
|env-update
|source /etc/profile
|export PS1="(chroot) $PS1"
|cd}}

Setup serial terminals

{{Cmd|prompt=(chroot) root #
|color=purple
|sed -i -e 's\#s0:12345:respawn:/sbin/agetty -L 115200 ttyS0 vt100\s0:12345:respawn:/sbin/agetty -a root -L 115200 ttyS0 vt100\' /etc/inittab
|sed -i -e 's\#s1:12345:respawn:/sbin/agetty -L 115200 ttyS1 vt100\s1:12345:respawn:/sbin/agetty -a root -L 115200 ttyS1 vt100\' /etc/inittab}}

Disable the fstab entries. We do not need them with a 9p-virtio rootfs:

{{Cmd|prompt=(chroot) root #
|color=purple
|sed -i -e "s/\(.*\)\/\(BOOT\{{!}}ROOT\{{!}}SWAP\)\(.*\)/\#\1\/\2\3/g" /etc/fstab}}

Now lets setup portage:

{{Cmd|prompt=(chroot) root #
|color=purple|mkdir -p /usr/portage
|chown portage:portage /usr/portage}}

Lets also setup distfiles and packages:

{{Cmd|prompt=(chroot) root #
|color=purple|mkdir -p /usr/portage-{distfiles,packages}
|chown portage:portage /usr/portage-{distfiles,packages}
}}

{{Note|If you wish to share the portage tree, distfiles or packages between your main system and the chroot, it is rather trivial to use bind mounts to do it}}

Do some portage configuration.

{{Cmd|prompt=(chroot) root #
|color=purple|echo 'dev-libs/beecrypt threads' >> /etc/portage/package.use
|echo 'app-emulation/qemu ~amd64' >> /etc/portage/package.accept_keywords
|echo 'dev-util/perf ~*' >> /etc/portage/package.accept_keywords
|echo 'sys-kernel/vanilla-sources ~amd64' >> /etc/portage/package.accept_keywords}}

Keyword the 9999 ebuilds.

{{Cmd|prompt=(chroot) root #
|color=purple|echo "sys-kernel/spl **" >> /etc/portage/package.accept_keywords
|echo "sys-fs/zfs-kmod **" >> /etc/portage/package.accept_keywords
|echo "sys-fs/zfs **" >> /etc/portage/package.accept_keywords}}

Configure ZFS packaging
{{Cmd|prompt=(chroot) root #
|color=purple|echo "sys-kernel/spl custom-cflags debug debug-log" >> /etc/portage/package.use
|echo "sys-fs/zfs-kmod custom-cflags debug -rootfs" >> /etc/portage/package.use
|echo "sys-fs/zfs custom-cflags debug -rootfs test-suite" >> /etc/portage/package.use}}

If you are not bind mounting a portage tree, install one:

{{Cmd|prompt=(chroot) root #
|color=purple|emerge-webrsync}}

Install a few tools we will need:

{{Cmd|prompt=(chroot) root #
|color=purple|emerge ccache debugedit}}

Configure make.conf:

{{Cmd|prompt=(chroot) root #
|color=purple|cat << END > /etc/portage/make.conf
USE{{=}}"mmx sse sse2 multilib dlz -X -gtk -sdl -qt -nptl -xpm -gpm"
CFLAGS{{=}}"-march{{=}}native -O2 -pipe -ggdb"
CXXFLAGS{{=}}"\${CFLAGS}"
MAKEOPTS{{=}}"-j7"
CHOST{{=}}"x86_64-pc-linux-gnu"

PORTDIR{{=}}"/usr/portage"
DISTDIR{{=}}"\${PORTDIR}-distfiles"
PKGDIR{{=}}"\${PORTDIR}-packages"

FEATURES{{=}}"buildpkg ccache collision-protect installsources metadata-transfer multilib-strict noinfo parallel-fetch parallel-install sign split-log splitdebug userpriv usersandbox usersync webrsync-gpg"

spl_LIVE_BRANCH{{=}}master
spl_LIVE_REPO{{=}}'/mnt/code/spl'
zfs_kmod_LIVE_BRANCH{{=}}master
zfs_kmod_LIVE_REPO{{=}}'/mnt/code/zfs'
zfs_LIVE_BRANCH{{=}}master
zfs_LIVE_REPO{{=}}'/mnt/code/zfs'
END
}}

We compile quite a bit, so we therefore try to optimize GCC somewhat
{{Cmd|prompt=(chroot) root #
|color=purple|mkdir -p /etc/portage/env/sys-devel
|echo 'GCC_MAKE_TARGET{{=}}"profiledbootstrap"' >> /etc/portage/env/sys-devel/gcc}}

Lets rebuild everything and install the tools we need at the same time
{{Cmd|prompt=(chroot) root #
|color=purple|emerge --jobs --keep-going -ave @world qemu tmux wgetpaste gdb dev-vcs/git htop genlop gentoolkit gentoolkit-dev vim layman ccache debugedit perf sys-kernel/vanilla-sources genkernel pax-utils strace iotop}}

Lets cheat at kernel configuration
{{Cmd|prompt=(chroot) root #
|color=purple|zcat /proc/config.gz > /usr/src/linux/.config
|make -C /usr/src/linux olddefconfig menuconfig}}

In menuconfig, make certain that you enable the following

* CONFIG_MODULES=y
* CONFIG_MODULE_UNLOAD=y
* CONFIG_EXPERT=y
* CONFIG_KALLSYMS=y
* CONFIG_KPROBES=y
* CONFIG_FTRACE=y
* CONFIG_KPROBE_EVENT=y (probably already set)
* CONFIG_UPROBE_EVENT=y
* CONFIG_FUNCTION_TRACER=y
* CONFIG_FUNCTION_GRAPH_TRACER=y (probably already set)
* CONFIG_DEBUG_INFO=y
* CONFIG_READABLE_ASM=y
* CONFIG_LOCKUP_DETECTOR=y
* CONFIG_DEBUG_LIST=y
* CONFIG_KGDB=y
* CONFIG_DEBUG_SET_MODULE_RONX=y
* CONFIG_CC_STACKPROTECTOR_REGULAR=y (CONFIG_CC_STACKPROTECTOR_STRONG preferred, but we don't have GCC 4.9 yet)
* CONFIG_VIRTIO_PCI=y
* CONFIG_NET_9P=y
* CONFIG_NET_9P_VIRTIO=y
* CONFIG_9P_FS=y
* CONFIG_9P_FS_POSIX_ACL=y
* CONFIG_9P_FS_SECURITY=y

Then compile the kernel:

{{Cmd|prompt=(chroot) root #
|color=purple|make -C /usr/src/linux bzImage}}

Now install ZFS. It should pull from your local checkout.

{{Cmd|prompt=(chroot) root #
|color=purple|emerge zfs}}

Now you should be able to start a VM:

{{Cmd|sudo qemu-kvm -smp 12,cores{{=}}6,threads{{=}}1,sockets{{=}}1 -cpu host -m 1024 -kernel /guest/gentoo/usr/src/linux/arch/x86/boot/bzImage -append 'root{{=}}/dev/root rootfstype{{=}}9p rootflags{{=}}trans{{=}}virtio,version{{=}}9p2000.L ro console{{=}}ttyS0' -serial mon:stdio -serial pty -fsdev local,id{{=}}root,path{{=}}/guest/gentoo,security_model{{=}}passthrough -device virtio-9p-pci,fsdev{{=}}root,mount_tag{{=}}/dev/root -vga none -nographic}}

== Development ==

You will commit changes to a branch in your git checkouts in your home directory. Inside the chroot, you will rebuild the ZFS kernel modules and userland tools as needed:

{{Cmd|prompt=(chroot) root #
|color=purple|emerge --oneshot @module-rebuild sys-fs/zfs}}

Edit the appropriate variables in /etc/portage/make.conf to point to the branch that you want to compile. Sometimes, you will encounter situations where a running virtual machine has old copies of the files from the chroot. You can resolve that by running drop_caches inside the VM:

{{RootCmd|echo 3 > /proc/sys/vm/drop_caches}

== Debugging ==

QEMU's monitor and first serial console are multiplexed on the terminal by the QEMU command in the previous section. Switching between them can be done by typing Ctrl+A C. QEMU's monitor has several interesting functions. One being that it permits you to start the gdb server by typing `gdbserver`. gdb can then be attached to debug. This has an issue where gdb cannot find the kernel sources, but this can be resolved by using gdb from the chroot to debug the running VM:

{{Cmd|sudo -i chroot /guest/gentoo /usr/bin/gdb /usr/src/linux/vmlinux}}

If on a 64-bit architecture, it is often necessary to specify that to gdb explicitly. Afterward, gdb can be sanely told to attach to the server. The default port is 1234.

{{Cmd|prompt=(gdb)
|color=blue
|set architecture i386:x86-64
|target remote localhost:1234}}

Since the ZFSOnLinux code is loaded as modules, we will need to tell gdb about them. At present, the only known way of doing this is getting the module address from /proc/modules inside the VM environment and then telling gdb to load the symbol files. For example:

{{Cmd|prompt=(gdb)
|color=blue
|add-symbol-file /lib/modules/2.6.32-431.11.2.el6.x86_64/extra/zfs/zfs.ko 0xffffffffa0181000
|add-symbol-file /lib/modules/2.6.32-431.11.2.el6.x86_64/extra/taskq/ztaskq.ko 0xffffffffa0177000
|add-symbol-file /lib/modules/2.6.32-431.11.2.el6.x86_64/extra/spl/spl.ko 0xffffffffa00cb000}}

After doing this, you will be able to set breakpoints on the ZFS code in gdb and step through execution. These breakpoints will be lost in the event that you reset the virtual machine using `system_reset` from the QEMU monitor.

Since gdbserver is running at the level of QEMU, you will not be able to see individual threads. Instead, you will see cores, but that in itself can be advantageous in certain scenarios. Getting direct access to threads requires using kgdb.
