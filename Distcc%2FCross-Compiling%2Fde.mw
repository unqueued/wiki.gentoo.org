<languages />


{{Metadata|abstract=Diese Anleitung zeigt wie distcc für das Übersetzen von Programmen für eine andere Rechnerarchitektur, als die vorhandene, konfiguriert werden msuss.}}

Diese Anleitung zeigt wie distcc für das Übersetzen von Programmen für eine andere Rechnerarchitektur, als die vorhandene, konfiguriert werden msuss.

== Cross-Compiling mit distcc ==

=== Einleitung ===

{{c|distcc}} ist ein Tool mit dem die Aufgaben eines Compilierprozesses auf mehrere im Netzwerk verteilte Rechner, aufgeteilt werden können. Wenn alle beteiligten Rechner die gleiche GCC-Version und Prozessorarchitektur verwenden, ist für {{c|distcc}} keine spezielle Konfiguration notwendig. 

'''Diese Anleitung enthält die Instruktionen wie distcc zu konfigurieren ist um Übersetzungen für andere Rechnerarchitekturen durchführen zu können.''' 

=== Installieren der benötigten Werkzeuge ===

Zuerst muss {{c|crossdev}} auf allen beteiligten Rechnern installiert werden. {{c|crossdev}} ist ein Tool mit dem die Werkzeuge die für andere Rechnerarchitekturen benötigt werden, einfach erstellt werden können. Es wird folgendermaßen aufgerufen: {{c|crossdev -t sparc}} erstellt alle Werkzeuge für die Sparc-Architektur. Die beinhaltet binutils, gcc, glibc und linux-Headers. 

Es ist notwendig die passenden Werkzeuge auf allen teilnehmenden Rechner zu installieren. Weitere Hilfe wird durch {{c|crossdev --help}} angezeigt.

Hier ist ein Skript das die genauen Versionen für binutils, gcc, kernel, glibc und verwendete Architektur anzeigt (dieses sollte auf der Ziel-Platform aufgerufen werden).

{{CodeBox|title=Anzeige der Versionen der Build-Werkzeuge|lang=bash|1=
#! /bin/bash
A="sys-devel/binutils" ; B=`equery l $A` ; BINUTILS_VER=`echo $B {{!}} cut -d- -f3-`
A=`/usr/bin/gcc-config -c` ; B=`echo $A {{!}} cut -d- -f5` ; GCC_VER=`equery l sys-devel/gcc {{!}} grep $B {{!}} cut -d- -f3-`
KERNEL_VER=`uname -r {{!}} sed s/-gentoo//`
A="sys-libs/glibc" ; B=`equery l $A` ; LIBC_VER=`echo $B {{!}} cut -d- -f3-`
echo "crossdev --b =$BINUTILS_VER --g =$GCC_VER --k =$KERNEL_VER --l =$LIBC_VER -t `uname -m`"
}}

Als nächstes muss {{c|distcc}} auf allen Rechnern installiert werden, die am Übersetzungsprozess beteiligt werden sollen. Dies schließt die Zielplattform und die Rechnern die für das Crosscompiling vorgesehen sind ein. Die [[Distcc|Gentoo Distcc Dokumentation]] enthält weitere Informationen für die Konfiguration und Benutzung von {{c|distcc}}.

{{Note|Aktuelle Versionen von {{c|crossdev}} haben ein <code>S (--stable)</code> Flag. Wenn dieses Flag gesetzt ist, werden nur als stabil gekennzeichnete Versionen der Compiler Werkzeuge benutzt. (z.B. {{c|crossdev -t i686-pc-linux-gnu --stable --ex-gcc --ex-gdb --portage --pretend}}). Ohne diese Option, installiert {{c|crossdev}} die letzte experimentelle Version der Compiler! Das Skript oben wird nicht benötigt, es sei den es wurden spezifische Versionen für Portage unmaskiert.}}

=== Hinweise für spezifische Architekturen ===

{{Note|Den Namen der verwendeten Prozessorarchitektur enthält die <var>CHOST</var> Variable in {{Path|/etc/make.conf}}. Crossdev wird für jede Architektur unterhalb {{Path|/usr}} die erforderlichen Tools installieren (z.B. {{Path|/usr/i686-pc-linux-gnu/}}, {{Path|/usr/i686-linux-gnu/}}, ...). Es wird empfohlen jede nicht mehr benötigte Architektur mit dem Befehl {{c|crossdev --clean}} vom System zu entfernen, bzw. die betreffenden Verzeichnisse manuell zu löschen.}}

==== Intel x86 Architekturen ====

Wird das Crosscompiling für verschiedene Intel-x86-Prozessoren (z.B. i586 und i686) durchgeführt, müssen die Tools für jeden gewünschten <var>CHOST</var> installiert werden, ansonsten schlägt die Übersetzung fehl. Die Prozessoren i586 und i686 sind aktuell verschiedene CHOST, obwohl es sich bei beiden um x86-Prozessoren handelt. Diese Unterscheidung darf nicht vergessen werden, wenn die Cross-Compiling Werkzeuge installiert werden. Wenn zum Beispiel für einen i586 Rechner Programme übersetzt werden sollen und über {{c|distcc}} i686 Rechner beteiligt werden, müssen auf diese die Werkzeuge für i586 installiert sein. 

==== SPARC ====

Der Aufruf von {{c|crossdev -t sparc}} kann mit einer der folgenden Fehlermeldungen fehlschlagen.

{{CodeBox|title=Angezeigte Fehler beim Aufruf von crossdev -t sparc|1=
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
}}

Wenn dies zutrifft, kann der folgende Befehl verwendet werden:

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== Fehlerfreies Crosscompiling mit distcc ===

In the default distcc setup, cross-compiling will ''not'' work properly. The problem is that many builds just call {{c|gcc}} instead of the full compiler name (e.g. {{c|sparc-unknown-linux-gnu-gcc}}). When this compile gets distributed to a distcc helper box, the native compiler gets called instead of your shiny new cross-compiler. 

Fortunately, there is a workaround for this little problem. All it takes is a wrapper script and a few symlinks on the box that will be running {{c|emerge}}. We'll use a Sparc box as an example. Wherever you see <code>sparc-unknown-linux-gnu</code> below, you will want to insert your own <var>CHOST</var> value (<code>x86_64-pc-linux-gnu</code> for an AMD64 box, for example). When you first emerge distcc, the {{Path|/usr/lib/distcc/bin}} directory looks like this: 

{{Note|The following instructions are to be performed only on the box running the emerge. Do not perform these steps on the helper boxes.}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

Here is what you want to do: 

{{RootCmd|rm c++ g++ gcc cc}}

Next, we'll create the new script on this box. Fire up your favorite editor and create a file with the following text in it, then save it as {{Path|sparc-unknown-linux-gnu-wrapper}}. Remember to change the <var>CHOST</var> value (in this case, <code>sparc-unknown-linux-gnu</code>) to the actual <var>CHOST</var> of the box that will be running the emerge. 

{{CodeBox|title=The new wrapper script|lang=bash|1=
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
}}

Next, we'll make the script executable and create the proper symlinks: 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

When you're done, {{Path|/usr/lib/distcc/bin}} will look like this: 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

Next we want to make sure that these wrappers stay available after upgrading the distcc package as it will overwrite the symbolic links. We can do this through a {{Path|/etc/portage/bashrc}} file that looks like so:

{{FileBox|filename=/etc/portage/bashrc|lang=bash|1=
case ${CATEGORY}/${PN} in
<pre>                 sys-devel/distcc | sys-devel/gcc)</pre>
			if [ "${EBUILD_PHASE}" == "postinst" ]; then
				/usr/local/sbin/distcc-fix &
			fi
		;;
esac
}}

Then create this file:

{{FileBox|filename=/usr/local/sbin/distcc-fix|lang=bash|1=
#!/bin/bash	                
 
sleep 20
# change TUPLE to match your machine
TUPLE="sparc-unknown-linux-gnu"
cd /usr/lib/distcc/bin
rm cc c++ gcc g++ ${TUPLE}-wrapper
echo '#!/bin/bash' > ${TUPLE}-wrapper
echo "exec ${TUPLE}-g\${0:\$[-2]}" "\"\$@\"" >> ${TUPLE}-wrapper
chmod 755 ${TUPLE}-wrapper
ln -s ${TUPLE}-wrapper cc
ln -s ${TUPLE}-wrapper c++
ln -s ${TUPLE}-wrapper gcc
ln -s ${TUPLE}-wrapper g++
}}

Give it the proper permissions:

{{RootCmd|chmod 755 /usr/local/sbin/distcc-fix}}

Congratulations; you (hopefully) now have a working cross-distcc setup.

=== How this works ===

When {{c|distcc}} is called, it checks to see what it was called as (e.g. <code>i686-pc-linux-gnu-gcc</code>, <code>sparc-unknown-linux-gnu-g++</code>, etc.) When distcc then distributes the compile to a helper box, it passes along the name it was called as. The distcc daemon on the other helper box then looks for a binary with that same name. If it sees just {{c|gcc}}, it will look for {{c|gcc}}, which is likely to be the native compiler on the helper box, if it is not the same architecture as the box running {{c|emerge}}. When the ''full'' name of the compiler is sent (e.g. <code>sparc-unknown-linux-gnu-gcc</code>), there is no confusion.

=== Troubleshooting ===

This section covers a number of common problems when using {{c|distcc}} for cross-compiling.

==== Remote host distccd COMPILE ERRORS ====

When receiving the message <code>COMPILE ERRORS</code> within a remote host's {{Path|/var/log/distccd.log}} file, see the above notes concerning specifying the correct architecture name (ie. {{c|crossdev -t $TARGET}}).

Another solution is to uninstall and re-install {{c|crossdev}} compiler tools, using the {{c|crossdev --clean}} option, or ensuring {{Path|/usr/$TARGET}} no longer exists, and then completely reinstall the cross compiler.

It might also be wise to edit the remote host's {{Path|/usr/$TARGET/etc/portage/make.conf}}, and ensure the contents of the <var>CFLAGS</var> variable are similar on all computers or hosts performing compiler operations.

==== Failed to exec $TARGET-unknown-linux-gnu-gcc: No such file or directory ====

The wrapper scripts might fail to execute, even with correct permissions:

{{CodeBox|title=Error message from wrapper|1=
distcc[6195] (dcc_execvp) ERROR: failed to exec i686-unknown-linux-gnu-gcc: No such file or directory)
}}

To resolve this, make sure to have the wrapper script created with the complete name of the architecture target:

{{Cmd|ls -alh /usr/lib/distcc/bin/c++|output=<pre>
/usr/lib/distcc/bin/c++ ->./i686-pc-linux-gnu-wrapper
</pre>}}

[[Category:Compilation]]
{{Migrated|originalauthors=Andrew Gaffney, Joshua Saddler}}
