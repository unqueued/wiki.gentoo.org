This guide provides instruction on securing systems by using the {{Package|app-misc/pax-utils}} package to find and identify problematic binaries.

== What is this guide about? ==

=== Introduction ===

The security of a system goes beyond setting up a decent firewall and good service configurations. The binaries being run and the libraries that are loaded might also be vulnerable against attacks. Although the exact vulnerabilities are not known until they are discovered, there are methods used to help prevent attacks from happening. 

One possible attack vector is to make advantage of writable ''and'' executable segments in a program or library, allowing malicious users to run their own code using the vulnerable application or library. 

This guide will inform the reader on how to use the {{Package|app-misc/pax-utils}} package to find and identify problematic binaries. The use of {{c|pspax}} (a tool to view PaX-specific capabilities) and {{c|dumpelf}} (a tool that prints out a C structure containing a workable copy of a given object) will also be covered. 

But before we start with that, some information on ''objects'' is in place. Users familiar with segments and dynamic linking will not learn anything from this and can immediately continue with [[#Extracting ELF Information from Binaries|Extracting ELF Information from Binaries]].

=== ELF objects ===

Every executable binary on the system is structured in a specific way, allowing the Linux kernel to load and execute the file. Actually, this goes beyond plain executable binaries: this also holds for shared objects; more about those later. 

The structure of such a binary is defined in the ELF standard. ELF stands for ''Executable and Linkable Format''. For readers who are really interested in the gory details, check out the [http://refspecs.linux-foundation.org/LSB_4.0.0/LSB-Core-generic/LSB-Core-generic/elf-generic.html Generic ELF spec] or the elf(5) man page. 

An executable ELF file has the following parts: 

* The ''ELF header'' contains information on the ''type'' of file (is it an executable, a shared library, ...), the target architecture, the location of the Program Header, Section Header and String Header in the file and the location of the first executable instruction
* The ''Program Header'' informs the system how to create a process from the binary file. It is actually a table consisting of entries for each segment in the program. Each entry contains the type, addresses (physical and virtual), size, access rights, ...
* The ''Section Header'' is a table consisting of entries for each section in the program. Each entry contains the name, type, size, ... and ''what'' information the section holds.
* Data, containing the sections and segments mentioned previously.

A ''section'' is a small unit consisting of specific data: instructions, variable data, symbol table, relocation information, and so on. A ''segment'' is a collection of sections; segments are the units that are actually transferred to memory. 

=== Shared objects ===

Way back when, every application binary contained ''everything'' it needed to operate correctly. Such binaries are called ''statically linked'' binaries. They are, however, space consuming since different applications use the same functions over and over again. 

A ''shared object'' contains the definition and instructions for such functions. Every application that wants can ''dynamically'' link against such a shared object so that it can benefit from the already existing functionality. 

An application that is dynamically linked to a shared object contains ''symbols'', references for the real functionality. When such an application is loaded in memory, it will first ask the runtime linker to resolve each and every symbol it has. The runtime linker will load the appropriate shared objects in memory and resolve the symbolic references between them. 

=== Segments and sections ===

How the ELF file is looked upon depends on the view we have: when we are dealing with a binary file in Execution View, the ELF file contains segments. When the file is seen in Linking View, the ELF file contains sections. One segment spans just one or more (continuous) sections. 

== Extracting ELF information from binaries ==

=== The scanelf application ===

The {{c|scanelf}} application is part of the {{Package|app-misc/pax-utils}} package. With this application it is possible to print out information specific to the ELF structure of a binary. The following table sums up the various options. 

{| class="table" style="text-align: left;" 
|- 
! Option
! Long option
! Description
|- 
| <code>-p</code>
| <code>--path</code>
| Scan all directories in PATH environment
|- 
| <code>-l</code>
| <code>--ldpath</code>
| Scan all directories in {{Path|/etc/ld.so.conf}}
|- 
| <code>-R</code>
| <code>--recursive</code>
| Scan directories recursively
|- 
| <code>-m</code>
| <code>--mount</code>
| Don't recursively cross mount points
|- 
| <code>-y</code>
| <code>--symlink</code>
| Don't scan symlinks
|- 
| <code>-A</code>
| <code>--archives</code>
| Scan archives ({{Path|.a}} files)
|- 
| <code>-L</code>
| <code>--ldcache</code>
| Utilize {{Path|ld.so.cache}} information (use with <code>-r</code> or <code>-e</code>).
|- 
| <code>-X</code>
| <code>--fix</code>
| Try and 'fix' bad things (use with <code>-r</code> or <code>-e</code>).
|- 
| <code>-z <arg>
| <code>--setpax <arg>
| Sets EI_PAX/PT_PAX_FLAGS to [arg] (use with -Xx)
|- 
! Option
! Long option
! Description
|- 
| <code>-x</code>
| <code>--pax</code>
| Print PaX markings
|- 
| <code>-e</code>
| <code>--header</code>
| Print GNU_STACK/PT_LOAD markings
|- 
| <code>-t</code>
| <code>--textrel</code>
| Print TEXTREL information
|- 
| <code>-r</code>
| <code>--rpath</code>
| Print RPATH information
|- 
| <code>-n</code>
| <code>--needed</code>
| Print NEEDED information
|- 
| <code>-i</code>
| <code>--interp</code>
| Print INTERP information
|- 
| <code>-b</code>
| <code>--bind</code>
| Print BIND information
|- 
| <code>-S</code>
| <code>--soname</code>
| Print SONAME information
|- 
| <code>-s <arg></code>
| <code>--symbol <arg></code>
| Find a specified symbol
|- 
| <code>-k <arg></code>
| <code>--section <arg></code>
| Find a specified section
|- 
| <code>-N [arg]</code>
| <code>--lib [arg]</code>
| Find a specified library
|- 
| <code>-g</code>
| <code>--gmatch</code>
| Use strncmp to match libraries (use with <code>-N</code>).
|- 
| <code>-T</code>
| <code>--textrels</code>
| Locate cause of TEXTREL
|- 
| <code>-E <arg></code>
| <code>--etype <arg></code>
| Print only ELF files matching etype ET_DYN,ET_EXEC ...
|- 
| <code>-M <arg></code>
| <code>--bits <arg></code>
| Print only ELF files matching numeric bits
|- 
| <code>-a</code>
| <code>--all</code>
| Print all scanned info (-x -e -t -r -b)
|- 
! Option
! Long option
! Description
|- 
| <code>-q</code>
| <code>--quiet</code>
| Only output 'bad' things
|- 
| <code>-v</code>
| <code>--verbose</code>
| Be verbose (can be specified more than once)
|- 
| <code>-F <arg></code>
| --format <arg></code>
| Use specified format for output
|- 
| <code>-f <arg></code>
| <code>--from <arg></code>
| Read input stream from a filename
|- 
| <code>-o <arg></code>
| <code>--file <arg></code>
| Write output stream to a filename
|- 
| <code>-B</code>
| <code>--nobanner</code>
| Don't display the header
|- 
| <code>-h</code>
| <code>--help</code>
| Print this help and exit
|- 
| <code>-V</code>
| <code>--version</code>
| Print version and exit
|-
|}

The format specifiers for the <code>-F</code> option are given in the following table. Prefix each specifier with <code>%</code> (verbose) or <code>#</code> (silent) accordingly. 

{| class="table" style="text-align: left;" 
|- 
! Specifier
! Full name
! Specifier
! Full name
|- 
| F
| Filename
| x
| PaX Flags
|- 
| e
| STACK/RELRO
| t
| TEXTREL
|- 
| r
| RPATH
| n
| NEEDED
|- 
| i
| INTERP
| b
| BIND
|- 
| s
| Symbol
| N
| Library
|- 
| o
| Type
| p
| File name
|- 
| f
| Base file name
| k
| Section
|- 
| a
| ARCH/e_machine
|  
|  
|-
|}

=== Using scanelf for text relocations ===

As an example, we will use {{c|scanelf}} to find binaries containing text relocations. 

A relocation is an operation that rewrites an address in a loaded segment. Such an address rewrite can happen when a segment has references to a shared object and that shared object is loaded in memory. In this case, the references are substituted with the real address values. Similar events can occur inside the shared object itself. 

A text relocation is a relocation in the text segment. Since text segments contain executable code, system administrators might prefer not to have these segments writable. This is perfectly possible, but since text relocations actually write in the text segment, it is not always feasible. 

When desiring to eliminate text relocations, make sure that the application and shared object is built with ''Position Independent Code'' (PIC), making references obsolete. This not only increases security, but also increases the performance in case of shared objects (allowing writes in the text segment requires a swap space reservation and a private copy of the shared object for each application that uses it). 

The following example will search library paths recursively, without leaving the mounted file system and ignoring symbolic links, for any ELF binary containing a text relocation: 

{{RootCmd|scanelf -lqtmyR}}

To scan the entire system for ''any'' file containing text relocations: 

{{RootCmd|scanelf -qtmyR /}}

=== Using scanelf for specific header ===

The {{c|scanelf}} utility can be used to quickly identify files that contain a given section header using the <code>-k</code> .section option. 

In this example we are looking for all files in {{Path|/usr/lib/debug}} recursively using a format modifier with quiet mode enabled that have been stripped. A stripped ELF will lack a {{Path|.symtab}} entry, so we use the '!' to invert the matching logic. 

{{RootCmd|scanelf -k '!.symtab' /usr/lib/debug -Rq -F%F#k}}


=== Using {{c|scanelf}} for specific segment markings ===

Each segment has specific flags assigned to it in the Program Header of the binary. One of those flags is the type of the segment. Interesting values are PT_LOAD (the segment must be loaded in memory from file), PT_DYNAMIC (the segment contains dynamic linking information), PT_INTERP (the segment contains the name of the program interpreter), PT_GNU_STACK (a GNU extension for the ELF format, used by some stack protection mechanisms), and PT_PAX_FLAGS (a PaX extension for the ELF format, used by the security-minded [http://pax.grsecurity.net/ PaX Project]. 

If we want to scan all executables in the current working directory, PATH environment and library paths and report those who have a writable and executable PT_LOAD or PT_GNU_STACK marking, use the following command can be used: 

{{RootCmd|scanelf -lpqe .}}

=== Using scanelf's format modifier handler ===

A useful feature of the {{c|scanelf}} utility is the format modifier handler. With this option the output of {{c|scanelf}} can be controlled, thereby simplifying parsing the output with scripts. 

As an example {{c|scanelf}} will be used to print the file names that contain text relocations: 

{{RootCmd|scanelf -l -p -R -q -F "%F #t"}}

== Listing PaX flags and capabilities ==

=== About PaX ===

[http://pax.grsecurity.net PaX] is a project hosted by the [http://www.grsecurity.net grsecurity] project. Quoting the [http://pax.grsecurity.net/docs/pax.txt PaX documentation], its main goal is "to research various defense mechanisms against the exploitation of software bugs that give an attacker arbitrary read/write access to the attacked task's address space. This class of bugs contains among others various forms of buffer overflow bugs (be they stack or heap based), user supplied format string bugs, etc." 

To be able to benefit from these defense mechanisms a Linux kernel patched with the latest PaX code is required. The [[Project:Hardened|Hardened Gentoo]] project supports PaX and its parent project grsecurity. The supported kernel package is {{Package|sys-kernel/hardened-sources}}. 

The Gentoo Hardened project has a [[Project:Hardened/PaX_Quickstart|Gentoo PaX Quickstart Guide]] for the reader's pleasure.

=== Flags and capabilities ===

If the system toolchain supports it binaries can have additional PaX flags in their program header. The following flags are supported: 

{| class="table" style="text-align: left;" 
|- 
! Flag
! Name
! Description
|- 
| <code>P</code>
| PAGEEXEC
| Refuse code execution on writable pages based on the NX bit (or emulated NX bit)
|- 
| <code>S</code>
| SEGMEXEC
| Refuse code execution on writable pages based on the segmentation logic of IA-32
|- 
| <code>E</code>
| EMUTRAMP
| Allow known code execution sequences on writable pages that should not cause any harm
|- 
| <code>M</code>
| MPROTECT
| Prevent the creation of new executable code to the process address space
|- 
| <code>R</code>
| RANDMMAP
| Randomize the stack base to prevent certain stack overflow attacks from being successful
|- 
| <code>X</code>
| RANDEXEC
| Randomize the address where the application maps to prevent certain attacks from being exploitable
|-
|}

The default Linux kernel also supports certain capabilities, grouped in the so-called ''POSIX.1e capabilities''. A listing of those capabilities can be found in the [[Hardened/Overview_of_POSIX_capabilities|POSIX Capabilities]] article.

=== Using pspax ===

The {{c|pspax}} application, which is part of the {{Package|app-misc/pax-utils}} package, displays the run-time capabilities of all programs the user has permission to run. On Linux kernels with additional support for extended attributes (such as SELinux) those attributes are shown as well. 

When ran, {{c|pspax}} shows the following information: 

{| class="table" style="text-align: left;" 
|- 
! Column
! Description
|- 
| USER
| Owner of the process
|- 
| PID
| Process id
|- 
| PAX
| Run-time PaX flags (if applicable)
|- 
| MAPS
| Write/eXecute markings for the process map
|- 
| ELF_TYPE
| Process executable type: ET_DYN or ET_EXEC
|- 
| NAME
| Name of the process
|- 
| CAPS
| POSIX.1e capabilities (see note)
|- 
| ATTR
| Extended attributes (if applicable)
|-
|}

{{Note|{{c|pspax}} only displays these capabilities when it is linked with the external capabilities library. This requires {{Package|app-misc/pax-utils}} to be built with <code>-DWANT_SYSCAP</code>.}}

By default, {{c|pspax}} does not show any kernel processes. For those to be taken as well use the <code>-a</code> option.

== Programming with ELF files ==

=== The dumpelf utility ===

The {{c|dumpelf}} utility can convert a ELF file into human readable C code that defines a structure with the same image as the original ELF file. 

{{Cmd|dumpelf /bin/hostname|output=<pre>
#include <elf.h>
  
## /*
 * ELF dump of '/bin/hostname'
 *     10276 (0x2824) bytes
 */
  
struct {
        Elf32_Ehdr ehdr;
        Elf32_Phdr phdrs[8];
        Elf32_Shdr shdrs[26];
} dumpedelf_0 = {
  
.ehdr = {
## (... Output stripped ...)
</pre>
}}

{{Migrated|originalauthors=Ned Ludd, Joshua Saddler}}
