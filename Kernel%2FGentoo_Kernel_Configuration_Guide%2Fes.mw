<languages />


{{Metadata|abstract=Este documento tiene la finalidad de presentar conceptos sobre la configuración manual del núcleo y detallar algunos de los problemas de configuración más comunes.}}

Este documento tiene la finalidad de presentar conceptos sobre la configuración manual del núcleo y detallar algunos de los problemas de configuración más comunes.

== Introducción ==

Gentoo ofrece dos formas para que los usuarios puedan gestionar la instalación, configuración y actualización del núcleo: la ''automática'' (con genkernel) y la ''manual''. Aunque el método se puede verse como ''más fácil'' para la mayoría de los usuarios, hay un gran número de razones por las cuales una gran proporción de usuarios Gentoo escogen configurar sus núcleos manualmente:

# Mayor flexibilidad
# Menores tamaños (del núcleo)
# Menores tiempos de compilación
# La experiencia del aprendizaje
# Aburrimiento severo
# Conocimiento absoluto de la configuración del núcleo, o
# Completo control

Esta guía no cubre el método automático (genkerne). Si se prefiere utilizar genkernel para gestionar las cuestiones relacionadas con el núcleo, eche un vistazo al [[Genkernel/es|artículo sobre Genkernel]] para más detalles. 

Esta guía no persigue documentar el proceso de configuración manual desde el principio hasta el final. El proceso de configuración depende en mayor medida del sentido común y un grado de conocimiento técnico relativamente alto acerca del sistema que se está utilizando. En lugar de esto, se presentan los conceptos de la configuración manual y detallan los problemas más comunes a los que se enfrentan los usuarios. 

{{Note|Esta guía documento está escrito tomando en cuenta las versiones más recientes del núcleo, para las arquitecturas de computadora más comunes. Algunos detalles pueden ser distintos para núcleos más antiguos o para arquitecturas más exóticas, sin embargo, la mayor parte del contenido seguirá siendo relevante.}}

En este punto asumiremos que se dispone de las fuentes del núcleo Linux desempaquetadas en el disco duro (usualmente en algún lugar bajo {{Path|/usr/src}}) y se supone que se debe saber como entrar en la configuración <tt>menuconfig</tt> y cómo navegar a través de su sistema de menús basado en ncurses. Si el usuario no tiene estos conocimiento, hay otros documentos disponibles que le pueden ayudar. Se deben leer los siguientes artículos antes de volver a esta guía:

* El [[Kernel/Overview/es|artículo resumen del núcleo]] contiene información sobre los distintos paquetes fuente del núcleo que están disponibles en el árbol  Portage.
* El [[Kernel/Upgrade/es|artículo sobre la actualización del núcleo]] explica como actualizar un núcleo o cambiar de un núcleo a otro.
* El Manual de Gentoo [[Handbook:Main_Page/es|en su sección de configuración]] se cubren algunos aspectos sobre la instalación del núcleo. Seleccione la arquitectura apropiada y luego navegue a la sección titulada "Configurar el núcleo Linux".

== Conceptos de configuración ==

=== Lo básico ===

El proceso general es realmente simple: se presentan una serie de opciones categorizadas en menús individuales y submenús y se selecciona el soporte hardware deseado y las características relevantes del núcleo aplicadas al sistema.

El núcleo incluye una ''configuración por defecto'' que se presenta la primera vez que se lanza menuconfig en un conjunto particular de fuentes. Los valores por defecto normalmente son amplios y adecuados, lo que significa que la mayoría de los usuarios tendrán que realizar pocos cambios a la configuración base. Si se decide deshabilitar una opción que estaba habilitada por defecto, se debe asegurar que se tiene una buena comprensión relativamente bien lo que hace la opción y las consecuencias que pueden acarrear su deshabilitación. 

La primera vez que se se configura el núcleo Linux, se debe ser conservador, no muy aventurero, y en la medida de los posible, realizar las menor cantidad de modificaciones a los ajustes por defecto. Recuerde también que hay ciertas partes en el ajuste de un sistema que deben ser personalizadas para que el sistema arranque.

=== Incluidas frente a modulares ===

La mayoría de las opciones de configuración tienen ''tres
estados'': se puede evitar su construcción <code>(N)</code>, se pueden construir para formar parte integral del núcleo <code>(Y)</code> o construidas como un módulo <code>(M)</code>. Los módulos se almacenan externamente en el sistema de ficheros, mientras que las opciones incluidas forman parte de la propia imagen del núcleo. 

Hay una diferencia importante entre opciones incluidas y modulares: con pocas excepciones, el núcleo no hace ningún intento de cargar módulos externos cuando el sistema los necesita, esto se deja por cuenta del usuario para que decida cuándo a cuándo no se debe cargar un módulo. Mientras que otras partes del sistema puedan cargar módulos bajo demanda, se recomienda que construya las opciones de soporte de hardware y características del núcleo incluidas. El núcleo puede entonces asegurar que la funcionalidad y soporte de hardware estén disponibles cuando hagan falta. Esto se hace activando todas las características del sistema (Y). Para que esta configuración sea coherente también es necesario incluir soporte para el firmware en el núcleo. Esto se hace definiendo <code>FW_LOADER=y</code> y <code>CONFIG_FIRMWARE_IN_KERNEL=y</code> en el fichero  {{Path|.config}} del núcleo o mediante:

{{KernelBox|title=Habilitar firmware en el núcleo|
Device Drivers  --->
   Generic Driver Options  --->
       -*- Userspace firmware loading support
       [*] Include in-kernel firmware blobs in kernel binary
}}

Para otras partes de la configuración, la construcción integral es un requisito absoluto. Por ejemplo, si la partición raíz era un sistema de ficheros btrfs, el sistema no podría arrancar si se construye btrfs como un módulo. El sistema debería buscar en la partición raíz para cargar el módulo btrfs (ya que los módulos se almacenan en la partición raíz), sin embargo no puede buscar en la partición raíz ¡A menos que se haya cargado el soporte para btrfs!. Si no se ha construido btrfs integrado en el núcleo, entonces el proceso de inicio no podrá encontrar el dispositivo raíz.

=== Soporte del hardware ===

Aparte de detectar el ''tipo de arquitectura'' del sistema,
la herramienta de configuración no hace ningún intento para identificar qué hardware está presente en el sistema. Aunque hay una configuración por defecto con ''algo de soporte'' para el hardware, los usuarios seguramente tendrán que encontrar y seleccionar las opciones de configuración relevantes para la configuración de hardware de cada sistema. 

Para seleccionar las opciones de configuración apropiadas se requiere conocer los componentes internos del equipo y de los conectados al mismo. En la mayoría de los casos, estos componentes se pueden identificar sin tener que abrir la caja del equipo. Para identificar la mayoría de componentes, el usuario necesita conocer el ''chipset'' utilizado por cada dispositivo en lugar del nombre que le ha dado el fabricante a su producto. Muchas tarjetas de expansión se venden con cierto nombre de marca sin embargo utilizan un chipset de otro fabricante.

Existen algunas herramientas disponibles para ayudar a los usuarios a determinar qué opciones de configuración del núcleo utilizar. La orden <tt>lspci</tt> (parte del paquete {{Package|sys-apps/pciutils}}) identificará su hardware PCI y AGP, incluyendo componentes construidos en la propia placa base. La orden <tt>lsusb</code> (del paquete {{Package|sys-apps/usbutils}}) identificará varios de los dispositivos conectados a los puertos USB del sistema. 

La situación es algo confusa por la variación de grados de estandarización en el mundo del hardware. A menos que el usuario seleccione una desviación extrema de la configuración por defecto, los discos IDE deberían "sencillamente funcionar" al igual que el teclado y ratón PS/2 o USB. También se ofrece soporte básico para una pantalla VGA. Sin embargo, algunos dispositivos, tales como adaptadores Ethernet prácticamente no tienen estandarización. Para estos adaptadores los usuarios tendrán que identificar el chipset Ethernet y seleccionar el soporte apropiado de hardware para la tarjeta específica para poder obtener acceso a la red.

Además, debido a que algunas cosas apenas funcionan con la configuración por defecto, tal vez se necesite seleccionar opciones más especializadas para obtener el potencial pleno del sistema. Por ejemplo, si no se ha habilitado el soporte para el chipset IDE apropiado, los discos IDE funcionarán ''muy'' lentamente.

=== Características del núcleo ===

Además del soporte de hardware, los usuarios deben considerar la características del software que se necesitarán en el núcleo. Un ejemplo importante de este tipo de característica es el soporte para sistemas de ficheros: los usuarios deberán seleccionar soporte para los sistemas de ficheros que utilizan en sus discos duros así como cualquier otro sistema de ficheros que vayan a utilizar en dispositivos de almacenamiento externo (por ejemplo VFAT en discos USB). 

Otro ejemplo de característica común del software es la funcionalidad avanzada de redes. Para hacer algún tipo de enrutamiento o trabajar con un cortafuegos, se deben incluir las opciones relevantes en la configuración del núcleo. 

=== ¿Preparado? ===

Ahora que se han presentado los conceptos, debería ser sencillo comenzar a identificar el hardware del sistema echando un vistazo a la interfaz de menuconfig y seleccionar las opciones requeridas para el núcleo del sistema. 

El resto de esta guía debería clarificar algunas áreas comunes de confusión y proporcionar consejos para evitar problemas comunes que los usuarios encuentran a menudo. ¡Nuestros mejores deseos!

== Problemas comunes y áreas de confusión ==

=== Los discos SATA son SCSI ===

La mayoría de sistemas de escritorio modernos incorporan dispositivos de almacenamiento (discos duros y discos CD/DVD) en un bus [https://es.wikipedia.org/wiki/Serial_ATA Serial ATA], en lugar del más antiguo tipo de bus [https://es.wikipedia.org/wiki/Integrated_Drive_Electronics IDE] (cable plano). 

El soporte SATA en Linux está implementado en una capa llamada ''libata'', la cual se asienta debajo del subsistema SCSI. Debido a esto, los controladores SATA se encuentran en la sección de configuración de controladores SCSI. Además, los dispositivos de almacenamiento del sistema se tratan como dispositivos SCSI, lo cual significa que también se requerirá
soporte para discos y cdroms SCSI. El primer disco duro SATA se denominará {{Path|/dev/sda}} y el primer disco
CD/DVD SATA se denominará {{Path|/dev/sr0}}. 

Aunque la mayoría de estos controladores son para dispositivos SATA, libata no diseñó para ser específica de SATA. Todos los controladores IDE comunes también se migrarán a libata en un futuro cercano y en ese momento, las consideraciones mencionadas anteriormente se podrán aplicar también a los usuarios de
dispositivos IDE. 

{{KernelBox|title=Configuration options for libata|1=
Device Drivers  --->
   SCSI device support  --->
      <*> SCSI device support
      <*> SCSI disk support
      <*> SCSI CDROM support
 
      [ ] SCSI low-level drivers  --->
 
   <*> Serial ATA and Parallel ATA drivers (libata)  --->
}}

{{Note|Los chipsets no estándar se listan debajo de "SCSI low-level drivers" en la caja del núcleo ''Configuration options for libata'' mostrada arriba.}}

=== Chipsets IDE y DMA ===

A pesar de la introducción de SATA, los dispositivos IDE todavía son muy comunes y muchos sistemas dependen de ellos. IDE es una tecnología bastante genérica y como tal, Linux soporta casi todos los controladores IDE por defecto sin seleccionar opciones específicas de determinados controladores. 

Sin embargo, IDE es una tecnología antigua y en su encarnación original ''Programmed Input/Output'' (Entrada/Salida Programada), no logra proporcionar las tasas de transferencia requeridas para acceso rápido a dispositivos modernos de almacenamiento. El controlador genérico IDE está limitado a usar el modo de transferencia PIO, lo cual resulta en bajas tasas de transferencia y un uso significativamente alto de la CPU mientras se transfieren los datos desde y hacia el disco. 

A menos que un usuario esté tratando con un sistema anterior a 1995, el controlador IDE también ofrecerá soporte de un modo alternativo de transferencia conocido como 
''Direct Memory Access'' (Acceso Directo a Memoria o DMA). El modo DMA es mucho más rápido y el uso de la CPU es prácticamente nulo mientras se efectúan las transferencias. Si el sistema sufre de un rendimiento general realmente pobre cuando está utilizando un disco IDE, es muy posible que no esté usando DMA y éste se debe habilitar.

{{Note|Tal y como se ha mencionado anteriormente, libata está también disponible para discos IDE. Si se está utilizando libata, entonces todos los discos, incluyendo los discos IDE, deberán usar DMA. Para hacer esto no se necesita realizar más comprobaciones ni configuraciones.}}

Cuando no se está utilizando libdata para los discos IDE, se debe comprobar la utilización de DMA y habilitarla. La siguiente orden se puede utilizar para averiguar si se está utilizando DMA:

{{RootCmd|hdparm -d /dev/hda|output=<pre>
/dev/hda:
  using_dma = 0 (off)
</pre>
}}

Para habilitar DMA en dispositivos IDE antiguos (lo cual es un ajuste obsoleto), se deben habilitar las siguientes características del núcleo.

{{Warning|Si se habilita <code>CONFIG_BLK_DEV_IDE_SATA</code> se creará un conflicto con el controlador SATA libata. Normalmente el soporte para SATA está deshabilitado en controladores IDE debido a que el subsistema SCSI tiene un mayor mantenimiento mejor y lo controla mejor. El habilitar <code>CONFIG_BLK_DEV_IDE_SATA</code> causará que este controlador entre en conflicto con el soporte libata para SATA, lo cual, generalmente es una mala idea. Este controlador está ahí para gestionar los antiguos controladores IDE. ¡Se debe dejar la gestión de SATA a libata si es posible!}}

{{KernelBox|title=Opciones de configuración para los controladores IDE obsoletos|1=
Device Drivers  --->
   <*> ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
      <*> ATA/ATAPI/MFM/RLL support
      <*>   Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
      [*]     PCI IDE chipset support
}}

{{Note|Seleccione el chipset o chipsets correctos entre las opciones listadas bajo "PCI IDE chipset support" en la caja del núcleo ''Configuration options for IDE controllers'' de arriba.}}

=== Controladores de anfitrión USB ===

[[USB]] es un bus ampliamente adoptado para conectar periféricos externos a una computadora. Una de las razones del éxito de USB es que es un protocolo estandarizado. Sin embargo, los ''dispositivos controladores de anfitrión'' (HCDs) implementados en la
computadora anfitriona varían un poco. Hay cuantro tipos principales: 

{{Dated}}
# <code>UHCI</code> es el Interfaz Universal Controlador de Anfitriones (Universal Host Controller Interface). Ofrece soporte para USB 1.1 y normalmente se encuentra en placas base con un chipset VIA o Intel.
# <code>OHCI</code> es el Interfaz Abierto Controlador de Anfitriones (Open Host Controller Interface). Ofrece soporte para USB 1.1 y normalmente se encuentra en placas base con un chipset Nvidia o SiS.
# <code>EHCI</code> es el Interfaz Controlador de Anfitriones Extendido (Extended Host Controller Interface). Es el único controlador de anfitriones común que soporta USB 2.0 y se puede encontrar normalmente en cualquier computador que soporte USB 2.0.
# <code>XHCI</code> es el Interfaz eXtensible Controlador de Anfitriones (eXtensible Host Controller Interface). Se trata del controlador para USB 3.0 y es compatible con USB 1.0, 1.1, 2.0, 3.0 y tasas de transferencia futuras. Habilite esta característica cuando la placa base ofrezca soporte para USB 3.0.

La mayoría de los sistemas incorporan dos de los tipos de interfaz arriba indicados: XHCI (USB 3.0) ''y'' EHCI (USB 2.0). Para utilizar dispositivos USB no es necesario seleccionar ambas opciones ya que XHCI es compatible con controladores USB más lentos. Los usuarios también pueden habilitar EHCI para tener una configuración segura "extra", ya que no tiene ningún impacto si no se dispone de los controladores USB 2.0.

Si no se seleccionan las opciones relevantes que correspondan a los tipos HCD USB que se disponen en el sistema, se puede experimentar el caso de puertos 'muertos'. Este caso se puede detectar si se enchufa un dispositivo USB que funciona sin embargo se observa que no está recibiendo energía o no responde de ninguna forma. 

Un excelente truco es utilizar <tt>lspci</tt> (del paquete {{Package|sys-apps/pciutils}}) que hace que sea relativamente sencillo detectar los HCDs que están disponibles en el sistema. Sin tener en cuenta el controlador SATA que también aparece, es sencillo determinar que este sistema requiere soporte EHCI y XHCI:

{{RootCmd|lspci -v {{!}} grep HCI|output=<pre>
00:14.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB xHCI (rev 04) (prog-if 30 [XHCI])
00:1a.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #2 (rev 04) (prog-if 20 [EHCI])
00:1d.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #1 (rev 04) (prog-if 20 [EHCI])
00:1f.2 SATA controller: Intel Corporation 8 Series/C220 Series Chipset Family 6-port SATA Controller 1 [AHCI mode] (rev 04) (prog-if 01 [AHCI 1.0])
</pre>
}}

Seleccione los HCDs presentes en el sistema. En general, se pueden seleccionar las tres opciones para un soporte máximo o en caso de que no se esté seguro de cuál es la opción correcta:

{{KernelBox|title=[[USB#Kernel_Configuration|Configuración para HCDs USB]]|1=
Device Drivers  --->
   USB support  --->
      <*> Support for Host-side USB
      ---   USB Host Controller Drivers
      <*>   xHCI HCD (USB 3.0) support
      <*>   EHCI HCD (USB 2.0) support
      < >   OHCI HCD  (USB 1.1) support
      < >   UHCI HCD (most Intel and VIA) support
}}

En la versión 3.12.13 de núcleo y posteriores, se tiene que habilitar ''OHCI support for PCI-bus USB controllers'' (<code>CONFIG_USB_OHCI_HCD_PCI</code>) si el controlador es un OHCI y se utiliza un ratón o teclado USB.

=== Sistemas Multiprocesador, Hyper-Threading y de Múltiples Núcleos de Procesamiento ===

Muchos sistemas de computación están basados en múltiples procesadores pero no siempre de una forma inmediatamente obvia. 

* Muchas CPUs de Intel soportan una tecnología que ellos llaman [https://es.wikipedia.org/wiki/Hyperthreading hyper-threading]. Esta tecnología habilita el hecho de que el sistema vea una sola CPU como si fuesen dos procesadores ''lógicos''.
* La mayoría de las CPUs Intel/AMD contienen varios procesadores físicos dentro del mismo chip. Se conocen como procesadores [http://es.wikipedia.org/wiki/Procesador_multin%C3%BAcleo multinúcleo].
* Algunos sistema de alto rendimiento tienen de hecho múltiples procesadores físicos instalados en placas base especializadas para proporcionar un aumento significativo del rendimiento sobre un sistema ''uniprocesador''. Los usuarios del ssitema probablemente sabrán si tienen uno de estos sistemas, ya que no son nada baratos.

En todos estos casos se deben seleccionar las opciones apropiadas del núcleo para obtener el rendimiento óptimo con estas configuraciones:

{{KernelBox|title=Configuración para soporte de multiprocesamiento|1=
Processor type and features  --->
 [*] Symmetric multi-processing support
 [*]   SMT (Hyperthreading) scheduler support
 [*]   Multi-core scheduler support (NEW)
}}

La siguiente opción únicamente habilita las características de gestión de la energía, sin embargo, puede ser también un requisito para que todas las CPUs estén disponibles en el sistema:

{{KernelBox|title=Gestión de la energía en sistemas multiprocesador|1=
Power management and ACPI options  --->
 [*] ACPI (Advanced Configuration and Power Interface) Support
}}

=== Soporte para memoria alta en x86 ===

Debido a limitaciones en el espacio de direcciones de 32 bits de la arquitectura x86, un núcleo con la configuración por defecto solo puede soportar hasta 896MB RAM. Si el sistema tiene más memoria, solo serán visibles los primeros 896MB, a menos que se haya habilitado el soporte para memoria alta. 

{{Note|Esta limitación es específica a la arquitectura x86 (IA32). Las demás
arquitecturas soportan naturalmente grandes cantidades de memoria, sin requerir afinamientos en la configuración.}}

El soporte para la memoria alta no está activado por defecto porque introduce un pequeño costo en términos de rendimiento. No se distraiga por esto, ¡Esta carga es insignificante en comparación con el aumento del rendimiento por disponer de la memoria adicional! 

Elija la opción de 4GB a menos que su sistema tenga instalados más de 4GB de RAM

{{KernelBox|title=Habilitar el soporte de memoria alta en x86|1=
Processor type and features  --->
 High Memory Support  --->
  (X) 4GB
  ( ) 64GB
}}

=== Módulos del núcleo comprimidos ===

A partir de la versión 3.18.x (y posteriores) es posible realizar la compresión de módulos del núcleo. Están disponibles Los formatos de compresión gzip y xz compression. Es importante hacer emerge de {{Package|sys-apps/kmod}} con los ajustes USE apropiados ''antes'' de construir un núcleo con módulos comprimidos:

{{FileBox|filename=/etc/portage/package.use|title=Habilitar el soporte de compresión para kmod|1=
sys-apps/kmod lzma zlib
}}

Haga emerge de nuevo de {{Package|sys-apps/kmod}}:

{{Emerge|params+=--oneshot --changed-use|sys-apps/kmod}}

Habilite al compresión de módulos y seleccione un método de compresión preferido:
{{KernelBox|title=Habilite la compresión de módulos|1=
Enable loadable module support --->
  [*]   Compress modules on installation
  Compression algorithm ()  --->
    <X> GZIP
        XZ
}}

Normalmente <tt>make modules_install</tt> lanza <tt>depmod</tt>. Si {{Package|sys-apps/kmod}} no tiene definidos los ajustes USE apropiados (lea el paso concerniente a {{Path|package.use}} de arriba) , la primera línea se lanzó, entonces las lista de dependencias estará vacía. El sistema por tanto, no podrá cargar ningún módulo que que se construyera como módulo comprimido.

Una vez se haya recompilado kmod, lance de nuevo <tt>depmod</tt> como solución a este problema:

{{RootCmd|depmod -a
|modprobe <module_name>
}}

== Notación corta para la configuración del núcleo ==

=== Introducción ===

Cuando se lee sobre la configuración del núcleo, a menudo los ajustes se describen como <code>CONFIG_<algo></code>. Esta notación corta es lo que realmente utiliza internamente el núcleo, y es lo que se encuentra en el fichero de configuración del núcleo (bien esté en {{Path|/usr/src/linux/.config}} o en el fichero autogenerado {{Path|/proc/config.gz}}). Desde luego, el hecho de utilizar la notación corta no sería muy útil si no se puede traducir a la localización real en la configuración del núcleo. La herramienta <tt>make menuconfig</tt> permite hacer precisamente esto.

=== Traducir CONFIG_FOO a la localización real de la configuración ===

Supongamos que se necesita habilitar la característica <code>CONFIG_TMPFS_XATTR</code>. Lance el menú de configuración del núcleo (<tt>make menuconfig</tt>) y pulse la tecla {{Key|/}}. Esto abrirá una caja de búsqueda. Teclee <code>CONFIG_TMPFS_XATTR</code>. 

Lo siguiente es una salida del resultado de esta búsqueda:

{{KernelBox|title=Resultado de buscar CONFIG_TMPFS_XATTR en menuconfig|1=
Symbol: TMPFS_XATTR [=n]
Type  : boolean
Prompt: Tmpfs extended attributes
  Defined at fs/Kconfig:138
  Depends on: TMPFS [=y]
  Location:
    -> File systems
      -> Pseudo filesystems
        -> Virtual memory file system support (former shm fs) (TMPFS [=y])
  Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
}}

Esta salida ofrece un montón de información interesante.

{| class="table" style="text-align: left;" 
|- 
! Entry
! Description
|- 
| Symbol: TMPFS_XATTR [=n]
| This identifies the kernel configuration entry being searched for. It also shows that this setting is currently ''not enabled'' ([=n]).
|- 
| Type: boolean
| The setting searched for is a boolean (which means it can be one of two options: enabled or disabled). Some settings are numbers or strings.
|- 
| Prompt: Tmpfs extended attributes
| This is the text found in the <tt>make menuconfig</tt> entry that controls the variable (<code>TMPFS_XATTR</code>) in the {{Path|.config}} file. It is essentially the variable name in a more human readable format.
|- 
| Depends on: TMPFS [=y]
| Before this entry can be seen <code>CONFIG_TMPFS</code> must be enabled. In this case it is already done (hence the [=y]) but if this is not the case, first look for (and enable) <code>CONFIG_TMPFS</code>.
|- 
| Location: ...
| This is the location in the <tt>make menuconfig</tt> structure where the setting can be found. Remember, the setting to look for is ''Tmpfs extended attributes''.
|- 
| Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
| If the settings described here are both enabled (in this case the first one is not), then <code>CONFIG_TMPFS_XATTR</code> will be automatically enabled and will not be possible to be ''disabled'' until one of these settings is de-selected.
|-
|}

Con esta información, se debería poder traducir de forma fácil cualquier requerimiento
<code>CONFIG_*</code> que se encuentre. Resumiendo, esto significa que un usuario debe:

# Habilitar los ajustes en el campo ''Depends on''
# Navegar a dónde indique ''Location:''
# Activar el valor indicado por ''Prompt:''

== Otra documentación sobre la configuración del núcleo ==

So far only general concepts and specific problems related to kernel configuration has been discussed; precise details have been left up to the user to discover. However, other parts of the Gentoo documentation collection provide specialized details for the topics at hand.

Such documents may be helpful while configuring specific areas of the kernel. Although this warning was mentioned previously in this guide, remember: users who are new to kernel configuration should not be adventurous when attempting to configure their kernels. Start by getting a basic system up and running, support for your audio, printing, etc., can always be added at a later date.

Tener un núcleo básico operativo ayudará a los usuarios en los pasos para realizar una configuración futura debido a que el usuario detectará qué está rompiendo el sistema y qué no. Es siempre recomendable guardar una configuración básica del núcleo (que funcione correctamente) en una carpeta distinta a la carpeta que contiene los fuentes del núcleo ''antes'' de intentar añadir nuevas características o hardware.  

* En el [[ALSA|artículo sobre ALSA]] se detallan las opciones de configuración necesarias para dar soporte a una tarjeta de sonido. Observe que ALSA es una excepción al esquema de no construir las cosas como módulos: ALSA es de hecho más sencillo de configurar cuando los componentes son modulares.

* El [[Bluetooth|artículo sobre Bluetooth]] muestra los detalles de las opciones necesarias para utilizar dispositivos Bluetooth.

* La [[IPv6 router guide/es|guía del enrutador IPv6]] describe cómo configurar el núcleo para enrutar usando el esquema de direccionamiento de redes de próxima generación.

* If the closed-source nVidia graphics drivers will be used for improved 3D graphics performance, the [[NVidia/nvidia-drivers|nVidia Guide]] lists the options that should and should not be selected on such a system.

* Amongst other things, the [[Power_management/Guide|Power Management guide]] explains how to configure the kernel for CPU frequency scaling, and for suspend and hibernate functionality.

Si se está corriendo un sistema PowerPC, las [[PPC/FAQ|Preguntas Frecuentes de PPC]] tiene algunas secciones sobre la configuración del núcleo para PPC.

* La [[Printing/es|guía de impresión]] lista las opciones del núcleo necesarias para ofrecer soporte a la impresión en Linux.

* La [[USB/Guide|guía USB]] detalla los ajustes de configuración necesaria para utilizar dispositivos USB comunes como teclados, ratones, dispositivos de almacenamiento e impresoras USB.

== Solución de problemas ==

=== Cambios de configuración que no tienen efecto ===

It is very common for users to make a configuration change, but then make a small mistake in the process of actually booting to their newly configured kernel. They reboot into a kernel image that is not the one they just reconfigured, observe that whatever problem they were trying to solve is still present, and conclude that the configuration change does not solve the problem. 

El proceso de compilar e instalar núcleos está fuera del alcance de este documento. Se puede consultar la [[Kernel/Upgrade/es|guía de actualización]] para obtener unas directrices generales. Resumiendo: el proceso para obtener un núcleo modificado es el siguiente: 1&41; configurar, 2&41; compilar, 3&41; montar {{Path|/boot}} (si no está aún montado), 4&41; copiar la nueva imagen del núcleo a {{Path|/boot}}, 5&41; asegurarse de que el cargador de arranque hará referencia al nuevo núcleo y 6&41; reiniciar. Si se omite alguno de los últimos pasos, entonces los cambios realizados no tendrán efecto.

It is possible to verify if the kernel that has booted matches the newly kernel compiled on the hard disk. This is performed by examining the date and time of the kernel's compilation. Assuming the system architecture is x86 and the kernel sources are installed at {{Path|/usr/src/linux}}, the following command can be used:

{{RootCmd|uname -v|output=<pre>
#4 SMP PREEMPT Sáb Jul 15 08:49:26 BST 2006
</pre>}}

The above command will display the date and time the currently booted kernel was compiled.

{{RootCmd|ls -l /usr/src/linux/arch/i386/boot/bzImage|output=<pre>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
</pre>}}

La orden de arriba muestra la fecha y la hora en que se compiló por última vez la imagen del núcleo en el disco duro.

If the time stamps from the above commands differ by more than 2 minutes, it indicates a mistake was made during kernel reinstallation and the system has not booted from the newly modified kernel image.

=== Los módulos no se cargan automáticamente ===

Como se ha mencionado anteriormente en este documento, el sistema de configuración del núcleo experimenta un gran cambio en su comportamiento cuando se selecciona la compilación de un componente como módulo (M) en vez de integrarlo (Y). Vale la pena repetir esto porque muchos usuarios caen
en esta trampa.

Cuando se selecciona un componente como integrado, el código forma parte de la imagen del núcleo (bzImage). Cuando el núcleo necesita utilizar ese componente se puede inicializar y cargar automáticamente sin intervención por parte del usuario. 

Cuando se selecciona un componente como módulo, el código se construye como un archivo de módulo del núcleo aparte instalado en el sistema de ficheros. En general, cuando 
el núcleo necesita usar ese componente, no podrá encontrarlo. Con algunas excepciones, el núcleo no hace esfuerzo alguno para cargar estos módulos. Esa tarea queda en manos del usuario. 

Si se está construyendo soporte para una tarjeta de red como un módulo y se observa que no es accesible, es probablemente debido a que el módulo no se ha cargado. Esto se debe hacer manualmente o se debe configurar el sistema para cargar el módulo de forma automática durante el inicio.

A menos que un usuario tenga razones para hacerlo de otra manera, se puede ahorrar algo de tiempo construyendo estos componentes 
de manera integrada en la imagen del núcleo, de modo que éste pueda configurar estos pequeños ajustes por si mismo. 

== Ver también ==

* [[genkernel/es|Genkernel]]. Una herramienta para automatizar el proceso de construcción del núcleo y del initramfs.


[[Category:Server and Security]] {{Migrated|originalauthors=Daniel Drake, Curtis Napier, Justin Robinson, Lukasz Damentko, Jonathan Smith, nightmorph}}
