<languages />


{{Metadata|abstract=Данное руководство покажет, как настроить distcc для кросс-компиляции между различными архитектурами процессоров.}}

Данное руководство покажет, как настроить distcc для кросс-компиляции между различными архитектурами процессоров.

== Кросс-компиляция с distcc ==

=== Введение ===

{{c|distcc}} — это инструмент, который позволяет распределить компиляцию программ по нескольким компьютерам в сети. Если соединенные по сети машины используют один toolchain и имеют одинаковую процессорную архитектуру, то для работы {{c|distcc}} никаких особенных настроек не потребуется. 

'''Этот руководство содержит указания как настроить distcc для компиляции на различных архитектурах''' 

=== Устанавливаем необходимые утилиты ===

Сперва нужно установить {{c|crossdev}} на всех машинах, которые будут вовлечены в процесс компиляции. {{c|crossdev}} — это инструмент, облегчающий сборку кросс-платформенных toolchain’ов. Использовать его просто: {{c|crossdev -t sparc}} соберет полный cross-toolchain для архитектуры Sparc. Он включает binutils, gcc, glibc и linux-headers. 

Вам необходимо установить подходящий toolchain для кросс-компиляции на все участвующие машины. Если вам нужно больше информации, попробуйте запустить {{c|crossdev --help}}.

Если вы хотите произвести более точную настройку cross-toolchain’а, то вот скрипт, который генерирует команду с точными версиями toolchain-пакетов для сборки на вспомогательных машинах (скрипт нужно запускать на целевой машине).

{{CodeBox|title=Скрипт для тонкой настройки инструментов распределенной разработки|lang=bash|1=
#! /bin/bash
A="binutils" ; B=`eselect $A show` ; BINUTILS_VER=`echo $B {{!}} cut -d- -f3-`
A=`/usr/bin/gcc-config -c` ; B=`echo $A {{!}} cut -d- -f5` ; GCC_VER=`equery l sys-devel/gcc {{!}} grep $B {{!}} cut -d- -f5-`
KERNEL_VER=`uname -r {{!}} sed s/-gentoo//`
A="sys-libs/glibc" ; B=`equery l $A` ; LIBC_VER=`echo $B {{!}} cut -d- -f3-`
echo "crossdev --b =$BINUTILS_VER --g =$GCC_VER --k =$KERNEL_VER --l =$LIBC_VER -t `uname -m`"
}}

Затем необходимо установить {{c|distcc}} на все машины, которые будут вовлечены в процесс. Это включает и машину, на которой будет запущен emerge, и машины с кросс-компиляторами. Посмотрите [[Distcc/ru|документацию Gentoo по Distcc]] для более подробной информации по настройке и использованию {{c|distcc}}.

{{Note|Текущие версии {{c|crossdev}} имеют флаг <code>-S</code> (<code>--stable</code>) для установки только стабильных версий компиляторов. (Т. е. {{c|crossdev -t i686-pc-linux-gnu --stable --ex-gcc --ex-gdb --portage --pretend}}). Без этой опции, {{c|crossdev}} установит пакет с последним экспериментальным компилятором! В противном случае, выше предложенный скрипт не нужен, если специальные версии инструментов и/или заголовков замаскированы.}}

=== Специфичные для архитектур замечания ===

{{Note|Получить имя архитектуры можно, взглянув на переменную <var>CHOST</var> с целями компилятора в {{Path|/etc/make.conf}}. Когда идет искажение имени архитектуры для опции {{c|crossdev -t}}, {{c|crossdev}} будет устанавливать инструменты, используя искаженное имя для имен директорий в {{Path|/usr}} (т. е. {{Path|/usr/i686-pc-linux-gnu/}}, {{Path|/usr/i686-linux-gnu/}}, ...). Что бы исправить это, определите каждое искаженное имя архитектуры/директории и удалите через {{c|crossdev --clean}} или вручную, удалив эти директории из системы.}}

==== Подархитектуры Intel x86 ====

Если вы проводите кросс-компиляцию между различными субархитектурами процессоров Intel {{Keyword|x86}} (например, i586 и i686), то, как и в других случаях, вам нужно собрать полный cross-toolchain для желаемого <var>CHOST</var>, иначе компиляция завершится неудачей. Это потому, что субархитектурам i586 и i686 соответствуют разные CHOST, несмотря на то что обе относятся к "x86". Помните об этом, когда собираете свои cross-toolchain’ы. Если, например, целевая платформа — i586, то потребуется собрать cross-toolchain’ы для i586 на вспомогательных i686-машинах. 

==== SPARC ====

При использовании {{c|crossdev -t sparc}} может появиться одна из следующих ошибок:

{{CodeBox|title=Ошибки, появляющиеся при запуске crossdev -t sparc|1=
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
}}

Если это происходит, попробуйте использовать другую команду:

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== Настройка distcc для корректной кросс-компиляции ===

При настройках distcc по умолчанию кросс-компиляция ''не'' будет работать как положено. Проблема в том, что многие сборки вызывают просто {{c|gcc}} вместо полного имени компилятора (например, {{c|sparc-unknown-linux-gnu-gcc}}). Когда такая сборка распределяется на вспомогательную машину с distcc, вызывается нативный компилятор вместо вашего абсолютно нового кросс-компилятора. 

К счастью, для этой небольшой проблемы существует обходное решение. Все, что требуется, это оберточный скрипт и несколько символьных ссылок на компьютере, с которого вызывается {{c|emerge}}. Будем использовать в качестве примера компьютер архитектуры Sparc. Ниже, где бы вы ни видели текст <code>sparc-unknown-linux-gnu</code>, подразумевается ваше значение <var>CHOST</var> (<code>x86_64-pc-linux-gnu</code> для AMD64, к примеру). Каталог {{Path|/usr/lib/distcc/bin}} после первой установки distcc выглядит следующим образом: 

{{Note|Следующие инструкции предназначены для выполнения на тех компьютерах, где будет запускаться emerge. Не выполняйте эти шаги на вспомогательных хостах.}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

Проделаем следующие шаги: 

{{RootCmd|rm c++ g++ gcc cc}}

Затем создадим новый скрипт на этой машине. Запустите свой любимый текстовый редактор и создайте файл со следующим текстом, сохранив его как {{Path|sparc-unknown-linux-gnu-wrapper}}. Помните о том, что значение <var>CHOST</var> (в данном случае <code>sparc-unknown-linux-gnu</code>) нужно заменить на реальный <var>CHOST</var> данного компьютера, т. е. того, на котором будет запускаться emerge. 

{{CodeBox|title=Новый оберточный скрипт|lang=bash|1=
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
}}

Далее, сделаем скрипт исполняемым и создадим соответствующие символьные ссылки: 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

После этого {{Path|/usr/lib/distcc/bin}} будет выглядеть следующим образом: 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

{{Note|With new distcc versions, the following steps are unnecessary—you can emerge distcc on the client with the <code>crossdev</code> USE flag set instead to achieve the same result.}}

Далее нужно позаботиться о том, чтобы обертки оставались доступными после обновлений distcc, поскольку символьные ссылки при обновлении перезаписываются. Можно сделать это с помощью файла {{Path|/etc/portage/bashrc}}, примерно такого:

{{FileBox|filename=/etc/portage/bashrc|lang=bash|1=
case ${CATEGORY}/${PN} in
<pre>                 (sys-devel/distcc | sys-devel/gcc)</pre>
			if [ "${EBUILD_PHASE}" == "postinst" ]; then
				/usr/local/sbin/distcc-fix &
			fi
		;;
esac
}}

Затем создайте этот файл:

{{FileBox|filename=/usr/local/sbin/distcc-fix|lang=bash|1=
#!/bin/bash	                
 
sleep 20
# change TUPLE to match your machine
TUPLE="sparc-unknown-linux-gnu"
cd /usr/lib/distcc/bin
rm cc c++ gcc g++ ${TUPLE}-wrapper
echo '#!/bin/bash' > ${TUPLE}-wrapper
echo "exec ${TUPLE}-g\${0:\$[-2]}" "\"\$@\"" >> ${TUPLE}-wrapper
chmod 755 ${TUPLE}-wrapper
ln -s ${TUPLE}-wrapper cc
ln -s ${TUPLE}-wrapper c++
ln -s ${TUPLE}-wrapper gcc
ln -s ${TUPLE}-wrapper g++
}}

Назначьте правильные разрешения:

{{RootCmd|chmod 755 /usr/local/sbin/distcc-fix}}

Поздравляем! Теперь у вас (надеемся) есть работающая установка cross-distcc.

=== Как это работает ===

При вызове {{c|distcc}} проверяет, как его вызвали (например, <code>i686-pc-linux-gnu-gcc</code>, <code>sparc-unknown-linux-gnu-g++</code>, и т. п.). Затем, когда distcc распределяет компиляцию на вспомогательную машину, он передает название, с которым был вызван. Далее, демон distcc на вспомогательной машине ищет исполняемый файл с подобным именем. Если он видит только {{c|gcc}}, то будет искать {{c|gcc}}, что, скорее всего, будет нативным компилятором вспомогательной машины. Это сработает только если на ней такая же архитектура, как и на компьютере, с которого запускался {{c|emerge}}. Когда отправляется ''полное'' имя компилятора, (например, <code>sparc-unknown-linux-gnu-gcc</code>), путаница исключена.

=== Устранение проблем ===

В этом разделе приведены распространенные проблемы, связанные с использованием {{c|distcc}} для кросс-компиляции.

==== Ошибки компиляции в distccd на удаленном компьютере ====

При получении сообщения <code>COMPILE ERRORS</code> в файле {{Path|/var/log/distccd.log}} на удаленном компьютере, посмотрите описанные выше заметки касательно определения корректного имени архитектуры (т. е. {{c|crossdev -t $TARGET}}).

Другое решение заключается в удалении и переустановке {{c|crossdev}}, используя опцию {{c|crossdev --clean}}, или в полной переустановке кросс компилятора, перед которой нужно убедиться, что {{Path|/usr/$TARGET}} больше нет.

It might also be wise to edit the remote host's {{Path|/usr/$TARGET/etc/portage/make.conf}}, and ensure the contents of the <var>CFLAGS</var> variable are similar on all computers or hosts performing compiler operations. Also make sure the <var>USE</var> flags for the cross compiler are sufficient: if you built GCC with <code>USE=graphite</code> on the client, you need a line like <code>cross-i686-pc-linux-gnu/gcc graphite</code> in {{Path|/etc/portage/package.use}} too.

==== Failed to exec $TARGET-unknown-linux-gnu-gcc: No such file or directory ====

Скрипты могут не запуститься, даже с корректными разрешениями:

{{CodeBox|title=Ошибка выполнения скриптов|1=
distcc[6195] (dcc_execvp) ERROR: failed to exec i686-unknown-linux-gnu-gcc: No such file or directory
}}

Для разрешения этого, убедитесь, что скрипты созданы с полным именем архитектуры:

{{Cmd|ls -alh /usr/lib/distcc/bin/c++|output=<pre>
/usr/lib/distcc/bin/c++ ->./i686-pc-linux-gnu-wrapper
</pre>}}

[[Category:Compilation]]
{{Migrated|originalauthors=Andrew Gaffney, Joshua Saddler}}
