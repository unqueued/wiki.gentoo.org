<languages />


{{Metadata|abstract=Данное руководство покажет, как настроить distcc для кросс-компиляции между различными архитектурами процессоров.}}

Данное руководство покажет, как настроить distcc для кросс-компиляции между различными архитектурами процессоров.

== Кросс-компиляция с distcc ==

=== Введение ===

{{c|distcc}} — это инструмент, который позволяет распределить компиляцию программ по нескольким компьютерам в сети. Если соединенные по сети машины используют один toolchain и имеют одинаковую процессорную архитектуру, то для работы {{c|distcc}} никаких особенных настроек не потребуется. 

'''This guide provides instructions on how to configure distcc to compile for different architectures.''' 

=== Устанавливаем необходимые утилиты ===

Сперва нужно установить {{c|crossdev}} на всех машинах, которые будут вовлечены в процесс компиляции. {{c|crossdev}} — это инструмент, облегчающий сборку кросс-платформенных toolchain’ов. Использовать его просто: {{c|crossdev -t sparc}} соберет полный cross-toolchain для архитектуры Sparc. Он включает binutils, gcc, glibc и linux-headers. 

You will need to emerge the proper cross-toolchain on all the helper boxes. If you need more help, try running {{c|crossdev --help}}.

Если вы хотите произвести более точную настройку cross-toolchain’а, то вот скрипт, который генерирует команду с точными версиями toolchain-пакетов для сборки на вспомогательных машинах (скрипт нужно запускать на целевой машине).

{{CodeBox|title=Скрипт для тонкой настройки инструментов распределенной разработки|lang=bash|1=
#! /bin/bash
A="sys-devel/binutils" ; B=`equery l $A` ; BINUTILS_VER=`echo $B {{!}} cut -d- -f3-`
A=`/usr/bin/gcc-config -c` ; B=`echo $A {{!}} cut -d- -f5` ; GCC_VER=`equery l sys-devel/gcc {{!}} grep $B {{!}} cut -d- -f3-`
KERNEL_VER=`uname -r {{!}} sed s/-gentoo//`
A="sys-libs/glibc" ; B=`equery l $A` ; LIBC_VER=`echo $B {{!}} cut -d- -f3-`
echo "crossdev --b =$BINUTILS_VER --g =$GCC_VER --k =$KERNEL_VER --l =$LIBC_VER -t `uname -m`"
}}

Затем необходимо установить {{c|distcc}} на все машины, которые будут вовлечены в процесс. Это включает и машину, на которой будет запущен emerge, и машины с кросс-компиляторами. Посмотрите [[Distcc/ru|документацию Gentoo по Distcc]] для более подробной информации по настройке и использованию {{c|distcc}}.

{{Note|Current versions of {{c|crossdev}} have a <code>-S</code> (<code>--stable</code>) flag for installing only stable versions of compiler tools.  (ie. {{c|crossdev -t i686-pc-linux-gnu --stable --ex-gcc --ex-gdb --portage --pretend}}). Without this option, {{c|crossdev}} installs the latest experimental compiler tools packages! Otherwise, the above script is no longer needed, unless specific versions of package tools and/or headers have been unmasked.}}

=== Специфичные для архитектур замечания ===

{{Note|Obtain the architecture name by looking at the compile target's <var>CHOST</var> variable within {{Path|/etc/make.conf}}. When mangling the architecture name for the {{c|crossdev -t}} option, {{c|crossdev}} will merrily guess and install tools using the mangled architecture name for folder names within {{Path|/usr}} (ie. {{Path|/usr/i686-pc-linux-gnu/}}, {{Path|/usr/i686-linux-gnu/}}, ...). To resolve this, specify each mangled architecture/folder name to {{c|crossdev --clean}} for uninstalling, or manually remove the folders from the system.}}

==== Подархитектуры Intel x86 ====

Если вы проводите кросс-компиляцию между различными субархитектурами процессоров Intel {{Keyword|x86}} (например, i586 и i686), то, как и в других случаях, вам нужно собрать полный cross-toolchain для желаемого <var>CHOST</var>, иначе компиляция завершится неудачей. Это потому, что субархитектурам i586 и i686 соответствуют разные CHOST, несмотря на то что обе относятся к "x86". Помните об этом, когда собираете свои cross-toolchain’ы. Если, например, целевая платформа — i586, то потребуется собрать cross-toolchain’ы для i586 на вспомогательных i686-машинах. 

==== SPARC ====

При использовании {{c|crossdev -t sparc}} может появиться одна из следующих ошибок:

{{CodeBox|title=Ошибки, появляющиеся при запуске crossdev -t sparc|1=
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
}}

Если это происходит, попробуйте использовать другую команду:

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== Настройка distcc для корректной кросс-компиляции ===

In the default distcc setup, cross-compiling will ''not'' work properly. The problem is that many builds just call {{c|gcc}} instead of the full compiler name (e.g. {{c|sparc-unknown-linux-gnu-gcc}}). When this compile gets distributed to a distcc helper box, the native compiler gets called instead of your shiny new cross-compiler. 

Fortunately, there is a workaround for this little problem. All it takes is a wrapper script and a few symlinks on the box that will be running {{c|emerge}}. We'll use a Sparc box as an example. Wherever you see <code>sparc-unknown-linux-gnu</code> below, you will want to insert your own <var>CHOST</var> value (<code>x86_64-pc-linux-gnu</code> for an AMD64 box, for example). When you first emerge distcc, the {{Path|/usr/lib/distcc/bin}} directory looks like this: 

{{Note/ru|Следующие инструкции предназначены для выполнения на тех компьютерах, где будет запускаться emerge. Не выполняйте эти шаги на вспомогательных хостах.}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

Проделаем следующие шаги: 

{{RootCmd|rm c++ g++ gcc cc}}

Next, we'll create the new script on this box. Fire up your favorite editor and create a file with the following text in it, then save it as {{Path|sparc-unknown-linux-gnu-wrapper}}. Remember to change the <var>CHOST</var> value (in this case, <code>sparc-unknown-linux-gnu</code>) to the actual <var>CHOST</var> of the box that will be running the emerge. 

{{CodeBox|title=Новый оберточный скрипт|lang=bash|1=
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
}}

Далее, сделаем скрипт исполнимым и создадим соответствующие символьные ссылки: 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

После этого {{Path|/usr/lib/distcc/bin}} будет выглядеть следующим образом: 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

Далее нужно позаботиться о том, чтобы обертки оставались доступными после обновлений distcc, поскольку символьные ссылки при обновлении перезаписываются. Можно сделать это с помощью файла {{Path|/etc/portage/bashrc}}, примерно такого:

{{FileBox|filename=/etc/portage/bashrc|lang=bash|1=
case ${CATEGORY}/${PN} in
<pre>                 sys-devel/distcc | sys-devel/gcc)</pre>
			if [ "${EBUILD_PHASE}" == "postinst" ]; then
				/usr/local/sbin/distcc-fix &
			fi
		;;
esac
}}

Then create this file:

{{FileBox|filename=/usr/local/sbin/distcc-fix|lang=bash|1=
#!/bin/bash	                
 
sleep 20
# change TUPLE to match your machine
TUPLE="sparc-unknown-linux-gnu"
cd /usr/lib/distcc/bin
rm cc c++ gcc g++ ${TUPLE}-wrapper
echo '#!/bin/bash' > ${TUPLE}-wrapper
echo "exec ${TUPLE}-g\${0:\$[-2]}" "\"\$@\"" >> ${TUPLE}-wrapper
chmod 755 ${TUPLE}-wrapper
ln -s ${TUPLE}-wrapper cc
ln -s ${TUPLE}-wrapper c++
ln -s ${TUPLE}-wrapper gcc
ln -s ${TUPLE}-wrapper g++
}}

Give it the proper permissions:

{{RootCmd|chmod 755 /usr/local/sbin/distcc-fix}}

Поздравляем! Теперь у вас (надеемся) есть работающая установка cross-distcc.

=== Как это работает ===

When {{c|distcc}} is called, it checks to see what it was called as (e.g. <code>i686-pc-linux-gnu-gcc</code>, <code>sparc-unknown-linux-gnu-g++</code>, etc.) When distcc then distributes the compile to a helper box, it passes along the name it was called as. The distcc daemon on the other helper box then looks for a binary with that same name. If it sees just {{c|gcc}}, it will look for {{c|gcc}}, which is likely to be the native compiler on the helper box, if it is not the same architecture as the box running {{c|emerge}}. When the ''full'' name of the compiler is sent (e.g. <code>sparc-unknown-linux-gnu-gcc</code>), there is no confusion.

=== Troubleshooting ===

This section covers a number of common problems when using {{c|distcc}} for cross-compiling.

==== Remote host distccd COMPILE ERRORS ====

When receiving the message <code>COMPILE ERRORS</code> within a remote host's {{Path|/var/log/distccd.log}} file, see the above notes concerning specifying the correct architecture name (ie. {{c|crossdev -t $TARGET}}).

Another solution is to uninstall and re-install {{c|crossdev}} compiler tools, using the {{c|crossdev --clean}} option, or ensuring {{Path|/usr/$TARGET}} no longer exists, and then completely reinstall the cross compiler.

It might also be wise to edit the remote host's {{Path|/usr/$TARGET/etc/portage/make.conf}}, and ensure the contents of the <var>CFLAGS</var> variable are similar on all computers or hosts performing compiler operations.

==== Failed to exec $TARGET-uknown-linux-gnu-gcc: No such file or directory ====

The wrapper scripts might fail to execute, even with correct permissions:

{{CodeBox|title=Error message from wrapper|1=
distcc[6195] (dcc_execvp) ERROR: failed to exec i686-unknown-linux-gnu-gcc: No such file or directory)
}}

To resolve this, make sure to have the wrapper script created with the complete name of the architecture target:

{{Cmd|ls -alh /usr/lib/distcc/bin/c++|output=<pre>
/usr/lib/distcc/bin/c++ ->./i686-pc-linux-gnu-wrapper
</pre>}}


{{Migrated|originalauthors=Andrew Gaffney, Joshua Saddler}}
