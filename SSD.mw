{{InfoBox stack
|{{InfoBox wikify|header=true}}
|{{InfoBox wikipedia|Solid-state_drive}}
}}
{{Stub}}

This article describes how to set up SSDs (Solid State Drives) on Gentoo Linux. It presumes the user has obtained knowledge of setting up, partitioning, and formatting [[HDD|mechanical hard drives]].

== Considerations ==

=== Rootfs ===

The <code>-odiscard</code> option on a rootfs mount should not be used. {{c|discard}} is the "TRIM" command that tells the SSD to do its magic. Having discard running constantly could potentially cause performance degradation on older SSDs. Modern SSDs use discard by default. Rather the following command can be used manually or be setup as a cron job (see below) to run twice a day, which should suffice for the rootfs:

{{RootCmd|fstrim -v /}}

On a [[btrfs]] system, running the {{c|fstrim}} command on any mounted subvolume will perform the TRIM command on the device.

=== Mount point ===

Situations with a low amount of disk write occurring on an SSD can use the <code>discard</code> mount option in {{Path|[[fstab|/etc/fstab]]}}. In a high-write situation, such as having a database on an SSD, it is better to use TRIM commands rather than the <code>discard</code> mount option.

== After hardware installation ==

=== Partitioning ===

The {{c|[[Handbook:AMD64/Blocks/Disks#Alternative:_Using_fdisk_to_partition_the_disk|fdisk]]}} utility ({{Package|sys-apps/util-linux}}, version 2.24.1-r2 and up) can be used for GPT disk partitioning.

Use type {{c|[[Handbook:AMD64/Blocks/Disks#Viewing_the_current_partition_layout|fdisk /dev/sda]]}} to run {{c|fdisk}}, use {{Key|M}} option for help. The following is an example for GPT partition table with BIOS motherboard. Type {{Key|G}}+{{Key|Enter}} to create a new empty GPT partition table on the SSD. Type {{Key|N}}+{{Key|Enter}}, {{Key|Enter}}, {{Key|Enter}}, {{Key|+2M}}+{{Key|Enter}}, {{Key|T}}+{{Key|Enter}}, {{Key|4}}+{{Key|Enter}} to create BIOS boot partition.

{{RootCmd|fdisk /dev/sda|output=<pre>
   Command (m for help): n
   Partition number (1-128, default 1): 
   First sector (2048-117231374, default 2048): 
   Last sector, +sectors or +size{K,M,G,T,P} (2048-117231374, default 117231374): +2M
   
   Created a new partition 1 of type 'Linux filesystem' and of size 2 MiB.
   
   Command (m for help): t
   Selected partition 1
   Partition type (type L to list all types): 4
   Changed type of partition 'Linux filesystem' to 'BIOS boot partition'.
</pre>}}
   
Next create a 2GB swap partition:

{{GenericCmd|<pre>
   Command (m for help): n
   Partition number (2-128, default 2): 
   First sector (6144-117231374, default 6144): 
   Last sector, +sectors or +size{K,M,G,T,P} (6144-117231374, default 117231374): +2G
   
   Created a new partition 2 of type 'Linux filesystem' and of size 2 GiB.
   
   Command (m for help): t
   Partition number (1,2, default 2):
   Partition type (type L to list all types): 19
   
   Changed type of partition 'Linux filesystem' to 'Linux swap'.
</pre>}}

Finally create system root partition and write the changes:

{{GenericCmd|<pre>
   Command (m for help): n
   Partition number (3-128, default 3): 
   First sector (4200448-117231374, default 4200448): 
   Last sector, +sectors or +size{K,M,G,T,P} (4200448-117231374, default 117231374): 
   
   Created a new partition 3 of type 'Linux filesystem' and of size 53.9 GiB.
   
   Command (m for help): p
   Disk /dev/sda: 55.9 GiB, 60022480896 bytes, 117231408 sectors
   Units: sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   Disklabel type: gpt
   Disk identifier: E19B261A-21EA-4529-B736-1A4E48FC77A1
   
   Device           Start          End   Size Type
   /dev/sda1         2048         6143     2M BIOS boot partition
   /dev/sda2         6144      4200447     2G Linux swap
   /dev/sda3      4200448    117231374  53.9G Linux filesystem
   
   Command (m for help): w
   
   The partition table has been altered.
   Calling ioctl() to re-read partition table.
   Syncing disks.
</pre>}}

Although {{c|fdisk}} is a tool familiar to many Linux users, other common partitioning tools exist: {{c|gdisk}}, {{c|gparted}}, and {{c|[[Handbook:AMD64/Blocks/Disks#Default:_Using_parted_to_partition_the_disk|parted]]}}. All of them (newer versions) handle partition alignment automatically. When in doubt whether partition is aligned, check that each partition starts on a MiB boundary (multiple of 2048 sectors). This should be 'safe' for any device (SSD or not).

==== LVM ====

LVM aligns to MiB boundaries and allows discards by default. No special configuration is required.

In order to TRIM all unused space in the VG use the {{c|blkdiscard}} utility:

{{RootCmd
|lvcreate -l100%FREE -n trim yourvg
|blkdiscard /dev/yourvg/trim
|lvremove yourvg/trim
}}

Alternatively, there is a discard option in {{Path|lvm.conf}} which makes LVM discard entire LV on lvremove, lvreduce, pvmove and other actions that free physical extents (PE) in a VG. However, enabling it will immediately render the system unable to undo any changes to the LV layout.

{{FileBox|filename=/etc/lvm/lvm.conf|1=
devices {
  [...]
  issue_discards = 1
} 
}}

==== LUKS ====

For TRIM to work on encrypted [[DM-Crypt_LUKS|LUKS]] devices, they have to be opened with the <code>--allow-discards</code> option.

{{RootCmd|cryptsetup luksOpen --allow-discards /dev/thing luks}}

When root-device exists on [[DM-Crypt_LUKS|LUKS]], enabling TRIM depends on the [[Initramfs]] implementation.
When using [[genkernel]] for creating your initramfs, pass the following kernel option:

{{FileBox|filename=/etc/default/grub|1=
GRUB_CMDLINE_LINUX_DEFAULT="root_trim=yes"
}}

When using [[dracut]] for creating the initramfs, pass the following kernel option:

{{FileBox|filename=/etc/default/grub|1=
GRUB_CMDLINE_LINUX_DEFAULT="rd.luks.allow-discards"
}}

=== Formatting ===

If you can find your erase block size, you can add some extended attributes that may help performance.
For software raid, you really should know the erase block size. Consider this information when making your purchase.
Regardless of whether you're using RAID or not, setting extended values is known to be beneficial. https://raid.wiki.kernel.org/index.php/RAID_setup#ext2.2C_ext3.2C_and_ext4_.282011.29

http://blog.nuclex-games.com/2009/12/aligning-an-ssd-on-linux/

The modern FAQ found on the Arch wiki too:

https://wiki.archlinux.org/index.php/SSD

==== Without knowing the erase block size ====

#Formatting the rootfs partition /dev/sda3:
#Using 4096 byte blocks by default aligns the SSD for writes (see [defaults] section of /etc/mke2fs.conf and also 
#man mkfs.ext4 about "-b block-size" and "-T usage-type[,...]" inside it):

{{RootCmd|mkfs.ext4 /dev/sda3}}

==== With knowing the erase block size | this info can be outdated ====

#Formatting the rootfs partition /dev/sda3:
#Using 4096 byte blocks aligns the SSD for writes;
#Using ERASE_BLOCK_SIZE / 4 as the stride and stripe width size;
#In this example, OCZ Vertex drives have 512 kibbibyte -
#Erase Block size, therefore stride/stripe-width = 512/4 = 128:

{{RootCmd|mkfs.ext4 -E stride{{=}}128,stripe-width{{=}}128 /dev/sda3}}

===== known erase block sizes =====

* crucial m500 240G; stride and stripe width is 2048KB
{{Note|1=Page size is 16KB, there are 512 pages per Block.<ref>http://www.anandtech.com/show/6884/crucial-micron-m500-review-960gb-480gb-240gb-120gb</ref> 16KB * 512 = 8192KB for block size. Block erase size = block size. 8192KB / 4 = 2048KB for stride and stripe width size.}}
* SanDisk z400s; stride an stripe width is 4096KB
{{Note|1=According to Dutch customer care service from SanDisk the block erase size = 16MB.}}

==== blkdiscard ====

If you are formatting a previously used device and your preferred {{c|mkfs}} does not support bulk discards when creating the filesystem, you can use {{c|blkdiscard}} (from {{Package|1=sys-apps/util-linux-2.23}} or later) before creating the filesystem.

=== Mounting ===

Given the considerations above, either add something similar to this:

{{FileBox|filename=/etc/fstab|1=
/dev/sda3          /          ext4          defaults,relatime,discard          0 1
}}

Or:

{{FileBox|filename=/etc/fstab|1=
/dev/sda3          /          ext4          defaults,relatime                  0 1
}}

When choosing the latter, see the [[SSD#Cron|cron]] section below to automate TRIM on the drive.

Once {{Path|/etc/fstab}} can been modified, run the following command to have the drive mounted:

{{RootCmd|mount -a}}

In the same way, the <code>discard</code> mount option can be added to the swap line in fstab too. The following example shows SSD disk swap can be parallelized with SATA disk swap:

{{FileBox|filename=/etc/fstab|1=
/dev/sda2          none           swap         sw,pri=3,discard          0 0
/dev/sdb2          none           swap         sw,pri=3                  0 0
}}

Once the swap has been configured in fstab, run the following command to make swap available:

{{RootCmd|swapon -a}}

== Notes ==

=== cron ===

Run {{c|fstrim -v /}} from cron twice a day to automatically do "discard":

   #Mins  Hours  Days   Months  Day of the week   command
   15     1,13   *      *       *                 /sbin/fstrim -v /

There is also a semi-automatic cronjob available on GitHub called [http://chmatse.github.io/SSDcronTRIM/ SSDcronTRIM] which has the following features:

* Distribution Independent script (developed on my Gentoo system).
* The script decides every time depending on the disk usage how often (monthly, weekly, daily, hourly) each partition has to be trimmed.
* Recognizes if it should install itself into /etc/cron.{monthly,weekly,daily,hourly}, {{Path|/etc/cron.d}} or any other defined directory and if it should make an entry into crontab.
* Checks if the kernel meets the requirements, the filesystem is able to and if the SSD supports trimming.
* Simply install it by running it once without any option and uninstall it with the <code>-d</code> option

Future version should implement:

* Use of {{c|nice}} and {{c|ionice}} to let trimm only run when the disc is not busy.
* Overgive options to fstrim (e.g. '-m 1M')
* support for encrypted filesystem (LUKS)

=== fstrim systemd timer ===

When running systemd, a timer can be created that will run fstrim every 12 hours.

Two files need to be created in the {{Path|/etc/systemd/system}} directory:

{{FileBox|filename=/etc/systemd/system/fstrim.service|lang=ini|1=
[Unit]
Description=Runs fstrim on all mounted devices that support TRIM

[Service]
Type=oneshot
ExecStart=/bin/sh -c '/sbin/fstrim -a'
}}

{{FileBox|filename=/etc/systemd/system/fstrim.timer|lang=ini|1=
[Unit]
Description=Run fstrim.service every 12 hours

[Timer]
OnUnitInactiveSec=12h
Persistent=true

[Install]
WantedBy=multi-user.target
}}

Make sure the permissions are correct:

{{RootCmd|chmod 644 /etc/systemd/system/fstrim.*}}

Tell systemd to reload its unit files, then enable it:

{{RootCmd
|systemctl daemon-reload
|systemctl enable fstrim.timer
}}

It is now possible to see if it has been run and when the next time it will be ran by using list-timers:

{{RootCmd|systemctl list-timers|output=<pre>
NEXT                         LEFT     LAST                         PASSED    UNIT                         ACTIVATES
Sun 2017-01-15 07:07:48 PST  11h left Sat 2017-01-14 19:03:26 PST  25min ago fstrim.timer                 fstrim.service
Sun 2017-01-15 19:16:26 PST  23h left Sat 2017-01-14 19:16:26 PST  12min ago systemd-tmpfiles-clean.timer systemd-tmpfiles-clean.service
</pre>}}

This will run fstrim twice a day, and also run it if it was missed. The {{c|journalctl}} command can be used to make sure the timer runs successfully.

=== fstrimDaemon ===

If your computer turned off when cron scheduled its job, fstrim would not be called at all. You can install [https://github.com/dobek/fstrimDaemon fstrimDaemon] to solve this problem.

=== Temporal files to TMPFS ===

When using an SSD, administrators generally want to reduce the amount of writes performed. You can mount your desired mountpoints into a TMPFS for reduce the I/O to the disk (and improve performance)

this is an example of {{Path|/tmp}} and {{Path|/var/tmp}} on TMPFS but you must study all your actions and your convenience
{{FileBox|filename=[[fstab|/etc/fstab]]|1=# temporal mountpoints on TMPFS
tmpfs           /tmp            tmpfs           size=16G,noatime        0 0
tmpfs           /var/tmp        tmpfs           size=1G,noatime         0 0}}

Remember that all data in TMPFS will be loss after reboot or shutdown

==== Portage TMPDIR on TMPFS ====

On Gentoo, Portage is a huge source of writes, and putting these writes into system memory rather than a disk is beneficial. If you have more than 8GB of ram you may want to consider using [[Portage_TMPDIR_on_tmpfs|tmpfs]], which is a way to dedicate some system memory to storage on a temporary basis. It is generally advised to not use more than half of the available system memory for [[Portage_TMPDIR_on_tmpfs|tmpfs]].

For the next example, presume the system has 12GB of memory and the user would like to allow up to 6GBs for [[Portage_TMPDIR_on_tmpfs|tmpfs]]. Edit {{Path|/etc/fstab}} and add:

{{FileBox|filename=[[fstab|/etc/fstab]]|1=
tmpfs			/tmp		tmpfs		size=6G,noatime 	0 0
}}

After the fstab entry is set, tell Portage to use the above location to compile temporary space. This is done in {{Path|[[:/etc/portage/make.conf]]}}:

{{FileBox|filename=[[:/etc/portage/make.conf]]|lang=bash|1=
# This may fail on large compiles unless you have greater than 20GB of system memory is available. Scratch space for Libreoffice can exceed 8GB; compile will fail if it runs out of space.
# RAM used by [[Portage_TMPDIR_on_tmpfs|tmpfs]] is freed back to the pool when it is no longer in use, so when using Portage or other software that uses /tmp there should be a huge performance gain.
PORTAGE_TMPDIR="/tmp"
}}

you can explain your information on an specific gentoo's wiki article: [[Portage_TMPDIR_on_tmpfs]]

=== XDG cache ===

When running Gentoo on desktop, many programs, using X windows systems (Chromium, Firefox, Skype, etc.) are making frequent disk I/O every few seconds to cache. Default cache directory is {{Path|~/.cache}}, which is on hard drive and should be moved to [[tmpfs]].

Create the file {{Path| /etc/profile.d/xdg_cache_home.sh }} and add the following lines to it:

{{FileBox|filename=/etc/profile.d/xdg_cache_home.sh|lang=bash|1=
#!/bin/bash

export XDG_CACHE_HOME="/tmp/${USER}/.cache"
}}

Do not forget to run <tt>env-update && source /etc/profile</tt>:

{{RootCmd|env-update && source /etc/profile}}

{{Note|The above command only updates the variables in the current terminal, new consoles, and their children. Thus, if the user is working in X11, he needs to either type {{Cmd|source /etc/profile}} in every new terminal opened or restart X so that all new terminals source the new variables. If a login manager is used, it is necessary to become root and restart the /etc/init.d/xdm service. }}

{{Warning|
With above change, auto unlocking the gnome keyring didn't work anymore.
/var/log/messages said the following:

   May  5 10:02:52 localhost gnome-keyring-daemon[5561]: couldn't bind to control socket: /home/david/.cache/keyring-hRt5QC/control: No such file or directory
}}

=== Browser profile/s and cache to RAM or HDD ===

Since the profile/s, browser cache*, etc. are relocated into TMPFS (RAM disk) or another mount point into an HDD, the corresponding I/O associated with using the browser is also redirected from the physical drive to RAM, thus reducing wear to the physical drive and also greatly improving browser speed and responsiveness.

You can move them with the utility {{Package|www-misc/profile-sync-daemon}}

{{RootCmd|emerge --ask www-misc/profile-sync-daemon}}

{{Note|{{Package|www-misc/profile-sync-daemon}} version 6 or greater requires systemd}}

Add that users whose browser/s profile/s will get symlinked to a TMPFS or another mountpoint in the value USERS=  

{{FileBox|filename=/etc/psd.conf|1= USERS="user user2 root"}}

close all the browsers, start the daemon and enable it
{{RootCmd|systemctl enable psd && systemctl start psd}}

you can view all symlinks  viewing the status of the daemon since started
{{RootCmd|psd p}}

More info about Profile Sync Daemon on https://wiki.archlinux.org/index.php/profile-sync-daemon

== See also ==

* [[HDD]] - Hard Disk Drive.
* [[NVMe]] - Non-Volatile Memory Express.

== References ==

{{Reflist}}

[[Category:Storage devices]]
