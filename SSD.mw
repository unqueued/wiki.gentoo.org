{{InfoBox stack
|{{InfoBox wikify|header=true}}
}}
How to set up SSDs on Gentoo Linux.
This article assumes you know how to set up, partition, and format a mechanical hard drive.

== Considerations ==

=== rootfs ===
You don't want to use -odiscard on a rootfs mount. discard is the "TRIM" command that tells the SSD to do its magic. Having this running potentially constantly may cause performance degredation, and there are articles to suggest this all over the web. Rather, you want to use:
{{RootCmd|fstrim -v /}}
on a command line, as root. You can set this up as a cron (see below) to run twice a day, which should suffice for rootfs.

=== mountpoint===
If you're going to have a low write directory mounted on SSD, using "discard" option will be fine in fstab. See below. If you're going to mount a database to an SSD, you probably want timed TRIM commands rather than the discard option. 

== After hardware installation ==

=== Partitioning ===
You can use usual fdisk (sys-apps/util-linux>=2.24.1-r2). Here's example for GPT partition table with BIOS motherboard.
Use "fdisk /dev/sda" to run fdisk, use m option for help. Type g and [Enter] to create a new empty GPT partition table on your SSD. Type n [Enter], [Enter], [Enter], +2M [Enter], t [Enter], 4 [Enter] to create BIOS boot partition.

   Command (m for help): n
   Partition number (1-128, default 1): 
   First sector (2048-117231374, default 2048): 
   Last sector, +sectors or +size{K,M,G,T,P} (2048-117231374, default 117231374): +2M
   
   Created a new partition 1 of type 'Linux filesystem' and of size 2 MiB.
   
   Partition type (type L to list all types): 4
   Changed type of partition 'Linux filesystem' to 'BIOS boot partition'.
   
Then we create 2GB swap partition:

   Command (m for help): n
   Partition number (2-128, default 2): 
   First sector (6144-117231374, default 6144): 
   Last sector, +sectors or +size{K,M,G,T,P} (6144-117231374, default 117231374): +2G
   
   Created a new partition 2 of type 'Linux filesystem' and of size 2 GiB.
   
   Command (m for help): t
   Partition number (1,2, default 2):
   Partition type (type L to list all types): 15
   
   Changed type of partition 'Linux filesystem' to 'Linux swap'.
   
Then we create system root partition and write changes:

   Command (m for help): n
   Partition number (3-128, default 3): 
   First sector (4200448-117231374, default 4200448): 
   Last sector, +sectors or +size{K,M,G,T,P} (4200448-117231374, default 117231374): 
   
   Created a new partition 3 of type 'Linux filesystem' and of size 53.9 GiB.
   
   Command (m for help): p
   Disk /dev/sda: 55.9 GiB, 60022480896 bytes, 117231408 sectors
   Units: sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   Disklabel type: gpt
   Disk identifier: E19B261A-21EA-4529-B736-1A4E48FC77A1
   
   Device           Start          End   Size Type
   /dev/sda1         2048         6143     2M BIOS boot partition
   /dev/sda2         6144      4200447     2G Linux swap
   /dev/sda3      4200448    117231374  53.9G Linux filesystem
   
   Command (m for help): w
   
   The partition table has been altered.
   Calling ioctl() to re-read partition table.
   Syncing disks.

So, as you can see, you don't need anything special with new fdisk from linux utils.

==== LVM ====
If you are using LVM, you need to allow discards on the logical volumes too.

{{File|/etc/lvm/lvm.conf||<pre>
devices {
  [...]
  issue_discards = 1
} 
</pre>}}

==== LUKS ====
If you have your root-device on LUKS, you need to set a kernel option:

{{File|/etc/default/grub||<pre>
GRUB_CMDLINE_LINUX_DEFAULT="[...] root_trim=yes"
</pre>}}

==== fdisk ====
   #assuming /dev/sda is the SSD
   #Per OCZ.

   fdisk -S 32 -H 32 /dev/sda
Set up the first partition to start on the second 512-cylinder unit:
   Device Boot         Start         End      Blocks   Id  System
   /dev/sda1               2         129       65536   83  Linux
   /dev/sda2             130    31457279    15662080   83  Linux
''so long as the first start number is 2 the rest will fall in line if you use size parameters rather than sector paramters (e.g start <enter> end <+4GB>)''

=== Formatting ===
If you can find your erase block size, you can add some extended attributes that may help performance.
For software raid, you really should know the erase block size. Consider this information when making your purchase.
Regardless of whether you're using RAID or not, setting extended values is known to be beneficial. https://raid.wiki.kernel.org/index.php/RAID_setup#ext2.2C_ext3.2C_and_ext4
http://blog.nuclex-games.com/2009/12/aligning-an-ssd-on-linux/

==== Without knowing the erase block size ====
   #Formatting the rootfs partition /dev/sda2:
   #Using 4096 byte blocks by default aligns the SSD for writes (see [defaults] section of /etc/mke2fs.conf and also 
   #man mkfs.ext4 about "-b block-size" and "-T usage-type[,...]" inside it):

   mkfs.ext4 /dev/sda2

==== With knowing the erase block size ====
   #Formatting the rootfs partition /dev/sda2:
   #Using 4096 byte blocks aligns the SSD for writes;
   #Using ERASE_BLOCK_SIZE / 4 as the stride and stripe width size;
   #In this example, OCZ Vertex drives have 512 kibbibyte -
   #Erase Block size, therefore stride/stripe-width = 512/4 = 128:

   mkfs.ext4 -E stride=128,stripe-width=128 /dev/sda2

=== Mounting ===
Given the considerations above, either add something similar to this:
   /dev/sda2          /          ext4          defaults,relatime,discard          0 1
Or this:
   /dev/sda2          /          ext4          defaults,relatime                  0 1
If you choose the latter, see the section on the cronjob needed if you don't want to manually TRIM the drive.

Once you've set up /etc/fstab you can run the following command to have the drive mounted:
   mount -a

== Notes ==

=== cron ===
Run fstrim -v / from cron twice a day to automatically do "discard":
   #Mins  Hours  Days   Months  Day of the week   command
   15     1,13   *      *       *                 /sbin/fstrim -v /

There is also a semi-automatic cronjob available on github called [http://chmatse.github.io/SSDcronTRIM/ SSDcronTRIM] which has the following features:

* Distribution Independent script (developed on my Gentoo system).
* The script decides every time depending on the disk usage how often (monthly, weekly, daily, hourly) each partition has to be trimmed.
* Recognizes if it should install itself into /etc/cron.{monthly,weekly,daily,hourly}, /etc/cron.d or any other defined directory and if it should make an entry into crontab.
* Checks if the kernel meets the requirements, the filesystem is able to and if your ssd supports trimming.
* simply install it by running it once without any option and deinstall it with the -d option

Future version should implement:

* Use of '''nice''' and '''ionice''' to let trimm only run when the disc is not busy.
* Overgive options to fstrim (e.g. '-m 1M')
* support for encrypted filesystem (LUKS)

== fstrimDemon ==

If your computer is not turned on when cron would trigger its job, fstrim would not be called. You can install [https://github.com/dobek/fstrimDemon fstrimDemon] instead.

=== tmpfs ===
When using an SSD, administrators generally want to reduce the amount of writes performed. On Gentoo, portage is a huge source of writes, and putting these writes into system memory rather than a disk is beneficial.
If you have more than 8gb of ram you may want to consider using tmpfs, which is a way to dedicate some system memory to storage on a temporary basis.
It's generally advised to not use more than 1/2 of your available system memory for tmpfs unless you know what you're doing. So let's assume you have 12GB of memory and want to allow up to 6 gigs of tmpfs. Edit /etc/fstab and add:
   tmpfs			/tmp		tmpfs		noatime,nodiratime,size=6G 	0 0
You can then tell portage to use this as it's compile scratch space in /etc/portage/make.conf:
   PORTAGE_TMPDIR="/tmp"
#this may fail on large compiles unless you have >20GB of system memory. scratch space for libreoffice can exceed 8GB, and the entire compile will fail if it runs out of space.
#Ram used by TMPFS is freed back to the pool when it is no longer in use, so when using portage or other software that uses /tmp you will notice a huge performance gain.

=== XDG cache ===

If you are running gentoo on desktop, many programs, using X windows systems (like: chromium, firefox, skype) are making frequent disk I/O every few seconds to cache. Default cache dir is ~/.cache, which is on hard drive.

Edit /etc/env.d/30xdg-data-local and add line:

   XDG_CACHE_HOME="/tmp/.cache"

Don't forget:
{{RootCmd|env-update}}


'''Warning:'''
With above change, auto unlocking the gnome keyring didn't work anymore. /var/log/messages said the following:

   May  5 10:02:52 localhost gnome-keyring-daemon[5561]: couldn't bind to control socket: /home/david/.cache/keyring-hRt5QC/control: No such file or directory

[[Category:Storage devices]]
