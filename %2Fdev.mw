<noinclude>
== The /dev directory ==
</noinclude>

<!--T:6-->
When Linux users talk about the hardware on their system in the vicinity of people who believe Linux is some sort of virus or brand of coffee, the use of "slash dev slash foo" will return strange looks for sure. But for the fortunate user (and that includes the reader of this article) using {{Path|/dev/sda1}} is just a fast way of referring to the primary master SATA, first partition. That's pretty easy, right? 

<!--T:7-->
Most Linux users know what a [[device file]] is. Some even know why device files have special numbers. Take a close look at device list when {{c|ls -l}} is issued in the {{Path|/dev}} folder. What users take for granted is that the primary SATA disk is referred to as {{Path|/dev/sda}} Some users might not see it this way, but this is a flaw by design. 

<!--T:8-->
Think about hotpluggable devices like USB, IEEE1394, hot-swappable PCI, etc. What is the first device? And for how long? What will the other devices be named when the first one disappears? How will that affect ongoing transactions? Wouldn't it be fun that a printing job is suddenly moved from a super-new laser printer to an almost-dead matrix printer because someone's mom decided to pull the plug of the laser printer which just so ''happened'' to be the first printer? 

<!--T:9-->
Enter {{c|udev}}. The goals of the udev project are both interesting and needed. Udev:

<!--T:10-->
* Runs in userspace;
* Dynamically creates and removes device files;
* Provides consistent naming;
* Provides a userspace application program interface (API).

<!--T:11-->
Every time a change happens within the device structure, the kernel emits a ''uevent'' which gets picked up by {{c|udev}}. {{c|udev}} then follows the rules as declared in the {{Path|/etc/udev/rules.d}}, {{Path|/run/udev/rules.d}} and {{Path|/lib/udev/rules.d}} directories. Based on the information contained within the uevent, it finds the rule or rules it needs to trigger and performs the required actions. These actions can be creating or deleting device files, but can also trigger the loading of particular firmware files into kernel memory.
