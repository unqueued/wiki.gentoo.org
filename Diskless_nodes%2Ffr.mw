<languages />

{{Metadata|abstract=This HOWTO will help with creating and setting up diskless nodes with Gentoo Linux.}}

This HOWTO will help with creating and setting up diskless nodes with Gentoo Linux.

== Introduction ==

=== À propos de ce guide ===

This HOWTO will help setting up ''diskless'' workstations based on the Gentoo Linux distribution. This is guide is intended to make the process as user friendly as possible and cater to the Linux newbie, because everyone was at a certain point :) While an experienced user could easily tie the multiple HOWTOs available on diskless nodes and networking together it's hoped that this guide can ease the installation for all interested users, geeks or not.

=== Qu'est-ce qu'une machine sans disque ? ===

A diskless machine is a PC without any of the usual boot devices such as hard disks, floppy drives or CD-ROMs. The diskless node boots off the network and needs a server that will provide it with storage space as a local hard disk would. From now on the server will be the ''master'' , while the diskless machine gets called the ''slave'' (what's in a name :). The slave node needs a network adapter that supports PXE booting or Etherboot; check [http://www.etherboot.org Etherboot.org] for support listings. Most modern cards support PXE and many built-in adapters on motherboards will also work. 

=== Before starting ===

Gentoo should be installed on the master node and enough space on the master to store the file systems of the slave nodes that are going to be hosted. Also make sure there is one interface to the internet separated from the local area connection. 

== Configurer le maître et les esclaves ==

=== À propos des noyaux ===

The kernel is the software that sits between the hardware and all other software that is loaded on the machine, essentially the heart of a kernel based operating system. When a computer is started, the BIOS executes the instructions found at the reserved boot space of the hard drive. These instructions are typically a boot loader that loads a kernel. After a kernel has been loaded all processes are handled by the kernel. 

For more information on kernels and kernel configuration check out the [http://www.tldp.org/HOWTO/Kernel-HOWTO.html kernel HOWTO] . 

=== Configurer le noyau du maître  ===

The master kernel can be as large and as customized as desired but there are a few required kernel options that need to be selected. Go into the kernel configuration menu by typing: 

{{RootCmd|cd /usr/src/linux
|make menuconfig}}

There should be a grey and blue GUI that offers a safe alternative to manually editing the {{Path|/usr/src/linux/.config}} file. If the kernel is currently functioning well it might be a good idea to save the current configuration file by exiting the GUI and typing: 

{{RootCmd|cp .config .config_working}}

Go into the following sub-menus and make sure the listed items are checked as built-in (and ''NOT'' as modular). The options show below are taken from the 2.6.10 kernel version. If a different version is used, the text or sequence might differ. Just make sure to select at least those shown below. 

{{KernelBox|title=master's kernel options|<pre>
[*] Networking support --->
  Networking options --->
    <*> Packet socket
    <*> Unix domain sockets
    [*] TCP/IP networking
    [*]   IP: multicasting
    [ ] Network packet filtering (replaces ipchains)
  
File systems --->
  Network File Systems  --->
    <*> NFS server support
    [*]   Provide NFSv3 server support
</pre>}}

If access to internet through the master node is required and/or a secure firewall is needed make sure to add support for iptables:

{{KernelBox|title=Activer la prise en charge des iptables |<pre>
  [*] Network packet filtering (replaces ipchains)
  IP: Netfilter Configuration  --->
    <*> Connection tracking (required for masq/NAT)
    <*> IP tables support (required for filtering/masq/NAT)
</pre>
}}

If packet filtering is required, add the rest as modules later. Make sure to read the [http://www.gentoo.org//doc/en/security/security-handbook.xml?part=1&chap=12 Gentoo Security Handbook Chapter about Firewalls] on how to set this up properly. 

{{Note|These kernel configuration options should only be added to the system specific configuration options and are not meant to completely replace the kernel configuration.}}

After the master kernel has been re-configured, it needs to be rebuilt:

{{RootCmd|make && make modules_install
|cp arch/i386/boot/bzImage /boot/bzImage-master}}

Then add an entry for that new kernel into {{Path|lilo.conf}} or {{Path|grub.conf}} depending on which bootloader that is being used and make the new kernel the default one. Now that the new bzImage has been copied into the boot directory all that has to be done is to reboot the system in order to load these new options. 

=== À propos du noyau de l'esclave ===

It is recommended that the slave kernel be compiled without any modules, since loading and setting them up via remote boot is a difficult and unnecessary process. Additionally, the slave kernel should be as small and compact as possible in order to efficiently boot from the network. The slave's kernel is going to be compiled in the same place where the master was configured. 

Pour éviter toute confusion et toute perte de temps, il vaut mieux garder une copie de la configuration du noyau maître comme ceci : 

{{RootCmd|cp /usr/src/linux/.config /usr/src/linux/.config_master}}

The slave's kernel is now to be configured in the same fashion as the master's kernel. If a fresh configuration file is needed it can be recovered from the default {{Path|/usr/src/linux/.config}} file by typing: 

{{RootCmd|cd /usr/src/linux
|cp .config_master .config}}

Ensuite, utilisez l'interface de configuration en tapant : 

{{RootCmd|cd /usr/src/linux
|make menuconfig}}

Make sure to select the following options as built-in and ''NOT'' as kernel modules: 

{{KernelBox|title=slave's kernel options|<pre>
[*] Networking support --->
  Networking options --->
    <*> Packet socket
    <*> Unix domain sockets
    [*] TCP/IP networking
    [*]   IP: multicasting
    [*]   IP: kernel level autoconfiguration
    [*]     IP: DHCP support
  
File systems --->
  Network File Systems  --->
    <*> file system support
    [*]   Provide NFSv3 client support
    [*]   Root file system on NFS
</pre>
}}

{{Note| Configurer un serveur BOOTP est une alternative au serveur DHCP.}}

{{Important|It is important to add the network adapter into the kernel (and not as a module) on the nodes. Using modules however is generally not a problem for diskless nodes.}}

Now the slave's kernel needs to be compiled. Be careful here not to overwrite or mess up the modules (if any) that have been built for the master:

{{RootCmd|cd /usr/src/linux
|make}}

Now create the directory on the master that will be used to hold slaves' files and required system files. The {{Path|/diskless}} is used but any location preferred may be chosen here. Now copy the slave's bzImage into the {{Path|/diskless}} directory: 


{{Note|If there are different architectures being used it might be useful to save each config into {{Path|.config_arch}} . Do the same with the images: save them into the {{Path|/diskless}} as {{Path|bzImage_arch}} .}}


{{RootCmd|mkdir /diskless
|cp /usr/src/linux/arch/i386/boot/bzImage /diskless}}

=== Configurer un système de fichiers préliminaire pour l'esclave ===

The master and slave filesystems can be tweaked and changed a lot. Right now the only point of interest is in getting a preliminary filesystem of appropriate configuration files and mount points. First it's required to create a directory within {{Path|/diskless}} for the first slave. Each slave needs its own root file system because sharing certain system files will cause permission problems and hard crashes. These directories can be called anything the administrator deems appropriate but the author suggests using the slaves IP addresses as they are unique and not confusing. The static IP of the first slave will be, for instance, <code>192.168.1.21</code> : 

{{RootCmd|mkdir /diskless/192.168.1.21}}

Various configuration files in {{Path|/etc}} need to be altered to work on the slave. Copy the master's {{Path|/etc}} directory onto the new slave root by typing: 

{{RootCmd|cp -r /etc /diskless/192.168.1.21/etc}}

Le système de fichiers est encore incomplet, il lui manque différents points de montage. Pour les créer tapez : 

{{RootCmd|mkdir /diskless/192.168.1.21/home
|mkdir /diskless/192.168.1.21/dev
|mkdir /diskless/192.168.1.21/proc
|mkdir /diskless/192.168.1.21/tmp
|mkdir /diskless/192.168.1.21/mnt
|chmod a+w /diskless/192.168.1.21/tmp
|mkdir /diskless/192.168.1.21/mnt/.initd
|mkdir /diskless/192.168.1.21/root}}

{{RootCmd|mkdir /diskless/192.168.1.21/sys
|mkdir /diskless/192.168.1.21/var
|mkdir /diskless/192.168.1.21/var/empty
|mkdir /diskless/192.168.1.21/var/lock
|mkdir /diskless/192.168.1.21/var/log
|mkdir /diskless/192.168.1.21/var/run
|mkdir /diskless/192.168.1.21/var/spool
|mkdir /diskless/192.168.1.21/usr
|mkdir /diskless/192.168.1.21/opt
}}

Most of these "stubs" should be recognizable; stubs like {{Path|/dev}} , {{Path|/proc}} or {{Path|/sys}} will be populated when the slave starts, the others will be mounted later. The {{Path|/diskless/192.168.1.21/etc/conf.d/hostname}} file should also be changed to reflect the hostname of the slave. Binaries, libraries and other files will be populated later in this HOWTO right before attempting to boot the slave. 

Even though {{Path|/dev}} is populated by <code>udev</code> later on, the {{Path|console}} entry needs to be created. If not, the error message "unable to open initial console" will be encountered. 

{{RootCmd|mknod /diskless/192.168.1.21/dev/console c 5 1}}

== Configurer le  serveur DHCP  ==

=== À propos du serveur DHCP  ===

DHCP signifie ''Dynamic Host Configuration Protocol'' (protocole dynamique de configuration des hôtes). Le serveur DHCP est le premier ordinateur contacté par les nœuds esclaves quand ils démarrent par le système PXE via le réseau. La principale fonction d'un serveur DHCP est d'attribuer des adresses IP. Un tel serveur peut attribuer des adresses en se basant sur les adresses MAC des cartes réseau (N.D.T. : l'adresse MAC est censée être unique pour chaque carte sur le marché et est attribuée par le constructeur). Une fois l'adresse attribuée, le serveur DHCP indique au nœud esclave où il peut obtenir son noyau et son système de fichiers préliminaire. 

=== Before getting started ===

There are several things to make sure of, that they are working properly before beginning. First check the network connectivity: 

{{RootCmd|ifconfig eth0 multicast
|ifconfig -a}}

Make sure there is an ''eth0'' device running. It should look something like this: 

{{CodeBox|title=Un périphérique eth0 fonctionnant correctememt |1=
eth0      Link encap:Ethernet  HWaddr 00:E0:83:16:2F:D6
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:26460491 errors:0 dropped:0 overruns:2 frame:0
          TX packets:32903198 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:100
          RX bytes:2483502568 (2368.4 Mb)  TX bytes:1411984950 (1346.5 Mb)
          Interrupt:18 Base address:0x1800
}}

It's important that it says ''MULTICAST'', if it doesn't then the kernel will have to be recompiled to include multicast support.

=== Installer le serveur  DHCP ===

If the network does not already have a DHCP server installed, one needs to be installed now: 

{{Emerge|dhcp}}

If the network already has a DHCP server installed, edit the configuration file to get the PXE boot to function correctly. 

=== Configurer le serveur  ===

There is only one configuration file that needs to be edited before starting the DHCP server: {{Path|/etc/dhcp/dhcpd.conf}}. Copy and edit the provided sample file: 

{{RootCmd|cp /etc/dhcp/dhcpd.conf.sample /etc/dhcp/dhcpd.conf
|nano -w /etc/dhcp/dhcpd.conf}}

Le fichier de configuration est organisé et indenté comme ceci : 

{{CodeBox|title=Exemple de présentation du {{Path|dhcpd.conf}}|1=
# global options here
ddns-update-style none;
shared-network LOCAL-NET {
  # shared network options here
  subnet 192.168.1.0 netmask 255.255.255.0 {
    # subnet network options here
    host slave{
        # host specific options here
    }
    group {
        # group specific options here
    }
  }
}
}}

The <code>shared-network</code> block is optional and should be used for IPs that are required to be assigned that belong to the same network topology. At least one <code>subnet</code> must be declared and the optional <code>group</code> block allows options to be grouped between items. A good example of {{Path|dhcpd.conf}} looks like this: 

{{CodeBox|title=Exemple de fichier {{Path|dhcpd.conf}}|1=
#
# Exemple de fichier  dhcpd.conf pour les clients sans disque
#
  
# Désactiver le  DNS dynamique
ddns-update-style none;
  
# Supposons qu'une passerelle par défaut pour le trafic IP suffise 
option routers 192.168.1.1;
  
# Procure les information DNS aux clients
option domain-name-servers 192.168.1.1;
option domain-name "mydomain.com";
  
# Spécifie le serveur TFTP à utiliser
next-server 192.168.1.1;
  
# Declare une option de  tampon spécifique au constructeur pour les clients  PXE :
# Code 1: adress IP Multicast du serveur de fichier de démarrage 
# Code 2: port UDP que le clien devrait surveiller pour les réponse MTFTP
# Code 3: port UDP que les serveurs  MTFTP utilisent pour écouter les requêtes  MTFTP 
# Code 4: Nombre de secondes pendant lesquelles un client doit écouter avant d'essayer
#  de  démarrer un nouveau transfert  MTFTP 
# Code 5: Nombre de secondes pendant lesquelles un client doit écouter avant d'essayer
#  de redémarrer un  transfert  MTFTP 
  
option space PXE;
option PXE.mtftp-ip               code 1 = ip-address;
option PXE.mtftp-cport            code 2 = unsigned integer 16;
option PXE.mtftp-sport            code 3 = unsigned integer 16;
option PXE.mtftp-tmout            code 4 = unsigned integer 8;
option PXE.mtftp-delay            code 5 = unsigned integer 8;
option PXE.discovery-control      code 6 = unsigned integer 8;
option PXE.discovery-mcast-addr   code 7 = ip-address;
  
# Déclare le sous-réseau où se trouvera notre nœud sans disque 
subnet 192.168.1.0 netmask 255.255.255.0 {
  
  # Procure aux clients PXE l'information appropriée
  class "pxeclient" {
    match if substring(option vendor-class-identifier, 0, 9) = "PXEClient";
    vendor-option-space PXE;
  
    # Au moins une option PXE spécifique au constructeur  doit être définie
    # afin que la ROM de démarrage du client  réalise que nous adhérons au protocole  PXE
    # serveur.  Nous définissons l'adresse IP MCAST à  0.0.0.0 pour dire à la ROM de démarrage 
    # que nous ne pouvons pas fournir le  multicast TFTP.
  
    option PXE.mtftp-ip 0.0.0.0;
  
    # Le nom du fichier que la ROM de démarrage devrait télécharger.
    filename "pxelinux.0";
  }
  
  # Procure aux clients  Etherboot l'information appropriée
  class "etherboot" {
    match if substring(option vendor-class-identifier, 0, 9) = "Etherboot";
    filename "vmlinuz_arch";
  }
  
  # Ajoutez une déclaration d'hôte pour chacun des hôtes sans disque
  host slave21 {
    hardware ethernet 00:02:A5:04:3B:66;
    fixed-address 192.168.1.21;
  }
}
}}

{{Note|There is nothing prohibiting the use of both PXE boot and Etherboot together. The above Code Listing is merely an example; if there are issues, please consult the DHCPd documentation.}}

The IP address after <code>next-server</code> will be asked for the specified <code>filename</code>. This IP address should be the IP of the tftp server, usually the same as the master's IP address. The <code>filename</code> is relative to the {{Path|/diskless}} directory (this is due to the tftp server specific options which will be covered later). Inside the <code>host</code> block, the <code>hardware ethernet</code> option specifies a MAC address, and <code>fixed-address</code> assigns a fixed IP address to that particular MAC address. There is a pretty good man page on {{Path|dhcpd.conf}} with options that are beyond the scope of this HOWTO. The man page can be read by typing: 

{{Cmd|man dhcpd.conf}}

=== Démarrer le serveur DHCP ===

Before starting the dhcp initialization script edit the {{Path|/etc/conf.d/dhcp}} file so that it looks something like this: 

{{CodeBox|title=Exemple de fichier {{Path|/etc/conf.d/dhcp}}|lang=bash|1=
IFACE="eth0"
# Insert any customizations needed
}}

The <code>IFACE</code> variable is the device that the DHCP server will be running on, in this case <code>eth0</code>. Adding more arguments to the <code>IFACE</code> variable can be useful for a complex network topology with multiple Ethernet cards. To start the dhcp server type: 

{{RootCmd|/etc/init.d/dhcp start}}

To add the dhcp server to the start-up scripts type: 

{{RootCmd|rc-update add dhcp default}}

=== Dépanner le serveur  DHCP ===

To see if a node boots, take a look at {{Path|/var/log/messages}}. If the node successfully boots, the {{Path|messages}} file should have some lines at the bottom looking like this: 

{{CodeBox|title=Exemple d'entrée de journalisation créée par dhcp|1=
DHCPDISCOVER from 00:00:00:00:00:00 via eth0
DHCPOFFER on 192.168.1.21 to 00:00:00:00:00:00 via eth0
DHCPREQUEST for 192.168.1.21 from 00:00:00:00:00:00 via eth0
DHCPACK on 192.168.1.21 to 00:00:00:00:00:00 via eth0
}}

{{Note|This log file can also help in discovering the slaves' MAC addresses.}}

If the following message is encountered it probably means there is something wrong in the configuration file but that the DHCP server is broadcasting correctly. 

{{CodeBox|title=Exemple d'erreur du serveur dhpc |1=
no free leases on subnet LOCAL-NET
}}

Every time after changing the configuration file the DHCP server must be restarted. To restart the server type: 

{{RootCmd|/etc/init.d/dhcpd restart}}

== Configurer le serveur TFTP et le chargeur de démarrage  Linux PXE et/ou Etherboot ==

=== À propos du serveur TFTP   ===

TFTP signifie « ''Trivial File Transfer Protocol'' ». Le serveur TFTP va fournir un noyau et un système de fichiers aux nœuds esclaves. Tous les noyaux des esclaves et leur système de fichiers seront stockés sur le serveur TFTP. Il est donc recommandé de l'installer sur le nœud maître. 

=== Installer le serveur TFTP  ===

Un serveur TFTP reconnu est celui compris dans le paquet tftp-hpa. Il se trouve qu'il a été écrit par le même auteur que SYSLINUX et ils fonctionnent très bien ensemble. Faites : 

{{Emerge|tftp-hpa}}

=== Configurer le serveur TFTP  ===

Edit {{Path|/etc/conf.d/in.tftpd}}. The tftproot directory needs to specified with <code>INTFTPD_PATH</code> and any command line options with <code>INTFTPD_OPTS</code>. It should look something like this: 

{{FileBox|filename=/etc/conf.d/in.tftpd|lang=bash|1=
INTFTPD_PATH="/diskless"
INTFTPD_OPTS="-l -v -s ${INTFTPD_PATH}"
}}

The <code>-l</code> option indicates that this server listens in stand alone mode so inetd does not have to be run. The <code>-v</code> indicates that log/error messages should be verbose. The <code>-s /diskless</code> specifies the root of the tftp server.

=== Démarrer le serveur TFTP ===

Pour démarrer le serveur tftp tapez : 

{{RootCmd|/etc/init.d/in.tftpd start}}

This should start the tftp server with the options that were specified in the {{Path|/etc/conf.d/in.tftpd}}. If this server is to be automatically started at boot type: 

{{RootCmd|rc-update add in.tftpd default}}

=== À propos de PXELINUX ===

This section is not required if only Etherboot is being used. PXELINUX is the network bootloader equivalent to LILO or GRUB and will be served via TFTP. It is essentially a tiny set of instructions that tells the client where to locate its kernel and initial filesystem and allows for various kernel options. 

=== Before getting started ===

Now the file pxelinux.0 is required, which comes in the SYSLINUX package by H. Peter Anvin. This package can be installed by typing: 

{{Emerge|syslinux}}

=== Configurer PXELINUX ===

{{Note|Ceci n'est pas nécessaire pour  Etherboot}}

Before starting the tftp server pxelinux needs to be set up. First copy the pxelinux binary into the {{Path|/diskless}} directory: 

{{RootCmd|cp /usr/share/syslinux/pxelinux.0 /diskless
|mkdir /diskless/pxelinux.cfg
|touch /diskless/pxelinux.cfg/default}}

Cela va créer un fichier de configuration par défaut pour syslinux. Le binaire {{Path|pxelinux.0}} cherche son fichier de configuration dans le répertoire {{Path|pxelinux.cfg}} . Il commence par chercher un fichier dont le nom est l'adresse IP attribuée au nœud écrite en hexadécimal. Si un tel fichier n'existe pas, {{Path|pxelinux.0}} enlève successivement le chiffre le plus à droite et regarde si un fichier correspondant existe jusqu'à ce qu'il trouve un fichier ou qu'il n'y ait plus de chiffre. Les version 2.05 et ultérieures de syslinux recherchent d'abord un fichier nommé d'après l'adresse MAC. Si ce fichier n'existe pas, la routine de recherche présentée ci-haut est effectuée. En dernier recours, le fichier {{Path|default}} est utilisé. 

{{CodeBox|title=Recherche du fichier de configuration dans {{Path|pxelinux.cfg/}}|1=
## (Le préfixe 01 signifie Ethernet, les octets suivant correspondent à l'adresse MAC de l'esclave)
01-00-40-63-c2-ca-c9
  
## (Adresse IP assignée en hexadécimal)
C0A80115
C0A8011
C0A801
C0A80
C0A8
C0A
C0
C
  
default
}}

{{Note|Tout ceci est en minuscules.}}

Démarrons avec le fichier {{Path|default}} file: 

{{CodeBox|title=Exemple de {{Path|pxelinux.cfg/default}}|1=
DEFAULT /bzImage
APPEND ip=dhcp root=/dev/nfs nfsroot=192.168.1.1:/diskless/192.168.1.21
}}

The <code>DEFAULT</code> tag directs pxelinux to the kernel bzImage that was compiled earlier. The <code>APPEND</code> tag appends kernel initialisation options. Since the slave kernel was compiled with <code>NFS_ROOT_SUPPORT</code> , the nfsroot will be specified here. The first IP is the master's IP and the second IP is the directory that was created in {{Path|/diskless}} to store the slave's initial filesystem.

=== À propos d'Etherboot ===

{{Note|This isn't required if PXE boot is being used.}}

Etherboot boots network boot images from a TFTP server. As the PXE this is equivalent to LILO or GRUB. The <code>mknbi</code> utility enables the creation of different images using different options. 

=== Before getting started ===

The <code>mknbi</code> (utility for making tagged kernel images useful for netbooting) package is needed to create the Etherboot images. This tool will create a preconfigured kernel image from the original kernel. This contains the boot options as shown further down. 

{{Emerge|mknbi}}

=== Configurer Etherboot ===

In this section a simple etherboot image will be created. As the dhcp server gives out the clients root-path in the "option root-path" dhcp.conf, this does not have to be included here. More details can be found in the mknbi manual. 

{{Cmd|man mknbi}}

Pour créer une image ELF sur laquelle démarrer qui sait passer les paramètres DHCP et la racine à utiliser au noyau tout en forçant le noyau à demander une adresse IP via DHCP, faites : 

{{RootCmd|mkelf-linux -ip{{=}}dhcp /diskless/bzImage > /diskless/vmlinuz }}

{{Note|For the arch specific images <code>bzImage_arch</code> and <code>vmlinuz_arch</code> have to be typed.}}

=== Dépanner le processus de démarrage sur réseau  ===

There are a few things that can be done to debug the network boot process. Primarily a tool called <code>tcpdump</code> can be used. To install <code>tcpdump</code> type: 

{{Emerge|tcpdump}}

Now various network traffic can be listened to, to make sure the client/server interactions are functioning. If something isn't working there are a few things that could be checked. First make sure that the client/server is physically connected properly and that the networking cables are not damaged. If the client/server is not receiving requests on a particular port make sure that there is no firewall interference. To listen to interaction between two computers type: 

{{RootCmd|tcpdump host client_ip and server_ip}}

The <code>tcpdump</code> command can also be configured to listen on particular port such as the tftp port by typing: 

{{RootCmd|tcpdump port 69}}

A common error that might be received is: "PXE-E32: TFTP open time-out". This is probably due to firewall issues. If <code>TCPwrappers</code> is being used, it might be worth checking {{Path|/etc/hosts.allow}} and {{Path|etc/hosts.deny}} and make sure that they are configured properly. The client should be allowed to connect to the server.

== Configurer le serveur NFS ==

=== À propos du serveur NFS  ===

NFS stands for Network File System. The NFS server will be used to serve directories to the slave. This part can be somewhat personalized later, but right now all that is wanted is a preliminary slave node to boot diskless. 

=== À propos de  Portmapper ===

Certains services ne sont pas toujours liés au même port, mais utilisent le système d'appel de fonction à distance (les RPC en anglais pour « Remote Procedure Call »). Dans ce cas, lorsqu'un service démarre, il écoute sur un port disponible choisi au hasard et il s'inscrit dans la liste de tels services tenue par le programme portmapper. NFS utilise ce mécanisme et a besoin que le programme portmapper soit actif avant de démarrer. 

=== Before starting ===

The NFS Server needs kernel level support so if the kernel does not have this, the master's kernel needs to be recompiled. To double check the master's kernel configuration type: 

{{RootCmd|grep NFS /usr/src/linux/.config_master}}

The output should look something like this if the kernel has been properly configured: 

{{KernelBox|title=Options spécifiques NFS adéquates dans la configuration du noyau du maître.|1=
CONFIG_PACKET=y
# CONFIG_PACKET_MMAP is not set
# CONFIG_NETFILTER is not set
CONFIG_NFS_FS=y
CONFIG_NFS_V3=y
# CONFIG_NFS_V4 is not set
# CONFIG_NFS_DIRECTIO is not set
CONFIG_NFSD=y
CONFIG_NFSD_V3=y
# CONFIG_NFSD_V4 is not set
# CONFIG_NFSD_TCP is not set
}}

=== Installer le serveur NFS  ===

Le paquet NFS est installé via Portage comme ceci : 

{{Emerge|nfs-utils}}

Ce paquet comprend le programme portmapper, le serveur nfs et les utilitaires pour les clients NFS. Les dépendances lors de l'initialisation sont automatiquement résolues. 

=== Configurer le serveur NFS  ===

There are three major configuration files that will have to be edited: 

{{CodeBox|title=Fichiers de configuration Nfs|1=
/etc/exports
/diskless/192.168.1.21/etc/fstab
/etc/conf.d/nfs
}}

Le fichier {{Path|/etc/exports}} indique comment, à qui et quoi exporter via NFS. Le fichier /etc/fstab des nœuds esclaves sera modifié pour monter les systèmes de fichiers exportés par le maître. 

Le fichier   {{Path|/etc/exports}} typique du maître devrait ressembler à ceci : 

{{FileBox|filename=/etc/exports|title=fichier d'export du maître|1=
# une telle ligne pour  chaque esclave
/diskless/192.168.1.21   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
# commun à tous les esclaves
/opt   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/usr   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/home  192.168.1.0/24(sync,rw,no_root_squash,no_all_squash)
# if you want to have a shared log
/var/log   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
}}

Le premier champ indique le nom du répertoire à exporter et le suivant spécifie à qui et comment. Le « qui » indique quel nœud peut monter ce répertoire via le réseau et le « comment » liste ce que le nœud peut faire. L'option <code>ro</code> interdit l'écriture (=read-only) et <code>rw</code> l'autorise. Les options <code>no_root_squash</code> et no_<code>no_all_squash</code> sont importantes pour les clients sans disque qui écrivent sur le disque, de manière à ce qu'ils ne soient pas ''squashés'' lors qu'ils font des requêtes d'entrée/sortie . Le fichier ''fstab'' de l'esclave, {{Path|/diskless/192.168.1.21/etc/fstab}}:  devrait ressembler à ceci : 

{{CodeBox|title=Exemple de fichier {{Path|fstab}} de l'esclave|1=
# these entries are essential
master:/diskless/192.168.1.21   /         nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
master:/opt                     /opt      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/usr                     /usr      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/home                    /home     nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
none                            /proc     proc    defaults                                     0 0
# useful but superfluous
master:/var/log                 /var/log  nfs     hard,intr,rw                                 0 0
}}

In this example, ''master'' is just the hostname of the master but it could easily be the IP of the master. The first field indicates the directory to be mounted and the second field indicates where. The third field describes the filesystem and should be NFS for any NFS mounted directory. The fourth field indicates various options that will be used in the mounting process (see mount(1) for info on mount options). Some people have had difficulties with soft mount points so here they are made hard mounts, a look into various {{Path|/etc/fstab}} options should be done to make the cluster more efficient. 

The last file that should be edited is {{Path|/etc/conf.d/nfs}} which describes a few options for nfs when it is initialised and looks like this: 

{{CodeBox|title=Exemple de fichier {{Path|/etc/conf.d/nfs du maître}}|1=
# Fichier de configuration pour /etc/init.d/nfs
  
# Nomber de serveur à démarrer par défaut
RPCNFSDCOUNT=8
  
# Options à passer à rpc.mountd
RPCMOUNTDOPTS=""
}}

The <code>RPCNFSDCOUNT</code> should be changed to the number of diskless nodes on the network. 

=== Démarrer le serveur NFS ===

The nfs server should be started with its init script located in {{Path|/etc/init.d}} by typing: 

{{RootCmd|/etc/init.d/nfs start}}

If this script is to be started every time the system boots simply type: 

{{RootCmd|rc-update add nfs default}}

== Finaliser le système de fichiers de l'esclave  ==

=== Copier les fichiers manquants ===

Now the slave's file system will be made in sync with the master's and provide the necessary binaries while still preserving slave specific files. 

{{RootCmd|rsync -avz /bin /diskless/192.168.1.21
|rsync -avz /sbin /diskless/192.168.1.21
|rsync -avz /lib /diskless/192.168.1.21}}

{{Note|}} L'utilisation de rsync -avz, au lieu de cp, permet de copier les liens symboliques et les permissions de fichiers.

=== Configurer le réseau des nœuds sans disque ===

In order to prevent the networking initscript from killing the connection to the NFS server, an option needs to be added to {{Path|/etc/conf.d/net}} on the diskless client's filesystem. 

{{CodeBox|title=Editer le fichier {{Path|/etc/conf.d/net}}|1=
config_eth0=( "noop" )
}}

{{Note| Pour plus d'informations, veuillez vous référer à {{Path|/usr/share/doc/openrc-*/net.example.bz2}} .}}

=== Scripts d'initialisation  ===

Init scripts for slaves are located under {{Path|/diskless/192.168.1.21/etc/runlevels}} for services needed on the diskless nodes. Each slave can be set up and customized here, it all depends on what each slave is meant to do. 

{{Warning|Do not use the <code>rc-update</code> program to add or remove scripts from the slave runlevels when logged on to the master. This would change the master runlevels. The links need to be manually created or by logging into the slave nodes using ssh or connecting a screen and keyboard to the slave.}}

{{CodeBox|title=Niveaux d'exécution typiques d'un esclave|1=
/diskless/192.168.1.21/etc/runlevels/:
total 16
drwxr-xr-x    2 root     root         4096 2003-11-09 15:27 boot
drwxr-xr-x    2 root     root         4096 2003-10-01 21:10 default
drwxr-xr-x    2 root     root         4096 2003-03-13 19:05 nonetwork
drwxr-xr-x    2 root     root         4096 2003-02-23 12:26 single
  
/diskless/192.168.1.21/etc/runlevels/boot:
total 0
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 bootmisc -> /etc/init.d/bootmisc
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 checkfs -> /etc/init.d/checkfs
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 domainname -> /etc/init.d/domainname
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 hostname -> /etc/init.d/hostname
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 localmount -> /etc/init.d/localmount
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 modules -> /etc/init.d/modules
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 net.lo -> /etc/init.d/net.lo
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 netmount -> /etc/init.d/netmount
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 rmnologin -> /etc/init.d/rmnologin
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 urandom -> /etc/init.d/urandom
  
/diskless/192.168.1.21/etc/runlevels/default:
total 0
lrwxrwxrwx    1 root     root           23 2003-10-18 17:28 consolefont -> /etc/init.d/consolefont
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 distccd -> /etc/init.d/distccd
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 keymaps -> /etc/init.d/keymaps
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 sshd -> /etc/init.d/sshd
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 syslog-ng -> /etc/init.d/syslog-ng
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 vixie-cron -> /etc/init.d/vixie-cron
  
/diskless/192.168.1.21/etc/runlevels/nonetwork:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
  
/diskless/192.168.1.21/etc/runlevels/single:
total 0
}}

Now is a good time to boot the slave and cross some fingers. It works? Congratulations, you are now the proud owner of (a) diskless node(s).

{{Migrated|originalauthors=Michael Andrews, Kristian Jerpetjoen, Sven Vermeulen, Xavier Neys}}
