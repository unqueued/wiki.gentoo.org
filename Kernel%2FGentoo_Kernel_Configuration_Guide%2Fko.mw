<languages />


{{Metadata|abstract=이 문서는 직접 커널 설정 개념을 소개하며 대부분의 일반 설정 과정의 함정을 낱낱이 파헤칩니다.}}

이 문서는 직접 커널 설정 개념을 소개하며 대부분의 일반 설정 과정의 함정을 낱낱이 파헤칩니다.

== 도입부 ==

젠투에서는 커널 설정, 설치, 업그레이드 방식을 두가지 제공합니다. 하나는 ''자동'' (genkernel) 그리고 다른 하나는 ''수동'' 입니다. 비록 자동 방식이 대부분 사용자에게 쉽겠지만, 상당수의 젠투 사용자들이 커널을 직접 설정하는 방법을 선택하는지에 대해서는 수많은 이유가 있습니다:

# 엄청난 유연성
# 작은 (커널) 크기
# 짧은 컴파일 시간
# 배움의 경험
# 극심한 귀차니즘
# 커널 설정에 대한 확실한 지식 확보 또는
# 완벽한 설정 처리

이 안내서에서는 자동 방식(genkernel)을 다루지 않습니다. 커널과 관련된 문제를 다루는데 genkernel을 원한다면 [[Genkernel/ko|Genkernel 글]]에 집중하십시오. 

이 안내서에서는 시작부터 끝날 때까지 직접 설정 과정을 문서화하지 않습니다. 설정 과정은 상식적으로 상당 범위를 다루며 시스템을 사용하는데 있어 비교적 고수준의 기술 지식을 요합니다. 대신 직접 설정의 개념 정도 소개하며 사용자 입장에서 대부분 빠지기 쉬운 함정을 자세하게 안내하겠습니다. 

{{Note|이 안내서는 일반적으로 사용하는 컴퓨터의 아키텍처 와 최근 커널을 기준으로 작성했다고 간주합니다. 이전 커널 또는 유별난 아키텍처에 대한 일부 세부 사항은 다를 수 있습니다. 허나 그래도 대부분의 내용은 어디든 관련성이 있습니다.}}

여기서, 사용자 여러분께서 이미 하드디스크(보통 {{Path|/usr/src}} 아래 어딘가에)에 리눅스 커널 소스 코드의 압축을 해제했고, ncurses 메뉴 체계 기반을 통해 어느 정도 설정을 탐색하는 지식을 갖춘 상태에서 <tt>menuconfig</tt> 설정 유틸리티에 들어가는 방법을 알고 있다고 가정하겠습니다. 만약 이 단계의 사용자가 아니라면 도움이 될 다른 문서가 있으니 찾아보십시오. 다음 게시글을 읽고, 이 안내서로 돌아오시면 됩니다:

* [[Kernel/Overview/ko|커널 소스 코드 개요]]는 포티지 트리에 있는 커널 소스 코드 꾸러미 정보가 있습니다.
* [[Kernel/Upgrade/ko|커널 업그레이드]]는 커널 업그레이드 및 커널 전환 방법을 설명합니다.
* 젠투 핸드북의 [[Handbook:Main_Page/ko|커널 설정 장]]에서는 커널 설치 방법을 다룹니다. 적당한 아키텍처를 선택하신 후 ''리눅스 커널 설정''장을 들어가서 내용을 살펴보십시오.

== 설정 개념 ==

=== 기본 ===

일반 과정은 실제로 꽤 단순합니다: 여러개의 옵션을, 각 메뉴와 하위 메뉴로 분류한 채로 나타나며, 원하는 하드웨어 지원 및 시스템과 관련된 커널 기능이 이미 선택한 상태입니다.

커널에는 ''기본 설정''이 들어있는데 소스 코드 일부로 menuconfig를 처음 실행할 때 나타납니다. 기본 값은 보통 다양하고 분별성이 있는데, 대부분의 사용자가 기본 설정에서 바꾸는 설정 가지 수가 적음을 의미합니다. 이미 활성화한 커널의 기본 설정을 비활성화하기로 결정했다면 해당 옵션의 동작에 대해 정확하게 이해하고 있는지 확인하시고, 그 다음에 비활성화하십시오. 

리눅스 커널 설정을 처음 진행하는 동안, 설정 목적은 보수적이어야 합니다. 너무 도전적이어서도 안되며 가능한 한 기본 설정의 수정은 최소화하십시오. 또한, 실제 시스템을 부팅할 수 있도록 개별적으로 처리할 시스템 설정 부분이 있음을 고려하십시오.

=== 내장이냐 모듈이냐 ===

대부분의 설정 옵션은 ''3 상태'' 입니다: 빌드하지 않는 <code>(N)</code> 옵션, 커널에 빌드하는 <code>(Y)</code> 옵션, 모듈로 빌드하는 <code>(M)</code> 옵션이 될 수 있습니다. 모듈은 파일 시스템 상 외부에 저장하며, 내장 항목은 커널 이미지 자체에 직접 빌드합니다. 

There is an important difference between built-in and modular: with a few exceptions, the kernel makes no attempt whatsoever to load any external modules when the system might need them; it is left up to the user to decide when, or when to not, load a module. While certain other parts of the system may have load-on-demand facilities, and there are some automatic module loading utilities available, it is recommended to build hardware support and kernel features directly into the kernel. The kernel can then ensure the functionality and hardware support is available whenever needed. This is done by setting each kernel feature to (Y). For this setup to be coherent it is also necessary to include firmware support in the kernel. This is done setting <code>FW_LOADER=y</code> and <code>CONFIG_FIRMWARE_IN_KERNEL=y</code> in the kernel's {{Path|.config}} or by the following:

{{KernelBox|title=커널 펌웨어 활성화|
Device Drivers  --->
   Generic Driver Options  --->
       -*- Userspace firmware loading support
       [*] Include in-kernel firmware blobs in kernel binary
}}

For other parts of the configuration, built-in is an absolute requirement. For example, if the root partition was an btrfs filesystem the system would not boot if btrfs was built as a module. The system would have to look on the root partition to find the btrfs module (since modules are stored in the root partition), but it cannot look on the root partition unless it already has btrfs support loaded! If btrfs has not been built-in then the init process will fail to find the root device.

=== 하드웨어 지원 ===

Beyond detecting the ''architecture type'' of the system, the configuration utility makes no attempt to identify what hardware is actually present in the system. While there are default settings for ''some'' hardware support, users almost certainly need to find and select the configuration options relevant to each system's hardware configuration. 

Selecting the proper configuration options requires a knowledge of the components inside and connected to the computer. Most of the time these components can be identified without taking the lid off the system. For most internal components, users need to identify the ''chipset'' used on each device, rather than the retailed product name. Many expansion cards are retailed with a certain brand name, but use another manufacturer's chipset.

There are some utilities available to help users determine what kernel configuration options to use. <tt>lspci</tt> (part of the {{Package|sys-apps/pciutils}} package) will identify PCI-based and AGP-based hardware, this includes components built onto the motherboard itself. <tt>lsusb</tt> (from the {{Package|sys-apps/usbutils}} package) will identify various devices connected to the system's USB ports. 

The situation is somewhat confused by varying degrees of standardization in the hardware world. Unless the user selects extreme deviation from the default configuration settings, the IDE hard disks should "just work", as will the PS/2 or USB keyboard and mouse. Basic VGA display support is also included. However, some devices such as Ethernet adapters are hardly standardized at all; for these devices users will have to identify the Ethernet chipset and select the appropriate hardware support for the specific card to get network access.

In addition, while some things just-about-work with the default settings, more specialized options may need to be selected to get the full potential from the system. For example, if support for the appropriate IDE chipset has not been enabled, the IDE hard disks will run ''very'' slowly.

=== 커널 기능 ===

In addition to hardware support, users need to consider the software features that will be required in the kernel. One important example of such a feature is filesystem support: users must select support for the filesystems in use on their hard disks, as well as any filesystems they might use on external storage devices (e.g. VFAT on USB drives). 

Another common software feature example is advanced network functionality. In order to do some kind of routing or firewalling the relevant configuration items must be included in the kernel configuration. 

=== 준비됐죠? ===

이제 개념을 소개했으니 시스템 하드웨어를 식별하고, menuconfig 인터페이스로 탐색한 다음, 시스템에 필요한 커널 옵션을 선택하는 과정의 시작은 쉬울겝니다. 

The rest of this guide should clear up common areas of confusion, and provide advice for how to avoid common problems which users often run into. Best wishes!

== 보통 문제와 혼동하는 부분 ==

=== SATA 디스크는 SCSI 입니다 ===

Most modern desktop systems ship with storage devices (hard disk and CD/DVD drives) on a [https://en.wikipedia.org/wiki/SATA Serial ATA] bus, rather than the older [https://en.wikipedia.org/wiki/Parallel_ATA IDE] (ribbon cable) bus type. 

SATA support in Linux is implemented in a layer referred to as ''libata'', which sits below the SCSI subsystem. For this reason, SATA drivers are found in the SCSI driver section of the configuration. Additionally, the system's storage devices will be treated as SCSI devices, which means SCSI disk/cdrom support will also be required. The first SATA hard disk will be named {{Path|/dev/sda}} and the first SATA CD/DVD drive will be named {{Path|/dev/sr0}}. 

Although the majority of these drivers are for SATA controllers, libata was not designed to be SATA-specific. All common IDE drivers will also be ported to libata in the near future, and at this point, the above considerations will also apply for IDE users. 

{{KernelBox|title=libata용 옵션 설정|1=
Device Drivers  --->
   SCSI device support  --->
      <*> SCSI device support
      <*> SCSI disk support
      <*> SCSI CDROM support
 
      [ ] SCSI low-level drivers  --->
 
   <*> Serial ATA and Parallel ATA drivers (libata)  --->
}}

{{Note|Non-standard chipset(s) are listed under "SCSI low-level drivers" in the ''Configuration options for libata'' kernel box above.}}

=== IDE 칩셋과 DMA ===

Despite the introduction of SATA, IDE devices are still very common and depended upon by many systems. IDE is a fairly generic technology, and as such, Linux supports almost all IDE controllers out-of-the-box without any controller-specific options selected. 

However, IDE is an old technology, and in its original ''Programmed Input/Output'' incarnation, it is unable to provide the transfer rates required for speedy access to modern storage devices. The generic IDE driver is limited to these PIO transfer modes which result in slow data transfer rates and significantly high CPU usage while data is being transferred to and from disk. 

Unless a user is dealing with a pre-1995 system, the IDE controller will also support an alternative transfer mode, known as ''Direct Memory Access'' (DMA). DMA is much much faster, and CPU utilization is barely affected while data transfers are taking place. If the system is suffering from really poor general system performance while it is using an IDE disk, chances are that DMA is not being used and should be enabled.

{{Note|As mentioned earlier, libata is available even for IDE drives. If using libata, then all the drives, including IDE drives, will be using DMA. There is no need to do any further checking or configuration.}}

When not using libata for IDE disks check for DMA usage and enable it. The following command can be used to determine if DMA is being used:

{{RootCmd|hdparm -d /dev/hda|output=<pre>
/dev/hda:
 using_dma    =  0 (off)
</pre>
}}

To enable DMA for older IDE devices (which is a deprecated setting), enable the following kernel features.

{{Warning|Enabling <code>CONFIG_BLK_DEV_IDE_SATA</code> will create a conflict with the libata SATA driver. Normally support for SATA is disabled on IDE controllers because it is handled better by the actively maintained SCSI subsystem. Enabling <code>CONFIG_BLK_DEV_IDE_SATA</code> will cause this driver to conflict with libata's support for SATA, which is generally a bad idea. This driver exists to handle old IDE drives, leave the handling of SATA to libata if possible!}}

{{KernelBox|title=오래된 IDE 컨트롤러 설정 옵션|1=
Device Drivers  --->
   <*> ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
      <*> ATA/ATAPI/MFM/RLL support
      <*>   Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
      [*]     PCI IDE chipset support
}}

{{Note|Select the correct chipset(s) from the choices listed under "PCI IDE chipset support" in the ''Configuration options for IDE controllers'' kernel box above.}}

=== USB 호스트 컨트롤러 ===

[[USB]] is a widely adopted bus for connecting external peripherals to a computer. One of the reasons behind the success of USB is that it is a standardized protocol, however the USB ''host controller devices'' (HCDs) implemented on the host computer do vary a little. There are 4 main types: 

# <code>UHCI</code> is the Universal Host Controller Interface. It supports USB 1.1, and is usually found on motherboards based on a VIA or Intel chipset.
# <code>OHCI</code> is the Open Host Controller Interface. It supports USB 1.1 and is usually found on motherboards based on an Nvidia or SiS chipset.
# <code>EHCI</code> is the Extended Host Controller Interface. It is the only common host controller to support USB 2.0, and can typically be found on any computer that supports USB 2.0.
# <code>XHCI</code> is the eXtensible Host Controller Interface. It is the host controller for USB 3.0 and is compatible with USB 1.0, 1.1, 2.0, 3.0 and future speeds. Enable this feature when the board supports USB 3.0.

Most systems come with two of the above interface types: XHCI (USB 3.0) ''and'' EHCI (USB 2.0). To use USB devices, it is no longer necessary to select both options since XHCI is compatible with slower USB-controllers. Users can also enable EHCI to be "extra" safe; it does no harm if USB 2.0 controllers are unavailable.

If the relevant options corresponding to the USB HCD types present on the system are not selected, then 'dead' USB ports may be experienced. This case can be determined if a working USB device is plugged in, but it does not get power or respond in any way. 

A neat <tt>lspci</tt> trick (from the {{Package|sys-apps/pciutils}} package) makes it relatively easy to detect which HCDs are present on system. Ignoring the SATA controller which was also matched, it is easy to spot that this system requires EHCI and XHCI support:

{{RootCmd|lspci -v {{!}} grep HCI|output=<pre>
00:14.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB xHCI (rev 04) (prog-if 30 [XHCI])
00:1a.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #2 (rev 04) (prog-if 20 [EHCI])
00:1d.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #1 (rev 04) (prog-if 20 [EHCI])
00:1f.2 SATA controller: Intel Corporation 8 Series/C220 Series Chipset Family 6-port SATA Controller 1 [AHCI mode] (rev 04) (prog-if 01 [AHCI 1.0])
</pre>
}}

Select the HCDs present on the system. In general select all three options for maximum support, or if the correct option is uncertain:

{{KernelBox|title=[[USB#Kernel_Configuration|USB HCDs 설정<sup style="color: #ff0077">en</sup>]]|1=
Device Drivers  --->
   USB support  --->
      <*> Support for Host-side USB
      ---   USB Host Controller Drivers
      <*>   xHCI HCD (USB 3.0) support
      <*>   EHCI HCD (USB 2.0) support
      < >   OHCI HCD  (USB 1.1) support
      < >   UHCI HCD (most Intel and VIA) support
}}

In Linux kernel 3.12.13 and later, ''OHCI support for PCI-bus USB controllers'' (<code>CONFIG_USB_OHCI_HCD_PCI</code>) has to be enabled if the USB controller is OHCI and a USB keyboard or mouse is used.

=== Multiprocessor, Hyper-Threading and multi-core systems ===

Many computer systems are based on multiple processors, but not always in an immediately obvious way. 

* Many of Intel's CPUs support a technology which they call [https://en.wikipedia.org/wiki/Hyperthreading hyper-threading]. This technology enables a single CPU to be viewed by the system as two ''logical'' processors.
* Most Intel/AMD CPUs actually consist of multiple physical processors inside a single package, these processors are known as [https://en.wikipedia.org/wiki/Multi-core_processor multi-core] processors.
* Some high-end computer systems actually have multiple physical processors installed on specialized motherboards to provide a significant performance increase over a ''uniprocessor'' system. System users will probably know if they have such a system, since they are not cheap.

In all of these cases, the appropriate kernel options must be selected to obtain optimum performance from these setups:

{{KernelBox|title=다중 처리 지원 기능 설정|1=
Processor type and features  --->
 [*] Symmetric multi-processing support
 [*]   SMT (Hyperthreading) scheduler support
 [*]   Multi-core scheduler support (NEW)
}}

The next option not only enables power management features, but might also be a requirement for making all CPUs available to the system:

{{KernelBox|title=Power management for multi-processor systems|1=
Power management and ACPI options  --->
 [*] ACPI (Advanced Configuration and Power Interface) Support
}}

=== x86 상위 메모리 영역 지원 ===

Due to limitations in the 32-bit address space of the x86 architecture, a kernel with default configuration can only support up to 896MB RAM. If a system has more memory, only the first 896MB will be visible, unless high memory support has been enabled. 

{{Note|이 제한 사항은 x86(IA32) 아키텍처에 한합니다. 다른 아키텍처에서는 설정 조절 없이 큰 용량의 메모리를 자체적으로 지원합니다.}}

상위 메모리 영역 지원은 이제 기본적으로 비활성화 상태인데, 소규모 시스템의 과부하를 유발하기 때문입니다. 이 문제에 신경 쓰시지 마십시오. 더 많은 가용 메모리로 인한 성능 증가에 비하면 과부하는 별로 중요하지 않습니다. 

4GB를 넘는 RAM을 보유하고 있지 않다면 4GB 옵션을 선택하십시오:

{{KernelBox|title=x86 상위 메모리 지원 활성화|1=
Processor type and features  --->
 High Memory Support  --->
  (X) 4GB
  ( ) 64GB
}}

=== 압축 커널 모듈 ===

커널 버전 3.18.x(이상) 부터 커널 모듈 압축이 가능합니다. gzip과 xz 압축 방식을 활용할 수 있습니다. 압축 모듈로 커널을 컴파일 하기 ''전에'' 적당한 USE 플래그를 붙여 {{Package|sys-apps/kmod}}를 이머지하는 것이 중요합니다.

{{FileBox|filename=/etc/portage/package.use|title=kmod 압축 지원 활성화|1=
sys-apps/kmod lzma zlib
}}

{{Package|sys-apps/kmod}}를 다시 이머지하십시오:

{{Emerge|params+=--oneshot --changed-use|sys-apps/kmod}}

모듈 압축을 활성화하고 알맞은 압축 방식을 선택하십시오:
{{KernelBox|title=모듈 압축 활성화|1=
Enable loadable module support --->
  [*]   Compress modules on installation
  Compression algorithm ()  --->
    <X> GZIP
        XZ
}}

보통 {{c|make modules_install}}에서 {{c|depmod}}를 실행합니다. {{Package|sys-apps/kmod}} 에 적당한 USE 플래그를 설정하지 않았을 때(위 단계에서 {{Path|package.use}} 참고) 처음 실행하면, 의존성 목록이 비어있을 것입니다. 때문에, 시스템에서는 압축한 상태로 빌드한 어떤 모듈이든 불러올 수 없습니다.

kmod를 다시 컴파일 하고 나면, 이 문제를 해결하기 위해 <tt>depmod</tt>를 다시 실행하십시오:

{{RootCmd|depmod -a
|modprobe <module_name>
}}

== 커널 설정 간편 표기 ==

=== 도입부 ===

커널 설정 방법을 읽을 때, 종종 설정 항목은 <code>CONFIG_<거시기></code>로 나타납니다. 이 간편 표기 방식은 내부적으로 활용하는 커널 설정이며, 커널 설정 파일({{Path|/usr/src/linux/.config}} 또는 자동으로 만든 {{Path|/proc/config.gz}})에서 찾아볼 수 있습니다. 물론, 간편 표기 방식이 커널 설정에 있어 실제 위치로 변환하는데 있어 썩 좋은 방식은 아닙니다. {{c|make menuconfig}} 도구는 이 문제를 풀어냅니다.

=== CONFIG_FOO를 실제 설정 위치로 변환하기 ===

Suppose the <code>CONFIG_TMPFS_XATTR</code> feature needs to be enabled. Launch the kernel configuration menu (<tt>make menuconfig</tt>) and press the {{Key|/}} key. This will open a search box. In the search box, type <code>CONFIG_TMPFS_XATTR</code>. 

The following is an output of the result of this search:

{{KernelBox|title=menuconfig에서의 CONFIG_TMPFS_XATTR 검색 결과|1=
Symbol: TMPFS_XATTR [=n]
Type  : boolean
Prompt: Tmpfs extended attributes
  Defined at fs/Kconfig:138
  Depends on: TMPFS [=y]
  Location:
    -> File systems
      -> Pseudo filesystems
        -> Virtual memory file system support (former shm fs) (TMPFS [=y])
  Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
}}

This output yields lots of interesting information.

{| class="table" style="text-align: left;" 
|- 
! Entry
! Description
|- 
| Symbol: TMPFS_XATTR [=n]
| This identifies the kernel configuration entry being searched for. It also shows that this setting is currently ''not enabled'' ([=n]).
|- 
| Type: boolean
| The setting searched for is a boolean (which means it can be one of two options: enabled or disabled). Some settings are numbers or strings.
|- 
| Prompt: Tmpfs extended attributes
| This is the text found in the <tt>make menuconfig</tt> entry that controls the variable (<code>TMPFS_XATTR</code>) in the {{Path|.config}} file. It is essentially the variable name in a more human readable format.
|- 
| Depends on: TMPFS [=y]
| Before this entry can be seen <code>CONFIG_TMPFS</code> must be enabled. In this case it is already done (hence the [=y]) but if this is not the case, first look for (and enable) <code>CONFIG_TMPFS</code>.
|- 
| Location: ...
| This is the location in the <tt>make menuconfig</tt> structure where the setting can be found. Remember, the setting to look for is ''Tmpfs extended attributes''.
|- 
| Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
| If the settings described here are both enabled (in this case the first one is not), then <code>CONFIG_TMPFS_XATTR</code> will be automatically enabled and will not be possible to be ''disabled'' until one of these settings is de-selected.
|-
|}

With this information, it should be possible to translate any <code>CONFIG_*</code> requirements fairly easily. In short, it means a user must

# Enable the settings described in the ''Depends on'' field;
# Navigate where ''Location:'' points;
# Toggle the value referred to by ''Prompt:'';

== 기타 커널 설정 문서 ==

So far only general concepts and specific problems related to kernel configuration has been discussed; precise details have been left up to the user to discover. However, other parts of the Gentoo documentation collection provide specialized details for the topics at hand.

Such documents may be helpful while configuring specific areas of the kernel. Although this warning was mentioned previously in this guide, remember: users who are new to kernel configuration should not be adventurous when attempting to configure their kernels. Start by getting a basic system up and running, support for your audio, printing, etc., can always be added at a later date.

Getting the basics of a kernel operational will help users in later configuration steps because the user will know what is breaking their system and what is not. It is always wise to save the base (working) kernel configuration in a folder other than the kernel's sources folder ''before'' attempting to add new features or hardware.  

* The [[ALSA|ALSA article]] details the configuration options required for sound card support. Note that ALSA is an exception to the suggested scheme of not building things as modules: ALSA is actually much easier to configure when the components are modular.

* The [[Bluetooth|Bluetooth article]] details the options needed in order to use Bluetooth devices.

* The [[IPv6 router guide]] describes how to configure the kernel for routing using the next generation network addressing scheme.

* If the closed-source nVidia graphics drivers will be used for improved 3D graphics performance, the [[NVidia/nvidia-drivers|nVidia Guide]] lists the options that should and should not be selected on such a system.

* Amongst other things, the [[Power_management/Guide|Power Management guide]] explains how to configure the kernel for CPU frequency scaling, and for suspend and hibernate functionality.

* If running a PowerPC system, the [[PPC/FAQ|PPC FAQ]] has a few sections about PPC kernel configuration.

* The [[Printing|Printing guide]] lists the kernel options needed to support printing in Linux.

* The [[USB/Guide|USB Guide]] details the configuration settings required to use common USB devices such as keyboards, mice, storage devices, and USB printers.

== 문제 해결 ==

=== 바뀐 설정 적용 안됨 ===

It is very common for users to make a configuration change, but then make a small mistake in the process of actually booting to their newly configured kernel. They reboot into a kernel image that is not the one they just reconfigured, observe that whatever problem they were trying to solve is still present, and conclude that the configuration change does not solve the problem. 

The process of compiling and installing kernels is outside the scope of this document; refer to the [[Kernel/Upgrade|Kernel Upgrade Guide]] for general guidance. In short, the process to get a modified kernel is the following: 1) configure, 2) compile, 3) mount {{Path|/boot}} (if not already mounted), 4) copy new kernel image to {{Path|/boot}}, 5) Make sure the bootloader will reference the new kernel, 6) reboot. If one of those final stages has been missed, then the changes will not properly take effect.

It is possible to verify if the kernel that has booted matches the newly kernel compiled on the hard disk. This is performed by examining the date and time of the kernel's compilation. Assuming the system architecture is x86 and the kernel sources are installed at {{Path|/usr/src/linux}}, the following command can be used:

{{RootCmd|uname -v|output=<pre>
#4 SMP PREEMPT Sat Jul 15 08:49:26 BST 2006
</pre>}}

The above command will display the date and time the currently booted kernel was compiled.

{{RootCmd|ls -l /usr/src/linux/arch/i386/boot/bzImage|output=<pre>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
</pre>}}

The above command displays the date and time that the kernel image on the hard disk was last compiled.

If the time stamps from the above commands differ by more than 2 minutes, it indicates a mistake was made during kernel reinstallation and the system has not booted from the newly modified kernel image.

=== 모듈을 자동으로 불러오지 않음 ===

이 문서 앞에서 언급했듯이 커널 설정 시스템에서는 커널 구성 요소를 빌드시 포함(Y)이 아닌 모듈(M)로 설정했을 때, 상당한 양의 동작상 변화를 숨깁니다. 이 문제에 수많은 사용자들이 낚일 수 있기 때문에 다시 말씀드리는게 좋을거라 보고 있습니다.

커널에 포함하여 빌드하도록 구성 요소를 선택하면, 소스 코드를 커널 이미지(bzImage)에 넣어 빌드합니다. 커널에서 해당 구성 요소를 필요로 한다면, 사용자의 개입 과정 없이 자동으로 초기화한 후 불러옵니다. 

When selecting a component as a module, the code is built into a kernel module file and installed on the filesystem. In general, when the kernel needs to use that component, it will not be able to find it. With some exceptions, the kernel makes no effort to actually load these modules — this task is left up to the user. 

If building support for a network card as a module, and it is discovered the network is not accessible, it is probably because the module is not loaded — either this must be done manually or the system must be configured to autoload the module at boot time.

Unless a user has a reasons to do otherwise, some time can be saved by building these components directly into the kernel image, so that the kernel can automatically configure these small settings by itself. 

== 추가 참조 ==

* [[genkernel]] - 커널 및 initramfs 빌드 과정을 자동화할 때 쓰는 도구입니다.


[[Category:Server and Security]] {{Migrated|originalauthors=Daniel Drake, Curtis Napier, Justin Robinson, Lukasz Damentko, Jonathan Smith, nightmorph}}
