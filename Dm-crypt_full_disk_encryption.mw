{{InfoBox stack
|{{InfoBox homepage|https://gitlab.com/cryptsetup/cryptsetup|header=true}}
|{{InfoBox wikipedia|LUKS}}
}}

This article aims to get started with DM-Crypt LUKS to be able to install a new system from scratch, using Gentoo installation documents for example, and generate an [[initramfs]] with that in no time. For those new to this DM stands for Device-mapper, a kernel module for logical volume management. So this article will skip right away the premises on why to encrypt a system with DM-Crypt LUKS and on security insights. That said, encrypting a system with DM-Crypt LUKS will immediately put you in a position to choose between security versus usability, and secure versus system speed/responsiveness.

== Which cipher:hash combination? ==

The default cipher for LUKS is nowadays <code>aes-xts-plain64</code>, i.e. [[Wikipedia:Advanced Encryption Standard|AES]] as cipher and [[Wikipedia:Disk encryption theory|XTS]] as mode of operation. This should be changed only under very rare circumstances. The default is a very reasonable choice security wise and by far the best choice performance wise that can deliver between 2-3 GiB/s encryption/decryption speed on CPUs with [[Wikipedia:AES instruction set|AES-NI]] (for CPUs introduced around 2015). XTS uses two AES keys, hence possible key sizes are <code>-s 256</code> and <code>-s 512</code>.

Default choice of cipher and key size can be overriden by the command line parameters <code>-c</code> and <code>-s</code>, for example
{{RootCmd|cryptsetup luksFormat -c aes-xts-plain64 -s 512 ...|cryptsetup luksFormat -c aes-cbc-essiv:sha256 -s 256 ...}}

If you want to know more about the performance on a given set of cipher and mode of operation you can run <code>cryptsetup -c ... -s ... benchmark</code>. Issuing the command without <code>-c</code> and <code>-s</code> runs the benchmark for a number of different choices. For example, a (slightly shortened) output for a mid-2014 Intel Core i7 CPU might look like:
{{RootCmd|cryptsetup benchmark|output=<pre>
# Tests are approximate using memory only (no storage IO).
#  Algorithm | Key |  Encryption |  Decryption
     aes-cbc   256b   469.7 MiB/s  2093.2 MiB/s
 serpent-cbc   256b    85.3 MiB/s   523.3 MiB/s
 twofish-cbc   256b   173.4 MiB/s   340.2 MiB/s
     aes-xts   256b  2386.7 MiB/s  2387.4 MiB/s
 serpent-xts   256b   548.6 MiB/s   531.1 MiB/s
 twofish-xts   256b   320.0 MiB/s   342.3 MiB/s</pre>}}

{{Note|dm-crypt supports many different ciphers and modes of operation, some of which are considered not as secure as others (or worse, highly insecure, e.g. [[Wikipedia:Block cipher mode of operation#ECB|ECB]]). You can read more about cryptographic [[Wikipedia:Block cipher|ciphers]] and [[Wikipedia:Block cipher mode of operation|modes of operation]] elsewhere.}}

{{Note|Some cipher choices have an additional hash specification of the form <code>cipher:hash</code>, for example <code>aes-cbc-essiv:sha256</code>. Such a hash specification is used by <i>some</i> mode of operations (like <code>cbc-essiv</code>) for [[Wikipedia:Initialization vector|IV]] generation. Mode of operations with <code>plain64</code>, however, do not use such a supplied hash specification (for generating an IV). In this case the hash specification should be omitted.}}

== What choice of hash for key derivation? ==
LUKS uses [[Wikipedia:PBKDF2|PBKDF2]] for key derivation. In essence, the supplied passphrase by the user is combined with a salt and hashed a specified number of rounds. This [[Wikipedia:Key stretching|key stretching]] makes the password more secure against brute force attacks. The hash function used in PBKDF2 can be set via <code>-h</code> (the default is <code>sha256</code>). The total number of iterations is determined by the speed of the current hardware and can be influenced by setting the number of milliseconds that shall be spent in PBKDF2 passphrase processing by <code>--iter-time</code>. To increase the default from 2s to 3s and use sha512 one could for example use
{{RootCmd|cryptsetup luksFormat ... -h sha512 --iter-time 3000 ...}}

== On passphrases, detached LUKS headers, and (encrypted) keyfiles ==

A reasonably long passphrase (use, e.g., 8-12 common random words, see [https://xkcd.com/936/ xkcd] on that subject) in combination with PBKDF2 for key stretching can be considered a reasonably secure setup.

Additional protection against brute force attacks can be achieved by setting up a an external USB flash drive to store essential decryption information (like a keyfile, or the LUKS header itself). The flash drive then has the equivalent function of a physical key; opening the encrypted partition is only possible if both, flash drive and passphrase, are provided. However, this comes with a significant downside in terms of complexity, for example for setting up full disk encryption, or potential to loose decryption keys (by loosing the USB flash drive).

=== Detached LUKS header ===

It is possible to encrypt a partition with detached LUKS header (where all information about password derivation is stored) that is stored at (physically) different location, e.g., a USB flash drive. This leaves an attacker that is not in possession of the flash drive with no information about key derivation and encryption algorithms used. This makes brute force attacks potentially more difficult.

The following commands format create a detached header file <code>luks-header</code> while formatting a partition:

{{RootCmd|truncate -s 5M /path/to/luks-header|cryptsetup luksFormat ... --header /path/to/luks-header ...}}

In order to open the encrypted device

{{RootCmd|cryptsetup open ... --header /path/to/luks-header}}

See the cryptsetup man page for more details.

{{Note|A detached LUKS header is currently not supported by [[genkernel]].}}

=== Generating a GnuPG encrypted keyfile ===

The more traditional approach (that is also supported by [[genkernel]]) is to use a GnuPG encrypted keyfile (that contains sufficient entropy).
The following command create such a file and format an encrypted partition.
{{RootCmd|dd if{{=}}/dev/urandom count{{=}}48 {{!}} gpg --symmetric --cipher-algo aes --armor > /path/to/key.gpg|gpg --decrypt /path/to/key.gpg {{!}} cryptsetup luksFormat ...}}

In order to open the encrypted device

{{RootCmd|gpg --decrypt /path/to/key.gpg {{!}} cryptsetup open ...}}

== Preparing the disk(s) ==

{{Warning|This section contains factual wrong information pending an immediate rewrite [[User:Tamiko|Tamiko]] ([[User talk:Tamiko|talk]]) 06:33, 24 August 2016 (UTC)}} 

Preparing the disk(s) is the only thing that deviates from the official installation documents along with generating an initramfs. You may want to add a proper amount of entropy to new disks through some mechanism such as `cat /dev/random | wcs > /dev/XXX' or using other more usable methods be it ''secure erasing'' disks. The drawback is... a very long time to complete such a task.

A usable alternative and straight forward method is to set up DM-Crypt LUKS and then zero-ing the whole disk: e.g. after ''LUKS formating'' the disks run the following command.

{{RootCmd|dd if{{=}}/dev/zero of{{=}}/dev/mapper/root}}

Of course you have to replace ''root'' by the actual mapping name. This method will save several hours of secure erasing disks or dozen of hours to set up enough ''randomness'' or ''entropy''. This step might be necessary or even required depending on the ''plausible deniability'' requirements. Just make sure, afterwards, to not use specific block device commands like ''TRIM'' which will ''destroy'' this tedious effort. Anyway, nobody would ever want to do this with SSDs, so this is a non issue.

With the previous section, remains encrypting the physical devices. Before doing just that, one should consider the order of DM stack depending of using RAID, LVM or a modern file system that include ''both'' in the file system layer like [[ZFS]].

Using RAID and/or LVM together make it easier to only encrypt the resulting logical volume especially for RAID. If using LVM with fewer logical volume than the number of physical volume, it makes sense to crypt the logical volume. There's no practical advantages to use LUKS on the underlaying volumes of RAID arrays but to raise the complexity while lowing usability.

With a modern file system like ZFS, there's not choice but encrypt the physical volume or vdev in ZFS terms.

Before encrypting the devices, considering the {{Path|/boot}} partition should be taken into account as many bootloader does not support LUKS. [[GRUB2]] should support LUKS formated devices although I did not try to load kernel+initramfs yet. So some spare space should be allocated for `/boot' if necessary. 

GRUB2 also support ZFS so in that case, one could encrypt with '--align-payload 0 --header /dev/<removable_media>|/path/to/file', the whole disk, to set up a more secure setup and be able to claim the "plausible deniability" because nothing in the disk can prove that the disk is encrypted. This, however, require >=sys-fs/cryptsetup-1.4.0.

GnuPG crypted key file should be piped to cryptsetup with something like `gpg -qd /path/to/key |' while LUKS crypted key file via loop back device is given like a regular key file ({{Path|/dev/mapper/key.lbd}}) after decryption.

{{RootCmd|cryptsetup luksFormat /dev/sda -c aes-xts-plain64 -s 256}}

When done, creating logical volume if using LVM or adding the crypted cyphertext to a vdev can be done then.

== Generating an initramfs ==

After encrypting system or disk(s), one will need an initramfs so that rootfs can be mounted in there and then pass the control to real init. There are a few generic initramfs builder that can be used to accomplish the task such as [[dracut]], [[mkinitcpio]] (there's an ebuild ad thread in the forums) [https://github.com/tokiclover/mkinitramfs-ll sys-kernel/mkinitramfs-ll] or even {{Package|sys-kernel/genkernel}}[cryptsetup] (or the next variant) which has LUKS support.

=== Genkernel/Genkernel-next ===

To use {{Package|sys-kernel/genkernel}} or {{Package|sys-kernel/genkernel-next}}, edit {{Path|/etc/portage/package.use}} to enable the cryptsetup USE flag before emerging it.  The static USE flag may also be enabled on the {{Package|sys-fs/cryptsetup}} so that genkernel will use the system binaries (otherwise it will build its own private copy).  The following example will build only an initramfs (not an entire kernel) and enable support for luks. Even if you don't use lvm, `--lvm' option is required to include necessary udev rules.

{{RootCmd|genkernel --luks --lvm initramfs}}

The genkernel manpage outlines other options depending on system requirements.

The initrd will require parameters to tell it how to decrypt the drive, and they are supplied the same way as other kernel parameters.  For example:

{{FileBox|filename=grub.conf|1=
title Gentoo Linux 3.4.0-gentoo
root (hd0,0)
kernel /boot/kernel-3.4.0-gentoo crypt_root=UUID=<encrypted partition uuid> root=/dev/mapper/root
initrd /boot/initramfs-3.4.0-gentoo
}}

{{Note|Note TRIM support may be enabled if the encrypted device is capable (ie. SSD) with root_trim{{=}}yes but please read first about the security
implications of this outlined in the --allow-discards section of the [http://code.google.com/p/cryptsetup/wiki/Cryptsetup140# cryptsetup wiki].}}

Further information can be found in the [[genkernel|Genkernel Manual]].

=== Dracut ===

The {{Package|sys-kernel/dracut}} package was ported from the RedHat project and serves a similar tool for generating an initramfs. Since it is currently in ~arch for testing, users will need to edit {{Path|/etc/portage/package.accept_keywords}} to emerge it.  Before doing so, the variable DRACUT_MODULES="crypt" should be added to {{Path|/etc/portage/make.conf}}.  Other modules may be desired, please refer to [[Dracut]]. Generally, the following command will generate a usable default initramfs.

{{RootCmd|dracut -a crypt}}

The initrd will require parameters to tell it how to decrypt the drive, and they are supplied the same way as other kernel parameters.  For example:

{{FileBox|filename=grub.conf|1=
title Gentoo Linux 3.4.0-gentoo
root (hd0,0)
kernel /boot/kernel-3.4.0-gentoo root=UUID=<root filesystem uuid> rd.luks.uuid=<encrypted partition uuid>
initrd /boot/initramfs-3.4.0-gentoo.img
}}
{{Note|Dracut will match UUIDs that are not complete as long as they are not ambiguous, so it is possible to only enter the first stanza for brevity/clarity desired}}
{{Note|Note TRIM support may be enabled if the encrypted device is capable (ie. SSD) with rd.luks.allow-discards but please read first about the security
implications of this outlined in the --allow-discards section of the [http://code.google.com/p/cryptsetup/wiki/Cryptsetup140# cryptsetup wiki].}}

For a comprehensive list of luks options within dracut please see the section in the [https://www.kernel.org/pub/linux/utils/boot/dracut/dracut.html#_crypto_luks Dracut Manual].

=== Mkinitramfs-LL ===

The unofficial [https://github.com/tokiclover/mkinitramfs-ll sys-kernel/mkinitramfs-ll] (found in [https://github.com/tokiclover/bar-overlay tokiclover's bar-overlay]) is a lightweight and modular variant of the previous well known initramfs generating tools which comes with udev free dependency. It depends only on [[busybox]] with [[mdev]] by default and depends on extra packages for additional functionalities. So, nor bash, coreutils nor util-linux is bundled into the initramfs.
Extra flexibilities are offered as well, like the possibility to have DM-Crypt LUKS on top of [[LVM]] or vice versa, [[btrfs]] or [[ZFS]] on top of DM-Crypt LUKS, DM-Crypt LUKS on top of RAID, detached header (to a device or a file) for dm-crypt LUKS et al.

{{RootCmd|mkinitramfs-ll --luks --lvm --firmware{{=}}iwlwifi-5000}}

Use the following GRUB2 configuration excerpt to get going for LVM/LUKS and regular key file on a removable device setup.

{{FileBox|filename=/etc/default/grub|<pre>
...
GRUB_CMDLINE_LINUX="root=<VG-LV> luks=reg:LABEL=PENDRIVE:/key.reg lvm=<MAPPING>-UUID=<uuid>"
...</pre>}}

{{Note|
There is an optional environment variable in the configuration file (mkinitramfs-ll.conf) to set environment variables that have the same effect as the the kernel command line arguments that let boot with a kernel cmdline free kernel. This ''default'' cmdline (as environment variables), however, can be disabled at run time if necessary by appending ''env{{=}}No'' cmdline argument.
}}

=== Custom ===

Now, with a complicated setup one could have to build his/her own to satisfy specific requirements. This where modular or advanced initramfs package shine such as [https://github.com/tokiclover/mkinitramfs-ll mkinitramfs-ll] dracut or mkinitcpio.

The following is a simple script that will build an initramfs with LUKS support for the running kernel or for the kernel version passed as argument 1. Be careful as this will build the initramfs image and copy it into {{Path|/boot}} so you need to have that mounted (and if you have an existing initramfs for this kernel, it might get overwritten).
{{FileBox|filename=mkinitramfs.bash|lang=bash|<nowiki>
#!/bin/bash
kv=${1:-$(uname -r)}
arc=$(getconf LONG_BIT)

mkdir -p initramfs-$kv && pushd initramfs-$kv
mkdir -p {usr/,}{{,s}bin,lib$arc} dev proc sys newroot mnt/tok
ln -s lib{$arc,}
pushd usr && ln -s lib{$arc,} && popd
mkdir -p usr/share/{consolefonts,keymap}

mknod -m 600 dev/console c 5 1
mknod -m 666 dev/urandom c 1 9
mknod -m 666 dev/random  c 1 8
mknod -m 640 dev/mem     c 1 1
mknod -m 666 dev/null    c 1 3
mknod -m 666 dev/tty     c 5 0
mknod -m 666 dev/zero    c 1 5
mknod -m 640 dev/tty1    c 4 1

[[ $(echo "$kv" | cut -d'.' -f1 ) -eq 3 ]] &&
    [[ $(echo "$kv" | cut -d'.' -f2) -ge 1 ]] &&
    mknod -m 600 dev/loop-control c 10 237

cp $(which busybox) bin/busybox || exit
cp ../init . && chmod 755 init || exit

# this is handy for password
keymap="${2:-$(sed -nre 's,^keymap="([a-zA-Z].*)",\1,p' /etc/conf.d/keymaps)}"
[[ $keymap ]] && loadkeys -b -u $keymap >usr/share/keymaps/${keymap}-$(uname -m).bin

consolefont="${3:-$(sed -nre 's,^consolefont="([a-zA-Z].*)",\1,p' /etc/conf.d/consolefont)}"
[[ $consolefont ]] && pushd usr/share/consolefonts &&
cp /usr/share/consolefonts/${consolefont}*.gz . &&
gzip -d ${consolefont}*.gz && popd

cp $(which cryptsetup) sbin || exit
cp $(which lvm.static) sbin/lvm && lvm=lvm

function docp()
{
	local link=${1} prefix
	[[ -n ${link} ]] || return
	cp -a {,.}${link}

	[[ -h ${link} ]] &&
	while true; do
	    prefix=${link%/*}
		link=$(readlink ${link})
		[[ ${link%/*} == ${link} ]] && link=${prefix}/${link}
		cp -a {,.}${link} || die
		[[ -h ${link} ]] || break
	done

	return 0
}

for bin in busybox cryptsetup $lvm; do
    ldd $bin >/dev/null || continue
    for lib in $(ldd $bin  | sed -nre 's,.* (/.*lib.*/.*.so.*) .*,\1,p' \      
        -e 's,.*(/lib.*/ld.*.so.*) .*,\1,p')
    do
        mkdir -p ${lib%/*} && docp {,.}$lib
    done
done

mount /boot
find . -print0 | cpio --null -ov --format=newc | xz -9 --check=crc32 > /boot/initramfs-$kv.cpio.xz

popd
unset -v arc consolefont kv keymap
</nowiki>}}

And the following is a simple init script which will mount rootfs in initramfs environment. The following script and the previous are adapted from mkinitramfs-ll.

{{FileBox|filename=init|lang=bash|<nowiki>
#!/bin/sh
export PATH=/bin:/sbin:/usr/bin:/usr/sbin
export init=/sbin/init newroot=/newroot sh=/bin/sh

rescueshell() {
    export PS1='rsh:$(tty | cut -c6-):$PWD # '
    if which setsid &>/dev/null; then setsid $sh -i 0<$console 1>$console 2>&1
    else $sh -i 0<$console 1>$console 2>&1; fi
}

die() {
    echo -ne "Dropping into a rescueshell..."
    echo -ne "$@"
    rescueshell || exec $sh -i
}

getdev() {
    echo $(blkid | grep $1 | cut -d: -f1)
}

for arg in $(cat /proc/cmdline); do                                             
    case $arg in                                                                
        rescue*) export rescue=1;;                                            
        ro|rw) export mtopt=$arg;;                        
        single) export level=2;;
        console*|font*|init*|keyfile*|keymap*|lvm*|root*) export $arg;;                                           
     esac                                                                       
done

[ $keymap ] && loadkmap </usr/share/keymaps/$keymap
[ $font ] && loadfont </usr/share/consolefont/$font

umask 0077
mount -t proc proc /proc
mount -t sysfs sysfs /sys
if grep devtmpfs /proc/filesystems &>/dev/null; then
    mount -t devtmpfs devtmpfs /dev
else mount -t tmpfs tmpfs /dev; fi
mdev -s
echo /sbin/mdev > /proc/sys/kernel/hotplug

[ -h /dev/fd     ] || ln -fs /proc/self/fd   /dev/fd
[ -n /dev/stderr ] || ln -fs /proc/self/fd/2 /dev/stderr
[ -n /dev/stdin  ] || ln -fs /proc/self/fd/0 /dev/stdin
[ -n /dev/stdout ] || ln -fs /proc/self/fd/1 /dev/stdout
:   ${console:=/dev/console}
exec 0<$console 1>$console 2>&1

if [ $keyfile ]; then
    dev=$(echo $keyfile | cut -d: -f1)
    key=$(echo $keyfile | cut -d: -f2)
    dev=$(getdev $dev)
    mount $dev /mnt/tok || die
fi

root=$(getdev $root)
[ $root ] || die
cryptsetup open $root root ${key:+-d $key} && root=/dev/mapper/root || die

if [ $lvm ]; then
    # lvm cmdline argument is passed as <vg-lv>, standard way
    lvm vgscan ${lvm%-*}
    lvm vgchange -ay ${lvm%-*} && root=/dev/mapper/$lvm || die
fi

mount $root $newroot

umount -l /mnt/tok
umount /sys
umount /dev
umount /proc

exec switch_root $newroot ${init:-/sbin/init} $level
</nowiki>}}
{{Note|Note that, LVM is optional, just omit the cmdline argument to remove LVM support.}}

See [https://github.com/tokiclover/mkinitramfs-ll/blob/master/init mkintramfs-ll/init] for a fully featured init script.

Notice that the previous ''init'' script support LABEL UUID and raw block device name sd[a-z][0-9] with or without the ''/dev/'' prefix. One can even provide part of a LABEL or UUID, ''getdev()'' will just return the block device rightly.

Finally, you need to tweak the bootloader to use the initramfs - e.g. for Grub, something like this should work.

{{FileBox|filename=grub.conf|<pre>
title Gentoo Linux 3.4.0-gentoo
root (hd0,0)
kernel /boot/kernel-3.4.0-gentoo root=UUID<uuid> lvm=<VG-LV> keyfile=LABEL=PENDRIVE:/key
initrd /boot/initramfs-3.4.0-gentoo.cpio.xz
</pre>}}

{{Note|While playing with the initramfs (finding out what needs to be done in the init script), I do recommend to disable automatic start of X Window. It may happen that some of the devices won't work under X (e.g. keyboard and mouse), thus making you stuck on login screen. The chance of this happening in the console is much lower, and you can always start X with something like 'sleep 30; /etc/init.d/xdm' stop in another console.}}

[[Category:Core system]]
