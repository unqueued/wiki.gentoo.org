{{InfoBox stack
|{{InfoBox homepage|https://www.gnu.org/software/bash/|header=true}}
|{{InfoBox package|app-shells/bash}}
|{{InfoBox wikipedia|Bash_(Unix_shell)}}
}}

'''GNU Bash''' ('''B'''ourne-'''a'''gain '''sh'''ell) is [[Article description::the default shell on Gentoo systems and a popular [[shell]] program found on many Linux systems.]]

== Installation ==

{{c|bash}} is part of the [[System set (Portage)|''@system'' set]] and comes installed on every Gentoo system. It is also used by [[Portage]], Gentoo's default package manager. It is ''highly recommended'' to not uninstall {{c|bash}} (or any other package in the @system set), even if another shell is used as a login-shell.

=== USE flags ===

It is possible to change USE flags:

{{USEflag|package=app-shells/bash}}

After making USE modifications, ask Portage to update the system so the changes take effect:

{{Emerge|params+=--changed-use --deep|@world}}

== Configuration ==

=== Login shell ===

The default login shell for a user is defined in the {{Path|/etc/passwd}} file. The login shell can be changed using the {{c|chsh}} utility, which is part of {{Package|sys-apps/coreutils}} package.

=== Files ===

Many settings on how the shell behaves, can be defined via variables. Those variables are defined in several different configuration files, where the settings in the last file parsed do overwrite previous definitions.

* {{Path|/etc/profile}} - Initial settings for all users.
* {{Path|/home/USER/.bash_profile}} - Settings for this user.
* {{Path|/home/USER/.bash_login}} - Settings for this user, if {{Path|/home/USER/.bash_profile}} doesn't exist
* {{Path|/home/USER/.profile}} - Settings for this user, if {{Path|/home/USER/.bash_profile}} and {{Path|/home/USER/.bash_login}} does not exist.

If the shell is started without login (e.g. in a terminal on a desktop), the following files are used:

* {{Path|/etc/bashrc}} - Initial settings for all users.
* {{Path|/home/USER/.bashrc}} - Settings for this user.

In Gentoo, and many other Linux distributions, the {{Path|/etc/bashrc}} file is parsed in {{Path|/etc/profile}} to ensure that {{Path|/etc/bashrc}} and {{Path|/home/USER/.bashrc}} are always checked when someone logs into the system. The final settings are defined by the user in their personal {{Path|.bashrc}} file.

==== .bashrc ====

{{FileBox|filename=~/.bashrc|lang=bash|
# configure PS1 command prompt
PS1{{=}}'\u@\h \w \$ '

# no double entries in the shell history
export HISTCONTROL{{=}}"$HISTCONTROL erasedups:ignoreboth"

# do not overwrite files when redirecting output by default.
set -o noclobber

# wrap these commands for interactive use to avoid accidental overwrites.
rm() { command rm -i "$@"; }
cp() { command cp -i "$@"; }
mv() { command mv -i "$@"; }
}}

=== Tab completion ===

The {{Package|app-shells/bash-completion}} package adds completion to many programs and their parameters. To enable completion, just merge the package. No special use flags for packages, which support completion, are required.

{{Emerge|app-shells/bash-completion}}

Bash completion for all supported programs is enabled by default<ref>[https://www.gentoo.org/support/news-items/2014-11-25-bash-completion-2_1-r90.html News Items - bash-completion-2.1-r90], November 25th, 2014. Retrieved on May 13th, 2017.</ref>. You can view the available completions with {{cmd|eselect bashcomp list}} and disable specific completions with {{cmd|eselect bashcomp disable <command-name>}}

== Usage ==

=== Environment variables ===

See all variables for the current shell process which have the export attribute set:

{{Cmd|export}}

Of course, users can export their own variables, which are available to the current process and inherited by child processes:

{{Cmd|export MYSTUFF{{=}}Hello}}

Environment variables can also be localized to an individual child process by prepending an assignment list to a simple command. The resulting environment passed to <code>execve()</code> will be the union of the assignment list with the environment of the calling shell process:

{{Cmd|USE{{=}}kde emerge -pv libreoffice}}

To check the value of a variable:

{{Cmd|typeset -p MYSTUFF}}

=== PS1 ===

The special shell variable named <var>PS1</var> defines what the terminal prompt looks like:

{{CodeBox|title=Example prompt|MyUserName@MyPC: ~ $}}

{{Note|The <code>~</code> (tilde) symbol represents the current user's home directory (also represented by the <var>HOME</var> environment variable in bash).}}

This prompt would be the following value for the <var>PS1</var> variable:

{{CodeBox|title=<var>PS1</var> definition|lang=bash|
PS1{{=}}"\u@\h \w $ "
}}

The following table lists the possible placeholders that can be used in the <var>PS1</var> variable:

{| class="table table-striped table-condensed"
|- 
! Code
! Effect
|-
| <code>\u</code>
| Username.
|-
| <code>\h</code>
| Hostname.
|-
| <code>\w</code>
| Current directory.
|-
| <code>\d</code>
| Current date.
|-
| <code>\t</code>
| Current time.
|-
| <code>\$</code>
| Indicate the root user with '#' and normal users with '$'.
|-
| <code>\j</code>
| Number of currently running tasks (jobs).
|}

You can also put complete commands into your prompt using a command substitution. Here we want to execute {{c|cut -d\  -f1 /proc/loadavg}} to show the one-minute load average at the beginning of the prompt:

{{CodeBox|title=<var>PS1</var> definition|lang=bash|
PS1{{=}}"\$(cut -d\  -f1 /proc/loadavg) $ "
}}

Looks like:

{{CodeBox|title=Prompt|1=0.10 $ }}

Having colors in the prompt:

{{CodeBox|title=<var>PS1</var> definition|lang=bash|
PS1{{=}}"\e[0;32m\]\u@\h \w >\e[0m\] "
}}

The <code>\e[0;32m\]</code> changes the color for every next output, we have to put <code>\e[0m\]</code> at the end of our variable to reset the color, or we would type everything in green.

Color codes:

{| class="table table-striped table-condensed"
|-
! Code
! Color
|-
| <code>\e[0;30m\]</code>
| Black
|-
| <code>\e[0;31m\]</code>
| Red
|-
| <code>\e[0;32m\]</code>
| Green
|-
| <code>\e[0;33m\]</code>
| Yellow
|-
| <code>\e[0;34m\]</code>
| Blue
|-
| <code>\e[0;35m\]</code>
| Magenta
|-
| <code>\e[0;36m\]</code>
| Cyan
|-
| <code>\e[0;37m\]</code>
| White
|-
| <code>\e[0m\]</code>
| Reset to standard colors
|}

The <code>0;</code> in <code>\e[0;31m\]</code> means foreground. You can define other values like <code>1;</code> for foreground bold and <code>4;</code> for foreground underlined. Omit this number to refer to the background, e.g. <code>\e[31m\]</code>.

=== set ===

The set command is used to display and change settings in the bash shell.

Show all current settings:

{{Cmd|set -o}}

Disable the shell history:

{{Cmd|set +o history}}

Enable the shell history:

{{Cmd|set -o history}}

=== alias ===

You can use the {{c|alias}} builtin to define a new command or redefine an existing command:

{{Cmd|alias ll{{=}}'ls -l'}}

Whenever now {{c|ll}} (two lowercase Ls) is send to the shell, it will actually execute {{c|ls -l}}.

To remove an alias:

{{Cmd|unalias ll}}

{{Note|No harm is done to the actual command being redefined.}}

If you want to temporarily bypass an alias you can escape the first letter of the command with a backslash character:

{{Cmd|\ls}}

=== history ===

The history of used commands in a session is written to a file in the user's home directory. The easiest way to access the commands in the history is using the {{Key|Up}} and {{Key|Down}} keys.

To show all commands in the current history:

{{Cmd|history}}

To search for commands in the history, by piping the output through {{c|grep}} and filter for words:

{{Cmd|<nowiki>history | grep echo</nowiki>}}

The commands are numbered and can be executed using their index:

{{Cmd|!2}}

To execute the last command used:

{{Cmd|!!}}

Delete every command in the history:

{{Cmd|history -c}}

Show the current settings for history:

{{Cmd|echo $HISTCONTROL}}

=== Keyboard shortcuts ===

bash includes two different keyboard shortcuts modes to make editing input on the command-line easier: emacs mode and vi mode. bash defaults to emacs mode. 

==== vi mode ====

vi mode requires an {{Key|Esc}} key press to prefix very movement or edit, so it can be a bit awkward to learn this mode. To change the mode to vi mode, execute the following command:

{{Cmd|set -o vi}}

Review this bash [http://www.catonmat.net/download/bash-vi-editing-mode-cheat-sheet.pdf vi editing mode cheat sheet] document by Peteris Krumins for more details on key bindings in vim mode.

==== emacs mode ====

To switch to emacs mode (which is the default mode):

{{Cmd|set -o emacs}}

Movement:

; {{Key|Ctrl}}+{{Key|a}} : Move the cursor to the beginning of the line (Home).
; {{Key|Ctrl}}+{{Key|e}} : Move the cursor to the end of the line (End).
; {{Key|Ctrl}}+{{Key|f}} : Move the cursor forward one character.
; {{Key|Ctrl}}+{{Key|b}} : Move the cursor back one character.
; {{Key|Ctrl}}+{{Key|xx}} : Toggle the cursor between the current position and the beginning of the line.

Screen control:

; {{Key|Ctrl}}+{{Key|S}} : Stop (pause) output on the screen.
; {{Key|Ctrl}}+{{Key|Q}} : Resume output on the screen (after stopping it with the previous command).
; {{Key|Ctrl}}+{{Key|L}} : Clears the screen (very similar to the {{c|clear}} command).

== Scripts ==

Shell scripts are text files which contain programs written in a certain shell scripting language. Which shell is used to interpret the commands in a script is defined in the first line (which is called the shebang):

{{FileBox|filename=myscript|lang=bash|
#!/bin/bash
echo 'Hello World!'
}}

If no shell is defined the default shell for the user who executes the script is used. Often {{Path|/bin/sh}} is used, which is the father of all shells and has very limited functionalities. Nearly all shells available understand commands used when running {{Path|/bin/sh}}, so those scripts are highly portable.

{{Note|On many distributions {{Path|/bin/sh}} is a symbolic link to {{Path|/bin/bash}}. But on other distributions (like Debian) it can be a symbolic link to {{Path|/bin/dash}}, which is a POSIX compliant variant of {{c|sh}}. In order to insure a good portability, be sure to test any script using the same shell than the one used in its shebang.}}

=== Start scripts ===

To run scripts directly from the command-line, they need to be executable. To make a shell script executable:

{{Cmd|chmod +x myscript}}

Now the script can be executed by using the {{c|./}} prefix, where either the shell defined by the shebang in the script or the default shell of the user is used:

{{Cmd|./myscript}}

=== Redirection ===

In Bash it is possible to redirect the output of one program into the input of another program using a pipe, indicated by the <code>|</code> symbol. This enables users to create command chains. Here is an example to redirect the output of {{c|ls -l}} into the program {{Path|/usr/bin/less}}:

{{Cmd|ls -l {{!}} less}}

To redirect output into a file:

{{Cmd|ls -l > ls_l.txt}}

The <code>></code> operator will erase any previous content before adding new one. If this is not desired, use the <code>>></code> (append) operator instead.

=== Logical operators ===

Logical operators are very useful to chain commands together. This is helpful when checking if the previous command finished successfully or not.

<code>&&</code> (AND) - The following command prints 'Success' only if our test script is successful:

{{Cmd|./myscript && echo 'Success'}}

<code>||</code> (OR) - The following command prints 'Failure' only if our test script is unsuccessful: 

{{Cmd|./myscript {{!}}{{!}} echo 'Failure'}}

=== Jobs ===

Usually if we start a script or command, the input is blocked until the command is finished. To start a program directly in the background, so we can continue to work in the shell:

{{Cmd|./myscript &}}

This will execute the script as '''job''' number 1 and the prompt expects the next input.

If a program is already running and you need to do something on the shell, it is possible to move programs from ''foreground'' to ''background'' and vice versa. To get a command prompt if a command is running on the shell, put it into ''sleep'' using {{Key|Ctrl}}+{{Key|Z}}, then move it to the background:

{{Cmd|bg %1}}

To list all jobs running in the background:

{{Cmd|jobs}}

To move a job back to foreground:

{{Cmd|fg %1}}

{{Note|Programs running as jobs usually do not terminate once they finish execution, there will be a message if a job finished and bringing it to foreground will then terminate the program.}}

=== Command substitution ===

Using a command substitution, it is possible to run programs as parameters of other commands like here:

{{Cmd|emerge $(qlist -CI x11-drivers)}}

This will first execute the command in the brackets and append the output as parameter of emerge.

{{Note|This command is quite useful in Gentoo to quickly rebuild all X11 drivers.}}

More substitutions can be performed in one command like this:

{{Cmd|emerge $(qlist -CI x11-drivers) $(qlist -CI modules)}}

== See also ==

* [[shell]] - A command-line interpreter.
* {{c|[[dash]]}} - The '''D'''ebian '''A'''lmquist '''Sh'''ell.

== External resources ==

* [http://devmanual.gentoo.org/tools-reference/bash/index.html Bash reference] from the Gentoo Developer's Handbook.
* [http://tldp.org/LDP/abs/html/ Advanced Bash-Scripting Guide]
* [http://tiswww.case.edu/php/chet/bash/bashtop.html Chet's Bash page]
* Official [http://www.gnu.org/software/bash/manual/bash.html Bash documentation]
* The [http://mywiki.wooledge.org/BashFAQ Bash FAQ] and [http://mywiki.wooledge.org/BashGuide Bash guide] on Greg Wooledge's wiki
* [http://wiki.bash-hackers.org bash-hackers] wiki (very good reference)
* [http://git.savannah.gnu.org/cgit/bash.git Bash cgit]
* [http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html POSIX sh] spec
* [https://www.mirbsd.org/man/mksh.1 mksh], [http://www2.research.att.com/sw/download/man/man1/ksh.html ksh93], and [http://www2.research.att.com/sw/download/man/man1/ksh88.html ksh88] manuals for cross-reference
* [http://linuxtutorial.todolistme.net Comprehensive Beginner Linux Tutorial]

== References ==

{{reflist}}

[[Category:Shell]]
