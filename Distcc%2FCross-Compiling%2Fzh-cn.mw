<languages />


{{Metadata|abstract=本文向你展示如何配置distcc在不同的处理器架构之间进行交叉编译。}}

本文向你展示如何配置distcc在不同的处理器架构之间进行交叉编译。

== 使用distcc进行交叉编译 ==

=== 介绍 ===

<code>distcc</code>是一个工具，能让你在网络中的多台机器共同编译软件。只要在网络中的机器使用相同的工具链为相同的处理器架构编译，就不需要特殊的<code>distcc</code>配置。但是如果你想用不同的机器为不同的架构进行编译呢？这篇指南将向你展示如何配置<code>distcc</code>来为不同的架构进行编译。 

=== 安装必要的工具 ===

首先，你需要在所有的参与编译的机器上安装<code>crossdev</code>。<code>crossdev</code>是一个能够让简化跨架构工具链编译的工具。最初由Joshua Kinard编写，后来Mike Frysinger进行了完全的重写。它的使用非常的直观：<code>crossdev -t sparc</code>将为Sparc架构编译完整的交叉工具链。这包含binutils，gcc，glibc和linux-headers。如果你需要帮助，尝试运行<code>crossdev --help</code>。很明显，你要要在所有帮助编译的机器上安装合适的交叉工具链。 

然后，你需要在所有参与交叉编译的机器上安装<code>distcc</code>。这些机器包括将运行emerge的机器和进行交叉变异的机器。更多的关于配置和使用<code>distcc</code> 的信息请参考[http://www.gentoo.org//doc/en/distcc.xml Gentoo Distcc Documentation]。

=== 架构相关说明 ===

==== Intel x86 subarchitectures ====

如果你要在不同的intel x86子架构（例如i586和i686）上进行交叉编译，你仍然必须为目标CHOST编译完整的交叉工具链，否则编译会失败。这是因为i586和i686实际上是不同的CHOST，尽管它们都被认为是“x86”。当你建立交叉工具链的时候请谨记这一点。例如，如果目标机器是i586，这意味着你必须在i686机器上建立i586的交叉编译链。 

==== SPARC ====

Using <code>crossdev -t sparc</code> might fail with one of the following errors:

{{Code|Errors displayed when running crossdev -t sparc|<pre>
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
</pre>}}

If this happens, try using the following command instead:

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== Configuring distcc to cross-compile correctly ===

In the default distcc setup, cross-compiling will ''not'' work properly. The problem is that many builds just call <code>gcc</code> instead of the full compiler name (e.g. <code>sparc-unknown-linux-gnu-gcc</code> ). When this compile gets distributed to a distcc helper box, the native compiler gets called instead of your shiny new cross-compiler. 

Fortunately, there is a workaround for this little problem. All it takes is a wrapper script and a few symlinks on the box that will be running <code>emerge</code> . I'll use my Sparc box as an example. Wherever you see <code>sparc-unknown-linux-gnu</code> below, you will want to insert your own CHOST ( <code>x86_64-pc-linux-gnu</code> for an AMD64 box, for example). When you first emerge distcc, the {{Path|/usr/lib/distcc/bin}} directory looks like this: 

{{Note|The following instructions are to be performed only on the box running the emerge. Do not perform these steps on the helper boxes.}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

Here is what you want to do: 

{{RootCmd|rm c++ g++ gcc cc}}

Next, we'll create the new script on this box. Fire up your favorite editor and create a file with the following text in it, then save it as {{Path|sparc-unknown-linux-gnu-wrapper}} . Remember to change the CHOST (in this case, <code>sparc-unknown-linux-gnu</code> ) to the actual CHOST of the box that will be running the emerge. 

{{Code|The new wrapper script|<pre>
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
</pre>
}}

Next, we'll make the script executable and create the proper symlinks: 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

When you're done, {{Path|/usr/lib/distcc/bin}} will look like this: 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

Congratulations; you now have a (hopefully) working cross-distcc setup. 

=== How this works ===

When <code>distcc</code> is called, it checks to see what it was called as (e.g. <code>i686-pc-linux-gnu-gcc</code> , <code>sparc-unknown-linux-gnu-g++</code> , etc.) When distcc then distributes the compile to a helper box, it passes along the name it was called as. The distcc daemon on the other helper box then looks for a binary with that same name. If it sees just <code>gcc</code> , it will look for <code>gcc</code> , which is likely to be the native compiler on the helper box, if it is not the same architecture as the box running <code>emerge</code> . When the ''full'' name of the compiler is sent (e.g. <code>sparc-unknown-linux-gnu-gcc</code> ), there is no confusion. 

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* Andrew Gaffney
* Joshua Saddler
