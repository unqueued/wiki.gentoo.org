<languages />


{{Metadata|abstract=本文向你展示如何配置distcc在不同的处理器架构之间进行交叉编译。}}

本文向你展示如何配置distcc在不同的处理器架构之间进行交叉编译。

== 使用distcc进行交叉编译 ==

=== 介绍 ===

<code>distcc</code>是一个工具，能让你在网络中的多台机器共同编译软件。只要在网络中的机器使用相同的工具链为相同的处理器架构编译，就不需要特殊的<code>distcc</code>配置。但是如果你想用不同的机器为不同的架构进行编译呢？这篇指南将向你展示如何配置<code>distcc</code>来为不同的架构进行编译。 

=== 安装必要的工具 ===

首先，你需要在所有的参与编译的机器上安装<code>crossdev</code>。<code>crossdev</code>是一个能够让简化跨架构工具链编译的工具。最初由Joshua Kinard编写，后来Mike Frysinger进行了完全的重写。它的使用非常的直观：<code>crossdev -t sparc</code>将为Sparc架构编译完整的交叉工具链。这包含binutils，gcc，glibc和linux-headers。如果你需要帮助，尝试运行<code>crossdev --help</code>。很明显，你要要在所有帮助编译的机器上安装合适的交叉工具链。

If you want to fine tune the cross-toolchain, here is a script that will produce a command line with the exact versions of the cross development packages to be built on the helper boxes (the script is to be run on the target box).

{{Code|Script to fine-tune cross development tools|<pre>
#! /bin/bash
A="sys-devel/binutils" ; B=`equery l $A` ; BINUTILS_VER=`echo $B | cut -d- -f3-`
A=`/usr/bin/gcc-config -c` ; B=`echo $A | cut -d- -f5` ; GCC_VER=`equery l sys-devel/gcc | grep $B | cut -d- -f3-`
KERNEL_VER=`uname -r | sed s/-gentoo//`
A="sys-libs/glibc" ; B=`equery l $A` ; LIBC_VER=`echo $B | cut -d- -f3-`
echo "crossdev --b =$BINUTILS_VER --g =$GCC_VER --k =$KERNEL_VER --l =$LIBC_VER -t `uname -m`"
</pre>}}

然后，你需要在所有参与交叉编译的机器上安装<code>distcc</code>。这些机器包括将运行emerge的机器和进行交叉编译的机器。更多的关于配置和使用<code>distcc</code> 的信息请参考[http://www.gentoo.org//doc/en/distcc.xml Gentoo Distcc Documentation]。

=== 架构相关说明 ===

==== Intel x86 subarchitectures ====

如果你要在不同的intel x86子架构（例如i586和i686）上进行交叉编译，你仍然必须为目标CHOST编译完整的交叉工具链，否则编译会失败。这是因为i586和i686实际上是不同的CHOST，尽管它们都被认为是“x86”。当你建立交叉工具链的时候请谨记这一点。例如，如果目标机器是i586，这意味着你必须在i686机器上建立i586的交叉编译链。 

==== SPARC ====

使用<code>crossdev -t sparc</code>也许会失败，伴随如下错误：

{{Code|运行crossdev -t sparc时出现的错误|<pre>
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
</pre>}}

如果发生上述错误，尝试使用下面的命令：

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== 配置distcc以便正确的交叉编译 ===

使用默认的distcc配置，交叉编译“不”会正常工作。这是因为很多编译仅仅调用<code>gcc</code>而不是编译器的全名（例如<code>sparc-unknown-linux-gnu-gcc</code>）。当这一编译被分发到帮助交叉编译的机器上时，原生的编译器被调用，而非你新安装的交叉编译器。 

Fortunately, there is a workaround for this little problem. All it takes is a wrapper script and a few symlinks on the box that will be running <code>emerge</code>. We'll use a Sparc box as an example. Wherever you see <code>sparc-unknown-linux-gnu</code> below, you will want to insert your own CHOST (<code>x86_64-pc-linux-gnu</code> for an AMD64 box, for example). When you first emerge distcc, the {{Path|/usr/lib/distcc/bin}} directory looks like this: 

{{Note/zh-cn|下面的操作只需要在运行emerge的机器上执行，不要在帮助交叉编译的机器上运行。}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

这里你需要做： 

{{RootCmd|rm c++ g++ gcc cc}}

然后，你要在这台机器上创建一个新的脚本。打开你喜欢的文本编辑器，创建一个文件，内容如下。然后保存到{{Path|sparc-unknown-linux-gnu-wrapper}}。记住替换CHOST（这里是<code>sparc-unknown-linux-gnu</code>）成你要运行emerge的机器的实际的CHOST。 

{{Code|The new wrapper script|<pre>
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
</pre>
}}

接下来，将此脚本设置为可执行，并创建适当的符号链接： 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

当你完成以后，{{Path|/usr/lib/distcc/bin}}看起来像这样： 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

Next we want to make sure that these wrappers stay available after upgrading the distcc package as it will overwrite the symbolic links. We can do this through a {{Path|/etc/portage/bashrc}} file that looks like so:

{{Code|/etc/portage/bashrc|<pre>
case ${CATEGORY}/${PN} in
	sys-devel/distcc)
		# Hey man, how come that CONFIG PROTECT don't work?
		if [ "${EBUILD_PHASE}" == "postinst" ] || [ "${EBUILD_PHASE}" == "postrm" ];
		then
			cd /usr/lib/distcc/bin
			rm cc c++ gcc g++
			ln -s sparc-unknown-linux-gnu-wrapper cc
			ln -s sparc-unknown-linux-gnu-wrapper c++
			ln -s sparc-unknown-linux-gnu-wrapper gcc
			ln -s sparc-unknown-linux-gnu-wrapper g++
		fi
	;;
esac</pre>
}}

恭喜，你已经有一个可以工作的distcc配置了（希望如此）。

=== 这是如何工作的 ===

当<code>distcc</code>被调用的时候，它会检查自己是以何种方式被调用的（例如<code>i686-pc-linux-gnu-gcc</code>，<code>sparc-unknown-linux-gnu-g++</code>等等）。当distcc把编译工作分发到帮助交叉编译的机器上的时候，它会把调用方式一起分发。在帮助交叉编译的机器上，distcc的守护进程会去寻找有相同名字的程序。如果它看到的仅仅是<code>gcc</code>，它就会去找<code>gcc</code>，如果帮助交叉编译的机器架构跟运行<code>emerge</code>的机器不一致，distcc的守护进程找到的gcc很可能是这台机器上的原生的的编译器。如果发送的是编译器的“全名”（例如<code>sparc-unknown-linux-gnu-gcc</code>），就不会出现混淆。

== 感谢 ==

感谢下面的作者和编辑对这篇指南的贡献：

* Andrew Gaffney
* Joshua Saddler
