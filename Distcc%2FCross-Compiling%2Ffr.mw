<languages />


{{Metadata|abstract=Ce guide explique comment configurer distcc pour une compilation croisée à travers différentes architectures.}}

Ce guide vous explique comment configurer distcc pour la compilation croisée à travers différentes architectures de processeur.

== La compilation croisée avec distcc ==

=== Introduction ===

{{c|distcc}} is a tool that lets you share the burden of software compiling across several networked computers. As long as the networked boxes are all using the same toolchain built for the same processor architecture, no special {{c|distcc}} setup is required. 

'''This guide provides instructions on how to configure distcc to compile for different architectures.''' 

=== Installer les utilitaires nécessaires ===

First, you will need to emerge {{c|crossdev}} on all the machines that will be involved in the compiling process. {{c|crossdev}} is a tool that makes building cross-architecture toolchains easy. Its usage is straightforward: {{c|crossdev -t sparc}} will build a full cross-toolchain targeting the Sparc architecture. This includes binutils, gcc, glibc, and linux-headers. 

You will need to emerge the proper cross-toolchain on all the helper boxes. If you need more help, try running {{c|crossdev --help}}.

Si vous voulez régler finement la chaine de compilation croisée (cross-toolchain), voici un script qui produira une ligne de commande avec la version exacte du paquet de développement croisé à construire sur les machines assistantes (le script est à exécuter depuis la machine cible).

{{CodeBox|title=Script pour régler finement les outils de compilation croisée|lang=bash|1=
#! /bin/bash
A="sys-devel/binutils" ; B=`equery l $A` ; BINUTILS_VER=`echo $B {{!}} cut -d- -f3-`
A=`/usr/bin/gcc-config -c` ; B=`echo $A {{!}} cut -d- -f5` ; GCC_VER=`equery l sys-devel/gcc {{!}} grep $B {{!}} cut -d- -f3-`
KERNEL_VER=`uname -r {{!}} sed s/-gentoo//`
A="sys-libs/glibc" ; B=`equery l $A` ; LIBC_VER=`echo $B {{!}} cut -d- -f3-`
echo "crossdev --b =$BINUTILS_VER --g =$GCC_VER --k =$KERNEL_VER --l =$LIBC_VER -t `uname -m`"
}}

Next, you will need to emerge {{c|distcc}} on all the machines that will be involved in the process. This includes the box that will run emerge and the boxes with the cross-compilers. Please see the [[Distcc|Gentoo Distcc Documentation]] for more information on setting up and using {{c|distcc}}.

{{Note|Current versions of {{c|crossdev}} have a <code>-S</code> (<code>--stable</code>) flag for installing only stable versions of compiler tools.  (ie. {{c|crossdev -t i686-pc-linux-gnu --stable --ex-gcc --ex-gdb --portage --pretend}}). Without this option, {{c|crossdev}} installs the latest experimental compiler tools packages! Otherwise, the above script is no longer needed, unless specific versions of package tools and/or headers have been unmasked.}}

=== Notes spécifiques à Arch ===

{{Note|Obtain the architecture name by looking at the compile target's <var>CHOST</var> variable within {{Path|/etc/make.conf}}. When mangling the architecture name for the {{c|crossdev -t}} option, {{c|crossdev}} will merrily guess and install tools using the mangled architecture name for folder names within {{Path|/usr}} (ie. {{Path|/usr/i686-pc-linux-gnu/}}, {{Path|/usr/i686-linux-gnu/}}, ...). To resolve this, specify each mangled architecture/folder name to {{c|crossdev --clean}} for uninstalling, or manually remove the folders from the system.}}

==== Intel x86 sub-architectures ====

If you are cross-compiling between different subarchitectures for Intel {{Keyword|x86}} (e.g. i586 and i686), you must still build a full cross-toolchain for the desired <var>CHOST</var>, or else the compilation will fail. This is because i586 and i686 are actually different CHOSTs, despite the fact that they are both considered "x86." Please keep this in mind when you build your cross-toolchains. For example, if the target box is i586, this means that you must build i586 cross-toolchains on your i686 helper boxes. 

==== SPARC ====

Using {{c|crossdev -t sparc}} might fail with one of the following errors:

{{CodeBox|title=Erreurs affichées lors de l'exécution de  crossdev -t sparc|1=
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
}}

Si cela vous arrive, essayez la commande suivante à la place de la précédente :

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== Configurer distcc pour des compilations croisées correctes ===

In the default distcc setup, cross-compiling will ''not'' work properly. The problem is that many builds just call {{c|gcc}} instead of the full compiler name (e.g. {{c|sparc-unknown-linux-gnu-gcc}}). When this compile gets distributed to a distcc helper box, the native compiler gets called instead of your shiny new cross-compiler. 

Fortunately, there is a workaround for this little problem. All it takes is a wrapper script and a few symlinks on the box that will be running {{c|emerge}}. We'll use a Sparc box as an example. Wherever you see <code>sparc-unknown-linux-gnu</code> below, you will want to insert your own <var>CHOST</var> value (<code>x86_64-pc-linux-gnu</code> for an AMD64 box, for example). When you first emerge distcc, the {{Path|/usr/lib/distcc/bin}} directory looks like this: 

{{Note|Les instructions suivantes doivent être exécutées seulement sur la machine qui exécute la commande emerge. N'effectuez pas ces étapes sur les machines assistantes.}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

Voici ce que vous devez faire : 

{{RootCmd|rm c++ g++ gcc cc}}

Next, we'll create the new script on this box. Fire up your favorite editor and create a file with the following text in it, then save it as {{Path|sparc-unknown-linux-gnu-wrapper}}. Remember to change the <var>CHOST</var> value (in this case, <code>sparc-unknown-linux-gnu</code>) to the actual <var>CHOST</var> of the box that will be running the emerge. 

{{CodeBox|title=Le nouveau script enveloppe|lang=bash|1=
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
}}

Ensuite, nous allons rendre le script exécutable  et créer les liens symboliques corrects : 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

Voilà, c'est terminé. {{Path|/usr/lib/distcc/bin}} devrait ressemble à ceci : 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

{{Note|With new distcc versions, the following steps are unnecessary—you can emerge distcc on the client with the <code>crossdev</code> USE flag set instead to achieve the same result.}}

Ensuite nous devons nous assurer que ces enveloppes restent disponibles après la mise à jour du paquet distcc car il écrase les liens symboliques. Nous pouvons le faire grâce au fichier {{Path|/etc/portage/bashrc}} qui ressemble à ceci :

{{FileBox|filename=/etc/portage/bashrc|lang=bash|1=
case ${CATEGORY}/${PN} in
<pre>                 sys-devel/distcc | sys-devel/gcc)</pre>
			if [ "${EBUILD_PHASE}" == "postinst" ]; then
				/usr/local/sbin/distcc-fix &
			fi
		;;
esac
}}

Then create this file:

{{FileBox|filename=/usr/local/sbin/distcc-fix|lang=bash|1=
#!/bin/bash	                
 
sleep 20
# change TUPLE to match your machine
TUPLE="sparc-unknown-linux-gnu"
cd /usr/lib/distcc/bin
rm cc c++ gcc g++ ${TUPLE}-wrapper
echo '#!/bin/bash' > ${TUPLE}-wrapper
echo "exec ${TUPLE}-g\${0:\$[-2]}" "\"\$@\"" >> ${TUPLE}-wrapper
chmod 755 ${TUPLE}-wrapper
ln -s ${TUPLE}-wrapper cc
ln -s ${TUPLE}-wrapper c++
ln -s ${TUPLE}-wrapper gcc
ln -s ${TUPLE}-wrapper g++
}}

Give it the proper permissions:

{{RootCmd|chmod 755 /usr/local/sbin/distcc-fix}}

Félicitations ! Vous disposez maintenant d'une configuration distcc avec compilation croisée fonctionnelle.

=== Comment ça marche ===

When {{c|distcc}} is called, it checks to see what it was called as (e.g. <code>i686-pc-linux-gnu-gcc</code>, <code>sparc-unknown-linux-gnu-g++</code>, etc.) When distcc then distributes the compile to a helper box, it passes along the name it was called as. The distcc daemon on the other helper box then looks for a binary with that same name. If it sees just {{c|gcc}}, it will look for {{c|gcc}}, which is likely to be the native compiler on the helper box, if it is not the same architecture as the box running {{c|emerge}}. When the ''full'' name of the compiler is sent (e.g. <code>sparc-unknown-linux-gnu-gcc</code>), there is no confusion.

=== Dépannage ===

This section covers a number of common problems when using {{c|distcc}} for cross-compiling.

==== COMPILE ERRORS sur l’hôte distccd distant ====

When receiving the message <code>COMPILE ERRORS</code> within a remote host's {{Path|/var/log/distccd.log}} file, see the above notes concerning specifying the correct architecture name (ie. {{c|crossdev -t $TARGET}}).

Another solution is to uninstall and re-install {{c|crossdev}} compiler tools, using the {{c|crossdev --clean}} option, or ensuring {{Path|/usr/$TARGET}} no longer exists, and then completely reinstall the cross compiler.

It might also be wise to edit the remote host's {{Path|/usr/$TARGET/etc/portage/make.conf}}, and ensure the contents of the <var>CFLAGS</var> variable are similar on all computers or hosts performing compiler operations. Also make sure the <var>USE</var> flags for the cross compiler are sufficient: if you built GCC with <code>USE=graphite</code> on the client, you need a line like <code>cross-i686-pc-linux-gnu/gcc graphite</code> in {{Path|/etc/portage/package.use}} too.

==== Failed to exec $TARGET-unknown-linux-gnu-gcc: No such file or directory ====

Il est possible que le script d'emballage (''wrapper'') ne parvienne pas à s’exécuter, même avec les bonnes permissions :

{{CodeBox|title=Error message from wrapper|1=
distcc[6195] (dcc_execvp) ERROR: failed to exec i686-unknown-linux-gnu-gcc: No such file or directory)
}}

Pour résoudre ceci, assurez vous d'avoir créé le script d'emballage (''wrapper'') en utilisant le nom complet de l'architecture cible:

{{Cmd|ls -alh /usr/lib/distcc/bin/c++|output=<pre>
/usr/lib/distcc/bin/c++ ->./i686-pc-linux-gnu-wrapper
</pre>}}

[[Category:Compilation]]
{{Migrated|originalauthors=Andrew Gaffney, Joshua Saddler}}
