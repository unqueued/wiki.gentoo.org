<languages />


{{Metadata|abstract=Ce guide explique comment configurer distcc pour une compilation croisée à travers différentes architectures.}}

Ce guide vous explique comment configurer distcc pour la compilation croisée à travers différentes architectures de processeur.

== La compilation croisée avec distcc ==

=== Introduction ===

<code>distcc</code> est un outil qui vous permet de partager les tâches de compilation d'un logiciel sur plusieurs ordinateurs d'un réseau. Tant que les ordinateurs du réseau utilisent tous la même chaîne d'outils compilée pour la même architecture, aucune configuration spéciale de <code>distcc</code> n'est requise. 

'''Ce guide va vous montrer comment configurer <code>distcc</code> afin de permettre la compilation pour des architectures différentes.''' 

=== Installer les utilitaires nécessaires ===

Tout d'abord, vous devez installer <code>crossdev</code> sur toutes les machines qui seront impliquées dans le processus de compilation. <code>crossdev</code> est un outil qui permet une compilation facile de la chaîne des outils de compilation croisée. Son utilisation est assez directe : <code>crossdev -t sparc</code> compile une chaîne d'outils complète en ciblant l'architecture SPARC. Ceci inclut binutils, gcc, glibc, et linux-headers. 

Il vous faudra emerger la chaîne d'outils de compilation croisée sur toute les machines aidant à la compilation. Si vous avez besoin d'aide supplémentaire, tentez de lancer <code>crossdev --help</code>.

Si vous voulez régler finement la chaine de compilation croisée (cross-toolchain), voici un script qui produira une ligne de commande avec la version exacte du paquet de développement croisé à construire sur les machines assistantes (le script est à exécuter depuis la machine cible).

{{CodeBox|title=Script pour régler finement les outils de compilation croisée|lang=bash|1=
#! /bin/bash
A="sys-devel/binutils" ; B=`equery l $A` ; BINUTILS_VER=`echo $B {{!}} cut -d- -f3-`
A=`/usr/bin/gcc-config -c` ; B=`echo $A {{!}} cut -d- -f5` ; GCC_VER=`equery l sys-devel/gcc {{!}} grep $B {{!}} cut -d- -f3-`
KERNEL_VER=`uname -r {{!}} sed s/-gentoo//`
A="sys-libs/glibc" ; B=`equery l $A` ; LIBC_VER=`echo $B {{!}} cut -d- -f3-`
echo "crossdev --b =$BINUTILS_VER --g =$GCC_VER --k =$KERNEL_VER --l =$LIBC_VER -t `uname -m`"
}}

Ensuite il vous faudra installer  <code>distcc</code> sur toutes les machines qui sont impliquées dans le processus. Ceci inclut la machine qui doit exécuter emerge et les machines disposant du compilateur croisé (cross-compiler). Reportez-vous à la [[Distcc|Documentation Gentoo de Distcc ]] pour plus d'informations sur la manière de paramétrer et d'utiliser <code>distcc</code>.

{{Note|Les versions actuelles de <tt>crossdev</tt> ont une option <code>-S (--stable)</code> pour se limiter à l'installation des versions stables des outils de compilation (par exemple,<tt>crossdev -t i686-pc-linux-gnu --stable --ex-gcc --ex-gdb --portage --pretend</tt>). Sans cette option, <tt>crossdev</tt> installe la dernière version expérimentale des paquets d'outils de compilation!
Dans le cas où cette option est utilisée, le script d'au dessus n'est plus nécessaire, à moins que des versions spécifiques des outils de paquets et/ou des headers aient été démasquées.}}

=== Notes spécifiques à Arch ===

{{Note|Obtenez le nom de l'architecture en regardant la variable <code>CHOST</code> dans le fichier {{Path|/etc/make.conf}} de la cible de la compilation. En cas de massacre du nom de l'architecture passé à l'option <tt>crossdev -t</tt>, <tt>crossdev</tt> se fera une joie de deviner et d'installer les outils en utilisant le mauvais nom pour les dossiers dans {{Path|/usr/}} (par exemple: {{Path|/usr/i686-pc-linux-gnu/}}, {{Path|/usr/i686-linux-gnu/}}, ...). Pour corriger cela, indiquez chaque nom d'architecture ou de dossier à <tt>crossdev --clean</tt> afin de les désinstaller, ou supprimez manuellement les dossiers du système.}}

==== Intel x86 sub-architectures ====

Si vous effectuez une compilation croisée entre des sous-architectures pour Intel x86 (par exemple i586 et i686), vous devez toujours compiler une chaîne de compilation croisée complète pour le CHOST désiré, ou autrement la compilation échouera. Ceci est dû au fait que i586 et i686 sont réellement des CHOSTs différents, malgré le fait qu'ils sont tous les deux considérés comme des ''x86''. Garder cela à l'esprit lorsque vous compilez la chaîne de compilation croisée. Par exemple, si la machine cible est i586, ceci signifie que vous devez compiler les chaînes de compilation croisées sur vos machines assistantes i686. 

==== SPARC ====

Utiliser <code>crossdev -t sparc</code> pourrait échouer avec une des erreurs suivantes :

{{CodeBox|title=Erreurs affichées lors de l'exécution de  crossdev -t sparc|1=
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
}}

Si cela vous arrive, essayez la commande suivante à la place de la précédente :

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== Configurer distcc pour des compilations croisées correctes ===

Dans la configuration par défaut de  distcc, la compilation croisée ne fonctionnera ''pas'' correctement. Le problème est que beaucoup d'ebuilds appellent simplement le compilateur <code>gcc</code> au lieu de l'appeler par son nom complet (par exemple,  <code>sparc-unknown-linux-gnu-gcc</code> ). Quand cette compilation est distribuée sur une machine participante , le compilateur natif est appelé à la place de votre compilateur croisé flambant neuf. 

Heureusement, il y a un moyen de contourner ce petit problème. Tout ce qu'il faut, c'est un script enveloppe et quelques liens symboliques sur la machine qui exécutera la commande d'installation <code>emerge</code>. Nous allons utiliser le machine Sparc comme un exemple. Partout où vous rencontrez  <code>sparc-unknown-linux-gnu</code> ci-dessous, vous devrez insérer votre propre CHOST ( <code>x86_64-pc-linux-gnu</code> pour  une machine AMD64, par exemple). Quand vous installerez distcc pour la première fois, le répertoire {{Path|/usr/lib/distcc/bin}} devrait ressembler à ceci : 

{{Note|Les instructions suivantes doivent être exécutées seulement sur la machine qui exécute la commande emerge. N'effectuez pas ces étapes sur les machines assistantes.}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

Voici ce que vous devez faire : 

{{RootCmd|rm c++ g++ gcc cc}}

Ensuite, nous allons créer le nouveau script sur cette machine. Lancez votre éditeur favori et créez un fichier avec le texte suivant, puis sauvegardez-le comme {{Path|sparc-unknown-linux-gnu-wrapper}} . Pensez à remplacer  CHOST (dans ce cas, <code>sparc-unknown-linux-gnu</code> ) par le CHOST réel de la machine qui exécutera la commande emerge. 

{{CodeBox|title=Le nouveau script enveloppe|lang=bash|1=
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
}}

Ensuite, nous allons rendre le script exécutable  et créer les liens symboliques corrects : 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

Voilà, c'est terminé. {{Path|/usr/lib/distcc/bin}} devrait ressemble à ceci : 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

Ensuite nous devons nous assurer que ces enveloppes restent disponibles après la mise à jour du paquet distcc car il écrase les liens symboliques. Nous pouvons le faire grâce au fichier {{Path|/etc/portage/bashrc}} qui ressemble à ceci :

{{FileBox|filename=/etc/portage/bashrc|lang=bash|1=
case ${CATEGORY}/${PN} in
	sys-devel/distcc)
		# Hey man, how come that CONFIG PROTECT don't work?
		if [ "${EBUILD_PHASE}" == "postinst" ] {{!}}{{!}} [ "${EBUILD_PHASE}" == "postrm" ];
		then
			cd /usr/lib/distcc/bin
			rm cc c++ gcc g++
			ln -s sparc-unknown-linux-gnu-wrapper cc
			ln -s sparc-unknown-linux-gnu-wrapper c++
			ln -s sparc-unknown-linux-gnu-wrapper gcc
			ln -s sparc-unknown-linux-gnu-wrapper g++
		fi
	;;
esac
}}

Congratulations; you (hopefully) now have a working cross-distcc setup.

=== Comment ça marche ===

Lorsque <code>distcc</code> est appelé, il recherche ce qui est appelé  (par exemple <code>i686-pc-linux-gnu-gcc</code> , <code>sparc-unknown-linux-gnu-g++</code> , etc.) Lorsque distcc distribue ensuite la compilation à une machine assistante, il lui passe le nom par lequel il a été appelé. Le démon distcc sur l'autre machine assistante recherche alors un binaire de ce nom. S'il voit simplement  <code>gcc</code> , il cherchera  <code>gcc</code> , qui est probablement le compilateur natif sur la machine assistante, si ce n'est pas la même architecture que celle de la machine exécutant la commande  <code>emerge</code> . Quand le nom ''complet'' du compilateur est envoyé, (par exemple,  <code>sparc-unknown-linux-gnu-gcc</code> ), il ne peut y avoir de  confusion.


=== Dépannage ===

Cette section couvre un certain nombre des problèmes habituels dus à l'utilisation de <tt>distcc</tt> pour la compilation croisée.

==== COMPILE ERRORS sur l’hôte distccd distant ====

En cas d'apparition du message <code>COMPILE ERRORS</code> dans le fichier {{Path|/var/log/distccd.log}} de l'un des hôtes distant, regardez ci-dessus les notes concernant la spécification du nom correct pour l'architecture  (c'est à dire: <tt>crossdev -t $TARGET</tt>).

Une autre solution consiste à désinstaller et réinstaller les outils de compilation <tt>crossdev</tt>, en utilisant l'option <tt>crossdev --clean</tt>, ou en s'assurant que {{Path|/usr/$TARGET}} n'existe plus, puis en réinstallant complètement l'outil de compilation croisée.

Il peut aussi être prudent d’éditer le fichier  {{Path|/usr/$TARGET/etc/portage/make.conf}} de l’hôte distant afin de s'assurer que le contenu de la variable <code>CFLAGS</code> est similaire sur tous les ordinateurs ou hôtes performant les opérations de compilation.

==== Failed to exec $TARGET-uknown-linux-gnu-gcc: No such file or directory ====

Il est possible que le script d'emballage (''wrapper'') ne parvienne pas à s’exécuter, même avec les bonnes permissions :

{{CodeBox|title=Error message from wrapper|1=
distcc[6195] (dcc_execvp) ERROR: failed to exec i686-unknown-linux-gnu-gcc: No such file or directory)
}}

Pour résoudre ceci, assurez vous d'avoir créé le script d'emballage (''wrapper'') en utilisant le nom complet de l'architecture cible:

{{Cmd|ls -alh /usr/lib/distcc/bin/c++|output=<pre>
/usr/lib/distcc/bin/c++ ->./i686-pc-linux-gnu-wrapper
</pre>}}


{{Migrated|originalauthors=Andrew Gaffney, Joshua Saddler}}
