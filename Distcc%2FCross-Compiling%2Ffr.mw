<languages />

Ce guide vous explique comment configurer distcc pour la compilation croisée à travers différentes architectures de processeur.

== La compilation croisée avec distcc ==

=== Introduction ===

<code>distcc</code> est un outil qui vous permet de partager les tâches de compilation d'un logiciel sur plusieurs ordinateurs en réseau. Tant que les ordinateurs en réseau utilisent tous la même chaîne d'outils compilée pour la même architecture, aucune configuration spéciale de <code>distcc</code> n'est requise. Mais que faire pour compiler pour différentes architectures en utilisant des ordinateurs différents ? Ce guide va vous montre comment configurer <code>distcc</code> pour compiler pour différentes architectures. 

=== Installer les utilitaires nécessaires ===

Tout d'abord, vous devez installer <code>crossdev</code> sur toutes les machines qui seront impliquées dans le processus de compilation. <code>crossdev</code> est un outil qui permet une compilation facile de la chaîne des outils de compilation croisée. Il a été écrit à l'origine par Joshua Kinard et a été réécrit totalement par Mike Frysinger. Son utilisation est assez directe : <code>crossdev -t sparc</code> compile une chaîne d'outils complète en ciblant l'architecture Sparc. Ceci inclut binutils, gcc, glibc, et linux-headers. Si vous avez besoin de plus d'aide, essayez d'exécuter  <code>crossdev --help</code> . Évidemment, vous devrez installer la chaîne des outils de compilation croisée  sur tous les ordinateurs participants. 

Ensuite, vous devez installer <code>distcc</code> sur toutes les machines impliquées dans le processus de compilation. Ceci inclut l'ordinateur qui exécute la commande  et les ordinateurs avec les compilateurs croisés. Reportez-vous à la [http://www.gentoo.org//doc/fr/distcc.xml Documentation Gentoo sur distcc] pour plus d'information sur la manière d'installer et d'utiliser <code>distcc</code> .

=== Notes spécifiques par architecture ===

Si vous effectuez une compilation croisée entre différentes sous-architectures pour Intel x86 (par exemple, i586 et i686), vous devez quand-même compiler une chaîne des outils de compilation croisée pour le CHOST désiré, sinon la compilation plantera. Ceci est dû au fait que i586 et i686 sont des CHOSTs différents en réalité, malgré le fait qu'elles sont toutes les deux considérées comme étant des ''x86''. Pensez à ça quand vous compilez votre chaîne des outils de compilation. Par exemple, si la machine cible est i586, ceci signifie que vous devez construire des chaînes d'outils de compilation i586 sur vos machines participantes i686. 

=== Configurer distcc pour des compilations croisées correctes ===

Dans la configuration par défaut de  distcc, la compilation croisée ne fonctionnera ''pas'' correctement. Le problème est que beaucoup d'ebuilds appellent simplement le compilateur <code>gcc</code> au lieu de l'appeler par son nom complet (par exemple,  <code>sparc-unknown-linux-gnu-gcc</code> ). Quand cette compilation est distribuée sur une machine participante , le compilateur natif est appelé à la place de votre compilateur croisé flambant neuf. 

Heureusement, il y a un moyen de contourner ce petit problème. Tout ce qu'il faut, c'est un script enveloppe et quelques liens symboliques sur la machine qui exécutera la commande d'installation <code>emerge</code>. Nous allons utiliser le machine Sparc comme un exemple. Partout où vous rencontrez  <code>sparc-unknown-linux-gnu</code> ci-dessous, vous devrez insérer votre propre CHOST ( <code>x86_64-pc-linux-gnu</code> pour  une machine AMD64, par exemple). Quand vous installerez distcc pour la première fois, le répertoire {{Path|/usr/lib/distcc/bin}} devrait ressembler à ceci : 

{{Note|Les instructions suivantes doivent être exécutées seulement sur la machine qui exécute la commande emerge. N'effectuez pas ces étapes sur les machines assistantes.}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

Voici ce que vous devez faire : 

{{RootCmd|rm c++ g++ gcc cc}}

Next, we'll create the new script on this box. Fire up your favorite editor and create a file with the following text in it, then save it as {{Path|sparc-unknown-linux-gnu-wrapper}} . Remember to change the CHOST (in this case, <code>sparc-unknown-linux-gnu</code> ) to the actual CHOST of the box that will be running the emerge. 

{{Code|The new wrapper script|<pre>
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
</pre>
}}

Next, we'll make the script executable and create the proper symlinks: 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

When you're done, {{Path|/usr/lib/distcc/bin}} will look like this: 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

Congratulations; you now have a (hopefully) working cross-distcc setup. 

=== How this works ===

When <code>distcc</code> is called, it checks to see what it was called as (e.g. <code>i686-pc-linux-gnu-gcc</code> , <code>sparc-unknown-linux-gnu-g++</code> , etc.) When distcc then distributes the compile to a helper box, it passes along the name it was called as. The distcc daemon on the other helper box then looks for a binary with that same name. If it sees just <code>gcc</code> , it will look for <code>gcc</code> , which is likely to be the native compiler on the helper box, if it is not the same architecture as the box running <code>emerge</code> . When the ''full'' name of the compiler is sent (e.g. <code>sparc-unknown-linux-gnu-gcc</code> ), there is no confusion. 

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* Andrew Gaffney
* Joshua Saddler
