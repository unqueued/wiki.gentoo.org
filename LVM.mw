''LVM'' (Logical Volume Manager) is a software which uses physical devices abstract as PVs (Physical Volumes) in storage pools called VG (Volume Group). Whereas physical volumes could be a partition, whole hard drives grouped as JBOD ('''J'''ust a '''B'''unch '''O'''f '''D'''isks) or complete RAID systems.

== Installation ==
First we need to enable the ''device mapper'' in our kernel:
{{Kernel||<pre>
Device Drivers  --->
   Multiple devices driver support (RAID and LVM)  --->
       <*> Device mapper support
           <M> Crypt target support
           <M> Snapshot target
           <M> Mirror target
       <M> Multipath target
           <M> I/O Path Selector based on the number of in-flight I/Os
           <M> I/O Path Selector based on the service time</pre>}}
{{Note|You probably don't need everything enabled, but some of the options are needed for [[#LVM2_Snapshots]], [[#LVM2_MIRROR]], [[#LVM2_Stripeset]] and encryption.}}
{{Package|sys-fs/lvm2}} is available on Gentoo Linux and supports the following useflags:
* clvm = Allow users to build clustered lvm2
* cman = Cman support for clustered lvm
* lvm1 = Allow users to build lvm2 with lvm1 support
* nolvmstatic = Allow users to build lvm2 dynamically
* readline = Enables support for libreadline, a GNU line-editing library that almost everyone wants
* static-libs = Build static libraries
{{Note|there are some development USE flags which are not listed here}}
You can install LVM2 using the following command:
{{ShellRoot|emerge lvm2}}
The package comes with a start-stop-daemon, which we start and add to the boot runlevel:
{{ShellRoot|/etc/init.d/lvm start && rc-update add lvm boot}}
The configuration files are located in
{{Code|Configuration Files|<pre>
/etc/lvm/lvm.conf</pre>}}

== Usage ==
LVM organizes storage in three different levels as follows:
* hard drives, partitions, RAID systems or other means of storage are initialized as PV (Physical Volume)
* Physical Volumes (PV) are grouped together in Volume Groups (VG)
* Logical Volumes (LV) are managed in Volume Groups (VG)

=== PV (Physical Volume) ===
Physical Volumes are the actual hardware or storage system LVM builds up upon.

==== Partitioning ====
The partition type for ''LVM'' is ''8e''(Linux LVM):
{{ShellRoot|fdisk /dev/sdX}}
In fdisk, you can create MBR partitions using the '''n''' key and then change the partition type with the '''t''' key to ''8e''. We will end up with one primary partition /dev/sdX1 of partition type ''8e'' (Linux LVM).
{{Note|this step is not needed, since LVM can initialize whole hard drives as PV. Actual not using partitioning avoids LVM to be restricted to certain limits of MBR or GPT tables}}

==== Create PV ====
The following command creates a Physical Volume (PV) on the two first primary partitions of /dev/sdX and /dev/sdY:
{{ShellRoot|pvcreate /dev/sd[X-Y]1}}

==== List PV ====
The folloing command lists all active Physical Volumes (PV) in the system:
{{ShellRoot|pvdisplay}}
You can scan for PV in the system, to troubleshoot not properly initialized or lost storage devices:
{{ShellRoot|pvscan}}

==== Remove PV ====
LVM automatically distributed the data onto all available PV, if not told otherwise. To make sure there is no data left on our device before we remove it, use the following command:
{{ShellRoot|pvmove -v /dev/sdX1}}
This might take a long time and once finished, there should be no data left on /dev/sdX1. We first remove the PV from our Volume Group (VG) and then the actual PV:
{{ShellRoot|vgreduce vg0 /dev/sdX1 && pvremove /dev/sdX1}}
{{Note|If a whole hard drives was once initialized as PV, then you have to remove it before it can be properly partitioned again. That is because PV have no valid MBR table}}

=== VG (Volume Group) ===
Volume Groups (VG) consist of one or more Physical Volumes (PV) and show up as /dev/<VG name>/ in the device file system.

==== Create VG ====
The following command creates a Volume Group (VG) named ''vg0'' on two previously initialized Physical Volumes (PV) named /dev/sdX1 and /dev/sdY1:
{{ShellRoot|vgcreate vg0 /dev/sd[X-Y]1}}

==== List VG ====
The folloing command lists all active Volume Groups (VG) in the system:
{{ShellRoot|vgdisplay}}
You can scan for VG in the system, to troubleshoot not properly created or lost VGs:
{{ShellRoot|vgscan}}

==== Extend VG ====
With the following command, we extend the exisiting Volume Group (VG) vg0 onto the Physical Volume (PV) /dev/sdZ1:
{{ShellRoot|vgextend vg0 /dev/sdZ1}}

==== Reduce VG ====
Before we can remove a Physical Volume (PV), we need to make sure that LVM has no data left on the device. To move all data off that PV and distribute it onto the other available, use the following command:
{{ShellRoot|pvmove -v /dev/sdX1}}
This might take a while and once finished, we can remove the PV from our VG:
{{ShellRoot|vgreduce vg0 /dev/sdX1}}

==== Remove VG ====
Before we can remove a Volume Group (VG), we have to remove all existing Snapshots, all Logical Volumes (LV) and all Physical Volumes (PV) but one. The following command removes the VG named vg0:
{{ShellRoot|vgremove vg0}}

=== LV (Logical Volume) ===
Logical Volumes (LV) are created and managed in Volume Groups (VG), once created they show up as /dev/<VG name>/<LV name> and can be used like normal partitions.

==== Create LV ====
With the following command, we create a Logical Volume (LV) named lvol1 in Volume Group (VG) vg0 with a size of 150MB:
{{ShellRoot|lvcreate -L 150M -n lvol1 vg0}}
There are other useful options to set the size of a new LV like:
* -l 100%FREE = maximum size of the LV within the VG
* -l 50%VG = 50% size of the whole VG

==== List LV ====
The folloing command lists all Logical Volumes (LV) in the system:
{{ShellRoot|lvdisplay}}
You can scan for LV in the system, to troubleshoot not properly created or lost LVs:
{{ShellRoot|lvscan}}

==== Extend LV ====
With the following command, we can extend the Logical Volume (LV) named lvol1 in Volume Group (VG) vg0 to 500MB:
{{ShellRoot|lvextend -L500M /dev/vg0/lvol1}}
{{Note|use -L+350M to increase the current size of a LV by 350MB}}
Once the LV is extended, we need to grow the file system as well (in this example we used ext4 and the LV is mounted to /mnt/data):
{{ShellRoot|resize2fs /mnt/data 500M}}

==== Reduce LV ====
Before we can reduce the size of our Logical Volume (LV) without corrupting existing data, we have to shrink the file system on it. In this example we used ext4, the LV needs to be unmounted to shrink the file system:
{{ShellRoot|umount /mnt/data <br/>
e2fsck -f /dev/vg0/lvol1 <br/>
resize2fs /dev/vg0/lvol1 150M}}
Now we are ready to reduce the size of our LV:
{{ShellRoot|lvreduce -L150M /dev/vg0/lvol1}}
{{Note|use -L-350M to reduce the current size of a LV by 350MB}}

==== LV Permissions ====
Logical Volumes (LV) can be set to be ''read only'' storage devices.
{{ShellRoot|lvchange -p r /dev/vg0/lvol1}}
The LV needs to be remounted for the changes to take affect:
{{ShellRoot|mount -o remount /dev/vg0/lvol1}}
To set the LV to be read/write again:
{{ShellRoot|lvchange -p rw /dev/vg0/lvol1 && mount -o remount /dev/vg0/lvol1}}

==== Remove LV ====
Before we remove a Logical Volume (LV) we should unmount and deactivate, so no further write activity can take place:
{{ShellRoot|umount /dev/vg0/lvol1 && lvchange -a n /dev/vg0/lvol1}}
The following command removes the LV named lvol1 from VG named vg0:
{{ShellRoot|lvremove /dev/vg0/lvol1}}

== Examples ==
We can create some scenarios using loopback devices, so no real storage devices are used.

=== Preperation ===
First we need to make sure the loopback module is loaded. If you want to play around with partitions, use the following option:
{{ShellRoot|modprobe -r loop && modprobe loop max_part{{=}}63}}
{{Note|you cannot reload the module, if it is built into the kernel}}
Now we need to either tell LVM to not use ''udev'' to scan for devices or change the filers in /etc/lvm/lvm.conf. In this case we just temporarely do not use ''udev'':
{{File|/etc/lvm/lvm.conf||<pre>
<nowiki>obtain_device_list_from_udev = 0</nowiki></pre>}}
{{Important|this is for testing only, you want to change the setting back when dealing with real devices since it is much faster}}
We create some image files, that will become our storage devices (uses ~6GB of real hard drive space):
{{ShellRoot|mkdir /var/lib/lvm_img <br/>
dd if{{=}}/dev/zero of{{=}}/var/lib/lvm_img/lvm0.img bs{{=}}1024 count{{=}}2097152 <br/>
dd if{{=}}/dev/zero of{{=}}/var/lib/lvm_img/lvm1.img bs{{=}}1024 count{{=}}2097152 <br/>
dd if{{=}}/dev/zero of{{=}}/var/lib/lvm_img/lvm2.img bs{{=}}1024 count{{=}}2097152}}
Check which loopback devices are available:
{{ShellRoot|losetup -a}}
We assume all loopback devices are available and create our hard drives:
{{ShellRoot|losetup /dev/loop0 /var/lib/lvm_img/lvm0.img <br/>
losetup /dev/loop1 /var/lib/lvm_img/lvm1.img <br/>
losetup /dev/loop2 /var/lib/lvm_img/lvm2.img}}
Now we can use /dev/loop[0-2] as we would use any other hard drive in the system.
{{Note|On the next reboot, all the loopback devices will be released and the folder /var/lib/lvm_img can be deleted}}

=== Two Hard Drives ===
In this example, we will initialize two hard drive as PV and then create the VG ''vg0'':
{{ShellRoot|pvcreate /dev/loop[0-1] <br/>
vgcreate vg0 /dev/loop[0-1]}}
Now lets create the LV ''lvol1'' in our VG ''vg0'' and take the maximum space available:
{{ShellRoot|lvcreate -l 100%FREE -n lvol1 vg0}}
Create the file system and mount it to /mnt/data:
{{ShellRoot|mkfs.ext4 /dev/vg0/lvol1 <br/>
mount /dev/vg0/lvol1 /mnt/data}}
Now we have the capacity of 2GB from each hard drive available in /mnt/data as one 4GB device.
{{Note|The same applies to RAID systems, if you want to create one VG use /dev/md[X-Y] instead}}

=== /etc/fstab ===
Here is an example of an entry in /etc/fstab (using ext4):
{{File|/etc/fstab||<pre>
/dev/vg0/lvol1  /mnt/data  ext4  noatime  0 2</pre>}}

=== LVM2 MIRROR ===
We use two hard drives and create our LV ''lvol1'' like in the first example. This time we use 40% of the size of our VG ''vg0'', because we need some space in the VG for the MIRROR and log files:
{{ShellRoot|pvcreate /dev/loop[0-1] <br/>
vgcreate vg0 /dev/loop[0-1] <br/>
lvcreate -l 40%VG -n lvol1 vg0 <br/>
mkfs.ext4 /dev/vg0/lvol1 <br/>
mount /dev/vg0/lvol1 /mnt/data}}
To create our copy of /dev/vg0/lvol1 on the PV /dev/loop1, use the following command:
{{ShellRoot|lvconvert -m1 /dev/vg0/lvol1 --corelog /dev/loop1}}
LVM will now ensure that a full copy (MIRROR) of /dev/vg0/lvol1 exists on /dev/loop1 and is not distributed between other PVs.
{{Note|this is very I/O intensive, --corelog writes the log files for the conversion into memory}}
To remove the MIRROR:
{{ShellRoot|lvconvert -m0 /dev/vg0/lvol1}}
If one half of the MIRROR fails, the other one will be automatically converted into a not mirrored LV (loose the ''mirror'' atribute). LVM is different from Linux RAID1 that it doesn't read/write from both mirrored images, there is no performace increase.

== Links ==
* [http://sourceware.org/lvm2/ lvm2]
* [http://tldp.org/HOWTO/LVM-HOWTO/ LVM tldp.org]
