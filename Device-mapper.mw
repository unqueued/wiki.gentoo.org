{{WIP|author=Salahx}}
{{InfoBox stack|
{{InfoBox todo
|Figure out how to compute how large the metadata device should be give the origin size for the mirror/striped targets
|Complete the Targets section
|header=true}}
}}

Normally, users rarely use '''dmsetup''' directly. The '''dmsetup''' is a very low level, and difficult tool to use. LVM, mdtool or dmsetup is generally the preferred way to do it, as it takes care of saving the metadata and issuing the dmsetup commands for you. However, sometimes one want to deal with it directly: sometimes for recovery purposes, or because LVM doesn't yet support what you want.

{{Important|The device mapper, the the rest of the Linux block layer deals with things at the sector level. A sector defined as '''512 bytes''', regardless of the actual physical geometry the the block device}} 
{{Note|The article uses both IEC (1024-based) and Metric (1000-based). So 1GB is 1,000,000,000 bytes, but 1 GiB is 1,073,741,824 bytes}}

== Dmsetup commands ==
=== Create ===
The ''create'' command activates a new device mapper device. It appears in /dev/mapper. In addition, if the target has metadata, it reads it, or if this its first use, it initializes the metadata devices. Note the prior device mapper devices can be passed as paramters (if the target takes a device), thus it is possible to "stack" them. The syntax is:
<code>dmsetup create <new device name> --tables <start sector> <end sector> <target name> <target parmaters></code>
=== Remove ===
The ''remove'' command deactivates a device mapper device. It removes it from /dev/mapper. Syntax is
<code>dmsetup remove [-f] <device name></code>
Note is not possible to remove a device that's in use. The '''-f''' option may be passed the replace the target with one that fails all I/O, hopefully allowing the reference count to drop to 0.
=== Message ===
The ''message'' command send a message to the device. What message are supported depend on the target Syntax is:
<code>dmsetup message <sector number> <device name> <target message></code>
The <sector number> tends not to be used and is almost always 0.  
=== Suspend ===
The ''suspend''' command stops any NEW I/O. Existing I/O will still be completed. This can be used to quiesce a device. Syntax is:
<code>dmsetup message suspend <device name></code>
=== Resume ===
The '''resume''' command allows I/O to be submitted to a previously suspended device. Syntax is:
<code>dmsetup message suspend <device name></code>
== Dmsetup targets ==
=== Zero ===
See <tt>Documentation/device-mapper/zero.txt</tt> . This device has no device-specific parameters.  

The "zero" target create that functions similarly to /dev/zero: All reads return binary zero, and all writes are discarded> Normaly used in tests, but also useful in recovering linear and raid-type targets, when combined with the 'snapshot' target: a "zero" target of the same size as the missing piece(s) is created, a (writable) snapshot created (usually a loop device backed by a large sparse file, but it can be far smaller than the missing piece since it only has to the hold the changes). Then the snapshot can be mounted, fsck'd, or recover tools run against it. 

This creates a 1GB (1953125-sector) zero target:
{{RootCmd|<nowiki>dmsetup create 1gb-zero --table '0 1953125 zero'</nowiki>}}
=== Linear ===
=== Snapshot ===
=== Mirror and RAID1 ===
See <tt>Documentation/device-mapper/dm-raid.txt</tt>. Note that <chunk_size> is unused for RAID1, but a value is still required, therefore is value should be set to 0. There 2 other important, though optional, parameters: <region_size> and <[no]sync>. 

<region_size> controls how large the sync regions are. If a region gets out of sync, the entire region must be rewritten. The default is 4 MiB (8192 sectors). LVM, in contrast, uses a region size of 512 KiB (1024 sectors). The mirror metadata device needs 1 bit per region. The smaller the <regions_size>, the more metadata needed (TODO: How does one compute how big?), but the less wasted I/O to bring the mirrors back in sync. <[no]sync> controls whether or not to sync the mirror on creation. If a mirror is created with <nosync>, the result of a read to area that have no been written to yet are undefined. If the initial device device is blank, this is an appropriate option to use. 

If /dev/loop1 and /dev/loop2 are each 1GB (1953125 sectors), to create a simple 1 GB raid1 with no metadata devices.
{{RootCmd|<nowiki>dmsetup create test-raid1 --table '0 1953125 raid raid1 3 0 region_size 1024 2 - /dev/loop0 - /dev/loop1'</nowiki>}}
Note that because there's no metadata device, the array must be re-mirrored each time it is created. So normally, a metadata device is desired. Each 
"leg" needs it own metadata device (TODO: How does one compute how big?). If /dev/loop2 and /dev/loop3 are small metadata devices (4 MiB), then to create a 1G RAID1 would be:
{{RootCmd|<nowiki>dmsetup create test-raid1 --table '0 1953125 raid raid1 3 0 region_size 1024 2 /dev/loop2 /dev/loop0 /dev/loop3 /dev/loop1'</nowiki>}}
=== Striped (RAID 0) and RAID 4/5/6/10 ===
See <tt>Documentation/device-mapper/striped.txt</tt> and <tt>Documentation/device-mapper/dm-raid.txt</tt>. <chunk_size> is required. The <chunk size> must be both a power a two and a least a large as a memory page (for x86/x64 processors, pages are 4 KiB, so <chunk size> must be at least 8.) LVM uses a default value of 64 KiB (128 sectors). Also note the size of the array MUST be a multiple of the <chunk size>. Otherwise the target will give the error "Array size does not match requested target length". The rule for <region_size> is similar as it is for RAID1. <nosync> is usually not appropriate for RAID 4,5 and 6 as even for blank device parity must still be computed. 

All the following examples will use 4 1GB (1953125-sector) disk /dev/loop{0,1,2,3} and (if needed) metadata devices /dev/loop{4,5,6,7}, with a 64KiB (128 sector) cluster_size and a 512 KiB (1024 sector) region_size. Note that 1953125 is not a multiple of 128. So it must be rounded down to the nearest multiple of 128 sectors, which can be done using this template:

<tt><nowiki>echo 'scale=0; x=<dev_dize> / <chunk_size>; x*=<chunk_size>; x' | bc</nowiki></tt>

So in this case:
{{Cmd|<nowiki>scale=0; x=1953125 / 128; x*=128; x | bc</nowiki>|output=1953024}}

==== Striped (RAID0) ====
==== RAID4  ====
==== RAID5  ====
==== RAID6  ====
==== RAID10  ====
=== Crypt ===
=== Thin ===
=== Era ===
