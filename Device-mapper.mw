{{WIP|author=Salahx}}
{{InfoBox stack|
{{InfoBox todo
|Figure out how to compute how large the metadata device should be give the origin size for the mirror/striped targets
|Complete the Targets section
|header=true}}
}}

Normally, users rarely use '''dmsetup''' directly. The '''dmsetup''' is a very low level, and difficult tool to use. LVM, mdtool or dmsetup is generally the preferred way to do it, as it takes care of saving the metadata and issuing the dmsetup commands for you. However, sometimes one want to deal with it directly: sometimes for recovery purposes, or because LVM doesn't yet support what you want.

{{Important|The device mapper, the the rest of the Linux block layer deals with things at the sector level. A sector defined as '''512 bytes''', regardless of the actual physical geometry the the block device}} 
{{Note|The article uses both IEC (1024-based) and Metric (1000-based). So 1GB is 1,000,000,000 bytes, but 1 GiB is 1,073,741,824 bytes}}

== Dmsetup commands ==
=== Create ===
The ''create'' command activates a new device mapper device. It appears in /dev/mapper. In addition, if the target has metadata, it reads it, or if this its first use, it initializes the metadata devices. Note the prior device mapper devices can be passed as paramters (if the target takes a device), thus it is possible to "stack" them. The syntax is:
<code>dmsetup create <new device name> --tables <start sector> <end sector> <target name> <target parmaters></code>
=== Remove ===
The ''remove'' command deactivates a device mapper device. It removes it from /dev/mapper. Syntax is
<code>dmsetup remove [-f] <device name></code>
Note is not possible to remove a device that's in use. The '''-f''' option may be passed the replace the target with one that fails all I/O, hopefully allowing the reference count to drop to 0.
=== Message ===
The ''message'' command send a message to the device. What message are supported depend on the target Syntax is:
<code>dmsetup message <sector number> <device name> <target message></code>
The <sector number> tends not to be used and is almost always 0.  
=== Suspend ===
The ''suspend''' command stops any NEW I/O. Existing I/O will still be completed. This can be used to quiesce a device. Syntax is:
<code>dmsetup message suspend <device name></code>
=== Resume ===
The '''resume''' command allows I/O to be submitted to a previously suspended device. Syntax is:
<code>dmsetup message suspend <device name></code>
== Dmsetup targets ==
=== Zero ===
See <tt>Documentation/device-mapper/zero.txt</tt> . This device has no device-specific parameters.  

The "zero" target create that functions similarly to /dev/zero: All reads return binary zero, and all writes are discarded> Normaly used in tests, but also useful in recovering linear and raid-type targets, when combined with the 'snapshot' target: a "zero" target of the same size as the missing piece(s) is created, a (writable) snapshot created (usually a loop device backed by a large sparse file, but it can be far smaller than the missing piece since it only has to the hold the changes). Then the snapshot can be mounted, fsck'd, or recover tools run against it. 

This creates a 1GB (1953125-sector) zero target:
{{RootCmd|<nowiki>dmsetup create 1gb-zero --table '0 1953125 zero'</nowiki>}}
=== Linear ===
=== Snapshot ===
=== Mirror and Raid1 ===
See <tt>Documentation/device-mapper/dm-raid.txt</tt>. Note that <chunk_size> is unused for RAID1, but a value is still required, therefore is value should be set to 0.

If /dev/loop1 and /dev/loop2 are each 1GB (1953125 sectors), to create a simple 1 GB raid1 with no metadata:
{{RootCmd|<nowiki>dmsetup create test-raid1 --table '0 1953125 raid raid1 1 0 2 - /dev/loop0 - /dev/loop1'</nowiki>}}
Note that because there's no metadata device, the array but be re-mirrored each time it is created. So normally, a metadata device is desired. Each 
"leg" needs it own metadata device (TODO: How does one compute how big?}}. If /dev/loop2 and /dev/loop3 are small metadata devices (4 MiB), then to create a 1G RAID1 would be:
{{RootCmd|<nowiki>dmsetup create test-raid1 --table '0 1953125 raid raid1 1 0 2 /dev/loop2 /dev/loop0 /dev/loop3 /dev/loop1'</nowiki>}}
=== Striped and Raid 4/5/6/10 ===
See <tt>Documentation/device-mapper/striped.txt</tt> and <tt>Documentation/device-mapper/dm-raid.txt</tt>.

Note that the length (in sectors) MUST be a multiple of the <chunk size>*<# of non-parity disks>, otherwise the target will give the error "Array size does not match requested target length". The <chunk size> must also be both a power a two and a least a large as a memory page (for x86/x64 processors, pages are 4 KiB, so <chunk size> must be at least 8). So for 3 1GB (1953125-sector) devices, with a 32KiB (64 sector) chunk size, 1953125 must be rounded down to the nearest multiple for 64, which can be done according the following template (chunk_size and dev_size in sectors)
<tt>echo 'scale=0; x=<dev_dize> / <chunk_size>; x*=<chuck_size>; x*<# of non-parity disks> ' | bc -l
So for RAID 5,3 disk (in Raid 5, one disk is lost for parity), 1953125-sector devices, and a 64-sector chunk size:
{{Cmd|<nowiki>echo 'scale=0; x=1953125 / 64; x*=64; x*2' | bc -l</nowiki>|output=3906176}}
=== Crypt ===
=== Thin ===
=== Era ===
