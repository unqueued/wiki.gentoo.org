{{WIP|author=Salahx}}
{{InfoBox stack|
{{InfoBox todo
|Figure out how to compute how large the metadata device should be give the origin size for the mirror/striped targets
|Complete the Targets section
|header=true}}
}}

Normally, users rarely use '''dmsetup''' directly. The '''dmsetup''' is a very low level, and difficult tool to use. LVM, mdtool or dmsetup is generally the preferred way to do it, as it takes care of saving the metadata and issuing the dmsetup commands for you. However, sometimes one want to deal with it directly: sometimes for recovery purposes, or because LVM doesn't yet support what you want.

{{Important|The device mapper, the the rest of the Linux block layer deals with things at the sector level. A sector defined as '''512 bytes''', regardless of the actual physical geometry the the block device}} 
{{Note|The article uses both IEC (1024-based) and Metric (1000-based). So 1GB is 1,000,000,000 bytes, but 1 GiB is 1,073,741,824 bytes}}

== Dmsetup commands ==
=== Create ===
The ''create'' command activates a new device mapper device. It appears in /dev/mapper. In addition, if the target has metadata, it reads it, or if this its first use, it initializes the metadata devices. Note the prior device mapper devices can be passed as paramters (if the target takes a device), thus it is possible to "stack" them. The syntax is:
<code>dmsetup create <new device name> --tables <start sector> <end sector> <target name> <target parmaters></code>
=== Remove ===
The ''remove'' command deactivates a device mapper device. It removes it from /dev/mapper. Syntax is
<code>dmsetup remove [-f] <device name></code>
Note is not possible to remove a device that's in use. The '''-f''' option may be passed the replace the target with one that fails all I/O, hopefully allowing the reference count to drop to 0.
=== Message ===
The ''message'' command send a message to the device. What message are supported depend on the target Syntax is:
<code>dmsetup message <sector number> <device name> <target message></code>
The <sector number> tends not to be used and is almost always 0.  
=== Suspend ===
The ''suspend''' command stops any NEW I/O. Existing I/O will still be completed. This can be used to quiesce a device. Syntax is:
<code>dmsetup message suspend <device name></code>
=== Resume ===
The '''resume''' command allows I/O to be submitted to a previously suspended device. Syntax is:
<code>dmsetup message suspend <device name></code>
== Dmsetup targets ==
=== Zero ===
See <tt>Documentation/device-mapper/zero.txt</tt> . This device has no device-specific parameters.  

The "zero" target create that functions similarly to /dev/zero: All reads return binary zero, and all writes are discarded> Normaly used in tests, but also useful in recovering linear and raid-type targets, when combined with the 'snapshot' target: a "zero" target of the same size as the missing piece(s) is created, a (writable) snapshot created (usually a loop device backed by a large sparse file, but it can be far smaller than the missing piece since it only has to the hold the changes). Then the snapshot can be mounted, fsck'd, or recover tools run against it. 

This creates a 1GB (1953125-sector) zero target:
{{RootCmd|<nowiki>dmsetup create 1gb-zero --table '0 1953125 zero'</nowiki>}}
=== Linear ===
=== Snapshot ===
=== Mirror and RAID1 ===
{{Note|All examples for these targets assume /dev/loop{0,1} of 1 GB (1953125 sectors) each and 2 4 MiB metadata devices (TODO: Figure out how to compute size) /dev/loop{3,4} for the mirror log (if needed), with a the same defaults as LVM uses}}
==== Mirror ====
There is no kernel documentation for the ''mirror'' target. Parameters obtained from Linux sources: drivers/md/dm-log.c and drivers/md/dm-raid1.c
{{Code||<starting sector> <length> mirror <log type> <#log args> <log arg1>...<log argN> <#devs> <device name 1> <offset 1>...<device name N> <offset N> <#features> <features>}}

For <log type> there are 4 values with different arguments:
* '''core''' <region_size> [[no]sync] [block_on_error]
* '''disk''' <logdevice> <region_size> [[no]sync] [block_on_error] 

And the values of each argument:
* '''<region_size>''' is the region size of the mirror in sectors. It must be power of 2 and at least of a kernel page (for Intel x86/x64 processors, this is 4 KiB (8 sectors)  This is the granularity in which the mirror is kept to update, it is done in blocks of <region_size>. Its a tradeoff between increased metadata and wasted I/O. LVM uses a value of 512 KiB (1024 sectors).
* '''<logdevice>''' is the device in which to store the metadata, for the disk log types
* '''[no]sync''' is an optional argument. Default is "'sync'". '''nosync''' skips the sync steps, but any results reads from are not written to since the mirror was established are undefined. This is appropriate to use then the initial device is empty.  

And there is only 1 feature:
* '''handle_errors''' causes the mirror to respond to an error. Default is to ignore all errors. LVM enables this feature.

To create a mirror with in-memory log:
{{RootCmd|dmsetup create test_mirror --table '0 1953125 mirror core 1 1024 2 /dev/loop0 0 /dev/loop1 0 1 handle_errors'}}
Without a persistent log, the mirror will have to be recreated every time by copying the entire block device to the other "legs". To avoid this, the log may be stored on disk:
{{RootCmd|dmsetup create test_mirror --table '0 1953125 mirror core 2 /dev/loop3 1024 2 /dev/loop0 0 /dev/loop1 0 1 handle_errors'}}
Its possible to do LVM "--mirrorlog mirror" by creating 2 mirrors: a '''core''' mirror for the log device, and a '''disk''' mirror the data devices:
{{RootCmd
|dmsetup create test_mirror_log --table '0 8192 mirror core 1 1024 2 /dev/loop3 0 /dev/loop4 0 1 handle_errors'
|dmsetup create test_mirror --table '0 1953125 mirror disk 2 /dev/mapper/test_mirror_log 1024 2 /dev/loop0 0 /dev/loop1 0 1 handle_errors'}}

==== RAID1 ====
See <tt>Documentation/device-mapper/dm-raid.txt</tt>. Note that <chunk_size> is unused for RAID1, but a value is still required, therefore is value should be set to 0. There 2 other important, though optional, parameters: <region_size> and <[no]sync>. 

* <region_size> has the same meaning as it does in the ''mirror'' target. Unlike the ''mirror'' target. it has a default of 4 MiB (8192 sectors). LVM uses a region size of 512 KiB (1024 sectors).
* <[no]sync> has the same meaning as it does in the ''mirror'' target

To create a simple 1 GB raid1 with no metadata devices.
{{RootCmd|dmsetup create test-raid1 --table '0 1953125 raid raid1 3 0 region_size 1024 2 - /dev/loop0 - /dev/loop1'}}
Note that because there's no metadata device, the array must be re-mirrored each time it is created. So normally, a metadata device is desired. Each 
"leg" needs it own metadata device  If /dev/loop2 and /dev/loop3 are small metadata devices (4 MiB), then to create a 1G RAID1 would be:
{{RootCmd|dmsetup create test-raid1 --table '0 1953125 raid raid1 3 0 region_size 1024 2 /dev/loop2 /dev/loop0 /dev/loop3 /dev/loop1'}}

=== Striped (RAID 0) and RAID 4/5/6/10 ===
See <tt>Documentation/device-mapper/striped.txt</tt> and <tt>Documentation/device-mapper/dm-raid.txt</tt>. <chunk_size> is required. The <chunk size> must be both a power a two and a least a large as a memory page (for x86/x64 processors, pages are 4 KiB, so <chunk size> must be at least 8.) LVM uses a default value of 64 KiB (128 sectors). Also note the size of the array MUST be a multiple of the <chunk size>. Otherwise the target will give the error "Array size does not match requested target length". The rule for <region_size> is similar as it is for RAID1. <nosync> is usually not appropriate for RAID 4,5 and 6 as even for blank device parity must still be computed. 

All the following examples will use 4 1GB (1953125-sector) disk /dev/loop{0,1,2,3} and (if needed) metadata devices /dev/loop{4,5,6,7}, with a 64KiB (128 sector) cluster_size and a 512 KiB (1024 sector) region_size. Note that 1953125 is not a multiple of 128. So it must be rounded down to the nearest multiple of 128 sectors, which can be done using this template:

<tt><nowiki>echo 'scale=0; x=<dev_dize> / <chunk_size>; x*=<chunk_size>; x' | bc</nowiki></tt>

So in this case:
{{Cmd|<nowiki>scale=0; x=1953125 / 128; x*=128; x | bc</nowiki>|output=1953024}}

==== Striped (RAID0) ====
The striped target parameters is asymmetric to the RAID ones. First, the # device comes first, not the cluster size. Second, one must specify the offset (usually 0) of each device the makes up the stripe set.
{{RootCmd|dmsetup create test_raid0 --table '0 7812096 striped 4 128 /dev/loop0 0 /dev/loop1 0 /dev/loop2 0 /dev/loop3 0'}}
Where 7812096 is 1953024 * 4 (<# of devices>). There are no metadata devices associated with a striped set (RAID0).

==== RAID4  ====
RAID4 maintains a dedicated parity device, which it can use to rebuild the data if one disk is missing. To create a RAID4 set with the above numbers:
{{RootCmd|dmsetup create test-raid4 --table '0 5859072 raid raid4 3 64 region_size 1024 4 - /dev/loop0 - /dev/loop1 - /dev/loop2 - /dev/loop3'}}
As RAID1, there are no metadata device, which means the parity drive will have to be rebuilt every time we create the device. So metadata device are highly desirable:
{{RootCmd|dmsetup create test-raid4 --table '0 5859072 raid raid4 3 64 region_size 1024 4 /dev/loop4 /dev/loop0 /dev/loop5 /dev/loop1 /dev/loop6 /dev/loop2 /dev/loop7 /dev/loop3'}}
It is possible to create a RAID4 in degraded mode initially. It is necessary to not specific any metadata device, and "nosync" must added
{{RootCmd|dmsetup create test-raid4 --table '0 5859072 raid raid4 4 64 region_size 1024 nosync 4 - /dev/loop0 - /dev/loop1 - /dev/loop2 - -'}}
The reason for doing this is its faster to create a degraded array, populate it, tear it down, and then reassemble the array with the missing metadata and data device, so that the parity is only computed once, not twice.

==== RAID5  ====
==== RAID6  ====
==== RAID10  ====
=== Crypt ===
=== Thin ===
=== Era ===
