<languages />
{{Metadata|abstract=Portageを使用してバイナリパッケージをビルドしインストールすることもできます。このガイドではバイナリパッケージを作成し、インストールし、それらを配信するサーバーの設置方法を説明します。}}

Portage は、通常の ebuild のほかに、バイナリーパッケージの作成とインストールにも対応しています。
このガイドでは、バイナリーパッケージの作成方法、インストール方法、バイナリーパッケージサーバーのセットアップ方法について説明します。

== はじめに ==

There are many reasons why some system administrators like using binary packages for software installations on Gentoo:

# It allows administrators to ''save time when keeping similar systems updated''. Having to compile everything from source can become time consuming. Maintaining several similar systems, possibly some of them with older hardware, can be much easier if only one system has to compile everything from source and the other systems use the binary packages.
# ''Do safe updates''. For mission-critical systems in production it is important to stay ''usable'' as much as possible. This can be done by a staging server that performs all updates first to itself. Once the staging server is in a good state the updates can then be applied to the critical systems. A variant of this approach is to do the updates in a chroot on the same system and use the binaries created there on the real system.
# ''As a backup''. Often binary packages are the only way of recovering a broken system (i.e. broken compiler). Having pre-compiled binaries around either on a binary package server or locally can be of great help in case of a broken toolchain.
# It aids in ''updating very old systems''. The task of updating very old systems can be greatly eased using binary packages. It is usually helpful to install binary packages on old systems because they do not require build time dependencies to be installed/updated. Binaries packages also avoid failures in build processes since they are pre-compiled.

このガイドでは、次のトピックに焦点を当てます。: 

* Creating binary packages.
* Distributing the packages to clients.
* Implementing binary packages.
* Maintaining the binary packages.

最後に、バイナリパッケージの扱い方に関するいくつかの高度な話題を扱います。

{{Note|このガイドで使用するツールは、特に断りがなければ、すべて{{Package|sys-apps/portage}}に含まれます。}}

== バイナリパッケージを作成する ==

バイナリパッケージを作成する主な方法は3つあります：

# After a regular installation, using the {{c|quickpkg}} application.
# Explicitly during an {{c|emerge}} operation by using the <code>--buildpkg</code> (<code>-b</code>) option.
# Automatically through the use of the <code>buildpkg</code> value in Portage's <var>FEATURES</var> variable.

これらの三つの方法のうちいずれをとっても<var>PKGDIR</var>変数よって指定されるディレクトリにバイナリパッケージが作成されます。 (デフォルトでは{{Path|/usr/portage/packages}}です)

=== quickpkg を利用する ===

{{c|quickpkg}}は一つ以上のdependency atom (あるいはパッケージセット)を取り、そのatomと一致するインストールされたパッケージに対するバイナリパッケージを作成します。

例えば、すべてのインストールされたGCCのバージョンのバイナリパッケージを作るには

{{RootCmd|quickpkg sys-devel/gcc}}

システム上のインストールされたすべてのパッケージに対してバイナリパッケージを作成する場合は、<code>*</code> globを以下のように使います:

{{RootCmd|quickpkg "*/*"}}

この方法には注意すべき点があります。それは、インストールされたファイルを元にしてバイナリパッケージが作成され、コンフィグファイルをパッケージに含める際に問題となるかもしれないことです。システム管理者はパッケージをインストールした後にコンフィグファイルを編集することがあります。重要な(、ひょっとしたら機密の)情報の漏洩を防止する観点から、{{c|quickpkg}}はデフォルトでは<var>CONFIG_PROTECT</var>によって保護さされたコンフィグファイルをバイナリパッケージに含めません。これらのコンフィグファイルを含めるには、<code>--include-config</code> or <code>--include-unmodified-config</code> オプションを使用してください。

=== emerge のオプションに --buildpkg を使用する ===

When installing software using {{c|emerge}}, Portage can be asked to create binary packages by using <code>--buildpkg</code> (<code>-b</code>) option:

{{Emerge|params+=--buildpkg|sys-devel/gcc}}

It is also possible to ask Portage to ''only'' create a binary package but ''not'' to install the software on the live system. For this, the <code>--buildpkgonly</code> (<code>-B</code>) option can be used:

{{Emerge|params+=--buildpkgonly|sys-devel/gcc}}

しかしながら、後者のアプローチでは、すべてのビルド時依存が事前にインストールされている必要があります。

=== buildpkgをPortageの機能として実行する ===

パッケージがPortageによってインストールされるたびにバイナリパッケージを自動的に作成するもっとも一般的な方法は、以下のようにして{{Path|/etc/portage/make.conf}}で設定できる<code>buildpkg</code>機能を利用することです:

{{FileBox|filename=/etc/portage/make.conf|title=Portageのbuildpkg機能を有効化する|lang=bash|1=
FEATURES="buildpkg"
}}

この機能を有効にすると、Portageがソフトウェアをインストールするたびに、同様にバイナリパッケージも作成します。

=== いくつかのパッケージの作成を除外する ===

Portageに、いくつかの選択したパッケージやカテゴリについてバイナリパッケージを作成しないよう通知することができます。これは、<code>--buildpkg-exclude</code>オプションをemergeに渡すことにより行います:

{{RootCmd|emerge -uDN @world --buildpkg --buildpkg-exclude "virtual/* sys-kernel/*-sources"}}

これは、バイナリパッケージを利用可能にすることにほとんど、あるいはまったく利益がないパッケージについて使用できます。例として、Linuxカーネルソースパッケージやアップストリームのバイナリパッケージ({{Package|www-client/firefox-bin}}のように''-bin''で終わるもの)があります。

== バイナリパッケージホストを構成する ==

Portageは、バイナリパッケージのダウンロードのための多くのプロトコルをサポートしています: FTP、FTPS、HTTP、HTTPSおよびSSH。このことは、多くのバイナリパッケージホストの実装を可能にする余地を与えます。

しかしながら、Portageでは、バイナリパッケージを配布する"既存の枠組みから外れる"方法は提供されていません。決めた構成によって、追加のソフトウェアのインストールが必要になるでしょう。

=== ウェブベースのバイナリパッケージホスト ===

バイナリパッケージを配布する一般的なアプローチの一つは、ウェブベースのバイナリパッケージホストを作成することです。

[[lighttpd]] ({{Package|www-servers/lighttpd}})のようなウェブサーバーを使用し、{{Path|/etc/portage/make.conf}}の<var>PKGDIR</var>ディレクトリへの読み込みアクセスを提供するよう設定します。

{{FileBox|filename=/etc/lighttpd/lighttpd.conf|title=lighttpd の設定例|lang=bash|1=
# add this to the end of the standard configuration
server.modules += ( "mod_alias" )
alias.url = ( "/packages" => "/usr/portage/packages/" )
}}

そして、クライアントシステムで、それに対応する<var>PORTAGE_BINHOST</var>変数を設定します:

{{FileBox|filename=/etc/portage/make.conf|title=ウェブベースのバイナリパッケージホストを使用する|lang=bash|1=
PORTAGE_BINHOST="http://binhost.example.com/packages"
}}

=== SSH バイナリパッケージホスト ===

バイナリパッケージへのより認証されたアプローチを提供するため、SSHの使用も考慮できます。

SSHを使用する場合、LinuxのrootユーザーのSSH鍵(インストールはバックグラウンドで行われる必要があるため、パスフレーズなしのもの)をリモートのバイナリパッケージホストへの接続に使用できます。

これを実現するには、rootユーザーのSSH鍵がサーバーで許可されていることを確認してください。これは、SSHに対応したバイナリホストに接続する各マシンのために行う必要があります:

{{RootCmd|cat root.id_rsa.pub >> /home/binpkguser/.ssh/authorized_keys}}

そして、<var>PORTAGE_BINHOST</var>変数は以下のようになります:

{{FileBox|filename=/etc/portage/make.conf|title=PORTAGE_BINHOSTをSSHアクセス用に設定する|lang=bash|1=
PORTAGE_BINHOST="ssh://binpkguser@binhostserver/usr/portage/packages"
}}

{{Note|{{Path|~/.ssh/config}}にあるSSH設定ファイルをポートやユーザー名の設定に使用しないでください。この場所はPortageがクライアントへのパッケージのrsyncを試みる際には無視されます。その代わりに、すべてのオプションを<var>PORTAGE_BINHOST</var>変数に正しくセットしてください。}}

=== NFSエクスポート ===

内部ネットワークでバイナリパッケージを使用する場合、パッケージをNFSを通じてエクスポートし、クライアントでそれをマウントするのがより簡単かもしれません。

{{Path|/etc/exports}}ファイルは以下のようになります:

{{FileBox|filename=/etc/exports|title=パッケージのディレクトリをエクスポート|1=
/usr/portage/packages   2001:db8:81:e2::/48(ro,no_subtree_check,root_squash) 192.168.100.1/24(ro,no_subtree_check,root_squash)
}}

その後、クライアントでその場所をマウント可能です。{{Path|/etc/fstab}}エントリーの例は以下のようになります:

{{FileBox|filename=/etc/fstab|title=パッケージフォルダーのマウントの例|1=
binhost:/usr/portage/packages      /usr/portage/packages    nfs    defaults    0 0
}}

== バイナリーパッケージを使用する ==

バイナリパッケージが他のシステムで利用可能であるためには、いくつかの要件を満たす必要があります:

* クライアントとサーバーのアーキテクチャおよび<var>[[CHOST]]</var>は一致していなければなりません。
* バイナリパッケージのビルドに使用された<var>CFLAGS</var>および<var>CXXFLAGS</var>変数は、すべてのクライアントとの間で互換性がなければなりません。
* プロセッサ特有の命令セット機能(たとえば、MMX、SSEなど)のためのUSEフラグは注意深く選択しなければなりません: すべてのクライアントがそれらをサポートしている必要があります。

{{Important|Portageは、これらの要件が満たされているか検証することができません。これらの設定を守るのはシステム管理者の責任です。}}

次に、Portageは、バイナリパッケージがクライアントにおいて期待されるのと同じUSEフラグを用いてビルドされているかチェックします。パッケージが異なるUSEフラグの組み合わせでビルドされている場合、実行の際に{{c|emerge}}コマンドに渡されたオプションによって、Portageはそのバイナリパッケージを無視する(そしてソースベースのビルドを使用する)か、あるいは失敗します([[#バイナリーパッケージをインストールする|バイナリーパッケージをインストールする]]を参照してください)。

クライアントでは、バイナリパッケージが使用されるようにするために、いくつかの設定の変更が必要です。

== バイナリーパッケージをインストールする ==

{{c|emerge}}に渡せる、Portageにバイナリパッケージの使用について通知するオプションがいくつかあります:

{| class="table table-condensed table-striped"
|-
! scope="col" width="20%" | Option 
! Description
|-
| <code>--usepkg</code> (<code>-k</code>) || Tries to use the binary package(s) in the locally available {{Path|packages}} directory. Useful when using [[NFS]] or [[SSHFS]] mounted binary package hosts. If the binary packages are not found, a regular (source-based) installation will be performed.
|-
| <code>--usepkgonly</code> (<code>-K</code>) || Similar to <code>--usepkg</code> (<code>-k</code>) but fail if the binary package cannot be found. This option is useful if only ''pre-built'' binary packages are to be used.
|-
| <code>--getbinpkg</code> (<code>-g</code>) || Download the binary package(s) from a remote binary package host. If the binary packages are not found, a regular (source-based) installation will be performed.
|-
| <code>--getbinpkgonly</code> (<code>-G</code>) || Similar to <code>--getbinpkg</code> (<code>-g</code>) but will fail if the binary package(s) cannot be downloaded. This option is useful if only ''pre-built'' binary packages are to be used.
|}

バイナリパッケージによるインストールを自動的に利用するために、適切なオプションを<var>EMERGE_DEFAULT_OPTS</var>変数に追加することができます:

{{FileBox|filename=/etc/portage/make.conf|title=自動的にバイナリパッケージを取得し、パッケージが利用可能でない場合には失敗する|lang=bash|1=
EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --getbinpkgonly"
}}

There is a Portage feature that automatically implements the equivalent of <code>--getbinpkg</code> (<code>-g</code>) without the need for updating the <var>EMERGE_DEFAULT_OPTS</var> variable with the <code>--getbinpkg</code> value:

{{FileBox|filename=/etc/portage/make.conf|title=<var>FEATURES</var>変数でgetbinpkgを有効化する|lang=bash|1=
FEATURES="getbinpkg"
}}

=== パッケージをバイナリパッケージホストから取得する ===

バイナリパッケージホストを使用する場合、クライアントでは<var>PORTAGE_BINHOST</var>がセットされている必要があります。さもないと、クライアントはバイナリパッケージがどこに保管されているかわからず、Portageがそれらを取得できないという結果をもたらします。

{{FileBox|filename=/etc/portage/make.conf|title=PORTAGE_BINHOSTをセットする|lang=bash|1=
PORTAGE_BINHOST="http://binhost.example.com/packages"
}}

<var>PORTAGE_BINHOST</var>変数は、スペースで区切られたURIのリストを使用します。これにより、管理者は複数のバイナリパッケージサーバーを同時に使用できます。URIは、{{Path|Packages}}ファイルが存在するディレクトリを常に指していなければなりません。

{{Note|複数のバイナリパッケージサーバーのサポートはやや不完全です。複数のサーバーが同じパッケージバージョンのバイナリパッケージを提供している場合、最初の1つのみが考慮されます。このことは、それらのバイナリパッケージでUSE変数の設定に違いがあり、かつ後の方のバイナリパッケージのUSE変数の設定がシステムの設定と一致する場合に問題となりえます。}}

=== 改変したバイナリーパッケージを再インストールする ===

Passing the <code>--rebuilt-binaries</code> option to {{c|emerge}} will reinstall every binary that has been rebuilt since the package was installed. This is useful in case rebuilding tools like {{c|revdep-rebuild}} are run on the binary package server.

関連するオプションの1つが<code>--rebuilt-binaries-timestamp</code>です。これにより、emergeは与えられたタイムスタンプよりも前にビルドされたバイナリパッケージを再インストールにおいて考慮しなくなります。これは、バイナリパッケージサーバーはいちから再ビルドする必要があるが、その他の点で<code>--rebuilt-binaries</code>が使用される場合に、全てのパッケージが再インストールされるのを回避するために有用です。

=== 追加のクライアント設定 ===

<code>getbinpkg</code>機能に次いで、Portageは<code>binpkg-logs</code>機能にも対応します。この機能は、成功したバイナリパッケージのインストールについてのログファイルを保持するかどうかを制御します。これは<var>PORT_LOGDIR</var>変数がセットされている場合のみ意味があり、またデフォルトでは有効化されています。

特定のパッケージやカテゴリのセットについてバイナリパッケージを除外するのと同様に、クライアントにおいて、特定のパッケージやカテゴリのセットについてバイナリパッケージのインストールを除外するように設定することができます。

これを実現するには、<code>--usepkg-exclude</code>オプションを使用します:

{{RootCmd|emerge -uDNg @world --usepkg-exclude "sys-kernel/gentoo-sources virtual/*"}}

こうした追加の設定をemergeの実行ごとに有効にするには、{{Path|make.conf}}ファイル内の<var>EMERGE_DEFAULT_OPTS</var>変数にオプションを追加します:

{{FileBox|title=emergeの設定をすべての実行で有効化する|filename=/etc/portage/make.conf|1=
EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --usepkg-exclude 'sys-kernel/gentoo-sources virtual/*'"
}}

== バイナリーパッケージを管理する ==

バイナリパッケージのリストが活発に管理されていない場合、バイナリパッケージのエクスポートや配布はストレージの無駄な消費につながります。

=== 不用なバイナリーパッケージを削除する ===

{{Package|app-portage/gentoolkit}}パッケージでは、{{c|eclean}}というアプリケーションが提供されています。これにより、ダウンロードされたソースコードファイルのようなPortageに関する可変ファイルだけでなく、バイナリパッケージも管理することができます。

以下のコマンドは、該当するebuildがインストール済みebuildのリポジトリの中にないバイナリパッケージをすべて削除します:

{{RootCmd|eclean packages}}

詳細は [[Eclean]] の記事を読んでください。

もう一つの利用可能なツールは、{{Package|app-portage/portage-utils}}パッケージの{{c|qpkg}}ツールです。しかしながら、このツールはやや設定可能性において劣ります。

''使用されていない''バイナリパッケージ(バイナリパッケージが保管されているサーバーによって使用されているかという意味で)をクリーンアップするには:

{{RootCmd|qpkg -c}}

=== Packages のファイルを管理する ===

パッケージディレクトリ内には、{{Path|Packages}}と呼ばれる[[wikipedia:Manifest_file|マニフェストファイル]]が存在します。このファイルは、パッケージディレクトリ内のすべてのバイナリパッケージのメタデータのキャッシュとして機能します。このファイルは、Portageがバイナリパッケージをディレクトリに追加するたびに更新されます。同様に、{{c|eclean}}はバイナリパッケージを削除する際にこのファイルを更新します。

なんらかの理由でパッケージが単に削除されたりパッケージディレクトリにコピーされたりした場合、または{{Path|Packages}}ファイルが破損したり削除されたりした場合には、ファイルを再作成する必要があります。これには{{c|emaint}}コマンドを利用します:

{{RootCmd|emaint binhost --fix}}

== 高度な話題 ==

=== パッケージディレクトリのスナップショットを作成する ===

多数のクライアントシステムへ向けてバイナリパッケージを配置する場合、パッケージディレクトリのスナップショットを作成する価値が出てきます。そうすると、クライアントシステムはパッケージディレクトリを直接使わず、バイナリパッケージのスナップショットを使用します。

スナップショットは、{{Path|/usr/lib64/portage/python2.7/binhost-snapshot}}または{{Path|/usr/lib64/portage/python3.3/binhost-snapshot}}ツールを使用して作成できます。このツールは4つの引数をとります:

# ソースディレクトリ(パッケージディレクトリへのパス)
# ターゲットディレクトリ(存在しないディレクトリである必要があります)
# URI
# バイナリパッケージサーバーディレクトリ

パッケージディレクトリのファイルはターゲットディレクトリへコピーされます。そして、{{Path|Packages}}ファイルが、バイナリパッケージサーバーディレクトリ(第四引数)内に、提供されたURIを用いて作成されます。

クライアントシステムは、バイナリパッケージサーバーディレクトリを指すURIを使う必要があります。そこから、{{c|binhost-snapshot}}に与えられたURIへとリダイレクトされます。このURIはターゲットディレクトリを参照していなければなりません。

=== バイナリパッケージの形式を理解する ===

Portageによって作成されたバイナリパッケージは、{{Path|.tbz2}}で終わるファイル名を持ちます。これらのファイルは2つの部分から成ります:

# システムへインストールされるファイルを含む{{Path|.tar.bz2}}アーカイブ
# パッケージのメタデータ、ebuild、そしてenvironmentファイルを含む{{Path|xpak}}アーカイブ

形式の詳細については、{{c|man xpak}}を参照してください。

{{Package|app-portage/portage-utils}}に、{{Path|tbz2}}および{{Path|xpak}}ファイルを分割、作成できるいくつかのツールがあります。

以下のコマンドは、{{Path|tbz2}}を{{Path|.tar.bz2}}および{{Path|.xpak}}ファイルに分割します:

{{Cmd|qtbz2 -s <package>.tbz2}}

{{Path|.xpak}}ファイルは、{{c|qxpak}}を使用して調査することができます。

内容をリストアップするには:

{{Cmd|qxpak -l <package>.xpak}}

次のコマンドは、このパッケージについて有効化されているUSEフラグを含む、{{Path|USE}}と呼ばれるファイルを抽出します:

{{Cmd|qxpak -x package-manager-0.xpak USE}}

=== PKGDIR の構成 ===

現在使用されているバージョン2形式は、以下のような構成になっています:

{{CodeBox|title=パッケージディレクトリの構成(バージョン2)|1=
PKGDIR
`+- Packages
 +- app-accessibility/
 {{!}}  +- pkg1-version.tbz2
 {{!}}  `- pkgN-version.tbz2
 +- app-admin/
 {{!}}  `- ...
 `- ...
}}

{{Path|Packages}}ファイルは、最初のバイナリパッケージディレクトリ形式(バージョン1)からの主要な改善点です(また、Portageが、バイナリパッケージディレクトリがバージョン2を採用していると判断するためのトリガーでもあります)。バージョン1では、すべてのバイナリパッケージは単一のディレクトリ({{Path|All/}})内で提供されており、カテゴリのディレクトリには{{Path|All/}}ディレクトリ内のバイナリパッケージへのシンボリックリンクのみが含まれていました。

=== quickunpkg を用いて展開する ===

Zoobab氏が、{{Path|tbz2}}ファイルを素早く展開するためのシンプルなシェルツール[https://github.com/zoobab/quickunpkg quickunpkg]を作成しました。


[[Category:Portage]]
