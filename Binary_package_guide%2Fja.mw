<languages />
{{Metadata|abstract=Portageを使用してバイナリパッケージをビルドしインストールすることもできます。このガイドではバイナリパッケージを作成し、インストールし、それらを配信するサーバーの設置方法を説明します。}}

Portage は、通常の ebuild のほかに、バイナリーパッケージの作成とインストールにも対応しています。
このガイドでは、バイナリーパッケージの作成方法、インストール方法、バイナリーパッケージサーバーのセットアップ方法について説明します。

== はじめに ==

いくつかのシステム管理者はGentooでバイナリパッケージのインストールを使用するのに多くの理由があります。

# まず第一に、管理者が複数の同様のシステムを更新された状態に維持することが可能になります。 ソースからすべてをコンパイルする必要があるのは、時間の浪費になりえます。 もし、ただひとつのシステムですべてをコンパイルして他のシステムでバイナリパッケージを再利用できれば、いくつかの似たようなシステム(そのうちいくらかには古いハードウェアがあるかもしれません)を管理するのはとても楽になるでしょう。
# 第二の理由は、安全な更新を行うことです。 ミッションクリティカルなシステムのためには、使用可能な状態で可能な限りありつづけることが重要です。 これは、すべての更新を一番最初に自分自身に行うステージングサーバーによって実現できます。 ステージングサーバが良好な状態になると、その次に更新が重要なシステムに適用することができます。 このアプローチの変化形として、同じシステムのchroot環境で更新を行い、そこで作成されたバイナリを実際のシステムで用いるという方法もあります。
# 第三の理由は、バックアップとしてです。 多くの場合、バイナリパッケージが壊れたシステム（すなわち、壊れたコンパイラ）を回復する唯一の方法です。 事前にコンパイルされたバイナリをバイナリパッケージサーバ上やローカルで持つことは、ツールチェーンが壊れた場合には大きな助けになるでしょう。
# 最後に、非常に古いシステムを更新する助けにもなります。 非常に古いシステムを更新する作業は、バイナリパッケージを使用することで大幅に楽になります。 バイナリパッケージではビルド時の依存関係を更新/インストールする必要がないので、通常は古いシステムにバイナリパッケージをインストールするのは助けになります。 また、バイナリパッケージは事前にコンパイルされているので、ビルド工程での失敗も避けられます。

このガイドでは、次のトピックに焦点を当てます。: 

* バイナリパッケージの作成方法;
* バイナリパッケージのクライアントへの配信方法;
* バイナリパッケージの使用方法;
* バイナリパッケージの管理方法.

最後に、バイナリパッケージの扱い方に関するいくつかの高度な話題を扱います。

{{Note|このガイドで使用するツールは、特に断りがなければ、すべて{{Package|sys-apps/portage}}に含まれます。}}

== バイナリパッケージを作成する ==

バイナリパッケージを作成する主な方法は3つあります：

# 通常のインストール後、{{c| quickpkg}}のアプリケーションを使用する
# {{c| emerge}}時に<code>--buildpkg (-b)</code>オプションを明示する
# Portageの<var>FEATURES</var>変数で値<code>buildpkg</code>を使用して自動的に作成する

これらの三つの方法のうちいずれをとっても<var>PKGDIR</var>変数よって指定されるディレクトリにバイナリパッケージが作成されます。 (デフォルトでは{{Path|/usr/portage/packages}}です)

=== quickpkg を利用する ===

{{c|quickpkg}}は一つ以上のdependency atom (あるいはパッケージセット)を取り、そのatomと一致するインストールされたパッケージに対するバイナリパッケージを作成します。

例えば、すべてのインストールされたGCCのバージョンのバイナリパッケージを作るには

{{RootCmd|quickpkg sys-devel/gcc}}

システム上のインストールされたすべてのパッケージに対してバイナリパッケージを作成する場合は、<code>*</code> globを以下のように使います:

{{RootCmd|quickpkg "*/*"}}

この方法には注意すべき点があります。それは、インストールされたファイルを元にしてバイナリパッケージが作成され、コンフィグファイルをパッケージに含める際に問題となるかもしれないことです。システム管理者はパッケージをインストールした後にコンフィグファイルを編集することがあります。重要な(、ひょっとしたら機密の)情報の漏洩を防止する観点から、{{c|quickpkg}}はデフォルトでは<var>CONFIG_PROTECT</var>によって保護さされたコンフィグファイルをバイナリパッケージに含めません。これらのコンフィグファイルを含めるには、<code>--include-config</code> or <code>--include-unmodified-config</code> オプションを使用してください。

=== emerge のオプションに --buildpkg を使用する ===

{{c|emerge}}でソフトウェアをインストールするときに、 Portageに<code>--buildpkg (-b)</code>オプションを通すことによってバイナリパッケージを同時に作成することもできますː

{{Emerge|params+=--buildpkg|sys-devel/gcc}}

システムにはソフトウェアをインストールせずに、バイナリパッケージのみを作成することもできます。この場合は<code>--buildpkgonly (-B)</code>オプションを通してください:

{{Emerge|params+=--buildpkgonly|sys-devel/gcc}}

しかしながら、後者のアプローチでは、すべてのビルド時依存が事前にインストールされている必要があります。

=== buildpkgをPortageの機能として実行する ===

パッケージがPortageによってインストールされるたびにバイナリパッケージを自動的に作成するもっとも一般的な方法は、以下のようにして{{Path|/etc/portage/make.conf}}で設定できる<code>buildpkg</code>機能を利用することです:

{{FileBox|filename=/etc/portage/make.conf|title=Portageのbuildpkg機能を有効化する|lang=bash|1=
FEATURES="buildpkg"
}}

この機能を有効にすると、Portageがソフトウェアをインストールするたびに、同様にバイナリパッケージも作成します。

=== いくつかのパッケージの作成を除外する ===

Portageに、いくつかの選択したパッケージやカテゴリについてバイナリパッケージを作成しないよう通知することができます。これは、<code>--buildpkg-exclude</code>オプションをemergeに渡すことにより行います:

{{RootCmd|emerge -uDN @world --buildpkg --buildpkg-exclude "virtual/* sys-kernel/*-sources"}}

これは、バイナリパッケージを利用可能にすることにほとんど、あるいはまったく利益がないパッケージについて使用できます。例として、Linuxカーネルソースパッケージやアップストリームのバイナリパッケージ({{Package|www-client/firefox-bin}}のように''-bin''で終わるもの)があります。

== バイナリパッケージホストを構成する ==

Portageは、バイナリパッケージのダウンロードのための多くのプロトコルをサポートしています: FTP、FTPS、HTTP、HTTPSおよびSSH。このことは、多くのバイナリパッケージホストの実装を可能にする余地を与えます。

しかしながら、Portageでは、バイナリパッケージを配布する"既存の枠組みから外れる"方法は提供されていません。決めた構成によって、追加のソフトウェアのインストールが必要になるでしょう。

=== ウェブベースのバイナリパッケージホスト ===

バイナリパッケージを配布する一般的なアプローチの一つは、ウェブベースのバイナリパッケージホストを作成することです。

[[lighttpd]] ({{Package|www-servers/lighttpd}})のようなウェブサーバーを使用し、{{Path|/etc/portage/make.conf}}の<var>PKGDIR</var>ディレクトリへの読み込みアクセスを提供するよう設定します。

{{FileBox|filename=/etc/lighttpd/lighttpd.conf|title=lighttpd の設定例|lang=bash|1=
# add this to the end of the standard configuration
server.modules += ( "mod_alias" )
alias.url = ( "/packages" => "/usr/portage/packages/" )
}}

そして、クライアントシステムで、それに対応する<var>PORTAGE_BINHOST</var>変数を設定します:

{{FileBox|filename=/etc/portage/make.conf|title=ウェブベースのバイナリパッケージホストを使用する|lang=bash|1=
PORTAGE_BINHOST="http://binhost.example.com/packages"
}}

=== SSH バイナリパッケージホスト ===

バイナリパッケージへのより認証されたアプローチを提供するため、SSHの使用も考慮できます。

SSHを使用する場合、LinuxのrootユーザーのSSH鍵(インストールはバックグラウンドで行われる必要があるため、パスフレーズなしのもの)をリモートのバイナリパッケージホストへの接続に使用できます。

これを実現するには、rootユーザーのSSH鍵がサーバーで許可されていることを確認してください。これは、SSHに対応したバイナリホストに接続する各マシンのために行う必要があります:

{{RootCmd|cat root.id_rsa.pub >> /home/binpkguser/.ssh/authorized_keys}}

そして、<var>PORTAGE_BINHOST</var>変数は以下のようになります:

{{FileBox|filename=/etc/portage/make.conf|title=PORTAGE_BINHOSTをSSHアクセス用に設定する|lang=bash|1=
PORTAGE_BINHOST="ssh://binpkguser@binhostserver/usr/portage/packages"
}}

{{Note|{{Path|~/.ssh/config}}にあるSSH設定ファイルをポートやユーザー名の設定に使用しないでください。この場所はPortageがクライアントへのパッケージのrsyncを試みる際には無視されます。その代わりに、すべてのオプションを<var>PORTAGE_BINHOST</var>変数に正しくセットしてください。}}

=== NFSエクスポート ===

内部ネットワークでバイナリパッケージを使用する場合、パッケージをNFSを通じてエクスポートし、クライアントでそれをマウントするのがより簡単かもしれません。

{{Path|/etc/exports}}ファイルは以下のようになります:

{{FileBox|filename=/etc/exports|title=パッケージのディレクトリをエクスポート|1=
/usr/portage/packages   2001:db8:81:e2::/48(ro,no_subtree_check,root_squash) 192.168.100.1/24(ro,no_subtree_check,root_squash)
}}

その後、クライアントでその場所をマウント可能です。{{Path|/etc/fstab}}エントリーの例は以下のようになります:

{{FileBox|filename=/etc/fstab|title=パッケージフォルダーのマウントの例|1=
binhost:/usr/portage/packages      /usr/portage/packages    nfs    defaults    0 0
}}

== バイナリーパッケージを使用する ==

バイナリパッケージが他のシステムで利用可能であるためには、いくつかの要件を満たす必要があります:

* クライアントとサーバーのアーキテクチャおよび<var>[[CHOST]]</var>は一致していなければなりません。
* バイナリパッケージのビルドに使用された<var>CFLAGS</var>および<var>CXXFLAGS</var>変数は、すべてのクライアントとの間で互換性がなければなりません。
* プロセッサ特有の命令セット機能(たとえば、MMX、SSEなど)のためのUSEフラグは注意深く選択しなければなりません: すべてのクライアントがそれらをサポートしている必要があります。

{{Important|Portageは、これらの要件が満たされているか検証することができません。これらの設定を守るのはシステム管理者の責任です。}}

次に、Portageは、バイナリパッケージがクライアントにおいて期待されるのと同じUSEフラグを用いてビルドされているかチェックします。パッケージが異なるUSEフラグの組み合わせでビルドされている場合、実行の際に{{c|emerge}}コマンドに渡されたオプションによって、Portageはそのバイナリパッケージを無視する(そしてソースベースのビルドを使用する)か、あるいは失敗します([[#バイナリーパッケージをインストールする|バイナリーパッケージをインストールする]]を参照してください)。

クライアントでは、バイナリパッケージが使用されるようにするために、いくつかの設定の変更が必要です。

== バイナリーパッケージをインストールする ==

{{c|emerge}}に渡せる、Portageにバイナリパッケージの使用について通知するオプションがいくつかあります:

{| class="table table-condensed table-striped"
|-
! scope="col" width="20%" | Option 
! Description
|-
| <code>--usepkg</code> <code>(-k)</code> || Tries to use the binary package(s) in the locally available {{Path|packages}} directory. Useful when using [[NFS]] or [[SSHFS]] mounted binary package hosts. If the binary packages are not found, a regular (source-based) installation will be performed.
|-
| <code>--usepkgonly</code> <code>(-K)</code> || Similar to <code>--usepkg (-k)</code> but fail if the binary package cannot be found. This option is useful if only ''pre-built'' binary packages are to be used.
|-
| <code>--getbinpkg</code> <code>(-g)</code> || Download the binary package(s) from a remote binary package host. If the binary packages are not found, a regular (source-based) installation will be performed.
|-
| <code>--getbinpkgonly</code> <code>(-G)</code> || Similar to <code>--getbinpkg (-g)</code> but will fail if the binary package(s) cannot be downloaded. This option is useful if only ''pre-built'' binary packages are to be used.
|}

In order to automatically use binary package installations, the appropriate option can be added to the <var>EMERGE_DEFAULT_OPTS</var> variable:

{{FileBox|filename=/etc/portage/make.conf|title=Automatically fetch binary packages and fail the package if not available|lang=bash|1=
EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --getbinpkgonly"
}}

There is a Portage feature that automatically implements the equivalent of <code>--getbinpkg (-g)</code> without the need for updating the <var>EMERGE_DEFAULT_OPTS</var> variable with the <code>--getbinpkg</code> value:

{{FileBox|filename=/etc/portage/make.conf|title=Enabling getbinpkg in the <var>FEATURES</var> variable|lang=bash|1=
FEATURES="getbinpkg"
}}

=== Pulling packages from a binary package host ===

When using a binary package host, clients need to have the <var>PORTAGE_BINHOST</var> variable set. Otherwise the client will not know where the binary packages are stored which results in Portage being unable to retrieve them.

{{FileBox|filename=/etc/portage/make.conf|title=Setting PORTAGE_BINHOST|lang=bash|1=
PORTAGE_BINHOST="http://binhost.example.com/packages"
}}

The <var>PORTAGE_BINHOST</var> variable uses a space-separated list of URIs. This allows administrators to use several binary package servers simultaneously. The URI must always point to the directory in which the {{Path|Packages}} file resides.

{{Note|The support for multiple binary package servers is somewhat incomplete. If several servers serve a binary package for the same package version, then only the first one will be considered. This can be problematic when these binary packages differ in their USE variable configuration and the USE variable configuration of a later binary package would match the systems configuration.}}

=== 改変したバイナリーパッケージを再インストールする ===

Passing the <code>--rebuilt-binaries</code> option to {{c|emerge}} will reinstall every binary that has been rebuilt since the package was installed. This is useful in case rebuilding tools like {{c|revdep-rebuild}} or {{c|python-updater}} are run on the binary package server.

A related option is <code>--rebuilt-binaries-timestamp</code>. It causes emerge not to consider binary packages for a re-install if those binary packages have been built before the given time stamp. This is useful to avoid re-installing all packages, if the binary package server had to be rebuild from scratch but <code>--rebuilt-binaries</code> is used otherwise.

=== Additional client settings ===

Next to the <code>getbinpkg</code> feature, Portage also listens to the <code>binpkg-logs</code> feature. This one controls if log files for successful binary package installations should be kept. It is only relevant if the <var>PORT_LOGDIR</var> variable has been set and is enabled by default.

Similar to excluding binary packages for a certain set of packages or categories, clients can be configured to exclude binary package installations for a certain set of packages or categories.

To accomplish this, use the <code>--usepkg-exclude</code> option:

{{RootCmd|emerge -uDNg @world --usepkg-exclude "sys-kernel/gentoo-sources virtual/*"}}

To enable such additional settings for each emerge command, add the options to the <var>EMERGE_DEFAULT_OPTS</var> variable in the {{Path|make.conf}} file:

{{FileBox|title=Enabling emerge settings on every invocation|filename=/etc/portage/make.conf|1=
EMERGE_DEFAULT_OPTS="${EMERGE_DEFAULT_OPTS} --usepkg-exclude 'sys-kernel/gentoo-sources virtual/*'"
}}

== バイナリーパッケージを管理する ==

Exporting and distributing the binary packages will lead to useless storage consumption if the binary package list is not actively maintained.

=== 不用なバイナリーパッケージを削除する ===

In the {{Package|app-portage/gentoolkit}} package an application called {{c|eclean}} is provided. It allows for maintaining Portage-related variable files, such as downloaded source code files, but also binary packages.

The following command will remove all binary packages that have no corresponding ebuild in the installed ebuild repositories:

{{RootCmd|eclean packages}}

詳細は [[Eclean]] の記事を読んでください。

Another tool that can be used is the {{c|qpkg}} tool from the {{Package|app-portage/portage-utils}} package. However, this tool is a bit less configurable.

To clean up ''unused'' binary packages (in the sense of used by the server on which the binary packages are stored):

{{RootCmd|qpkg -c}}

=== Packages のファイルを管理する ===

Inside the packages directory exists a [[wikipedia:Manifest_file|manifest file]] called {{Path|Packages}}. This file acts as a cache for the metadata of all binary packages in the packages directory. The file is updated whenever Portage adds a binary package to the directory. Similarly, {{c|eclean}} updates it when it removes binary packages.

If for some reason binary packages are simply deleted or copied into the packages directory, or the {{Path|Packages}} file gets corrupted or deleted, then it must be recreated. This is done using {{c|emaint}} command:

{{RootCmd|emaint binhost --fix}}

== Advanced topics ==

=== Creating snapshots of the packages directory ===

When deploying binary packages for a large number of client systems it might become worthwhile to create snapshots of the packages directory. The client systems then do not use the packages directory directly but use binary packages from the snapshot.

Snapshots can be created using the {{Path|/usr/lib64/portage/python2.7/binhost-snapshot}} or {{Path|/usr/lib64/portage/python3.3/binhost-snapshot}} tool. It takes four arguments:

# A source directory (the path to the packages directory).
# A target directory (that must not exist).
# A URI.
# A binary package server directory.

The files from the package directory are copied to the target directory. A {{Path|Packages}} file is then created inside the binary package server directory (fourth argument) with the provided URI.

Client systems need to use an URI that points to the binary package server directory. From there they will be redirected to the URI that was given to {{c|binhost-snapshot}}. This URI has to refer to the target directory.

=== Understanding the binary package format ===

Binary packages created by Portage have the file name ending with {{Path|.tbz2}}. These files consist of two parts:

# A {{Path|.tar.bz2}} archive containing the files that will be installed on the system.
# A {{Path|xpak}} archive containing package metadata, the ebuild, and the environment file.

See {{c|man xpak}} for a description of the format.

In {{Package|app-portage/portage-utils}} some tools exists that are able to split or create {{Path|tbz2}} and {{Path|xpak}} files.

The following command will split the {{Path|tbz2}} into a {{Path|.tar.bz2}} and an {{Path|.xpak}} file:

{{Cmd|qtbz2 -s <package>.tbz2}}

The {{Path|.xpak}} file can be examined using the {{c|qxpak}} utility.

To list the contents:

{{Cmd|qxpak -l <package>.xpak}}

The next command will extract a file called {{Path|USE}} which contains the enabled USE flags for this package:

{{Cmd|qxpak -x package-manager-0.xpak USE}}

=== PKGDIR の構成 ===

The currently used format version 2 has the following layout:

{{CodeBox|title=Packages directory layout (version 2)|1=
PKGDIR
`+- Packages
 +- app-accessibility/
 {{!}}  +- pkg1-version.tbz2
 {{!}}  `- pkgN-version.tbz2
 +- app-admin/
 {{!}}  `- ...
 `- ...
}}

The {{Path|Packages}} file is the major improvement (and also the trigger for Portage to know that the binary package directory uses version 2) over the first binary package directory layout (version 1). In version 1, all binary packages were also hosted inside a single directory (called {{Path|All/}}) and the category directories only had symbolic links to the binary packages inside the {{Path|All/}} directory.

=== quickunpkg を用いて展開する ===

Zoobab wrote a simple shell tool named [https://github.com/zoobab/quickunpkg quickunpkg] to quickly unpack {{Path|tbz2}} files.


[[Category:Portage]]
