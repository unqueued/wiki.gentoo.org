<languages />

{{Metadata|abstract=이 설명서는 젠투 리눅스에 무(無) 디스크 노드 설정을 만들고 설정하는 방법을 도와줍니다.}}

이 설명서는 젠투 리눅스에 무(無) 디스크 노드 설정을 만들고 설정하는 방법을 도와줍니다.

== 도입부 ==

=== 이 설명서 정보 ===

이 설명서는 젠투 리눅스 배포판을 기반으로 무(無) 디스크 워크스테이션 설정을 도와줍니다. 이 안내서에서는 경험자의 경우 무(無) 디스크 노드 및 네트워크와 관련된 여러 설명서에 쉽게 적응할 수 있지만, 우리 모두는 각각의 입장에 있는 편이기에, 리눅스 초짜들에게 가능한한 친숙하게 작성하여 제공하려 하며, 이 안내서가 흥미있는 사람이든, 덕후든 아니든간에 쉽게 설치할 수 있도록 도움이 되길 바랍니다.

=== 무(無) 디스크 머신이란게 뭔가요? ===

무디스크 머신은 하드 디스크, 플로피 드라이브, CD-ROM 같은 보통 사용하는 부팅 장치가 없는 PC입니다. 무티스크 노드는 네트워크를 통해 부팅하며, 저장공간을 로컬 하드 디스크처럼 제공하는 서버가 필요합니다. 이제 우리는 이 서버를 ''마스터''라 하고, 무디스크 머신을 ''슬레이브''라 하겠습니다(이름으로 둡니다).  슬레이브 노드는 PXE 부팅 또는 이더부트 기능을 제공하는 네트워크 어댑터가 필요합니다. 지원 목록은 [http://www.etherboot.org Etherboot.org]를 확인하세요. 대부분 최신 카드에서는 PXE를 지원하며, 수많은 마더보드 내장 어댑터에서도 동작합니다. 

=== 시작하기 전에 ===

마스터 노드에 젠투를 설치해야 하고, 제공할 슬레이브 노드의 파일 시스템을 저장할 충분한 용량을 마스터 노드에 확보해야 합니다. 또한 로컬 영역 연결에서 한 인터페이스는 인터넷에 연결했는지 확인해야 합니다. 

== 마스터, 슬레이브 설정 ==

=== 커널 설명 ===

커널은 하드웨어와 머신에 불러온 모든 다른 소프트웨어 사이에 놓인 프로그램이며, 커널 기반 운영체제의 핵심입니다. 컴퓨터를 시작하면 BIOS는 하드 드라이브의 예약 부팅영역의 기계어 명령을 실행합니다. 이 기계어 명령은 커널을 불러드리는 부트로더 입니다. 커널을 불러오고 나면 모든 프로세스를 커널이 처리합니다. 

커널과 커널 설정에 대한 더 많은 내용은 [http://www.tldp.org/HOWTO/Kernel-HOWTO.html 커널 HOWTO]를 확인해보십시오. 

=== 마스터 커널 설정 ===

마스터 커널은 원하는대로 사용자 설정을 한 만큼 커질 수 있지만 선택해야 할 커널 옵션은 극히 일부입니다. 다음을 입력하여 커널 설정 화면으로 이동하십시오: 

{{RootCmd|cd /usr/src/linux
|make menuconfig}}

{{Path|/usr/src/linux/.config}} 파일을 직접 설정하는 안전한 대안책으로 회색에 시퍼런 색이 곁들인 화면이 떠야합니다. 커널이 잘 동작한다면 GUI를 빠져나가서 다음을 입력하여 현재 설정 파일을 저장하시는 것이 좋습니다: 

{{RootCmd|cp .config .config_working}}

하위 메뉴를 따라가서 아래 항목을 내장 항목(그리고 모듈 ''아님'')으로 표시했는지 확인하십시오. 아래 옵션은 2.6.10 버전의 커널부터 볼 수 있습니다. 다른 버전을 사용한다면 나타난 글씨나 순서가 다를 수도 있습니다. 최소한 아래 나타난 항목만 선택했는지 확인하십시오. 

{{KernelBox|title=마스터 커널 옵션|<pre>
[*] Networking support --->
  Networking options --->
    <*> Packet socket
    <*> Unix domain sockets
    [*] TCP/IP networking
    [*]   IP: multicasting
    [ ] Network packet filtering (replaces ipchains)
  
File systems --->
  Network File Systems  --->
    <*> NFS server support
    [*]   Provide NFSv3 server support
</pre>}}

마스터 노드 또는 보안 방화벽을 통해 인터넷망을 쓸 경우 iptables 지원을 추가했는지 확인하십시오:

{{KernelBox|title=iptables 지원 활성화|<pre>
  [*] Network packet filtering (replaces ipchains)
  IP: Netfilter Configuration  --->
    <*> Connection tracking (required for masq/NAT)
    <*> IP tables support (required for filtering/masq/NAT)
</pre>
}}

패킷 차단 기능이 필요하면, 다음 나머지 부분을 모듈로 추가하십시오. [http://www.gentoo.org//doc/en/security/security-handbook.xml?part=1&chap=12 젠투 보안 핸드북 방화벽 정보]에서 어떻게 방화벽을 제대로 설정할 수 있는지 읽어보십시오. 

{{Note/ko|이 커널 설정 옵션은 시스템 설정 옵션에 따라서만 추가할 수 있으며 커널 설정을 완벽하게 바꾼다는 의미는 아닙니다.}}

마스터 커널을 재설정한 후, 다음과 같이 다시 빌드하십시오:

{{RootCmd|make && make modules_install
|cp arch/i386/boot/bzImage /boot/bzImage-master}}

어떤 부트로더를 사용하느냐에 따라 {{Path|lilo.conf}}또는 {{Path|grub.conf}}에 새 커널 설정 항목을 추가하시고, 새 커널을 기본 항목으로 지정하십시오. 이제 새 bzImage 파일을 boot 디렉터리에 복사했으며, 여러분이 앞으로 해야 할 모든 일은 시스템을 재부팅하여 새 옵션을 불러오는 것입니다. 

=== 슬레이브 커널 알아보기 ===

슬레이브 커널을 어떤 모듈도 포함하지 않고 컴파일 하는 것을 추천하지만, 원격 부팅을 통해 불러오고 설정하는 과정을 어렵고 필요하지 않은 과정입니다. 게다가, 슬레이브 커널은 작아야 하며, 네트워크로부터 효율적으로 부팅 과정을 수행하기 위해 가능한한 최소화해야 합니다. 이제, 마스터에서 설정한 동일한 위치에 슬레이브의 커널을 컴파일하겠습니다. 

혼동을 막고 시간을 절약하기 위해 마스터의 설정 파일을 다음 명령을 입력하여 백업하시는게 좋습니다: 

{{RootCmd|cp /usr/src/linux/.config /usr/src/linux/.config_master}}

이제 마스터 커널을 설정한 동일한 방식으로 슬레이브 커널을 설정하겠습니다. 새 설정 파일로 시작하려 한다면, 다음 명령을 입력하여 기본 {{Path|/usr/src/linux/.config}} 파일로 언제든 되돌릴 수 있습니다. 

{{RootCmd|cd /usr/src/linux
|cp .config_master .config}}

이제 다음 명령을 입력하여 설정 화면으로 이동하십시오: 

{{RootCmd|cd /usr/src/linux
|make menuconfig}}

다음 옵션을 커널 모듈이 ''아닌'' 내장 항목으로 선택했는지 확인하십시오: 

{{KernelBox|title=슬레이브 커널 옵션|<pre>
[*] Networking support --->
  Networking options --->
    <*> Packet socket
    <*> Unix domain sockets
    [*] TCP/IP networking
    [*]   IP: multicasting
    [*]   IP: kernel level autoconfiguration
    [*]     IP: DHCP support
  
File systems --->
  Network File Systems  --->
    <*> file system support
    [*]   Provide NFSv3 client support
    [*]   Root file system on NFS
</pre>
}}

{{Note/ko|DHCP 서버의 대안책은 BOOTP 서버입니다.}}

{{Important/ko|네트워크 어댑터를 노드 커널에 추가(모듈 아님)하는 것이 중요합니다. 무디스크 노드에서 모듈을 사용하는 것은 보통 문제를 일으키지 않습니다.}}

이제 슬레이브 커널을 컴파일해야 합니다. (어쩌다가) 마스터 커널을 빌드할 때 모듈을 덮어쓰거나 꼬이게 하고 싶진 않기에 여기서는 매우 조심해야 합니다:

{{RootCmd|cd /usr/src/linux
|make}}

이제 마스터에 슬레이브의 파일과 필요한 시스템 파일을 저장할 디렉터리를 만드십시오. 여기선 {{Path|/diskless}}를 사용하겠지만, 어디든 원하는 디렉터리를 여기서 선택하십시오. 이제 슬레이브의 bzImage 파일을 {{Path|/diskless}} 디렉터리에 복사하십시오: 


{{Note/ko|다른 아키텍처를 사용한다면 {{Path|.config_arch}}에 저장하는 것이 좋습니다. 이미지에도 같은 조치를 취하십시오: {{Path|/diskless}}에 {{Path|bzImage_arch}} 같은 방식으로 저장하십시오.}}


{{RootCmd|mkdir /diskless
|cp /usr/src/linux/arch/i386/boot/bzImage /diskless}}

=== 슬레이브 파일 시스템 기반 설정 ===

마스터 파일 시스템과 슬레이브 파일 시스템은 상당 부분을 주물러 바꿀 수 있습니다. 바로 지금 우리는 적당한 설정 파일의 기반 파일 시스템을 설정하고 마운트 지점을 지정하는 것입니다. 먼저 우리가 해야 할 일은 첫 슬레이브 머신에 대한 {{Path|/diskless}} 디렉터리에 디렉터리를 만드는 것입니다. 각각의 슬레이브에서는 자신의 루트 파일 시스템이 필요한데 각각의 시스템 파일을 공유하면 권한 문제가 생길 수 있으며, 최악의 경우는 복구하기 어렵게 깨질 수도 있습니다. 이 디렉터리를 관리자가 적절하다고 생각하는 어떤것이든 불러올 수 있지만, 저자는 슬레이브의 유일하며 혼동되지 않는 IP 주소 사용을 제안합니다. 첫번째 슬레이브에 할당할 정적 IP는 예를 들어 <code>192.168.1.21</code>과 같다면: 

{{RootCmd|mkdir -p /diskless/192.168.1.21/etc}}

Various configuration files in {{Path|/etc}} need to be altered to work on the slave. Copy the master's {{Path|/etc}} directory onto the new slave root by typing: 

{{RootCmd|cp -r /etc/* /diskless/192.168.1.21/etc/}}

이 파일시스템은 더 많은 마운트 지점과 디렉터리가 필요하기 때문에 아직 준비되지 않았습니다. 이들을 만들려면 다음 명령을 입력하십시오: 

{{RootCmd|mkdir /diskless/192.168.1.21/home
|mkdir /diskless/192.168.1.21/dev
|mkdir /diskless/192.168.1.21/proc
|mkdir /diskless/192.168.1.21/tmp
|mkdir /diskless/192.168.1.21/mnt
|chmod a+w /diskless/192.168.1.21/tmp
|mkdir /diskless/192.168.1.21/mnt/.initd
|mkdir /diskless/192.168.1.21/root}}

{{RootCmd|mkdir /diskless/192.168.1.21/sys
|mkdir /diskless/192.168.1.21/var
|mkdir /diskless/192.168.1.21/var/empty
|mkdir /diskless/192.168.1.21/var/lock
|mkdir /diskless/192.168.1.21/var/log
|mkdir /diskless/192.168.1.21/var/run
|mkdir /diskless/192.168.1.21/var/spool
|mkdir /diskless/192.168.1.21/usr
|mkdir /diskless/192.168.1.21/opt
}}

Most of these "stubs" should be recognizable; stubs like {{Path|/dev}} , {{Path|/proc}} or {{Path|/sys}} will be populated when the slave starts, the others will be mounted later. The {{Path|/diskless/192.168.1.21/etc/conf.d/hostname}} file should also be changed to reflect the hostname of the slave. Binaries, libraries and other files will be populated later in this HOWTO right before attempting to boot the slave. 

Even though {{Path|/dev}} is populated by <code>udev</code> later on, the {{Path|console}} entry needs to be created. If not, the error message "unable to open initial console" will be encountered. 

{{RootCmd|mknod /diskless/192.168.1.21/dev/console c 5 1}}

== DHCP 서버 설정 ==

=== DHCP 서버 알아보기 ===

DHCP는 동적 호스트 설정 프로토콜(Dynamic Host Configuration Protocol)의 약자입니다. DHCP 서버는 PXE 부팅을 시작할 때 가장 먼저 통신할 컴퓨터입니다. DHCP 서버의 주된목적은 IP 주소 할당입니다. DHCP 서버는 호스트의 이더넷 MAC 주소를 기반으로 IP 주소를 할당할 수 있습니다. 슬레이브에서 IP 주소를 받으면, DHCP 서버는 초기 파일 시스템과 커널이 어디있는지 슬레이브에게 알려줍니다. 

=== 시작하기 전에 ===

There are several things to make sure of, that they are working properly before beginning. First check the network connectivity: 

{{RootCmd|ifconfig eth0 multicast
|ifconfig -a}}

Make sure there is an ''eth0'' device running. It should look something like this: 

{{CodeBox|title=eth0 장치가 올바르게 동작하는 모습|1=
eth0      Link encap:Ethernet  HWaddr 00:E0:83:16:2F:D6
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:26460491 errors:0 dropped:0 overruns:2 frame:0
          TX packets:32903198 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:100
          RX bytes:2483502568 (2368.4 Mb)  TX bytes:1411984950 (1346.5 Mb)
          Interrupt:18 Base address:0x1800
}}

It's important that it says ''MULTICAST'', if it doesn't then the kernel will have to be recompiled to include multicast support.

=== DHCP 서버 설치 ===

If the network does not already have a DHCP server installed, one needs to be installed now: 

{{Emerge|dhcp}}

If the network already has a DHCP server installed, edit the configuration file to get the PXE boot to function correctly. 

=== DHCP 서버 설정 ===

There is only one configuration file that needs to be edited before starting the DHCP server: {{Path|/etc/dhcp/dhcpd.conf}}. Copy and edit the provided sample file: 

{{RootCmd|cp /etc/dhcp/dhcpd.conf.sample /etc/dhcp/dhcpd.conf
|nano -w /etc/dhcp/dhcpd.conf}}

의도한 방식 대로의 파일의 일반 구성은 다음과 같습니다: 

{{CodeBox|title=예제 {{Path|dhcpd.conf}} 구성|1=
# global options here
ddns-update-style none;
shared-network LOCAL-NET {
  # shared network options here
  subnet 192.168.1.0 netmask 255.255.255.0 {
    # subnet network options here
    host slave{
        # host specific options here
    }
    group {
        # group specific options here
    }
  }
}
}}

The <code>shared-network</code> block is optional and should be used for IPs that are required to be assigned that belong to the same network topology. At least one <code>subnet</code> must be declared and the optional <code>group</code> block allows options to be grouped between items. A good example of {{Path|dhcpd.conf}} looks like this: 

{{CodeBox|title={{Path|dhcpd.conf}} 예제|1=
#
# Sample dhcpd.conf for diskless clients
#
  
# Disable dynamic DNS
ddns-update-style none;
  
# Assume one default gateway for IP traffic will do
option routers 192.168.1.1;
  
# Provide DNS info to clients
option domain-name-servers 192.168.1.1;
option domain-name "mydomain.com";
  
# Specify the TFTP server to be used
next-server 192.168.1.1;
  
# Declare a vendor-specific option buffer for PXE clients:
# Code 1: Multicast IP address of boot file server
# Code 2: UDP port that client should monitor for MTFTP responses
# Code 3: UDP port that MTFTP servers are using to listen for MTFTP requests
# Code 4: Number of seconds a client must listen for activity before trying
#         to start a new MTFTP transfer
# Code 5: Number of seconds a client must listen before trying to restart
#         a MTFTP transfer
  
option space PXE;
option PXE.mtftp-ip               code 1 = ip-address;
option PXE.mtftp-cport            code 2 = unsigned integer 16;
option PXE.mtftp-sport            code 3 = unsigned integer 16;
option PXE.mtftp-tmout            code 4 = unsigned integer 8;
option PXE.mtftp-delay            code 5 = unsigned integer 8;
option PXE.discovery-control      code 6 = unsigned integer 8;
option PXE.discovery-mcast-addr   code 7 = ip-address;
  
# Declare the subnet where our diskless nodes will live
subnet 192.168.1.0 netmask 255.255.255.0 {
  
  # Provide PXE clients with appropriate information
  class "pxeclient" {
    match if substring(option vendor-class-identifier, 0, 9) = "PXEClient";
    vendor-option-space PXE;
  
    # At least one of the vendor-specific PXE options must be set in
    # order for the client boot ROMs to realize that we are a PXE-compliant
    # server.  We set the MCAST IP address to 0.0.0.0 to tell the boot ROM
    # that we can't provide multicast TFTP.
  
    option PXE.mtftp-ip 0.0.0.0;
  
    # This is the name of the file the boot ROMs should download.
    filename "pxelinux.0";
  }
  
  # Provide Etherboot clients with appropriate information
  class "etherboot" {
    match if substring(option vendor-class-identifier, 0, 9) = "Etherboot";
    filename "vmlinuz_arch";
  }
  
  # Add one host declaration for each diskless host
  host slave21 {
    hardware ethernet 00:02:A5:04:3B:66;
    fixed-address 192.168.1.21;
  }
}
}}

{{Note|There is nothing prohibiting the use of both PXE boot and Etherboot together. The above Code Listing is merely an example; if there are issues, please consult the DHCPd documentation.}}

The IP address after <code>next-server</code> will be asked for the specified <code>filename</code>. This IP address should be the IP of the tftp server, usually the same as the master's IP address. The <code>filename</code> is relative to the {{Path|/diskless}} directory (this is due to the tftp server specific options which will be covered later). Inside the <code>host</code> block, the <code>hardware ethernet</code> option specifies a MAC address, and <code>fixed-address</code> assigns a fixed IP address to that particular MAC address. There is a pretty good man page on {{Path|dhcpd.conf}} with options that are beyond the scope of this HOWTO. The man page can be read by typing: 

{{Cmd|man dhcpd.conf}}

=== DHCP 서버 시작하기 ===

Before starting the dhcp initialization script edit the {{Path|/etc/conf.d/dhcp}} file so that it looks something like this: 

{{CodeBox|title=Sample {{Path|/etc/conf.d/dhcp}}|lang=bash|1=
IFACE="eth0"
# Insert any customizations needed
}}

The <code>IFACE</code> variable is the device that the DHCP server will be running on, in this case <code>eth0</code>. Adding more arguments to the <code>IFACE</code> variable can be useful for a complex network topology with multiple Ethernet cards. To start the dhcp server type: 

{{RootCmd|/etc/init.d/dhcpd start}}

dhcp 서버를 시작 스크립트로 추가하려면 다음 명령을 입력하십시오: 

{{RootCmd|rc-update add dhcpd default}}

=== DHCP 서버 문제 해결 ===

To see if a node boots, take a look at {{Path|/var/log/messages}}. If the node successfully boots, the {{Path|messages}} file should have some lines at the bottom looking like this: 

{{CodeBox|title=Sample log file entries created by dhcp|<pre>
DHCPDISCOVER from 00:00:00:00:00:00 via eth0
DHCPOFFER on 192.168.1.21 to 00:00:00:00:00:00 via eth0
DHCPREQUEST for 192.168.1.21 from 00:00:00:00:00:00 via eth0
DHCPACK on 192.168.1.21 to 00:00:00:00:00:00 via eth0
</pre>
}}

{{Note|This log file can also help in discovering the slaves' MAC addresses.}}

If the following message is encountered it probably means there is something wrong in the configuration file but that the DHCP server is broadcasting correctly. 

{{CodeBox|title=Sample dhpc server error|1=
no free leases on subnet LOCAL-NET
}}

Every time after changing the configuration file the DHCP server must be restarted. To restart the server type: 

{{RootCmd|/etc/init.d/dhcpd restart}}

== TFTP 서버와 PXE 리눅스 부트로더 또는 Etherboot 설정 ==

=== TFTP 서버 알아보기 ===

TFTP는 단순 파일 전송 프로토콜(Trivial File Transfer Protocol)을 의미합니다. TFTP 서버는 슬레이브의 커널과 초기 파일 시스템을 실어나릅니다. 모든 슬레이브 커널과 파일 시스템은 TFTP 서버에 저장하기 때문에, 마스터를 TFTP 서버로 만드는 것이 바람직합니다. 

=== TFTP 서버 설치 ===

가장 추천하는 tftp 서버는 tftp-hpa 패키지입니다. 이 tftp 서버는 SYSLINUX를 만든 사람이 만들었으며 pxelinux와 가장 잘 동작합니다. 설치하려면 다음과 같이 간단하게 입력하십시오: 

{{Emerge|tftp-hpa}}

=== TFTP 서버 설정 ===

Edit {{Path|/etc/conf.d/in.tftpd}}. The tftproot directory needs to specified with <code>INTFTPD_PATH</code> and any command line options with <code>INTFTPD_OPTS</code>. It should look something like this: 

{{FileBox|filename=/etc/conf.d/in.tftpd|lang=bash|1=
INTFTPD_PATH="/diskless"
INTFTPD_OPTS="-l -v -s ${INTFTPD_PATH}"
}}

The <code>-l</code> option indicates that this server listens in stand alone mode so inetd does not have to be run. The <code>-v</code> indicates that log/error messages should be verbose. The <code>-s /diskless</code> specifies the root of the tftp server.

=== TFTP 서버 시작하기 ===

tftp 서버를 시작하려면 다음 명령을 입력하십시오: 

{{RootCmd|/etc/init.d/in.tftpd start}}

This should start the tftp server with the options that were specified in the {{Path|/etc/conf.d/in.tftpd}}. If this server is to be automatically started at boot type: 

{{RootCmd|rc-update add in.tftpd default}}

=== PXELINUX 알아보기 ===

This section is not required if only Etherboot is being used. PXELINUX is the network bootloader equivalent to LILO or GRUB and will be served via TFTP. It is essentially a tiny set of instructions that tells the client where to locate its kernel and initial filesystem and allows for various kernel options. 

=== Before getting started ===

Now the file pxelinux.0 is required, which comes in the SYSLINUX package by H. Peter Anvin. This package can be installed by typing: 

{{Emerge|syslinux}}

=== PXELINUX 설정 ===

{{Note/ko|Etherboot는 필요하지 않습니다.}}

Before starting the tftp server pxelinux needs to be set up. First copy the pxelinux binary into the {{Path|/diskless}} directory: 

{{RootCmd|cp /usr/share/syslinux/pxelinux.0 /diskless
|mkdir /diskless/pxelinux.cfg
|touch /diskless/pxelinux.cfg/default}}

이 과정에서 기본 부트로더 설정 파일을 만듭니다. 16진수 클라이언트 IP 주소로 된 파일이 있는지 {{Path|pxelinux.0}} 바이너리에서 {{Path|pxelinux.cfg}} 디렉터리를 찾아봅니다. 파일이 없다면 파일 이름의 가장 오른쪽 자리를 지우고, 숫자가 바닥날 때까지 계속 찾습니다. 2.05 이상의 syslinux에서는 먼저 MAC 주소 다음의 파일 이름에 대해 검색을 수행합니다. 찾은 파일이 없다면, 앞서 언급한 발견 루틴을 따라갑니다. 발견한 파일이 없다면 {{Path|default}} 파일을 사용합니다. 

{{CodeBox|title=Files that PXE looks for in {{Path|pxelinux.cfg/}} in sequence|1=
## (Leading 01 means Ethernet, next bytes match our slave's MAC address)
01-00-40-63-c2-ca-c9
  
## (Assigned IP in hexadecimal)
C0A80115
C0A8011
C0A801
C0A80
C0A8
C0A
C0
C
  
default
}}

{{Note/ko|모두 소문자로 입력해야 합니다.}}

{{Path|default}} 파일로 시작해보겠습니다: 

{{CodeBox|title=Sample {{Path|pxelinux.cfg/default}}|1=
DEFAULT gentoo
LABEL gentoo
LINUX /bzImage
APPEND ip=dhcp root=/dev/nfs nfsroot=192.168.1.1:/diskless/192.168.1.21
}}

The <code>DEFAULT</code> tag directs pxelinux to the kernel bzImage that was compiled earlier. The <code>APPEND</code> tag appends kernel initialisation options. Since the slave kernel was compiled with <code>NFS_ROOT_SUPPORT</code> , the nfsroot will be specified here. The first IP is the master's IP and the second IP is the directory that was created in {{Path|/diskless}} to store the slave's initial filesystem.

=== Etherboot 알아보기 ===

{{Note|This isn't required if PXE boot is being used.}}

Etherboot boots network boot images from a TFTP server. As the PXE this is equivalent to LILO or GRUB. The <code>mknbi</code> utility enables the creation of different images using different options. 

=== Before getting started ===

The <code>mknbi</code> (utility for making tagged kernel images useful for netbooting) package is needed to create the Etherboot images. This tool will create a preconfigured kernel image from the original kernel. This contains the boot options as shown further down. 

{{Emerge|mknbi}}

=== Etherboot 설정 ===

In this section a simple etherboot image will be created. As the dhcp server gives out the clients root-path in the "option root-path" dhcp.conf, this does not have to be included here. More details can be found in the mknbi manual. 

{{Cmd|man mknbi}}

부팅 이미지를 만들겠습니다. DHCP에서 전달할 수 있는 ELF 부팅 이미지를만들고 커널의 루트 경로에 넣겠습니다. 또한 커널에서 네트워크 상의 DHCP 서버를 탐색하도록 커널에 지시합니다. 

{{RootCmd|mkelf-linux -ip{{=}}dhcp /diskless/bzImage > /diskless/vmlinuz }}

{{Note|For the arch specific images <code>bzImage_arch</code> and <code>vmlinuz_arch</code> have to be typed.}}

=== 네트워크 부팅 과정 문제 해결 ===

There are a few things that can be done to debug the network boot process. Primarily a tool called <code>tcpdump</code> can be used. To install <code>tcpdump</code> type: 

{{Emerge|tcpdump}}

Now various network traffic can be listened to, to make sure the client/server interactions are functioning. If something isn't working there are a few things that could be checked. First make sure that the client/server is physically connected properly and that the networking cables are not damaged. If the client/server is not receiving requests on a particular port make sure that there is no firewall interference. To listen to interaction between two computers type: 

{{RootCmd|tcpdump host_client_ip and server_ip}}

The <code>tcpdump</code> command can also be configured to listen on particular port such as the tftp port by typing: 

{{RootCmd|tcpdump port 69}}

A common error that might be received is: "PXE-E32: TFTP open time-out". This is probably due to firewall issues. If <code>TCPwrappers</code> is being used, it might be worth checking {{Path|/etc/hosts.allow}} and {{Path|etc/hosts.deny}} and make sure that they are configured properly. The client should be allowed to connect to the server.

== NFS 서버 설정 ==

=== NFS 서버 알아보기 ===

NFS stands for Network File System. The NFS server will be used to serve directories to the slave. This part can be somewhat personalized later, but right now all that is wanted is a preliminary slave node to boot diskless. 

=== 포트매퍼 알아보기 ===

여러 클라이언트/서버 서비스에서는 각각의 포트에 대한 포트를 감청하지 않지만 RPC(원격 프로시저 호출)에 의존합니다. 서비스를 초기화하면 임의의 포트를 감청하며 이 포트를 포트매퍼 유틸리티에 할당합니다. NFS는 RPC에 의존하기 때문에 NFC를 시작하기 전에 포트매퍼를 실행해야 합니다. 

=== Before starting ===

The NFS Server needs kernel level support so if the kernel does not have this, the master's kernel needs to be recompiled. To double check the master's kernel configuration type: 

{{RootCmd|grep NFS /usr/src/linux/.config_master}}

The output should look something like this if the kernel has been properly configured: 

{{KernelBox|title=Proper NFS specific options in the master's kernel configuration|<pre>
CONFIG_PACKET=y
# CONFIG_PACKET_MMAP is not set
# CONFIG_NETFILTER is not set
CONFIG_NFS_FS=y
CONFIG_NFS_V3=y
# CONFIG_NFS_V4 is not set
# CONFIG_NFS_DIRECTIO is not set
CONFIG_NFSD=y
CONFIG_NFSD_V3=y
# CONFIG_NFSD_V4 is not set
# CONFIG_NFSD_TCP is not set
</pre>
}}

=== NFS 서버 설치 ===

다음 명령을 입력하면 포티지를 통해 NFS 패키지를 설치할 수 있습니다: 

{{Emerge|nfs-utils}}

이 패키지는 포트매핑 유틸리티, NFS 서버, NFS 클라이언트 유틸리티를 이머지하며, 의존성 초기화를 자동으로 처리합니다. 

=== NFS 서버 설정 ===

There are three major configuration files that will have to be edited: 

{{CodeBox|title=Nfs configuration files|1=
/etc/exports
/diskless/192.168.1.21/etc/fstab
/etc/conf.d/nfs
}}

{{Path|/etc/exports}} 파일은 어떻게 누구에게 무얼 NFS를 통해 내보낼 것인지 지정합니다. 슬레이브의 fstab의 내용이 바뀌어서 마스터가 내보내는 NFS 파일 시스템에 마운트할 수 있게 됩니다. 

보통 마스터의 {{Path|/etc/exports}}는 다음과 같습니다: 

{{FileBox|filename=/etc/exports|title=master exports file|1=
# one line like this for each slave
/diskless/192.168.1.21   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
# common to all slaves
/opt   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/usr   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/home  192.168.1.0/24(sync,rw,no_root_squash,no_all_squash)
# if you want to have a shared log
/var/log   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
}}

첫번째 내용은 내보낼 디렉터리고, 다음 내용은 누구에게 어떻게 내보낼 것인지를 나타냅니다. 이 내용은 각각의 디렉터리에 누가 마운트할 수 있어야 하는지, 마운트한 클라이언트가  파일 시스템에서 할 수 있는 일은 무엇인지 두 부분으로 나뉩니다. <code>ro</code>는 읽기 전용을 의미하고 <code>rw</code>는 읽기/쓰기를 의미합니다. <code>no_root_squash</code>와 <code>no_all_squash</code> 옵션은 디스크에 기록하는 무 디스크 클라이언트에 중요하므로 입출력 요청이 나타나면 "압축"하지 않습니다. 슬레이브의 {{Path|/diskless/192.168.1.21/etc/fstab}} 파일은 다음과 같아야 합니다: 

{{CodeBox|title=Sample slave {{Path|fstab}}|1=
# these entries are essential
master:/diskless/192.168.1.21   /         nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
master:/opt                     /opt      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/usr                     /usr      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/home                    /home     nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
none                            /proc     proc    defaults                                     0 0
# useful but superfluous
master:/var/log                 /var/log  nfs     hard,intr,rw                                 0 0
}}

In this example, ''master'' is just the hostname of the master but it could easily be the IP of the master. The first field indicates the directory to be mounted and the second field indicates where. The third field describes the filesystem and should be NFS for any NFS mounted directory. The fourth field indicates various options that will be used in the mounting process (see mount(1) for info on mount options). Some people have had difficulties with soft mount points so here they are made hard mounts, a look into various {{Path|/etc/fstab}} options should be done to make the cluster more efficient. 

The last file that should be edited is {{Path|/etc/conf.d/nfs}} which describes a few options for nfs when it is initialised and looks like this: 

{{CodeBox|title=Sample master {{Path|/etc/conf.d/nfs}}|1=
# Config file for /etc/init.d/nfs
  
# Number of servers to be started up by default
RPCNFSDCOUNT=8
  
# Options to pass to rpc.mountd
RPCMOUNTDOPTS=""
}}

The <code>RPCNFSDCOUNT</code> should be changed to the number of diskless nodes on the network. 

=== NFS 서버 시작하기 ===

The nfs server should be started with its init script located in {{Path|/etc/init.d}} by typing: 

{{RootCmd|/etc/init.d/nfs start}}

If this script is to be started every time the system boots simply type: 

{{RootCmd|rc-update add nfs default}}

== 슬레이브 파일 시스템 완성하기 ==

=== 빠진 파일 복사 ===

Now the slave's file system will be made in sync with the master's and provide the necessary binaries while still preserving slave specific files. 

{{RootCmd|rsync -avz /bin /diskless/192.168.1.21
|rsync -avz /sbin /diskless/192.168.1.21
|rsync -avz /lib /diskless/192.168.1.21}}

{{Note/ko|cp 대신 rsync -avz를 사용하는 이유는 심볼릭 링크와 권한을 유지하기 위함입니다.}}

=== 무디스크 네트워크 설정 ===

In order to prevent the networking initscript from killing the connection to the NFS server, an option needs to be added to {{Path|/etc/conf.d/net}} on the diskless client's filesystem. 

{{CodeBox|title=Editing {{Path|/etc/conf.d/net}}|1=
config_eth0=( "noop" )
}}

{{Note/ko|더 많은 정보는 {{Path|/usr/share/doc/openrc-*/net.example.bz2}}를 읽어보십시오}}

=== 초기화 스크립트 ===

Init scripts for slaves are located under {{Path|/diskless/192.168.1.21/etc/runlevels}} for services needed on the diskless nodes. Each slave can be set up and customized here, it all depends on what each slave is meant to do. 

{{Warning|Do not use the <code>rc-update</code> program to add or remove scripts from the slave runlevels when logged on to the master. This would change the master runlevels. The links need to be manually created or by logging into the slave nodes using ssh or connecting a screen and keyboard to the slave.}}

{{CodeBox|title=Typical slave runlevels|1=
/diskless/192.168.1.21/etc/runlevels/:
total 16
drwxr-xr-x    2 root     root         4096 2003-11-09 15:27 boot
drwxr-xr-x    2 root     root         4096 2003-10-01 21:10 default
drwxr-xr-x    2 root     root         4096 2003-03-13 19:05 nonetwork
drwxr-xr-x    2 root     root         4096 2003-02-23 12:26 single
  
/diskless/192.168.1.21/etc/runlevels/boot:
total 0
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 bootmisc -> /etc/init.d/bootmisc
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 checkfs -> /etc/init.d/checkfs
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 domainname -> /etc/init.d/domainname
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 hostname -> /etc/init.d/hostname
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 localmount -> /etc/init.d/localmount
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 modules -> /etc/init.d/modules
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 net.lo -> /etc/init.d/net.lo
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 netmount -> /etc/init.d/netmount
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 rmnologin -> /etc/init.d/rmnologin
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 urandom -> /etc/init.d/urandom
  
/diskless/192.168.1.21/etc/runlevels/default:
total 0
lrwxrwxrwx    1 root     root           23 2003-10-18 17:28 consolefont -> /etc/init.d/consolefont
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 distccd -> /etc/init.d/distccd
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 keymaps -> /etc/init.d/keymaps
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 sshd -> /etc/init.d/sshd
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 syslog-ng -> /etc/init.d/syslog-ng
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 vixie-cron -> /etc/init.d/vixie-cron
  
/diskless/192.168.1.21/etc/runlevels/nonetwork:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
  
/diskless/192.168.1.21/etc/runlevels/single:
total 0
}}

Now is a good time to boot the slave and cross some fingers. It works? Congratulations, you are now the proud owner of (a) diskless node(s).

{{Migrated|originalauthors=Michael Andrews, Kristian Jerpetjoen, Sven Vermeulen, Xavier Neys}}
