<languages />

{{Metadata|abstract=В этом документе описано использование общих ключей SSH вместе с программой keychain. Предполагается базовое знание криптографии с открытым ключом.}}

В этом документе описано использование общих ключей SSH вместе с программой keychain. Предполагается базовое знание криптографии с открытым ключом.

== Основы ==

=== Рассматриваемая проблема ===

Необходимость вводить логин и пароль для каждого в каждой системе неудобна, особенно если под управлением находится множество систем. У некоторых администраторов, возможно, даже имеется скрипт или cron-задача, которые упрощают использование ssh соединения. Так или иначе, у этой проблемы есть решение, и оно начинается с аутентификации с открытым ключом. 

=== Как работает аутентификация с открытым ключом? ===

Предположим, что клиент хочет соединится с ssh демоном на сервере. Клиент сначала генерирует пару ключей и пересылает открытый ключ на сервер. Затем, когда бы клиент ни пытался соединиться с сервером, сервер отправляет послание, которое зашифровано с помощью открытого ключа. Только обладатель соответствующего закрытого ключа (т.е. клиент) способен его расшифровать, так что, правильный ответ ведет к успешной аутентификации. 

== Как использовать аутентификацию с открытым ключом ==

=== Генерация ключевой пары ===

Сперва необходимо создать ключевую пару. Для того, чтобы это сделать, используйте команду <tt>ssh-keygen</tt>: 

{{Cmd|ssh-keygen}}

Примите значения по умолчанию, и удостоверьтесь, что ввели надежную фразу-пароль.

{{Warning|Убедитесь, что выбрали надежную фразу-пароль, особенно если этот ключ используется для входа под root!}}

После завершения генерации закрытый ключ должен быть в {{Path|~/.ssh/id_rsa}} и открытый ключ в {{Path|~/.ssh/id_rsa.pub}}. Открытый ключ теперь готов для копирования на удаленный хост.

=== Подготовка сервера ===

Файл {{Path|~/.ssh/id_rsa.pub}} необходимо скопировать на сервер, на котором запущен <tt>sshd</tt>. Он должен быть добавлен в файл {{Path|~/.ssh/authorized_keys}}, который принадлежит соединяющемуся пользователю на удаленном сервере. После предоставления персоналом инфраструктуры <tt>ssh</tt> доступа к серверу, следующие шаги могут быть использованы для настройки автоматического входа с использованием открытого ключа на удаленный сервер:

{{Cmd|scp ~/.ssh/id_rsa.pub server_user@server:~/myhost.pub
|ssh server_user@server "cat ~/myhost.pub &gt;&gt; ~/.ssh/authorized_keys"
|ssh server_user@server "cat ~/.ssh/authorized_keys"}}

Вывод команды из последней строки должен отобразить содержимое файла {{Path|~/.ssh/authorized_keys}}. Убедитесь, что этот вывод выглядит корректно.

=== Тестирование настройки ===

В теории, если все прошло правильно, и <tt>ssh-демон</tt> на сервере это позволяет (как это может быть настроено), <tt>ssh</tt> доступ к серверу без ввода пароля должен быть сейчас возможен. Закрытый ключ клиента все равно будет необходимо дешифровать фразой-паролем, используемой ранее, но её не следует путать с паролем учетной записи пользователя на сервере.

{{Cmd|ssh <server_user>@<server>}}

Такая команда должна запросить фразу-пароль для {{Path|id_rsa}}, а затем предоставить доступ к серверу через <tt>ssh</tt> как пользователю <code><server_user></code>. Если это не так, зайдите как <code><server_user></code>, и проверьте содержимое в {{Path|~/.ssh/authorized_keys}}, что каждая запись (публичный ключ) находится на отдельной строке. Также будет хорошей идеей проверить конфигурацию sshd для того, чтобы убедиться что он позволяет использование авторизации с открытым ключом, когда это доступно.

В этом месте, читающий возможно подумает: "Какая разница, я просто заменил один пароль на другой?!" Успокойтесь, в следующем разделе будет продемонстрировано, как мы можем использовать это, чтобы вводить фразу-пароль только один раз и повторно использовать (расшифрованный) ключ для многократного входа.

== Как сделать аутентификацию с открытым ключом удобной ==

=== Обычное управление ключами с помощью ssh-agent ===

Далее необходимо расшифровать закрытый ключ(и) один раз, и получить возможность свободно соединяться по ssh, без каких-либо паролей. Это как раз то, для чего предназначена программа <tt>ssh-agent</tt>. 

<tt>ssh-agent</tt> обычно запускается вначале X-сессии, или из сценария запуска оболочки, например {{Path|~/.bash_profile}} . Она работает путем создания доменного сокета Unix и регистрации подходящих переменных среды, так чтобы все последующие приложения могли воспользоваться ее сервисами, подсоединяясь к этому сокету. Очевидно, имеет смысл запускать ее только в родительском процессе X-сессии для использования набора расшифрованных закрытых ключей во всех последующих X-приложениях. 

{{Cmd|eval `ssh-agent`}}

{{Note|Этот <tt>ssh-agent</tt> будет хранить ключи расшифрованными пока он работает. Чтобы установить время существования ключей, используйте параметр <code>-t</code>, как описано в <tt>man ssh-agent</tt>.}}

При запуске, <tt>ssh-agent</tt> он должен сообщить PID запущенного ssh-agent, и также установить несколько переменных среды, а именно <code>SSH_AUTH_SOCK</code> и <code>SSH_AGENT_PID</code> . Он также должен автоматически добавить {{Path|~/.ssh/id_rsa}} к своему набору и запросить у пользователя соответствующую фразу-пароль. Если есть другие закрытые ключи, которые необходимо добавить к запущенному ssh-agent, то используйте команду <tt>ssh-add</tt>: 

{{Cmd|ssh-add somekeyfile}}

А теперь начинается магия. С готовым расшифрованным закрытым ключом, Вы можете получить доступ к серверу (с настроенным открытым ключом) по ssh без ввода какого-либо пароля: 

{{Cmd|ssh server}}

Для того, чтобы выключить SSH-агент (после чего снова потребуется вводить фразу-пароль позже):

{{Cmd|ssh-agent -k}}

{{Note|It is possible to have multiple <tt>ssh-agent</tt> processes running, especially when configuring it initially took some effort and trials. These processes can be killed like any other process by running <tt>killall ssh-agent</tt>.}}

Чтобы с ssh-agent было еще более удобней работать, продолжайте читать следующую главу, описывающую использование keychain. Убедитесь, что завершили запущенный ssh-agent, так как keychain обрабатывает сессии <tt>ssh-agent</tt> самостоятельно.

=== Выжимание последней капли удобства из ssh-agent ===

Keychain позволит использовать ssh-agent заново между входами в систему, и, дополнительно, запрашивать фразу-пароль каждый раз, когда входит пользователь. Давайте сначала установим его:

{{Emerge|keychain}}

Если предположить, что установка прошла успешно, то <tt>keychain</tt> уже можно использовать. Добавьте следующее в файл {{Path|~/.bash_profile}}, для того, чтобы включить его: 

{{CodeBox|title=Обеспечение доступа к keychain в .bash_profile|<pre>
keychain ~/.ssh/id_rsa
. ~/.keychain/$HOSTNAME-sh
. ~/.keychain/$HOSTNAME-sh-gpg
</pre>
}}

{{Note|Большее количество закрытых ключей можно добавить  в командной строке, по желанию. Также, если хотите чтобы запрашивало фразу-пароль каждый раз, когда открывается оболочка, добавьте параметр <code>--clear</code>.}}

{{Note|Если не используется оболочка bash, проверьте раздел '''EXAMPLES''' <tt>man keychain</tt> для поиска примеров использования в других оболочках. Основной идеей является запуск этих команд каждый раз, когда используется оболочка.}}

Теперь протестируем это. Сперва, убедитесь, что завершен процесс ssh-agent из предыдущего раздела, затем откройте новую оболочку, обычно простым входом, или открытием нового эмулятора терминала. Должен быть запрошен пароль для каждого ключа, который был указан в командной строке. Все оболочки открытые после этого, должны использовать ssh-agent заново, позволяя использовать беспарольное ssh соединение снова и снова. 

=== Использование keychain с KDE ===

KDE пользователи, вместо использования {{Path|~/.bash_profile}}, могут позволить KDE управлять программой ssh-agent за место них. Для того, чтобы это сделать, необходимо отредактировать файл {{Path|/etc/kde/startup/agent-startup.sh}}, который читается во время запуска KDE, и {{Path|/etc/kde/shutdown/agent-shutdown.sh}}, который запускается во время закрытия KDE. Здесь показано, как можно отредактировать эти файлы: 

{{CodeBox|title=Редактирование /etc/kde/startup/agent-startup.sh|1=
if [ -x /usr/bin/ssh-agent ]; then
  eval "$(/usr/bin/ssh-agent -s)"
fi
}}

{{CodeBox|title=Редактирование /etc/kde/shutdown/agent-shutdown.sh|1=
if [ -n "${SSH_AGENT_PID}" ]; then
  eval "$(ssh-agent -k)"
fi
}}

Теперь, все, что необходимо сделать, это запустить эмулятор терминала по вкусу, например Konsole, и загрузить нужную связку ключей для использования. Например: 

{{Cmd|keychain ~/.ssh/id_rsa}}

Ключи будут запомнены до окончания KDE сессии (или пока не завершите процесс ssh-agent вручную).

== Завершающие примечания ==

=== Соображения безопасности ===

Of course, the use of ssh-agent may add a bit of insecurity to the system. If another user would gain access to a running shell, he could login to all of the servers without passwords. As a result, it is a risk to the servers, and users should be sure to consult the local security policy (if any). Be sure to take the appropriate measures to ensure the security of all sessions. 

=== Устранение проблем ===

Большинство из описанного должно работать хорошо, но если все-таки столкнулись с проблемами, то следующие пункты могут помочь. 

* Если не можете соединиться без <tt>ssh-agent</tt>, попробуйте использовать ssh с опцией <code>-vvv</code>, чтобы узнать что произошло. Иногда, сервер не настроен для использования аутентификации с открытым ключом, иногда он настроен на запрашивание локальных паролей в любом случае! Если это как раз тот самый случай, попробуйте использовать с <tt>ssh</tt> параметр <code>-o</code>, или изменить файл конфигурации {{Path|sshd_config}} на сервере.
* Если подключение при использовании <tt>ssh-agent</tt> или <tt>keychain</tt> не работает, то это может быть потому что используемая командная оболочка не понимает используемые команды. Проконсультируйтесь с man-страницами для программ ssh-agent и keychain для поиска подробностей по работе с другими оболочками.

== Внешние ресурсы ==

* [http://www.funtoo.org/Keychain Официальная страница проекта]
* [http://www.funtoo.org/OpenSSH_Key_Management,_Part_1 Серия статей IBM developerWorks] описывающая концепции, стоящие за Keychain


{{Migrated|originalauthors=Eric Brown, Marcelo Goes, nightmorph}}

[[Category:Server and Security]] 
[[Category:SSH]]
