<languages />


{{Metadata|abstract=Целью данного документа является ознакомление с понятием конфигурации ядра вручную и разбор наиболее распространённых проблем.}}

Целью данного документа является ознакомление с понятием конфигурации ядра вручную и разбор наиболее распространённых проблем.

== Введение ==

Gentoo предоставляет два способа настройки конфигурационного файла, установки и обновления ядра: ''автоматический'' (genkernel) и ''вручную''. Несмотря на то, что автоматический метод может показаться ''простым'' для большинства пользователей, существует ряд причин, по которым достаточно большой процент пользователей выбирает настройку ядра вручную:

# Большая свобода
# Меньший размер ядра
# Быстрая компиляция
# Удовольствие от обучения
# Всепоглащающая скука
# Абсолютные знания об устройстве ядра и/или
# Тотальный контроль

В этом руководстве не охватывается автоматический способ конфигурации ядра (genkernel). Если для компиляции и установки ядра предпочтительным является использование genkernel, следует обратиться к [[Genkernel/ru|документации Genkernel]]. 

Данное руководство не стремится задокументировать процесс конфигурации вручную от начала до конца, поскольку он опирается на определенную долю здравого смысла и относительно высокий уровень знаний о системе. Вместо этого, руководство раскрывает основные представления о конфигурации ядра вручную и достаточно подробное описание наиболее распространенных подводных камней, с которыми сталкиваются пользователи. 

{{Note|Данный документ написан с рассчётом на достаточно современные версии ядер и использование наиболее распространённых архитектур. Некоторые вещи разнятся на старых версиях ядра или более экзотичных архитектурах, но львиная доля приведённой ниже информации всё же будет применима.}}

На данный момент предполагается, что исходный код ядра Linux распакован на жёсткий диск (как правило в {{Path|/usr/src}}), а читатель обладает навыками работы с {{c|menuconfig}} и системой меню на базе ncursers. В случае, если данный уровень не достигнут, то, прежде чем продолжить, следует ознакомиться со следующими статьями:

* [[Kernel/Overview/ru|Обзор различных версий исходного кода ядра Linux]] содержит информацию о различных версиях исходного кода ядра, предоставляемого деревом Portage.
* [[Kernel/Upgrade/ru|Инструкция по обновлению ядра]] показывает, как обновить ядро или же сменить версию.
* Gentoo Handbook's [[Handbook:Main_Page/ru|секция, посвящённая настройке ядра]] покрывает некоторые аспекты установки. Выберите нужную архитектуру и перейдите по ссылке "Настройка ядра Linux".

== Основные понятия конфигурации ==

=== Основные идеи ===

Общий процесс достаточно прост: предлагаются несколько возможностей на выбор, распределенные по категориям в отдельные меню и подменю, в которых можно выбрать поддержку аппаратного обеспечения и функций ядра, подходящие для системы.

Ядро включает ''конфигурацию по умолчанию'', которая активирует отдельные части исходного кода ядра во время первого запуска команды menuconfig. В целом, предлагается широкий выбор разумных значений по умолчанию, что означает, что большинству пользователей потребуется только внести небольшое количество изменений в основную конфигурацию. Если необходимо отключить параметр, который был включен по умолчанию, убедитесь что вы хорошо понимаете что в точности делает данный параметр и последствия его отключения. 

При конфигурации ядра Linux в первый раз, следует придерживаться умеренных настроек и вносить так мало изменений в основные настройки, насколько это возможно. В то же время, следует учитывать, что существуют определенные настройки, которые необходимо изменить, чтобы система действительно могла загружаться.

=== Сравнение встроенных в ядро параметров и загружаемых модулей ядра ===

Большинство параметров конфигурации могут находиться в трех состояниях: они могут быть как отключены вовсе <code>(N)</code>, встроены прямо в ядро <code>(Y)</code>, или собраны в качестве модулей <code>(M)</code>. Модули хранятся вне ядра на файловой системе, в то время как встроенные компоненты встраиваются прямо в образ ядра. 

Между [[Kernel Modules|встроенными и модулями]] существует важное различие: за некоторыми исключениями, ядро не предпринимает каких-либо попыток загрузить внешние модули, если они нужны системе; это задача пользователя решать, когда загружать модуль. В то время как определенные части системы могут иметь возможность загрузки модулей по требованию и доступны несколько утилит для автоматической загрузки модулей, рекомендуется включение поддержки аппаратного обеспечения и функций ядра непосредственно в само ядро. В этом случае, ядро может гарантировать функциональность и поддержку аппаратного обеспечения при необходимости. Это можно сделать, установив (Y) для каждой необходимой функции ядра. Для этого также требуется включить поддержку встраиваемого (firmware) программного обеспечения в ядре. Включите <code>FW_LOADER=y</code> и <code>CONFIG_FIRMWARE_IN_KERNEL=y</code> в конфигурационном файле ядра {{Path|.config}} или следующее в {{c|menuconfig}}:

{{KernelBox|title=Включение firmware в ядро|
Device Drivers  --->
   Generic Driver Options  --->
       -*- Userspace firmware loading support
       [*] Include in-kernel firmware blobs in kernel binary
}}

С некоторыми настройками, встроенные фунции являются абсолютной необходимостью. Например, если раздел root расположен на файловой системе btrfs, система не загрузится, если поддержка btrfs была построена в качестве модуля. Системе потребуется обратиться к разделу root чтобы найти модуль btrfs (если модули хранятся на root разделе), но обращения не произойдет до тех пор, пока модуль btrfs не будет загружен! Если поддержка btrfs не была встроена в ядро, init-процесс потерпит неудачу при поиске корневого устройства.

=== Поддержка аппаратного обеспечения ===

Помимо обнаружения ''типа архитектуры'' системы, утилита конфигурации не предпринимает попыток обнаружить какое аппаратное обеспечение имеется на системе. В то время как для ''некоторого'' типа аппаратного обеспечения имеются настройки по умолчанию, пользователю почти наверняка потребуется найти и выбрать параметры конфигурации, подходящие для аппаратного обеспечения в каждой системе. 

Для правильного выбора опций требует знание внутренних компонентов системы и компонентов, подключенных к компьютеру. В большинстве случаях компоненты могут быть определены без снятия крышки компьютера. Для большинства внутренних компонент, необходимо определить ''чипсет'', используемый для каждого устройства, вместо названия компонента на розничном рынке. Множество карт расширения, продаваемые под определенной торговой маркой, могут использовать чип от другого производителя.

Доступны несколько вспомогательных утилит, которые помогут пользователям определить, какие варианты конфигурации ядра лучше использовать. {{c|lspci}} (часть пакета {{Package|sys-apps/pciutils}}) определяет аппаратное обеспечение, основанное на PCI и AGP, включая компоненты, встроенные в материнскую плату. {{c|lsusb}} (из пакета {{Package|sys-apps/usbutils}}) определяет различные устройства, подсоединенные к USB портам. 

Положение в некотором смысле запутывается изменяющейся степенью стандартизации аппаратного обеспечения. До тех пор, пока не происходит сильных отклонения от значений по умолчанию, жесткие диски IDE должны "просто работать", как и PS/2 или USB-клавиатура и мышь. Базовая поддержка дисплея VGA также будет включена. Однако, некоторые устройства, такие как адаптеры ethernet, едва стандартизированы, поэтому чтобы получить доступ к сети, потребуется идентифицировать чипсет ethernet и выбрать подходящую поддержку для сетевой платы.

Кроме того, в то время как некоторые вещи просто работают с настройками по умолчанию, порой, необходимо выбрать более индивидуальные параметры, чтобы извлечь полный потенциал из системы. Например, если поддержка правильного чипсета IDE отключена, жесткие диски будут работать ''очень'' медленно.

=== Функции ядра ===

Помимо аппаратного обеспечения, необходимо также задуматься об особенностях программного обеспечения, поддержка которого необходима в ядре. Одним из важных примеров такой функции является поддержка файловой системы: необходимо выбрать поддерживаемые файловые системы для использования на жестком диске, а также любые другие файловые системы, которые могут находится на устройствах внешнего хранения (например, VFAT на флеш-накопителях USB). 

Другим распространенным примером функции программного обеспечения является расширенная функциональность сети. При необходимости включить маршрутизацию или межсетевую фильтрацию, соответствующие настройки должны быть включены в файл конфигурации ядра. 

=== Готовы? ===

После ознакомления с базовыми понятиями уже можно достаточно просто определить аппаратное обеспечение, просматривать интерфейс menuconfig и выбирать требуемые параметры ядра для системы. 

Остальная часть этого руководства направлена на разъяснение областей часто вызывающих затруднения и объяснение как избежать общих проблем, с которыми сталкиваются пользователи. Успехов!

== Распространенные проблемы и затруднения ==

=== SATA-диски являются дисками SCSI ===

Большинство современных настольных систем поставляются с запоминающими устройствами (жесткий диск и приводы CD/DVD) на шине [https://en.wikipedia.org/wiki/SATA Serial ATA], вместо более старой шины [https://en.wikipedia.org/wiki/Parallel_ATA IDE] (резиновый кабель). 

Поддержка SATA в Linux реализована через слой, называемый ''libata'', который располагается уровнем ниже подсистемы SCSI. По этой причине, драйвера SATA находятся в разделе конфигурации с драйверами SCSI. Кроме того, устройства хранения данных могут обрабатываться как SCSI-устройства, а это значит, что необходима поддержка SCSI диска или cdrom. Первый жесткий диск SATA, будет иметь название {{Path|/dev/sda}}, а первый привод CD/DVD — {{Path|/dev/sr0}}. 

Хотя большинство этих драйверов предназначено для контроллеров SATA, libata не была предназначена только для SATA. Все распространенные драйвера IDE будут также портированы на libata в ближайшем будущем, и, на тот момент, вышеупомянутые рассмотрения также будут применимы и к пользователям IDE. 

{{KernelBox|title=Параметры конфигурации для libata|1=
Device Drivers  --->
   SCSI device support  --->
      <*> SCSI device support
      <*> SCSI disk support
      <*> SCSI CDROM support
 
      [ ] SCSI low-level drivers  --->
 
   <*> Serial ATA and Parallel ATA drivers (libata)  --->
}}

{{Note|Non-standard chipset(s) are listed under "SCSI low-level drivers" in the ''Configuration options for libata'' kernel box above.}}

=== Чипсеты IDE и DMA ===

Вопреки появлению SATA, устройства IDE все еще являются очень распространенными, и от них зависят многие части системы. IDE является достаточно общей технологией и, таким образом, Linux поддерживает почти все контроллеры IDE "из коробки" без необходимости выбирать какие-либо параметры для контроллера. 

Хотя, IDE является старой технологией и в своей первоначальной версии с программным вводом-выводом не может предоставить скорости передачи необходимые для быстрого доступа к современным запоминающим устройствам. Универсальный драйвер IDE ограничен этими режимами передачи программного ввода-вывода, что приводит медленным скоростям передачи данных и гораздо более высокому использованию центрального процессора, когда данные передаются с диска и на диск. 

Если не работаете с системой 1995-го года и ранее, контроллер IDE также может поддерживать альтернативный режим передачи, известный как ''Direct Memory Access'' (DMA) - прямой доступ к памяти. DMA намного быстрее и при передаче данных центральный процессор едва используется. При действительно плохой общей производительности системы и использовании IDE-диска, вероятно, DMA не используется и должен быть выключен.

{{Note|Как упомянуто ранее, libata доступна даже для приводов IDE. Если используется libata, то все приводы, включая приводы IDE, будут использовать DMA. Нет необходимости делать дальнейшую проверку или конфигурацию.}}

Если libata не используется для IDE-дисков, то необходимо включить использование DMA. Следующая команда поможет определить используется ли DMA:

{{RootCmd|hdparm -d /dev/hda|output=<pre>
/dev/hda:
 using_dma    =  0 (off)
</pre>
}}

Для включения DMA на старых устройствах IDE (deprecated (устаревший) параметр), включите следующую функцию ядра.

{{Warning|Включение <var>CONFIG_BLK_DEV_IDE_SATA</var> приведет к конфликту с драйверами libata SATA. Как правило, на контроллерах IDE поддержка SATA отключена, так как они лучше поддерживаются со стороны активно разрабатываемой SCSI подсистемы. Включение <var>CONFIG_BLK_DEV_IDE_SATA</var> вызовет конфликт с поддержкой libata в SATA, что является плохой идеей. Этот драйвер предназначен для работы со старыми устройствами IDE. Оставьте SATA для libata, если это возможно!}}

{{KernelBox|title=Параметры конфигурации для устаревших контроллеров IDE|1=
Device Drivers  --->
   <*> ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
      <*> ATA/ATAPI/MFM/RLL support
      <*>   Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
      [*]     PCI IDE chipset support
}}

{{Note|Select the correct chipset(s) from the choices listed under "PCI IDE chipset support" in the ''Configuration options for IDE controllers'' kernel box above.}}

=== USB хост-контроллеры ===

[[USB]] — это общепринятая шина для подсоединения внешних периферийных устройств к компьютеру. Одной из причин успеха USB является то, что это стандартизированный протокол. Однако же, устройства хост-контроллера USB (USB ''host controller devices'', или HCD), размещенные на хосте, немного различаются. Имеются 4 главных вида: 

# <code>UHCI</code> - Universal Host Controller Interface (универсальный интерфейс хост-контроллера). Он поддерживает USB 1.1, и обычно имеется на материнских платах, основанных на чипсете VIA или Intel.
# <code>OHCI</code> - Open Host Controller Interface (открытый интерфейс хост-контроллера). Он поддерживает USB 1.1 и обычно имеется на материнских платах, основанных на чипсете Nvidia или SiS.
# <code>EHCI</code> - Extended Host Controller Interface (усовершенствованный интерфейс хост-контроллера). Это единственный распространенный интерфейс хост-контроллера, поддерживающий USB 2.0 и обычно присутствующий на любом компьютере с поддержкой USB 2.0.
# <code>XHCI</code> - eXtensible Host Controller Interface (расширяемый интерфейс хост-контроллера). Это хост-контроллер интерфейс для USB 3.0, который совместим с USB 1.0, 1.1, 2.0, 3.0 и будущими версиями. Включите эту опцию, если ваша плата поддерживает USB 3.0.

Большинство систем поставляются с двумя из перечисленных выше типов интерфейсов: XHCI (USB 3.0) и EHCI (USB 2.0). Для использования USB-устройств не нужно выбирать оба варианта, так как XHCI совместим с более медленными контроллерами USB. Но что бы "обезопасить" себя, пользователь может включить поддержку EHCI; это не причинит вреда, если USB 2.0 контроллер отсутствует в системе.

Если параметры, соответствующие типам USB HCD, отсутствуют в системе, тогда можете получиться эффект 'мертвых' USB-портов. Такой случай определить так: при подключении работающего устройства оно не снабжается питанием или не подает каких-либо признаков жизни. 

С помощью отличной команды {{c|lspci}} (из пакета {{Package|sys-apps/pciutils}}) можно относительно легко обнаружить какие устройства HCD присутствуют на системе. Игнорируя контроллер SATA, который также соответствует запросу, легко обнаружить, что эта система требует поддержку EHCI и XHCI:

{{RootCmd|lspci -v {{!}} grep HCI|output=<pre>
00:14.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB xHCI (rev 04) (prog-if 30 [XHCI])
00:1a.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #2 (rev 04) (prog-if 20 [EHCI])
00:1d.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #1 (rev 04) (prog-if 20 [EHCI])
00:1f.2 SATA controller: Intel Corporation 8 Series/C220 Series Chipset Family 6-port SATA Controller 1 [AHCI mode] (rev 04) (prog-if 01 [AHCI 1.0])
</pre>
}}

Выберите HCD присутствующий в системе. В общем случае, можно выбрать все три варианта для максимальной поддержки, если правильный вариант неизвестен:

{{KernelBox|title=[[USB#Kernel_Configuration|Конфигурация USB HCDs]]|1=
Device Drivers  --->
   USB support  --->
      <*> Support for Host-side USB
      ---   USB Host Controller Drivers
      <*>   xHCI HCD (USB 3.0) support
      <*>   EHCI HCD (USB 2.0) support
      < >   OHCI HCD  (USB 1.1) support
      < >   UHCI HCD (most Intel and VIA) support
}}

В ядре Linux версии 3.12.13 и новее “OHCI support for PCI-bus USB controllers” (<var>CONFIG_USB_OHCI_HCD_PCI</var>) стоит включить, если USB-контроллер это OHCI и используется USB клавиатура или мышь.

=== Мультипроцессоры, гиперпоточность и многоядерные системы ===

Множество компьютеров основаны на многоядерных процессорах, но это не всегда очевидно. 

* Множество центральных процессоров Intel поддерживают технологию, называемую [https://en.wikipedia.org/wiki/Hyperthreading гиперпоточность]. Эта технология позволяет системе задействовать одноядерный процессор как процессор с двумя ''логическими'' процессорами.
* Большинство процессоров Intel и AMD фактически состоят из множества физических процессоров внутри одного корпуса, такие процессоры известны как [https://en.wikipedia.org/wiki/Multi-core_processor многоядерные] процессоры.
* Некоторые дорогие (последней модели) системы в действительности имеют множество физических процессоров, установленных на специализированной материнской плате для значительного увеличения производительности по сравнению с ''однопроцессорной'' системой. Пользователи таких систем, возможно, будут в курсе, что у них такая система, так как они недешевы.

Во всех этих случаях требуется выбрать соответствующие параметры ядра для получения оптимальной производительности для этих установок:

{{KernelBox|title=Конфигурация поддержки мультипроцессорных систем|1=
Processor type and features  --->
 [*] Symmetric multi-processing support
 [*]   SMT (Hyperthreading) scheduler support
 [*]   Multi-core scheduler support (NEW)
}}

Следующая опция предназначена не только для управления питанием, но также может быть необходима для определения всех процессоров, доступных в системе:

{{KernelBox|title=Управление питанием для мультипроцессорных систем|1=
Power management and ACPI options  --->
 [*] ACPI (Advanced Configuration and Power Interface) Support
}}

=== Поддержка High Memory для x86 ===

Вследствие ограничений в 32-битном адресном пространстве на архитектуре x86, ядро с настройками по умолчанию поддерживает только 896 Мб оперативной памяти. Если система обладает большим количеством памяти, будут доступны только первые 896 Мб, если только не включена поддержка "верхней памяти" (high memory support). 

{{Note|Это ограничение характерно для архитектуры x86 (IA32). Другие архитектуры свободно поддерживают большие количества памяти без каких-либо настроек.}}

Поддержка верхней памяти по умолчанию не включена, потому что она накладывает небольшую дополнительную нагрузку на систему. Не волнуйтесь, дополнительная нагрузка незначительна по сравнению с подъемом производительности или доступностью большего количества памяти! 

Выберите вариант 4 Гб, если ваша система имеет более 4 ГБ оперативной памяти:

{{KernelBox|title=Включение поддержки верхней памяти для архитектуры x86|1=
Processor type and features  --->
 High Memory Support  --->
  (X) 4GB
  ( ) 64GB
}}

=== Сжатые модули ядра ===

Начиная с версии ядра 3.18.x (и выше) возможно сжатие модулей ядра. Доступно сжатие gzip и xz. Важно установить {{Package|sys-apps/kmod}} с нужными USE-флагами ''перед'' компиляцией ядра со сжатыми модулями:

{{FileBox|filename=/etc/portage/package.use|title=Включение поддержки сжатия для kmod|1=
sys-apps/kmod lzma zlib
}}

Перекомпилируйте {{Package|sys-apps/kmod}}:

{{Emerge|params+=--oneshot --changed-use|sys-apps/kmod}}

Включите сжатие модулей и выберите предпочитаемый метод сжатия:
{{KernelBox|title=Включение сжатие модулей|1=
Enable loadable module support --->
  [*]   Compress modules on installation
  Compression algorithm ()  --->
    <X> GZIP
        XZ
}}

Usually {{c|make modules_install}} runs {{c|depmod}}. If {{Package|sys-apps/kmod}} did not have the proper USE flags set (see the {{Path|package.use}} step above) the first time it was run, then the dependency list will be empty. The system will therefore be unable to load any modules that were built compressed.

После перекомпиляции kmod, еще раз запустите {{c|depmod}}, чтобы решить эту проблему:

{{RootCmd|depmod -a
|modprobe <module_name>
}}

== Сокращенное обозначение настроек ядра ==

=== Введение ===

При прочтении о конфигурации ядра, часто настройки описываются как <var>CONFIG_<something></var>. Это сокращенное обозначение является тем, что используется в конфигурации ядра внутренне, и то, что можно обнаружить в файле конфигурации ядра (будь это {{Path|/usr/src/linux/.config}} или автоматически созданный файл {{Path|/proc/config.gz}}). Конечно же, использование сокращенных обозначений бесполезно если их нельзя перевести в действительное местонахождение настроек ядра. Утилита {{c|make menuconfig}} позволяет это сделать.

=== Перевод параметра CONFIG_FOO в действительное местонахождение настроек ===

Предположим, неоходимо включить параметр <var>CONFIG_TMPFS_XATTR<var>. Запустите меню конфигурации ядра ({{c|make menuconfig}}) и нажмите {{Key|/}}. Это откроет поле поиска. В это поле введите <var>CONFIG_TMPFS_XATTR</var>. 

Следующий вывод является результатом этого поиска:

{{KernelBox|title=Результат поиска "CONFIG_TMPFS_XATTR" в menuconfig|1=
Symbol: TMPFS_XATTR [=n]
Type  : boolean
Prompt: Tmpfs extended attributes
  Defined at fs/Kconfig:138
  Depends on: TMPFS [=y]
  Location:
    -> File systems
      -> Pseudo filesystems
        -> Virtual memory file system support (former shm fs) (TMPFS [=y])
  Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
}}

Вывод работы команды содержит много интересной информации.

{| class="table table-condensed table-striped" style="text-align: left;" 
|- 
! Entry
! Description
|- 
| Symbol: TMPFS_XATTR [=n]
| This identifies the kernel configuration entry being searched for. It also shows that this setting is currently ''not enabled'' ([=n]).
|- 
| Type: boolean
| The setting searched for is a boolean (which means it can be one of two options: enabled or disabled). Some settings are numbers or strings.
|- 
| Prompt: Tmpfs extended attributes
| This is the text found in the {{c|make menuconfig}} entry that controls the variable (<var>TMPFS_XATTR</var>) in the {{Path|.config}} file. It is essentially the variable name in a more human readable format.
|- 
| Depends on: TMPFS [=y]
| Before this entry can be seen <var>CONFIG_TMPFS</var> must be enabled. In this case it is already done (hence the [=y]) but if this is not the case, first look for (and enable) <var>CONFIG_TMPFS</var>.
|- 
| Location: ...
| This is the location in the {{c|make menuconfig}} structure where the setting can be found. Remember, the setting to look for is ''Tmpfs extended attributes''.
|- 
| Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
| If the settings described here are both enabled (in this case the first one is not), then <var>CONFIG_TMPFS_XATTR</var> will be automatically enabled and will not be possible to be ''disabled'' until one of these settings is de-selected.
|-
|}

С помощью этой информации можно довольно легко перевести любые требования <var>CONFIG_*</var>. Вкратце, это означает что пользователю необходимо:

# Включить настройки, описанные в поле ''Depends on'';
# Перейти к указанному местоположению ''Location'';
# Переключить значение, указанное в ''Prompt:'';

== Другая документация по конфигурации ядра ==

До сих пор обсуждались только основные концепции и специфические проблемы, относящиеся к конфигурации ядра, без углубления в подробности; подробности оставлены для изучения пользователю. Однако, другие части документации Gentoo предусматривают специализированные подробности для рассматриваемых тем.

Such documents may be helpful while configuring specific areas of the kernel. Although this warning was mentioned previously in this guide, remember: users who are new to kernel configuration should not be adventurous when attempting to configure their kernels. Start by getting a basic system up and running, support for your audio, printing, etc., can always be added at a later date.

Getting the basics of a kernel operational will help users in later configuration steps because the user will know what is breaking their system and what is not. It is always wise to save the base (working) kernel configuration in a folder other than the kernel's sources folder ''before'' attempting to add new features or hardware.  

* [[ALSA|Статья ALSA]] описывает в подробностях параметры, требуемые для звуковой карты. Следует заметить, что ALSA является исключением из предложенной схемы сборки компонентов не в качестве модулей: систему ALSA намного проще сконфигурировать, если компоненты являются модульными.

* [[Bluetooth|Статься Bluetooth]] описывает параметры, необходимые для использования устройств Bluetooth.

* [[IPv6 router guide/ru|Руководство по развертыванию IPv6-маршрутизатора]] описывает как сконфигурировать ядро для маршрутизации, используя схему сетевой адресации нового поколения.

* При использовании закрытых графических драйверов nVidia для улучшенной производительности 3D-графики, в [[NVidia/nvidia-drivers/ru|руководстве по nVidia]] перечисляются параметры, которые требуется выбрать или отключить.

* В числе прочих вещей, в [[Power_management/Guide/ru|руководстве по управлению питанием]] объясняется как настроить ядро для управления частотой центрального процессора и для функций энергосбережения и режима сна.

* Если используется система PowerPC, в [[PPC/FAQ/ru|в списке часто задаваемых вопросов по PPC]] имеются несколько разделов, посвященных конфигурации ядра для PPC.

* [[Printing/ru|Руководство по печати]] перечисляет параметры ядра, необходимые для поддержки печати в Linux.

* [[USB/Guide|Руководство по USB]] описывает конфигурацию, необходимую для использования распространенных USB-устройств, таких как клавиатуры и мыши, запоминающие устройства и USB-принтеры.

== Устранение проблем ==

=== Изменения конфигурации не вступают в силу ===

Среди пользователей весьма распространенной ошибкой является то, что они делают изменения в конфигурации, но затем совершают небольшую ошибку в процессе загрузки в только что настроенное ядро. Они перезагружаются в образ ядра, не являющийся тем, который они только что сконфигурировали, замечают, что проблема, которую они пытались решить, все еще присутствует и приходят к выводу что изменения конфигурации не решили проблему. 

Процесс компиляции и установки ядер находится за рамками этого документа; обратитесь к [[Kernel/Upgrade/ru|руководству по обновлению ядра]]  за общими инструкциями. Вкратце, процесс получения измененного ядра заключается в следующем: 1&#41; конфигурация, 2&#41; компиляция, 3&#41; монтирование раздела {{Path|/boot}} (если он еще не примонтирован), 4&#41; копирование нового образа ядра в {{Path|/boot}}, 5&#41; убедитесь, что загрузчик ссылается на новое ядро, 6&#41; перезагрузка. Если какой-нибудь из финальных шагов пропущен, изменения не вступят в силу.

It is possible to verify if the kernel that has booted matches the newly kernel compiled on the hard disk. This is performed by examining the date and time of the kernel's compilation. Assuming the system architecture is x86 and the kernel sources are installed at {{Path|/usr/src/linux}}, the following command can be used:

{{RootCmd|uname -v|output=<pre>
#4 SMP PREEMPT Sat Jul 15 08:49:26 BST 2006
</pre>}}

Приведенная выше команда отобразит дату и время компиляции ядра, загруженного в настоящий момент.

{{RootCmd|ls -l /usr/src/linux/arch/i386/boot/bzImage|output=<pre>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
</pre>}}

Приведенная выше команда отображает дату и время когда образ ядра был скомпилирован в последний раз.

If the time stamps from the above commands differ by more than 2 minutes, it indicates a mistake was made during kernel reinstallation and the system has not booted from the newly modified kernel image.

=== Модули не загружаются автоматически ===

As mentioned earlier in this document, the kernel configuration system hides a large behavioral change when selecting a kernel component as a module (M) rather than built-in (Y). It is worth repeating this again because so many users fall into this trap.

When selecting a component as built-in, the code is built into the kernel image (bzImage). When the kernel needs to use that component, it can initialize and load it automatically, without any user intervention. 

When selecting a component as a module, the code is built into a kernel module file and installed on the filesystem. In general, when the kernel needs to use that component, it will not be able to find it. With some exceptions, the kernel makes no effort to actually load these modules — this task is left up to the user. 

If building support for a network card as a module, and it is discovered the network is not accessible, it is probably because the module is not loaded — either this must be done manually or the system must be configured to autoload the module at boot time.

Unless a user has a reasons to do otherwise, some time can be saved by building these components directly into the kernel image, so that the kernel can automatically configure these small settings by itself. 

== Смотрите также ==

* [[genkernel]] - A tool used to automate the build process of the kernel and initramfs.
* [[Security Handbook/Kernel security#The proc filesystem|proc filesystem (Security Handbook)]] - Dynamically change kernel parameters and variables on the fly.


[[Category:Kernel]] [[Category:Server and Security]] {{Migrated|originalauthors=Daniel Drake, Curtis Napier, Justin Robinson, Lukasz Damentko, Jonathan Smith, nightmorph}}
