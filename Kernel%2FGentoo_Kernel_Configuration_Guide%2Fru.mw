<languages />


{{Metadata|abstract=Целью данного документа является ознакомление с понятием конфигурации ядра вручную и разбор наиболее распространённых проблем.}}

Целью данного документа является ознакомление с понятием конфигурации ядра вручную и разбор наиболее распространённых проблем.

== Введение ==

В Gentoo ядро можно установить двумя способами: ''автоматически'' (genkernel) и ''вручную''. Несмотря на то, что автоматический метод кажется ''проще'', существует ряд причин, по которым достаточно большрй процент пользователей выбирает настройку вручную:

# Большая свобода
# Меньший размер ядра
# Быстрая компилляция
# Удовольствие от обучения
# Всепоглащающая скука
# Абсолютные знания об устройстве ядра и/или
# Тотальный контроль

В этом руководстве не охватывается автоматический способ конфигурации ядра (genkernel). Если для компиляции и установки ядра предпочтительным является использование genkernel, следует обратиться к [[Genkernel|документации Genkernel]]. 

Данное руководство не стремится задокументировать процесс конфигурации вручную от начала до конца, поскольку он опирается на определенную долю здравого смысла и относительно высокий уровень знаний о системе. Вместо этого, руководство раскрывает основные представления о конфигурации ядра вручную и достаточно подробное описание наиболее распространенных подводных камней, с которыми сталкиваются пользователи. 

{{Note|Данный документ написан с рассчётом на достаточно современные версии ядер и использование наиболее распространённых архитектур. Некоторые вещи разнятся на более более экзотичных конфигурациях, но львиная доля приведённой ниже информации всё же будет применима.}}

На данный момент предполагается, что исходный код ядра Linux распакован на жёсткий диск (как правило в {{Path|/usr/src}}), а читатель обладает навыками работы с <tt>menuconfig</tt> и системой меню на базе ncursers. В случае, если данный уровент не достигнут, то, преджде чем продолжить, следует ознакомиться со следующей литературой:

* The [[Kernel/Overview|Обзор различных версий исходного кода ядра Linux]] содержит информацию о различных версиях исходного кода, предоставляемого деревом Portage.
* The [[Kernel/Upgrade|Инструкция по обновлению ядра]] показывает, как обновить ядро или же сменить версию.
* The Gentoo Handbook's [[Handbook:Main_Page|секция, посвящённая настройке ядра]] покрывает некоторые аспекты установки. Выберите нужную архитектуру и перейдите по ссылке "Настройка ядра Linux".

== Основные понятия конфигурации ==

=== Основные идеи ===

The general process is actually rather simple: a series of options, categorized into individual menus and sub-menus, are presented and the desired hardware support and kernel features relevant to the system are selected.

The kernel includes a ''default configuration'', which is presented the first time menuconfig is run on a particular set of sources. The defaults are generally broad and sensible, which means that the majority of users will only have to make a small number of changes to the base configuration. When deciding to disable an option that was enabled from kernel's default configuration, make sure a good understanding has been obtained of exactly what that option does, and the consequences of disabling it. 

During a first time Linux kernel configuring, aim to be conservative; do not be too adventurous, and try make as few modifications to the default settings as possible. At the same time, keep in mind that there are certain parts to a system's setup that must be customized to actually allow for the system to boot.

=== Сравнение встроенных в ядро параметров и загружаемых модулей ядра ===

Большинство параметров конфигурации могут находиться в трех состояниях: они могут быть как отключены вовсе <code>(N)</code>, встроены прямо в ядро <code>(Y)</code>, или собраны в качестве модулей <code>(M)</code>. Модули хранятся вне ядра на файловой системе, в то время как встроенные компоненты встраиваются прямо в образ ядра. 

There is an important difference between built-in and modular: with a few exceptions, the kernel makes no attempt whatsoever to load any external modules when the system might need them; it is left up to the user to decide when, or when to not, load a module. While certain other parts of the system may have load-on-demand facilities, and there are some automatic module loading utilities available, it is recommended to build hardware support and kernel features directly into the kernel. The kernel can then ensure the functionality and hardware support is available whenever needed. This is done by setting each kernel feature to (Y). For this setup to be coherent it is also necessary to include firmware support in the kernel. This is done setting <code>FW_LOADER=y</code> and <code>CONFIG_FIRMWARE_IN_KERNEL=y</code> in the kernel's {{Path|.config}} or by the following:

{{KernelBox|title=Enabling firmware in kernel|
Device Drivers  --->
   Generic Driver Options  --->
       -*- Userspace firmware loading support
       [*] Include in-kernel firmware blobs in kernel binary
}}

For other parts of the configuration, built-in is an absolute requirement. For example, if the root partition was an btrfs filesystem the system would not boot if btrfs was built as a module. The system would have to look on the root partition to find the btrfs module (since modules are stored in the root partition), but it cannot look on the root partition unless it already has btrfs support loaded! If btrfs has not been built-in then the init process will fail to find the root device.

=== Поддержка аппаратного обеспечения ===

Beyond detecting the ''architecture type'' of the system, the configuration utility makes no attempt to identify what hardware is actually present in the system. While there are default settings for ''some'' hardware support, users almost certainly need to find and select the configuration options relevant to each system's hardware configuration. 

Selecting the proper configuration options requires a knowledge of the components inside and connected to the computer. Most of the time these components can be identified without taking the lid off the system. For most internal components, users need to identify the ''chipset'' used on each device, rather than the retailed product name. Many expansion cards are retailed with a certain brand name, but use another manufacturer's chipset.

Доступны несколько вспомогательных утилит, которые помогут пользователям определить, какие варианты конфигурации ядра лучше использовать. <tt>lspci</tt> (часть пакета {{Package|sys-apps/pciutils}}) определяет аппаратное обеспечение, основанное на PCI и AGP, включая компоненты, встроенные в материнскую плату. <tt>lsusb</tt> (из пакета {{Package|sys-apps/usbutils}}) определяет различные устройства, подсоединенные к USB портам. 

The situation is somewhat confused by varying degrees of standardization in the hardware world. Unless the user selects extreme deviation from the default configuration settings, the IDE hard disks should "just work", as will the PS/2 or USB keyboard and mouse. Basic VGA display support is also included. However, some devices such as Ethernet adapters are hardly standardized at all; for these devices users will have to identify the Ethernet chipset and select the appropriate hardware support for the specific card to get network access.

In addition, while some things just-about-work with the default settings, more specialized options may need to be selected to get the full potential from the system. For example, if support for the appropriate IDE chipset has not been enabled, the IDE hard disks will run ''very'' slowly.

=== Функции ядра ===

In addition to hardware support, users need to consider the software features that will be required in the kernel. One important example of such a feature is filesystem support: users must select support for the filesystems in use on their hard disks, as well as any filesystems they might use on external storage devices (e.g. VFAT on USB drives). 

Another common software feature example is advanced network functionality. In order to do some kind of routing or firewalling the relevant configuration items must be included in the kernel configuration. 

=== Готовы? ===

Now that the concepts have been introduced, it should be easy to start identifying the system hardware, browsing through the menuconfig interface, and selecting the required kernel options for the system. 

The rest of this guide should clear up common areas of confusion, and provide advice for how to avoid common problems which users often run into. Best wishes!

== Распространенные проблемы и затруднения ==

=== SATA-диски являются дисками SCSI ===

Большинство современных настольных систем поставляются с запоминающими устройствами (жесткий диск и приводы CD/DVD) на шине [https://ru.wikipedia.org/wiki/SATA Serial ATA], вместо более старой шины [https://en.wikipedia.org/wiki/Parallel_ATA IDE] (резиновый кабель). 

SATA support in Linux is implemented in a layer referred to as ''libata'', which sits below the SCSI subsystem. For this reason, SATA drivers are found in the SCSI driver section of the configuration. Additionally, the system's storage devices will be treated as SCSI devices, which means SCSI disk/cdrom support will also be required. The first SATA hard disk will be named {{Path|/dev/sda}} and the first SATA CD/DVD drive will be named {{Path|/dev/sr0}}. 

Хотя большинство этих драйверов предназначено для контроллеров SATA, libata не была предназначена только для SATA. Все распространенные драйвера IDE будут также портированы на libata в ближайшем будущем, и, на тот момент, вышеупомянутые рассмотрения также будут применимы и к пользователям IDE. 

{{KernelBox|title=Параметры конфигурации для libata|1=
Device Drivers  --->
   SCSI device support  --->
      <*> SCSI device support
      <*> SCSI disk support
      <*> SCSI CDROM support
 
      [ ] SCSI low-level drivers  --->
 
   <*> Serial ATA and Parallel ATA drivers (libata)  --->
}}

{{Note|Non-standard chipset(s) are listed under "SCSI low-level drivers" in the ''Configuration options for libata'' kernel box above.}}

=== Чипсеты IDE и DMA ===

Вопреки появлению SATA, устройства IDE все еще являются очень распространенными, и от них зависят многие части системы. IDE является достаточно общей технологией и, таким образом, Linux поддерживает почти все контроллеры IDE "из коробки" без необходимости выбирать какие-либо параметры для контроллера. 

Хотя, IDE является старой технологией и в своей первоначальной версии с программным вводом-выводом не может предоставить скорости передачи необходимые для быстрого доступа к современным запоминающим устройствам. Универсальный драйвер IDE ограничен этими режимами передачи программного ввода-вывода, что приводит медленным скоростям передачи данных и гораздо более высокому использованию центрального процессора, когда данные передаются с диска и на диск. 

Unless a user is dealing with a pre-1995 system, the IDE controller will also support an alternative transfer mode, known as ''Direct Memory Access'' (DMA). DMA is much much faster, and CPU utilization is barely affected while data transfers are taking place. If the system is suffering from really poor general system performance while it is using an IDE disk, chances are that DMA is not being used and should be enabled.

{{Note/ru|Как упомянуто ранее, libata доступна даже для приводов IDE. Если используется libata, то все приводы, включая приводы IDE, будут использовать DMA. Нет необходимости делать дальнейшую проверку или конфигурацию.}}

Если libata не используется для IDE-дисков, то необходимо включить использование DMA. Следующая команда поможет определить используется ли DMA:

{{RootCmd|hdparm -d /dev/hda|output=<pre>
/dev/hda:
 using_dma    =  0 (off)
</pre>
}}

To enable DMA for older IDE devices (which is a deprecated setting), enable the following kernel features.

{{Warning|Enabling <code>CONFIG_BLK_DEV_IDE_SATA</code> will create a conflict with the libata SATA driver. Normally support for SATA is disabled on IDE controllers because it is handled better by the actively maintained SCSI subsystem. Enabling <code>CONFIG_BLK_DEV_IDE_SATA</code> will cause this driver to conflict with libata's support for SATA, which is generally a bad idea. This driver exists to handle old IDE drives, leave the handling of SATA to libata if possible!}}

{{KernelBox|title=Параметры конфигурации для устаревших контроллеров IDE|1=
Device Drivers  --->
   <*> ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
      <*> ATA/ATAPI/MFM/RLL support
      <*>   Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
      [*]     PCI IDE chipset support
}}

{{Note|Select the correct chipset(s) from the choices listed under "PCI IDE chipset support" in the ''Configuration options for IDE controllers'' kernel box above.}}

=== USB хост-контроллеры ===

[USB] - это общепринятая шина для подсоединения внешних периферийных устройств к компьютеру. Одной из причин успеха USB является то, что это стандартизированный протокол. Однако же, устройства хост-контроллера USB (USB ''host controller devices'', или HCD), размещенные на хосте, немного различаются. Имеются 4 главных вида: 

# <code>UHCI</code> - Universal Host Controller Interface (универсальный интерфейс хост-контроллера). Он поддерживает USB 1.1, и обычно имеется на материнских платах, основанных на чипсете VIA или Intel.
# <code>OHCI</code> - Open Host Controller Interface (открытый интерфейс хост-контроллера). Он поддерживает USB 1.1 и обычно имеется на материнских платах, основанных на чипсете Nvidia или SiS.
# <code>EHCI</code> - Extended Host Controller Interface (усовершенствованный интерфейс хост-контроллера). Это единственный распространенный интерфейс хост-контроллера, поддерживающий USB 2.0 и обычно присутствующий на любом компьютере с поддержкой USB 2.0.
# <code>XHCI</code> - eXtensible Host Controller Interface (расширяемый интерфейс хост-контроллера). Это хост-контроллер интерфейс для USB 3.0, который совместим с USB 1.0, 1.1, 2.0, 3.0 и будущими версиями. Включите эту опцию, если ваша плата поддерживает USB 3.0.

Most systems come with two of the above interface types: XHCI (USB 3.0) ''and'' EHCI (USB 2.0). To use USB devices, it is no longer necessary to select both options since XHCI is compatible with slower USB-controllers. Users can also enable EHCI to be "extra" safe; it does no harm if USB 2.0 controllers are unavailable.

If the relevant options corresponding to the USB HCD types present on the system are not selected, then 'dead' USB ports may be experienced. This case can be determined if a working USB device is plugged in, but it does not get power or respond in any way. 

С помощью отличной команды <tt>lspci</tt> (из пакета {{Package|sys-apps/pciutils}}) можно относительно легко обнаружить какие устройства HCD присутствуют на системе. Игнорируя контроллер SATA, который также соответствует запросу, легко обнаружить, что эта система требует поддержку EHCI и XHCI:

{{RootCmd|lspci -v {{!}} grep HCI|output=<pre>
00:14.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB xHCI (rev 04) (prog-if 30 [XHCI])
00:1a.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #2 (rev 04) (prog-if 20 [EHCI])
00:1d.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #1 (rev 04) (prog-if 20 [EHCI])
00:1f.2 SATA controller: Intel Corporation 8 Series/C220 Series Chipset Family 6-port SATA Controller 1 [AHCI mode] (rev 04) (prog-if 01 [AHCI 1.0])
</pre>
}}

Select the HCDs present on the system. In general select all three options for maximum support, or if the correct option is uncertain:

{{KernelBox|title=[[USB#Kernel_Configuration|Configuration for USB HCDs]]|1=
Device Drivers  --->
   USB support  --->
      <*> Support for Host-side USB
      ---   USB Host Controller Drivers
      <*>   xHCI HCD (USB 3.0) support
      <*>   EHCI HCD (USB 2.0) support
      < >   OHCI HCD  (USB 1.1) support
      < >   UHCI HCD (most Intel and VIA) support
}}

In Linux kernel 3.12.13 and later, ''OHCI support for PCI-bus USB controllers'' (<code>CONFIG_USB_OHCI_HCD_PCI</code>) has to be enabled if the USB controller is OHCI and a USB keyboard or mouse is used.

=== Мультипроцессоры, гиперпоточность и многоядерные системы ===

Many computer systems are based on multiple processors, but not always in an immediately obvious way. 

* Many of Intel's CPUs support a technology which they call [https://en.wikipedia.org/wiki/Hyperthreading hyper-threading]. This technology enables a single CPU to be viewed by the system as two ''logical'' processors.
* Most Intel/AMD CPUs actually consist of multiple physical processors inside a single package, these processors are known as [https://en.wikipedia.org/wiki/Multi-core_processor multi-core] processors.
* Some high-end computer systems actually have multiple physical processors installed on specialized motherboards to provide a significant performance increase over a ''uniprocessor'' system. System users will probably know if they have such a system, since they are not cheap.

In all of these cases, the appropriate kernel options must be selected to obtain optimum performance from these setups:

{{KernelBox|title=Configuration for multi-processing support|1=
Processor type and features  --->
 [*] Symmetric multi-processing support
 [*]   SMT (Hyperthreading) scheduler support
 [*]   Multi-core scheduler support (NEW)
}}

The next option not only enables power management features, but might also be a requirement for making all CPUs available to the system:

{{KernelBox|title=Power management for multi-processor systems|1=
Power management and ACPI options  --->
 [*] ACPI (Advanced Configuration and Power Interface) Support
}}

=== Поддержка High Memory для x86 ===

Due to limitations in the 32-bit address space of the x86 architecture, a kernel with default configuration can only support up to 896MB RAM. If a system has more memory, only the first 896MB will be visible, unless high memory support has been enabled. 

{{Note/ru|Это ограничение характерно для архитектуры x86 (IA32). Другие архитектуры свободно поддерживают большие количества памяти без каких-либо настроек.}}

Поддержка верхней памяти по умолчанию не включена, потому что она накладывает небольшую дополнительную нагрузку на систему. Не волнуйтесь, дополнительная нагрузка незначительна по сравнению с подъемом производительности или доступностью большего количества памяти! 

Choose the 4GB option, unless your system has more than 4GB of RAM:

{{KernelBox|title=Enabling high memory support on x86|1=
Processor type and features  --->
 High Memory Support  --->
  (X) 4GB
  ( ) 64GB
}}

=== Compressed kernel modules ===

From kernel version 3.18.x (and up) compression of kernel modules has been possible. gzip and xz compression are available. It is important to emerge {{Package|sys-apps/kmod}} with the proper USE flags ''before'' compiling a kernel with compressed modules:

{{FileBox|filename=/etc/portage/package.use|title=Enabling compression support for kmod|1=
sys-apps/kmod lzma zlib
}}

Re-emerge {{Package|sys-apps/kmod}}:

{{Emerge|params+=--oneshot --changed-use|sys-apps/kmod}}

Enable module compression and select a preferred compression method:
{{KernelBox|title=Enable module compression|1=
Enable loadable module support --->
  [*]   Compress modules on installation
  Compression algorithm ()  --->
    <X> GZIP
        XZ
}}

Usually <tt>make modules_install</tt> runs <tt>depmod</tt>. If {{Package|sys-apps/kmod}} did not have the proper USE flags set (see the {{Path|package.use}} step above) the first time it was run, then the dependency list will be empty. The system will therefore be unable to load any modules that were built compressed.

After kmod has been recompiled, re-run <tt>depmod</tt> as a solution to this problem:

{{RootCmd|depmod -a
|modprobe <module_name>
}}

== Сокращенное обозначение настроек ядра ==

=== Введение ===

When reading about kernel configuration, often times settings are described as <code>CONFIG_<something></code>. This short-hand notation is what the kernel configuration actually uses internally, and is what will be found in the kernel configuration file (be it {{Path|/usr/src/linux/.config}} or in the auto-generated {{Path|/proc/config.gz}} file). Of course, using short-hand notation would not do much good if this cannot translate this to the real location in the kernel configuration. The <tt>make menuconfig</tt> tool makes this possible.

=== Перевод параметра CONFIG_FOO в действительное местонахождение настроек ===

Suppose the <code>CONFIG_TMPFS_XATTR</code> feature needs to be enabled. Launch the kernel configuration menu (<tt>make menuconfig</tt>) and press the {{Key|/}} key. This will open a search box. In the search box, type <code>CONFIG_TMPFS_XATTR</code>. 

The following is an output of the result of this search:

{{KernelBox|title=Result of searching menuconfig for CONFIG_TMPFS_XATTR|1=
Symbol: TMPFS_XATTR [=n]
Type  : boolean
Prompt: Tmpfs extended attributes
  Defined at fs/Kconfig:138
  Depends on: TMPFS [=y]
  Location:
    -> File systems
      -> Pseudo filesystems
        -> Virtual memory file system support (former shm fs) (TMPFS [=y])
  Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
}}

Вывод работы команды содержит много интересной информации.

{| class="table" style="text-align: left;" 
|- 
! Entry
! Description
|- 
| Symbol: TMPFS_XATTR [=n]
| This identifies the kernel configuration entry being searched for. It also shows that this setting is currently ''not enabled'' ([=n]).
|- 
| Type: boolean
| The setting searched for is a boolean (which means it can be one of two options: enabled or disabled). Some settings are numbers or strings.
|- 
| Prompt: Tmpfs extended attributes
| This is the text found in the <tt>make menuconfig</tt> entry that controls the variable (<code>TMPFS_XATTR</code>) in the {{Path|.config}} file. It is essentially the variable name in a more human readable format.
|- 
| Depends on: TMPFS [=y]
| Before this entry can be seen <code>CONFIG_TMPFS</code> must be enabled. In this case it is already done (hence the [=y]) but if this is not the case, first look for (and enable) <code>CONFIG_TMPFS</code>.
|- 
| Location: ...
| This is the location in the <tt>make menuconfig</tt> structure where the setting can be found. Remember, the setting to look for is ''Tmpfs extended attributes''.
|- 
| Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
| If the settings described here are both enabled (in this case the first one is not), then <code>CONFIG_TMPFS_XATTR</code> will be automatically enabled and will not be possible to be ''disabled'' until one of these settings is de-selected.
|-
|}

With this information, it should be possible to translate any <code>CONFIG_*</code> requirements fairly easily. In short, it means a user must

# Включить настройки, описанные в поле ''Depends on'';
# Перейти к указанному местоположению ''Location'';
# Переключить значение, указанное в ''Prompt:'';

== Другая документация по конфигурации ядра ==

So far only general concepts and specific problems related to kernel configuration has been discussed; precise details have been left up to the user to discover. However, other parts of the Gentoo documentation collection provide specialized details for the topics at hand.

Such documents may be helpful while configuring specific areas of the kernel. Although this warning was mentioned previously in this guide, remember: users who are new to kernel configuration should not be adventurous when attempting to configure their kernels. Start by getting a basic system up and running, support for your audio, printing, etc., can always be added at a later date.

Getting the basics of a kernel operational will help users in later configuration steps because the user will know what is breaking their system and what is not. It is always wise to save the base (working) kernel configuration in a folder other than the kernel's sources folder ''before'' attempting to add new features or hardware.  

* The [[ALSA|ALSA article]] details the configuration options required for sound card support. Note that ALSA is an exception to the suggested scheme of not building things as modules: ALSA is actually much easier to configure when the components are modular.

* The [[Bluetooth|Bluetooth article]] details the options needed in order to use Bluetooth devices.

* [[IPv6 router guide]] описывает как сконфигурировать ядро для маршрутизации, используя схему сетевой адресации нового поколения.

* При использовании закрытых графических драйверов nVidia для улучшенной производительности 3D-графики, в [[NVidia/nvidia-drivers|руководстве по nVidia]] перечисляются параметры, которые требуется выбрать или отключить.

* Amongst other things, the [[Power_management/Guide|Power Management guide]] explains how to configure the kernel for CPU frequency scaling, and for suspend and hibernate functionality.

* If running a PowerPC system, the [[PPC/FAQ|PPC FAQ]] has a few sections about PPC kernel configuration.

* The [[Printing|Printing guide]] lists the kernel options needed to support printing in Linux.

* The [[USB/Guide|USB Guide]] details the configuration settings required to use common USB devices such as keyboards, mice, storage devices, and USB printers.

== Устранение проблем ==

=== Изменения конфигурации не вступают в силу ===

It is very common for users to make a configuration change, but then make a small mistake in the process of actually booting to their newly configured kernel. They reboot into a kernel image that is not the one they just reconfigured, observe that whatever problem they were trying to solve is still present, and conclude that the configuration change does not solve the problem. 

The process of compiling and installing kernels is outside the scope of this document; refer to the [[Kernel/Upgrade|Kernel Upgrade Guide]] for general guidance. In short, the process to get a modified kernel is the following: 1) configure, 2) compile, 3) mount {{Path|/boot}} (if not already mounted), 4) copy new kernel image to {{Path|/boot}}, 5) Make sure the bootloader will reference the new kernel, 6) reboot. If one of those final stages has been missed, then the changes will not properly take effect.

It is possible to verify if the kernel that has booted matches the newly kernel compiled on the hard disk. This is performed by examining the date and time of the kernel's compilation. Assuming the system architecture is x86 and the kernel sources are installed at {{Path|/usr/src/linux}}, the following command can be used:

{{RootCmd|uname -v|output=<pre>
#4 SMP PREEMPT Sat Jul 15 08:49:26 BST 2006
</pre>}}

The above command will display the date and time the currently booted kernel was compiled.

{{RootCmd|ls -l /usr/src/linux/arch/i386/boot/bzImage|output=<pre>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
</pre>}}

The above command displays the date and time that the kernel image on the hard disk was last compiled.

If the time stamps from the above commands differ by more than 2 minutes, it indicates a mistake was made during kernel reinstallation and the system has not booted from the newly modified kernel image.

=== Модули не загружаются автоматически ===

As mentioned earlier in this document, the kernel configuration system hides a large behavioral change when selecting a kernel component as a module (M) rather than built-in (Y). It is worth repeating this again because so many users fall into this trap.

When selecting a component as built-in, the code is built into the kernel image (bzImage). When the kernel needs to use that component, it can initialize and load it automatically, without any user intervention. 

When selecting a component as a module, the code is built into a kernel module file and installed on the filesystem. In general, when the kernel needs to use that component, it will not be able to find it. With some exceptions, the kernel makes no effort to actually load these modules — this task is left up to the user. 

If building support for a network card as a module, and it is discovered the network is not accessible, it is probably because the module is not loaded — either this must be done manually or the system must be configured to autoload the module at boot time.

Unless a user has a reasons to do otherwise, some time can be saved by building these components directly into the kernel image, so that the kernel can automatically configure these small settings by itself. 

== See also ==

* [[genkernel]] - A tool used to automate the build process of the kernel and initramfs.


[[Category:Server and Security]] {{Migrated|originalauthors=Daniel Drake, Curtis Napier, Justin Robinson, Lukasz Damentko, Jonathan Smith, nightmorph}}
