<languages />


{{Metadata|abstract=Целью данного документа является ознакомление с основными понятиями конфигурации ядра вручную и подробное описание наиболее распространенных подводных камней.}}

Целью данного документа является ознакомление с основными понятиями конфигурации ядра вручную и подробное описание наиболее распространенных подводных камней.

== Введение ==

Операционной системой Gentoo предусматриваются два способа управления установкой и обновлением ядра: ''автоматический'' (genkernel) и ''вручную'' . Хотя автоматический способ может рассматриваться как ''более легкий'' для пользователя, существует множество причин, по которым большинство пользователей Gentoo выбирают конфигурацию ядра вручную: большая гибкость, меньшие размеры ядра, более короткое время компиляции, приобретение опыта, сильная скука и т. д. 

This guide does not cover the automatic method (genkernel). If you'd prefer to use genkernel to compile and install your kernel, head over to the [[Genkernel|Genkernel documentation]]. 

Данное руководство не стремится задокументировать процесс конфигурации вручную от начала до конца -- процесс конфигурации опирается на определенную долю здравого смысла и относительно высокий уровень технической подготовки и знаний о системе. Вместо этого, в руководстве вводятся основные представления о конфигурации ядра вручную и описываются в подробностях наиболее распространенные подводные камни, с которыми сталкиваются пользователи. 

Данный документ написан с учетом последних версий ядер и наиболее распространенных архитектур компьютера. Некоторые подробности могут отличаться в случае использования старых ядер или более экзотических архитектур, но большая часть содержимого будет все же применима. 

В данный момент подразумевается, что исходные тексты ядра Linux распакованы на жесткий диск (обычно в каталоге {{Path|/usr/src}}) и предполагается, что вам известно как вызвать утилиту конфигурации <code>menuconfig</code> и перемещаться по меню. Если вы еще не дошли до этого уровня, то имеется следующая вспомогательная документация. 

* В [[Kernel/Overview|Руководстве по версиям ядер]] перечислены различные доступные пакеты с исходными текстами ядра.
* В [[Kernel/Upgrade|Руководстве по обновлению ядра]] объясняется как обновить ядро или перейти с одного на другое.
* В [http://www.gentoo.org//doc/en/handbook/index.xml Настольной книге Gentoo]  также охватываются некоторые аспекты установки ядра.

== Основные понятия конфигурации ==

=== Основные идеи ===

Общий процесс достаточно прост: предлагаются несколько возможностей на выбор, распределенные по категориям в отдельные меню и подменю, и выбирается поддержка аппаратного обеспечения и функций ядра, подходящих для системы. 

Ядро включает ''конфигурацию по умолчанию'', которая показывается в первое время запуска команды menuconfig для отдельного набора исходных текстов ядра. В целом, предлагается широкий выбор разумных значений по умолчанию, что означает, что большинству пользователей потребуется только внести небольшое количество изменений в основную конфигурацию. Если необходимо отключить параметр, который был включен по умолчанию, убедитесь что вы хорошо понимаете что в точности делает данный параметр и последствия его отключения. 

При конфигурации ядра в первый раз, следует придерживаться умеренных настроек и вносить так мало изменений в основные настройки, насколько это возможно. В то же время, следует учитывать, что существуют определенные настройки, которые необходимо изменить, чтобы система действительно могла загружаться!

=== Сравнение встроенных в ядро параметров и загружаемых модулей ядра ===

Большинство параметров конфигурации могут находиться в трех состояниях: они могут быть как отключены вовсе (N), прямо встроены в ядро (Y), или собраны в качестве модулей (M). Модули хранятся вне ядра на файловой системе, в то время как встроенные компоненты встраиваются прямо в образ ядра. 

Между встроенными параметрами и модулями существует важное различие: за некоторыми исключениями, ядро не предпринимает каких-либо попыток загрузить внешние модули, если они нужны (это задача пользователя). В то время как определенные части системы могут иметь возможность загрузки модулей по требованию и доступны несколько утилит для автоматической загрузки модулей, рекомендуется включение аппаратных функций и функций ядра непосредственно в само ядро. В этом случае, ядром может гарантироваться поддержка программных функций и аппаратного обеспечения при необходимости. 

С некоторыми настройками, встроенные параметры являются абсолютной необходимостью. Например, если раздел root расположен на файловой системе <code>ext2</code>, система не загрузится, если ext2 был встроен в качестве модуля (системе потребуется обратиться к разделу root чтобы найти модуль ext2, но обращения не произойдет до тех пор, пока модуль ext2 не будет загружен!).

=== Поддержка аппаратного обеспечения ===

Помимо обнаружения ''типа архитектуры'' системы, утилита конфигурации не предпринимает попыток обнаружить какое аппаратное обеспечение имеется на системе. В то время как для определенного типа аппаратного обеспечения имеются настройки по умолчанию, вам почти наверняка потребуется найти и выбрать параметры конфигурации, подходящие для аппаратного обеспечения системы. 

Это просто требует знания внутренних компонентов системы и компонентов, подключенных к компьютеру, или их идентификации. Для большинства внутренних компонент, необходимо определить ''чипсет'', используемый для каждой из них, вместо названия компонента на розничном рынке. 

Доступны несколько вспомогательных утилит. <code>lspci</code> (часть пакета {{Package|sys-apps/pciutils}}) определяет аппаратное обеспечение, основанное на PCI и AGP, включая компоненты, встроенные в материнскую плату. <code>lsusb</code> (из пакета {{Package|sys-apps/usbutils}}) определяет устройства, подсоединенные к USB-портам. 

Положение в некотором смысле запутывается изменяющейся степенью стандартизации аппаратного обеспечения. До тех пор, пока не происходит отклонения от значений по умолчанию, жесткие диски IDE будут работать, как и PS/2 или USB-клавиатура и мышь. Основная поддержка дисплея VGA также будет включена. Однако, некоторые устройства, такие как адаптеры ethernet, едва стандартизированы, поэтому чтобы получить доступ к сети, потребуется идентифицировать чипсет ethernet и выбрать подходящую поддержку для сетевой платы. 

Кроме того, в то время как некоторые вещи просто работают с настройками по умолчанию, имеется возможность выбора более    индивидуальных параметров, чтобы извлечь полный потенциал из системы. Например, если поддержка правильного чипсета IDE отключена, жесткие диски работают ''очень'' медленно.

=== Функции ядра ===

Наряду с поддержкой аппаратного обеспечения, необходимо также задуматься о включении в ядро определенных функций программного обеспечения. Одним из важных примеров такой функции является поддержка файловой системы: необходимо выбрать поддержку файловых систем для использования на жестком диске, наряду с любыми другими файловыми системами, которые могут понадобиться для использования на внешнем хранилище (например, VFAT на флеш-накопителях USB). 

Другим распространенным примером является расширенная функциональность сети. При необходимости включить маршрутизацию или межсетевую фильтрацию, нужно проверить, что соответствующие настройки включены в файл конфигурации ядра. 

=== Готовы? ===

После ознакомления с базовыми понятиями, вы должны уметь определять аппаратное обеспечение и просматривать меню конфигурации, выбирая требуемые параметры ядра для системы. 

Остальная часть этой страницы направлена на разъяснение часто вызывающих затруднения областей и объяснение как избежать общих проблем, с которыми сталкиваются пользователи. Удачи! 

== Распространенные проблемы и затруднения ==

=== SATA-диски являются дисками SCSI ===

Большинство современных настольных систем поставляются с запоминающими устройствами (жесткий диск и приводы CD/DVD) на шине [https://ru.wikipedia.org/wiki/SATA Serial ATA], вместо более старой шины [https://en.wikipedia.org/wiki/Parallel_ATA IDE] (резиновый кабель). 

Поддержка SATA в Linux реализована через слой, называемый ''libata'', который располагается уровнем ниже подсистемы SCSI. По этой причине, драйвера SATA находятся в разделе конфигурации с драйверами SCSI. Дополнительно, запоминающие устройства могут обрабатываться как SCSI-устройства, что подразумевает поддержку SCSI диска или cdrom. Жесткий диск SATA, например, будет иметь название {{Path|/dev/sda}}, а привод CD/DVD -- {{Path|/dev/sr0}}. 

Хотя большинство этих драйверов предназначено для контроллеров SATA, libata не была предназначена только для SATA. Все распространенные драйвера IDE будут также портированы на libata в ближайшем будущем, и, на тот момент, вышеупомянутые рассмотрения также будут применимы и к пользователям IDE. 

{{Code|Параметры конфигурации для libata|<pre>
Device Drivers  --->
 SCSI device support  --->
  <*> SCSI device support
  <*>   SCSI disk support
  <*>   SCSI CDROM support
  
  SCSI low-level drivers  --->
   <*> Serial ATA (SATA) support
    Select your chipset from the choices listed below the above option
</pre>
}}

=== Чипсеты IDE и DMA ===

Вопреки появлению SATA, устройства IDE все еще являются очень распространенными, и от них зависят многие части системы. IDE является достаточно общей технологией и, таким образом, Linux поддерживает почти все контроллеры IDE "из коробки" без необходимости выбирать какие-либо параметры для контроллера. 

Хотя, IDE является старой технологией и в своей первоначальной версии с программным вводом-выводом не может предоставить скорости передачи необходимые для быстрого доступа к современным запоминающим устройствам. Универсальный драйвер IDE ограничен этими режимами передачи программного ввода-вывода, что приводит медленным скоростям передачи данных и гораздо более высокому использованию центрального процессора, когда данные передаются с диска и на диск. 

Если только вы не работаете с системой 1995-го года и ранее, контроллер IDE также может поддерживать альтернативный режим передачи, известный как ''Direct Memory Access'' (DMA) - прямой доступ к памяти. DMA намного быстрее и при передаче данных центральный процессор едва задействуется. При действительно плохой общей производительности системы и использовании IDE-диска, вероятно что DMA не используется. 


{{Note/ru|Как упомянуто ранее, libata доступна даже для приводов IDE. Если используется libata, то все приводы, включая приводы IDE, будут использовать DMA. Нет необходимости делать дальнейшую проверку или конфигурацию.}}

Если libata не используется для IDE-дисков, то необходимо включить использование DMA. 

{{RootCmd|hdparm -d /dev/hda|output=<pre>
/dev/hda:
 using_dma    =  0 (off)
</pre>
}}

Для включения DMA на всех устройствах IDE, нужно просто включить параметр конфигурации для контроллера IDE. 

{{Kernel|Параметры конфигурации для контроллеров IDE|<pre>
Device Drivers  --->
 ATA/ATAPI/MFM/RLL support  --->
  <*> ATA/ATAPI/MFM/RLL support
  <*>   Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
  [*]     PCI IDE chipset support
  Select your chipset from the choices listed below the above option
</pre>
}}

=== Хост-контроллеры USB ===

[http://en.wikipedia.org/wiki/USB USB] - это общепринятая шина для подсоединения внешних периферийных устройств к компьютеру. Одной из причин успеха USB является то, что это стандартизированный протокол. Однако же, устройства хост-контроллера USB (USB ''host controller devices'', или HCD), размещенные на хосте, немного различаются. Имеются 3 главных вида: 

* <code>UHCI</code> - Universal Host Controller Interface (универсальный интерфейс хост-контроллера). Он поддерживает USB 1.1, и обычно имеется на материнских платах, основанных на чипсете VIA или Intel.
* <code>OHCI</code> - Open Host Controller Interface (открытый интерфейс хост-контроллера). Он поддерживает USB 1.1 и обычно имеется на материнских платах, основанных на чипсете Nvidia или SiS.
* <code>EHCI</code> - Extended Host Controller Interface (усовершенствованный интерфейс хост-контроллера). Это единственный распространенный интерфейс хост-контроллера, поддерживающий USB 2.0 и обычно присутствующий на любом компьютере с поддержкой USB 2.0.

Most systems will come with two of the above interface types: EHCI (USB 2.0), plus either UHCI or OHCI (USB 1.1). It is important that you select both types present on your system. While all USB 2.0 devices are backwards compatible with USB 1.1, a large proportion of USB devices (even the ones being manufactured today) are based on the USB 1.1 interface - why would a USB mouse need more than 1.5Mb/s? 

Если параметры, соответствующие типам USB HCD, отсутствуют на системе, вы можете испытать проблему 'мертвых' USB-портов: при подключении устройства оно не снабжается питанием или не отвечает вообще. 

С помощью отличной команды <code>lspci</code> (из пакета {{Package|sys-apps/pciutils}}) можно относительно легко обнаружить какие устройства HCD присутствуют на системе. Игнорируя контроллер FireWire, который также соответствует запросу, легко обнаружить, что система автора требует поддержку OHCI и EHCI: 

{{RootCmd|lspci -v {{!}} grep HCI|output=<pre>
00:02.0 USB Controller: nVidia Corporation CK804 USB Controller (rev a2) (prog-if 10 [OHCI])
00:02.1 USB Controller: nVidia Corporation CK804 USB Controller (rev a3) (prog-if 20 [EHCI])
01:0b.0 FireWire (IEEE 1394): Agere Systems FW323 (rev 61) (prog-if 10 [OHCI])
</pre>
}}

{{Kernel|Конфигурация для USB HCD|<pre>
Device Drivers  --->
 USB support  --->
  <*> Support for Host-side USB
  ---   USB Host Controller Drivers
  <*>   EHCI HCD (USB 2.0) support
  <*>   OHCI HCD support
  <*>   UHCI HCD (most Intel and VIA) support
  Select the HCDs present on your system, or all 3 if you are unsure.
</pre>
}}

В ядре Linux версии 3.12.13 и новее “OHCI support for PCI-bus USB controllers” (<code>CONFIG_USB_OHCI_HCD_PCI</code>) стоит включить, если с OHCI USB-контроллером используется клавиатура или мышь.

=== Мультипроцессоры, гиперпоточность и многоядерные системы ===

Множество компьютеров основаны на многоядерных процессорах, но это не всегда очевидно. 

* Множество центральных процессоров Intel поддерживают технологию, называемую [https://en.wikipedia.org/wiki/Hyperthreading гиперпоточность], в которой центральный процессор рассматривается системой как два ''логических'' процессора.
* Большинство процессоров Intel и AMD фактически состоят из множества физических процессоров внутри одного корпуса, они известны как [https://en.wikipedia.org/wiki/Multi-core_processor многоядерные] процессоры.
* Некоторые высококачественные системы в действительности имеют множество физических процессоров, установленных на специализированной материнской плате для значительного увеличения производительности по сравнению с ''однопроцессорной'' системой. Вы, возможно, будете знать что обладаете такой системой, так как они недешевы.

Во всех этих случаях требуется выбрать соответствующие параметры ядра для получения оптимальной производительности для этих установок. 

{{Kernel|Конфигурация для мультипроцессорных систем|<pre>
Processor type and features  --->
 [*] Symmetric multi-processing support
 Select the above option if you are on a multi-processor system (of any type)
 [*]   SMT (Hyperthreading) scheduler support
 Select the above option if you are on an Intel Hyper-Threading CPU
 [*]   Multi-core scheduler support (NEW)
 Select the above option if your CPU is multi-core
Power management and ACPI options  --->
 [*] ACPI (Advanced Configuration and Power Interface) Support
 The above option not only enables power management features, but might
 also be a requirement for making all CPUs available to your system
</pre>
}}

=== Поддержка High Memory для x86 ===

Due to limitations in the 32-bit address space of the x86 architecture, a kernel with default configuration can only support up to 896MB RAM. If your system has more memory, only the first 896MB will be visible, unless you enable high memory support. 

{{Note/ru|Это ограничение характерно для архитектуры x86 (IA32). Другие архитектуры свободно поддерживают большие количества памяти без каких-либо настроек.}}

Поддержка верхней памяти по умолчанию не включена, потому что она накладывает небольшую дополнительную нагрузку на систему. Не волнуйтесь, дополнительная нагрузка незначительна по сравнению с подъемом производительности или доступностью большего количества памяти! 

{{Kernel|Включение поддержки верхней памяти для архитектуры x86|<pre>
Processor type and features  --->
 High Memory Support  --->
  (X) 4GB
  ( ) 64GB
  Choose the 4GB option, unless your system has more than 4GB of RAM.
</pre>
}}

== Сокращенное обозначение настроек ядра ==

=== Введение ===

При прочтении о конфигурации ядра, вы часто увидите, что настройки описываются как <code>CONFIG_<something></code>. Это сокращенное обозначение является тем, что используется в конфигурации ядра внутренне, и то, что можно обнаружить в файле конфигурации ядра (будь это {{Path|/usr/src/linux/.config}} или автоматически созданный файл {{Path|/proc/config.gz}}). Конечно же, использование сокращенных обозначений бесполезно если их нельзя перевести в действительное местонахождение настроек ядра. К счастью, утилита <code>make menuconfig</code> позволяет это сделать.

=== Перевод параметра CONFIG_FOO в действительное местонахождение настроек ===

Предположим, вам потребовалось включить параметр <code>CONFIG_TMPFS_XATTR<code>. Запустите меню конфигурации ядра (<code>make menuconfig</code>) и введите {{Key|/}}. Это откроет поле поиска. В этом поле введите <code>CONFIG_TMPFS_XATTR</code> (вы даже можете пропустить <code>CONFIG_</code>). Следующий листинг кода показывает результат поиска. 

{{Kernel|Результат поиска CONFIG_TMPFS_XATTR|<pre>
Symbol: TMPFS_XATTR [=n]
Type  : boolean
Prompt: Tmpfs extended attributes
  Defined at fs/Kconfig:138
  Depends on: TMPFS [=y]
  Location:
    -> File systems
      -> Pseudo filesystems
        -> Virtual memory file system support (former shm fs) (TMPFS [=y])
  Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
</pre>
}}

Вывод работы команды содержит много интересной информации. 

{| class="wikitable" style="text-align: left;" 
|- 
! Запись
! Описание
|- 
| Symbol: TMPFS_XATTR [=n]
| Это определяет искомый элемент конфигурации ядра. Оно также сообщает, что настройке в данный момент ''отключена'' ([=n]).
|- 
| Type: boolean
| Искомая настройка является булевым значением (что означает, что она может быть включена или отключена). Некоторые настройки являются числами или строками.
|- 
| Prompt: Tmpfs extended attributes
| Это текст, который можно обнаружить при работе команды <code>make menuconfig</code> и других утилит, является искомой записью в формате более удобном для чтения.
|- 
| Depends on: TMPFS [=y]
| Перед тем как увидеть эту запись, необходимо включить <code>CONFIG_TMPFS</code>. В данном случае, это сделано (отсюда и [=y]), но если это не так, необходимо сначала найти (и включить) параметр <code>CONFIG_TMPFS</code>.
|- 
| Location: ...
| Это местонахождение в структуре, генерируемой утилитой <code>make menuconfig</code>, где можно найти данную настройку. Вспомните что искомой настройкой является ''Tmpfs extended attributes''.
|- 
| Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
| Если настройки, описанные здесь, включены обе (в нашем случае, первая нет), то параметр <code>CONFIG_TMPFS_XATTR</code> будет также включен автоматически и не будет возможности его отключить.
|-
|}

С помощью этой информации можно легко перевести любые требования <code>CONFIG_*</code>. Вкратце, это означает что вам необходимо: 

# включить настройки, описанные в поле ''Depends on''
# перейти к указанному местоположению ''Location''
# переключить значение, указанное ''Prompt:''

== Другая документация по конфигурации ядра ==

На данный момент, мы обсудили только основные концепции и специфические проблемы, относящиеся к конфигурации ядра, без углубления в подробности (эти подробности оставлены для изучения вам!). Однако, другие части документации Gentoo предусматривают специализированные подробности для рассматриваемых тем. 

Эти документы могут быть полезны при конфигурации специфичных областей, но если вы новичок в конфигурации ядра, не следует смело изменять любые настройки. Начав с настраивания простой системы, вы всегда можете вернуться позже, чтобы добавить поддержку звука, печати и т. д. 

* Статья [[ALSA]] описывает в подробностях параметры, требуемые для звуковой платы. Следует заметить, что ALSA является одним из исключений предложенной схемы сборки компонентов не в качестве модулей: систему ALSA намного проще сконфигурировать, если компоненты являются модульными.

* Статься [[Bluetooth]] описывает параметры, необходимые для использования устройств bluetooth на системе.

* [[IPv6 router guide]] описывает как сконфигурировать ядро для маршрутизации, используя схему сетевой адресации нового поколения.

* При использовании закрытых графических драйверов nVidia для улучшенной производительности 3D-графики, в [[NVidia/nvidia-drivers|руководстве по nVidia]] перечисляются параметры, которые требуется выбрать или отключить.

* В числе прочих вещей, в [[Power_management/HOWTO|руководстве по управлению питанием]] объясняется как настроить ядро для масштабирования частоты центрального процессора и для функций энергосбережения и режима сна.

* Если используется система PowerPC, в [[PPC/FAQ|в списке часто задаваемых вопросов по PPC]] имеются несколько разделов, посвященных конфигурации ядра.

* [[Printing|Руководство Gentoo по печати]] перечисляет параметры ядра, необходимые для поддержки печати в Linux.

* [[USB/HOWTO|Руководство по USB]] описывает конфигурацию, необходимую для использования распространенных USB-устройств, таких как клавиатуры и мыши, запоминающие устройства и принтеры.

== Устранение проблем ==

=== Изменения конфигурации не вступают в силу ===

Среди пользователей весьма распространенной ошибкой является то, что они делают изменения в конфигурации, но затем совершают небольшую ошибку в последующих действиях. Они перезагружаются в образ ядра, не являющийся тем, который они только что сконфигурировали, замечают, что проблема, которую они пытались решить, все еще присутствует и приходят к выводу что изменения конфигурации не решили проблему. 

Процесс компиляции и установки ядер находится за рамками этого документа. Вам следует обратиться к [[Kernel/Upgrade|руководству по обновлению ядра]]  за общими инструкциями. Вкратце, процесс заключается в следующем: конфигурация, компиляция, монтирование раздела {{Path|/boot}} (если он еще не примонтирован), копирование нового образа ядра, перезагрузка. Если какой-нибудь из финальных шагов пропущен, изменения не вступят в силу! 

Возможно проверить соответствует ли загруженное ядро скомпилированному с помощью изучения даты и времени компиляции. Предполагается, что используется архитектура x86 и исходные тексты ядра установлены в {{Path|/usr/src/linux}}: 

{{RootCmd|uname -v|output=<pre>
#4 SMP PREEMPT Sat Jul 15 08:49:26 BST 2006
</pre>}}

Приведенная выше команда отображает дату и время компиляции ядра, загруженного в настоящий момент.

{{RootCmd|ls -l /usr/src/linux/arch/i386/boot/bzImage|output=<pre>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
</pre>}}

Приведенная выше команда отображает дату и время образа ядра, скомпилированного на жесткий диск.

Если время, выводимое приведенными выше командами, различается более чем на две минуты, это означает что в процессе переустановки ядра была допущена ошибка и загружен не тот образ ядра, который был нужен!

=== Модули не загружаются автоматически ===

Как указано в этом документе ранее, система конфигурации ядра скрывает под собой большие изменения в поведении при выборе компонента ядра в качестве модуля (M), вместо встроенного параметра (Y). Важно повторить это снова, так как много пользователей попадают в эту ловушку. 

При встраивании компонента в ядро, код встраивается в образ ядра (bzImage). Когда ядру требуется использовать этот компонент, оно может инициализировать и загрузить его автоматически, без вмешательства пользователя. 

При выборе компонента в качестве модуля, код встраивается в файл модуля ядра и устанавливается на файловую систему. В основном, когда ядру требуется использовать этот компонент, оно не может это сделать! За некоторыми исключениями, ядро не совершает попыток загрузки этих модулей - это задание оставлено пользователю. 

Поэтому, если поддержка сетевой платы включена в качестве модуля, и вы затем обнаруживаете что не можете получить доступ к сети, это, возможно, потому что модуль не загружен - требуется или сделать это вручную или сконфигурировать систему для автоматической загрузки модулей при ее запуске. 

Если только не имеется причин сделать по-другому, сохраните свое время и встройте эти компоненты прямо в образ ядра, так чтобы ядро могло автоматически настроить эти вещи. 

== Благодарности ==

Мы хотели бы поблагодарить следующих авторов и редакторов за их вклад в это руководство:


* Daniel Drake
* Curtis Napier
* Justin Robinson
* Åukasz Damentko
* Jonathan Smith
* nightmorph

[[Category:Server and Security]]
