<languages />


{{Metadata|abstract=Целью данного документа является ознакомление с понятием конфигурации ядра вручную и разбор наиболее распространённых проблем.}}

Целью данного документа является ознакомление с понятием конфигурации ядра вручную и разбор наиболее распространённых проблем.

== Введение ==

В Gentoo ядро можно установить двумя способами: ''автоматически'' (genkernel) и ''вручную''. Несмотря на то, что автоматический метод кажется ''проще'', существует ряд причин, по которым достаточно большой процент пользователей выбирает настройку вручную:

# Большая свобода
# Меньший размер ядра
# Быстрая компиляция
# Удовольствие от обучения
# Всепоглащающая скука
# Абсолютные знания об устройстве ядра и/или
# Тотальный контроль

В этом руководстве не охватывается автоматический способ конфигурации ядра (genkernel). Если для компиляции и установки ядра предпочтительным является использование genkernel, следует обратиться к [[Genkernel/ru|документации Genkernel]]. 

Данное руководство не стремится задокументировать процесс конфигурации вручную от начала до конца, поскольку он опирается на определенную долю здравого смысла и относительно высокий уровень знаний о системе. Вместо этого, руководство раскрывает основные представления о конфигурации ядра вручную и достаточно подробное описание наиболее распространенных подводных камней, с которыми сталкиваются пользователи. 

{{Note|Данный документ написан с рассчётом на достаточно современные версии ядер и использование наиболее распространённых архитектур. Некоторые вещи разнятся на более более экзотичных конфигурациях, но львиная доля приведённой ниже информации всё же будет применима.}}

На данный момент предполагается, что исходный код ядра Linux распакован на жёсткий диск (как правило в {{Path|/usr/src}}), а читатель обладает навыками работы с {{c|menuconfig}} и системой меню на базе ncursers. В случае, если данный уровень не достигнут, то, прежде чем продолжить, следует ознакомиться со следующей литературой:

* [[Kernel/Overview/ru|Обзор различных версий исходного кода ядра Linux]] содержит информацию о различных версиях исходного кода, предоставляемого деревом Portage.
* [[Kernel/Upgrade/ru|Инструкция по обновлению ядра]] показывает, как обновить ядро или же сменить версию.
* Gentoo Handbook's [[Handbook:Main_Page/ru|секция, посвящённая настройке ядра]] покрывает некоторые аспекты установки. Выберите нужную архитектуру и перейдите по ссылке "Настройка ядра Linux".

== Основные понятия конфигурации ==

=== Основные идеи ===

Общий процесс достаточно прост: предлагаются несколько возможностей на выбор, распределенные по категориям в отдельные меню и подменю, и выбирается поддержка аппаратного обеспечения и функций ядра, подходящих для системы.

Ядро включает ''конфигурацию по умолчанию'', которая активирует отдельные части исходного кода ядра во время первого запуска команды menuconfig. В целом, предлагается широкий выбор разумных значений по умолчанию, что означает, что большинству пользователей потребуется только внести небольшое количество изменений в основную конфигурацию. Если необходимо отключить параметр, который был включен по умолчанию, убедитесь что вы хорошо понимаете что в точности делает данный параметр и последствия его отключения. 

При конфигурации ядра в первый раз, следует придерживаться умеренных настроек и вносить так мало изменений в основные настройки, насколько это возможно. В то же время, следует учитывать, что существуют определенные настройки, которые необходимо изменить, чтобы система действительно могла загружаться!

=== Сравнение встроенных в ядро параметров и загружаемых модулей ядра ===

Большинство параметров конфигурации могут находиться в трех состояниях: они могут быть как отключены вовсе <code>(N)</code>, встроены прямо в ядро <code>(Y)</code>, или собраны в качестве модулей <code>(M)</code>. Модули хранятся вне ядра на файловой системе, в то время как встроенные компоненты встраиваются прямо в образ ядра. 

Между [[Kernel Modules|встроенными и модулями]] существует важное различие: за некоторыми исключениями, ядро не предпринимает каких-либо попыток загрузить внешние модули, если они нужны системе; это задача пользователя решать, когда загружать модуль. В то время как определенные части системы могут иметь возможность загрузки модулей по требованию и доступны несколько утилит для автоматической загрузки модулей, рекомендуется включение аппаратных функций и функций ядра непосредственно в само ядро. В этом случае, ядро может гарантировать функциональность и поддержку аппаратного обеспечения при необходимости. Это можно сделать, установив (Y) для каждой необходимой функции ядра. Для этого также требуется включить поддержку встраиваемого (firmware) программного обеспечения в ядре. Включите <code>FW_LOADER=y</code> и <code>CONFIG_FIRMWARE_IN_KERNEL=y</code> в конфигурационном файле ядра {{Path|.config}} или следующее в {{c|menuconfig}}:

{{KernelBox|title=Включение firmware в ядро|
Device Drivers  --->
   Generic Driver Options  --->
       -*- Userspace firmware loading support
       [*] Include in-kernel firmware blobs in kernel binary
}}

С некоторыми настройками, встроенные фунции являются абсолютной необходимостью. Например, если раздел root расположен на файловой системе btrfs, система не загрузится, если поддержка btrfs была построена в качестве модуля. Системе потребуется обратиться к разделу root чтобы найти модуль btrfs (если модули хранятся на root разделе), но обращения не произойдет до тех пор, пока модуль btrfs не будет загружен! Если поддержка btrfs не была встроена в ядро, init-процесс потерпит неудачу при поиске корневого устройства.

=== Поддержка аппаратного обеспечения ===

Помимо обнаружения ''типа архитектуры'' системы, утилита конфигурации не предпринимает попыток обнаружить какое аппаратное обеспечение имеется на системе. В то время как для ''некоторого'' типа аппаратного обеспечения имеются настройки по умолчанию, пользователю почти наверняка потребуется найти и выбрать параметры конфигурации, подходящие для аппаратного обеспечения в каждой системе. 

Selecting the proper configuration options requires a knowledge of the components inside and connected to the computer. Most of the time these components can be identified without taking the lid off the system. For most internal components, users need to identify the ''chipset'' used on each device, rather than the retailed product name. Many expansion cards are retailed with a certain brand name, but use another manufacturer's chipset.

Доступны несколько вспомогательных утилит, которые помогут пользователям определить, какие варианты конфигурации ядра лучше использовать. {{c|lspci}} (часть пакета {{Package|sys-apps/pciutils}}) определяет аппаратное обеспечение, основанное на PCI и AGP, включая компоненты, встроенные в материнскую плату. {{c|lsusb}} (из пакета {{Package|sys-apps/usbutils}}) определяет различные устройства, подсоединенные к USB портам. 

Положение в некотором смысле запутывается изменяющейся степенью стандартизации аппаратного обеспечения. До тех пор, пока не происходит сильных отклонения от значений по умолчанию, жесткие диски IDE должны "просто работать", как и PS/2 или USB-клавиатура и мышь. Базовая поддержка дисплея VGA также будет включена. Однако, некоторые устройства, такие как адаптеры ethernet, едва стандартизированы, поэтому чтобы получить доступ к сети, потребуется идентифицировать чипсет ethernet и выбрать подходящую поддержку для сетевой платы.

In addition, while some things just-about-work with the default settings, more specialized options may need to be selected to get the full potential from the system. For example, if support for the appropriate IDE chipset has not been enabled, the IDE hard disks will run ''very'' slowly.

=== Функции ядра ===

In addition to hardware support, users need to consider the software features that will be required in the kernel. One important example of such a feature is filesystem support: users must select support for the filesystems in use on their hard disks, as well as any filesystems they might use on external storage devices (e.g. VFAT on USB drives). 

Another common software feature example is advanced network functionality. In order to do some kind of routing or firewalling the relevant configuration items must be included in the kernel configuration. 

=== Готовы? ===

Now that the concepts have been introduced, it should be easy to start identifying the system hardware, browsing through the menuconfig interface, and selecting the required kernel options for the system. 

Остальная часть этого руководства направлена на разъяснение часто вызывающих затруднения областей и объяснение как избежать общих проблем, с которыми сталкиваются пользователи. Успехов!

== Распространенные проблемы и затруднения ==

=== SATA-диски являются дисками SCSI ===

Большинство современных настольных систем поставляются с запоминающими устройствами (жесткий диск и приводы CD/DVD) на шине [https://en.wikipedia.org/wiki/SATA Serial ATA], вместо более старой шины [https://en.wikipedia.org/wiki/Parallel_ATA IDE] (резиновый кабель). 

Поддержка SATA в Linux реализована через слой, называемый ''libata'', который располагается уровнем ниже подсистемы SCSI. По этой причине, драйвера SATA находятся в разделе конфигурации с драйверами SCSI. Кроме того, устройства хранения данных могут обрабатываться как SCSI-устройства, а это значит, что необходима поддержка SCSI диска или cdrom. Первый жесткий диск SATA, будет иметь название {{Path|/dev/sda}}, а первый привод CD/DVD — {{Path|/dev/sr0}}. 

Хотя большинство этих драйверов предназначено для контроллеров SATA, libata не была предназначена только для SATA. Все распространенные драйвера IDE будут также портированы на libata в ближайшем будущем, и, на тот момент, вышеупомянутые рассмотрения также будут применимы и к пользователям IDE. 

{{KernelBox|title=Параметры конфигурации для libata|1=
Device Drivers  --->
   SCSI device support  --->
      <*> SCSI device support
      <*> SCSI disk support
      <*> SCSI CDROM support
 
      [ ] SCSI low-level drivers  --->
 
   <*> Serial ATA and Parallel ATA drivers (libata)  --->
}}

{{Note|Non-standard chipset(s) are listed under "SCSI low-level drivers" in the ''Configuration options for libata'' kernel box above.}}

=== Чипсеты IDE и DMA ===

Вопреки появлению SATA, устройства IDE все еще являются очень распространенными, и от них зависят многие части системы. IDE является достаточно общей технологией и, таким образом, Linux поддерживает почти все контроллеры IDE "из коробки" без необходимости выбирать какие-либо параметры для контроллера. 

Хотя, IDE является старой технологией и в своей первоначальной версии с программным вводом-выводом не может предоставить скорости передачи необходимые для быстрого доступа к современным запоминающим устройствам. Универсальный драйвер IDE ограничен этими режимами передачи программного ввода-вывода, что приводит медленным скоростям передачи данных и гораздо более высокому использованию центрального процессора, когда данные передаются с диска и на диск. 

Unless a user is dealing with a pre-1995 system, the IDE controller will also support an alternative transfer mode, known as ''Direct Memory Access'' (DMA). DMA is much much faster, and CPU utilization is barely affected while data transfers are taking place. If the system is suffering from really poor general system performance while it is using an IDE disk, chances are that DMA is not being used and should be enabled.

{{Note|Как упомянуто ранее, libata доступна даже для приводов IDE. Если используется libata, то все приводы, включая приводы IDE, будут использовать DMA. Нет необходимости делать дальнейшую проверку или конфигурацию.}}

Если libata не используется для IDE-дисков, то необходимо включить использование DMA. Следующая команда поможет определить используется ли DMA:

{{RootCmd|hdparm -d /dev/hda|output=<pre>
/dev/hda:
 using_dma    =  0 (off)
</pre>
}}

To enable DMA for older IDE devices (which is a deprecated setting), enable the following kernel features.

{{Warning|Enabling <var>CONFIG_BLK_DEV_IDE_SATA</var> will create a conflict with the libata SATA driver. Normally support for SATA is disabled on IDE controllers because it is handled better by the actively maintained SCSI subsystem. Enabling <var>CONFIG_BLK_DEV_IDE_SATA</var> will cause this driver to conflict with libata's support for SATA, which is generally a bad idea. This driver exists to handle old IDE drives, leave the handling of SATA to libata if possible!}}

{{KernelBox|title=Параметры конфигурации для устаревших контроллеров IDE|1=
Device Drivers  --->
   <*> ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
      <*> ATA/ATAPI/MFM/RLL support
      <*>   Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
      [*]     PCI IDE chipset support
}}

{{Note|Select the correct chipset(s) from the choices listed under "PCI IDE chipset support" in the ''Configuration options for IDE controllers'' kernel box above.}}

=== USB хост-контроллеры ===

[[USB]] — это общепринятая шина для подсоединения внешних периферийных устройств к компьютеру. Одной из причин успеха USB является то, что это стандартизированный протокол. Однако же, устройства хост-контроллера USB (USB ''host controller devices'', или HCD), размещенные на хосте, немного различаются. Имеются 4 главных вида: 

# <code>UHCI</code> - Universal Host Controller Interface (универсальный интерфейс хост-контроллера). Он поддерживает USB 1.1, и обычно имеется на материнских платах, основанных на чипсете VIA или Intel.
# <code>OHCI</code> - Open Host Controller Interface (открытый интерфейс хост-контроллера). Он поддерживает USB 1.1 и обычно имеется на материнских платах, основанных на чипсете Nvidia или SiS.
# <code>EHCI</code> - Extended Host Controller Interface (усовершенствованный интерфейс хост-контроллера). Это единственный распространенный интерфейс хост-контроллера, поддерживающий USB 2.0 и обычно присутствующий на любом компьютере с поддержкой USB 2.0.
# <code>XHCI</code> - eXtensible Host Controller Interface (расширяемый интерфейс хост-контроллера). Это хост-контроллер интерфейс для USB 3.0, который совместим с USB 1.0, 1.1, 2.0, 3.0 и будущими версиями. Включите эту опцию, если ваша плата поддерживает USB 3.0.

Большинство систем поставляются с двумя из перечисленных выше типов интерфейсов: XHCI (USB 3.0) и EHCI (USB 2.0). Для использования USB-устройств не нужно выбирать оба варианта, так как XHCI совместим с более медленными контроллерами USB. Но что бы "обезопасить" себя, пользователь может включить поддержку EHCI; это не причинит вреда, если USB 2.0 контроллер отсутствует в системе.

Если параметры, соответствующие типам USB HCD, отсутствуют в системе, тогда можете получиться эффект 'мертвых' USB-портов. Такой случай определить так: при подключении работающего устройства оно не снабжается питанием или не подает каких-либо признаков жизни. 

С помощью отличной команды {{c|lspci}} (из пакета {{Package|sys-apps/pciutils}}) можно относительно легко обнаружить какие устройства HCD присутствуют на системе. Игнорируя контроллер SATA, который также соответствует запросу, легко обнаружить, что эта система требует поддержку EHCI и XHCI:

{{RootCmd|lspci -v {{!}} grep HCI|output=<pre>
00:14.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB xHCI (rev 04) (prog-if 30 [XHCI])
00:1a.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #2 (rev 04) (prog-if 20 [EHCI])
00:1d.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #1 (rev 04) (prog-if 20 [EHCI])
00:1f.2 SATA controller: Intel Corporation 8 Series/C220 Series Chipset Family 6-port SATA Controller 1 [AHCI mode] (rev 04) (prog-if 01 [AHCI 1.0])
</pre>
}}

Выберите HCD присутствующий в системе. В общем случае, можно выбрать все три варианта для максимальной поддержки, если правильный вариант неизвестен:

{{KernelBox|title=[[USB#Kernel_Configuration|Конфигурация USB HCDs]]|1=
Device Drivers  --->
   USB support  --->
      <*> Support for Host-side USB
      ---   USB Host Controller Drivers
      <*>   xHCI HCD (USB 3.0) support
      <*>   EHCI HCD (USB 2.0) support
      < >   OHCI HCD  (USB 1.1) support
      < >   UHCI HCD (most Intel and VIA) support
}}

В ядре Linux версии 3.12.13 и новее “OHCI support for PCI-bus USB controllers” (<var>CONFIG_USB_OHCI_HCD_PCI</var>) стоит включить, если USB-контроллер это OHCI и используется USB клавиатура или мышь.

=== Мультипроцессоры, гиперпоточность и многоядерные системы ===

Множество компьютеров основаны на многоядерных процессорах, но это не всегда очевидно. 

* Множество центральных процессоров Intel поддерживают технологию, называемую [https://en.wikipedia.org/wiki/Hyperthreading гиперпоточность]. Эта технология позволяет системе задействовать одноядерный процессор как процессор с двумя ''логическими'' процессорами.
* Большинство процессоров Intel и AMD фактически состоят из множества физических процессоров внутри одного корпуса, такие процессоры известны как [https://en.wikipedia.org/wiki/Multi-core_processor многоядерные] процессоры.
* Некоторые дорогие (последней модели) системы в действительности имеют множество физических процессоров, установленных на специализированной материнской плате для значительного увеличения производительности по сравнению с ''однопроцессорной'' системой. Пользователи таких систем, возможно, будут в курсе, что у них такая система, так как они недешевы.

Во всех этих случаях требуется выбрать соответствующие параметры ядра для получения оптимальной производительности для этих установок:

{{KernelBox|title=Конфигурация поддержки мультипроцессорных систем|1=
Processor type and features  --->
 [*] Symmetric multi-processing support
 [*]   SMT (Hyperthreading) scheduler support
 [*]   Multi-core scheduler support (NEW)
}}

The next option not only enables power management features, but might also be a requirement for making all CPUs available to the system:

{{KernelBox|title=Power management for multi-processor systems|1=
Power management and ACPI options  --->
 [*] ACPI (Advanced Configuration and Power Interface) Support
}}

=== Поддержка High Memory для x86 ===

Вследствие ограничений в 32-битном адресном пространстве на архитектуре x86, ядро с настройками по умолчанию поддерживает только 896 Мб оперативной памяти. Если система обладает большим количеством памяти, будут доступны только первые 896 Мб, если только не включена поддержка "верхней памяти" (high memory support). 

{{Note|Это ограничение характерно для архитектуры x86 (IA32). Другие архитектуры свободно поддерживают большие количества памяти без каких-либо настроек.}}

Поддержка верхней памяти по умолчанию не включена, потому что она накладывает небольшую дополнительную нагрузку на систему. Не волнуйтесь, дополнительная нагрузка незначительна по сравнению с подъемом производительности или доступностью большего количества памяти! 

Выберите вариант 4 Гб, если ваша система имеет более 4 ГБ оперативной памяти:

{{KernelBox|title=Включение поддержки верхней памяти для архитектуры x86|1=
Processor type and features  --->
 High Memory Support  --->
  (X) 4GB
  ( ) 64GB
}}

=== Сжатые модули ядра ===

From kernel version 3.18.x (and up) compression of kernel modules has been possible. gzip and xz compression are available. It is important to emerge {{Package|sys-apps/kmod}} with the proper USE flags ''before'' compiling a kernel with compressed modules:

{{FileBox|filename=/etc/portage/package.use|title=Включение поддержки сжатия для kmod|1=
sys-apps/kmod lzma zlib
}}

Перекомпилируйте {{Package|sys-apps/kmod}}:

{{Emerge|params+=--oneshot --changed-use|sys-apps/kmod}}

Enable module compression and select a preferred compression method:
{{KernelBox|title=Enable module compression|1=
Enable loadable module support --->
  [*]   Compress modules on installation
  Compression algorithm ()  --->
    <X> GZIP
        XZ
}}

Usually {{c|make modules_install}} runs {{c|depmod}}. If {{Package|sys-apps/kmod}} did not have the proper USE flags set (see the {{Path|package.use}} step above) the first time it was run, then the dependency list will be empty. The system will therefore be unable to load any modules that were built compressed.

After kmod has been recompiled, re-run {{c|depmod}} as a solution to this problem:

{{RootCmd|depmod -a
|modprobe <module_name>
}}

== Сокращенное обозначение настроек ядра ==

=== Введение ===

При прочтении о конфигурации ядра, часто настройки описываются как <var>CONFIG_<something></var>. Это сокращенное обозначение является тем, что используется в конфигурации ядра внутренне, и то, что можно обнаружить в файле конфигурации ядра (будь это {{Path|/usr/src/linux/.config}} или автоматически созданный файл {{Path|/proc/config.gz}}). Конечно же, использование сокращенных обозначений бесполезно если их нельзя перевести в действительное местонахождение настроек ядра. Утилита {{c|make menuconfig}} позволяет это сделать.

=== Перевод параметра CONFIG_FOO в действительное местонахождение настроек ===

Предположим, неоходимо включить параметр <var>CONFIG_TMPFS_XATTR<var>. Запустите меню конфигурации ядра ({{c|make menuconfig}}) и нажмите {{Key|/}}. Это откроет поле поиска. В это поле введите <var>CONFIG_TMPFS_XATTR</var>. 

The following is an output of the result of this search:

{{KernelBox|title=Результат поиска "CONFIG_TMPFS_XATTR" в menuconfig|1=
Symbol: TMPFS_XATTR [=n]
Type  : boolean
Prompt: Tmpfs extended attributes
  Defined at fs/Kconfig:138
  Depends on: TMPFS [=y]
  Location:
    -> File systems
      -> Pseudo filesystems
        -> Virtual memory file system support (former shm fs) (TMPFS [=y])
  Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
}}

Вывод работы команды содержит много интересной информации.

{| class="table table-condensed table-striped" style="text-align: left;" 
|- 
! Entry
! Description
|- 
| Symbol: TMPFS_XATTR [=n]
| This identifies the kernel configuration entry being searched for. It also shows that this setting is currently ''not enabled'' ([=n]).
|- 
| Type: boolean
| The setting searched for is a boolean (which means it can be one of two options: enabled or disabled). Some settings are numbers or strings.
|- 
| Prompt: Tmpfs extended attributes
| This is the text found in the {{c|make menuconfig}} entry that controls the variable (<var>TMPFS_XATTR</var>) in the {{Path|.config}} file. It is essentially the variable name in a more human readable format.
|- 
| Depends on: TMPFS [=y]
| Before this entry can be seen <var>CONFIG_TMPFS</var> must be enabled. In this case it is already done (hence the [=y]) but if this is not the case, first look for (and enable) <var>CONFIG_TMPFS</var>.
|- 
| Location: ...
| This is the location in the {{c|make menuconfig}} structure where the setting can be found. Remember, the setting to look for is ''Tmpfs extended attributes''.
|- 
| Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
| If the settings described here are both enabled (in this case the first one is not), then <var>CONFIG_TMPFS_XATTR</var> will be automatically enabled and will not be possible to be ''disabled'' until one of these settings is de-selected.
|-
|}

С помощью этой информации можно довольно легко перевести любые требования <var>CONFIG_*</var>. Вкратце, это означает что пользователю необходимо:

# Включить настройки, описанные в поле ''Depends on'';
# Перейти к указанному местоположению ''Location'';
# Переключить значение, указанное в ''Prompt:'';

== Другая документация по конфигурации ядра ==

So far only general concepts and specific problems related to kernel configuration has been discussed; precise details have been left up to the user to discover. However, other parts of the Gentoo documentation collection provide specialized details for the topics at hand.

Such documents may be helpful while configuring specific areas of the kernel. Although this warning was mentioned previously in this guide, remember: users who are new to kernel configuration should not be adventurous when attempting to configure their kernels. Start by getting a basic system up and running, support for your audio, printing, etc., can always be added at a later date.

Getting the basics of a kernel operational will help users in later configuration steps because the user will know what is breaking their system and what is not. It is always wise to save the base (working) kernel configuration in a folder other than the kernel's sources folder ''before'' attempting to add new features or hardware.  

* [[ALSA|Статья ALSA]] описывает в подробностях параметры, требуемые для звуковой платы. Следует заметить, что ALSA является исключением из предложенной схемы сборки компонентов не в качестве модулей: систему ALSA намного проще сконфигурировать, если компоненты являются модульными.

* [[Bluetooth|Статься Bluetooth]] описывает параметры, необходимые для использования устройств Bluetooth.

* [[IPv6 router guide/ru|Руководство по развертыванию IPv6-маршрутизатора]] описывает как сконфигурировать ядро для маршрутизации, используя схему сетевой адресации нового поколения.

* При использовании закрытых графических драйверов nVidia для улучшенной производительности 3D-графики, в [[NVidia/nvidia-drivers/ru|руководстве по nVidia]] перечисляются параметры, которые требуется выбрать или отключить.

* В числе прочих вещей, в [[Power_management/Guide/ru|руководстве по управлению питанием]] объясняется как настроить ядро для управления частотой центрального процессора и для функций энергосбережения и режима сна.

* Если используется система PowerPC, в [[PPC/FAQ/ru|в списке часто задаваемых вопросов по PPC]] имеются несколько разделов, посвященных конфигурации ядра для PPC.

* [[Printing/ru|Руководство по печати]] перечисляет параметры ядра, необходимые для поддержки печати в Linux.

* [[USB/Guide|Руководство по USB]] описывает конфигурацию, необходимую для использования распространенных USB-устройств, таких как клавиатуры и мыши, запоминающие устройства и USB-принтеры.

== Устранение проблем ==

=== Изменения конфигурации не вступают в силу ===

It is very common for users to make a configuration change, but then make a small mistake in the process of actually booting to their newly configured kernel. They reboot into a kernel image that is not the one they just reconfigured, observe that whatever problem they were trying to solve is still present, and conclude that the configuration change does not solve the problem. 

The process of compiling and installing kernels is outside the scope of this document; refer to the [[Kernel/Upgrade|Kernel Upgrade Guide]] for general guidance. In short, the process to get a modified kernel is the following: 1) configure, 2) compile, 3) mount {{Path|/boot}} (if not already mounted), 4) copy new kernel image to {{Path|/boot}}, 5) Make sure the bootloader will reference the new kernel, 6) reboot. If one of those final stages has been missed, then the changes will not properly take effect.

It is possible to verify if the kernel that has booted matches the newly kernel compiled on the hard disk. This is performed by examining the date and time of the kernel's compilation. Assuming the system architecture is x86 and the kernel sources are installed at {{Path|/usr/src/linux}}, the following command can be used:

{{RootCmd|uname -v|output=<pre>
#4 SMP PREEMPT Sat Jul 15 08:49:26 BST 2006
</pre>}}

The above command will display the date and time the currently booted kernel was compiled.

{{RootCmd|ls -l /usr/src/linux/arch/i386/boot/bzImage|output=<pre>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
</pre>}}

The above command displays the date and time that the kernel image on the hard disk was last compiled.

If the time stamps from the above commands differ by more than 2 minutes, it indicates a mistake was made during kernel reinstallation and the system has not booted from the newly modified kernel image.

=== Модули не загружаются автоматически ===

As mentioned earlier in this document, the kernel configuration system hides a large behavioral change when selecting a kernel component as a module (M) rather than built-in (Y). It is worth repeating this again because so many users fall into this trap.

When selecting a component as built-in, the code is built into the kernel image (bzImage). When the kernel needs to use that component, it can initialize and load it automatically, without any user intervention. 

When selecting a component as a module, the code is built into a kernel module file and installed on the filesystem. In general, when the kernel needs to use that component, it will not be able to find it. With some exceptions, the kernel makes no effort to actually load these modules — this task is left up to the user. 

If building support for a network card as a module, and it is discovered the network is not accessible, it is probably because the module is not loaded — either this must be done manually or the system must be configured to autoload the module at boot time.

Unless a user has a reasons to do otherwise, some time can be saved by building these components directly into the kernel image, so that the kernel can automatically configure these small settings by itself. 

== Смотрите также ==

* [[genkernel]] - A tool used to automate the build process of the kernel and initramfs.
* [[Security Handbook/Kernel security#The proc filesystem|proc filesystem (Security Handbook)]] - Dynamically change kernel parameters and variables on the fly.


[[Category:Kernel]] [[Category:Server and Security]] {{Migrated|originalauthors=Daniel Drake, Curtis Napier, Justin Robinson, Lukasz Damentko, Jonathan Smith, nightmorph}}
