<languages />


{{Metadata|abstract=Целью данного документа является ознакомление с понятием конфигурации ядра вручную и разбор наиболее распространённых проблем.}}

Целью данного документа является ознакомление с понятием конфигурации ядра вручную и разбор наиболее распространённых проблем.

== Введение ==

Gentoo предоставляет два способа настройки конфигурационного файла, установки и обновления ядра: ''автоматический'' (genkernel) и ''вручную''. Несмотря на то, что автоматический метод может показаться ''простым'' для большинства пользователей, существует ряд причин, по которым достаточно большой процент пользователей выбирает настройку ядра вручную:

# Большая свобода
# Меньший размер ядра
# Быстрая компиляция
# Удовольствие от обучения
# Всепоглащающая скука
# Абсолютные знания об устройстве ядра и/или
# Тотальный контроль

В этом руководстве не охватывается автоматический способ конфигурации ядра (genkernel). Если для компиляции и установки ядра предпочтительней использовать genkernel, следует обратиться к [[Genkernel/ru|документации Genkernel]]. 

Данное руководство не стремится задокументировать процесс конфигурации вручную от начала до конца, поскольку он опирается на определенную долю здравого смысла и относительно высокий уровень знаний о системе. Вместо этого, руководство раскрывает основные представления о конфигурации ядра вручную и достаточно подробное описание наиболее распространенных подводных камней, с которыми сталкиваются пользователи. 

{{Note|Данный документ написан с рассчётом на достаточно современные версии ядер и использование наиболее распространённых архитектур. Некоторые вещи разнятся на старых версиях ядра или более экзотичных архитектурах, но львиная доля приведённой ниже информации всё же будет применима.}}

На данный момент предполагается, что исходный код ядра Linux распакован на жёсткий диск (как правило в {{Path|/usr/src}}), а читатель обладает навыками работы с {{c|menuconfig}} и системой меню на базе ncursers. В случае, если данный уровень не достигнут, то, прежде чем продолжить, следует ознакомиться со следующими статьями:

* [[Kernel/Overview/ru|Обзор различных версий исходного кода ядра Linux]] содержит информацию о различных версиях исходного кода ядра, предоставляемого деревом Portage.
* [[Kernel/Upgrade/ru|Инструкция по обновлению ядра]] показывает, как обновить ядро или же сменить версию.
* Gentoo Handbook's [[Handbook:Main_Page/ru|секция, посвящённая настройке ядра]] покрывает некоторые аспекты установки. Выберите нужную архитектуру и перейдите по ссылке "Настройка ядра Linux".

== Основные понятия конфигурации ==

=== Основные идеи ===

Общий процесс достаточно прост: предлагаются несколько возможностей на выбор, распределенные по категориям в отдельные меню и подменю, в которых можно выбрать поддержку аппаратного обеспечения и функций ядра, подходящие для системы.

Ядро включает ''конфигурацию по умолчанию'', которая активирует отдельные части исходного кода ядра во время первого запуска команды menuconfig. В целом, предлагается широкий выбор разумных значений по умолчанию, что означает, что большинству пользователей потребуется только внести небольшое количество изменений в основную конфигурацию. Если необходимо отключить параметр, который был включен по умолчанию, убедитесь что вы хорошо понимаете что в точности делает данный параметр и последствия его отключения. 

При конфигурации ядра Linux в первый раз, следует придерживаться умеренных настроек и вносить так мало изменений в основные настройки, насколько это возможно. В то же время, следует учитывать, что существуют определенные настройки, которые необходимо изменить, чтобы система действительно могла загружаться.

=== Сравнение встроенных в ядро параметров и загружаемых модулей ядра ===

Большинство параметров конфигурации могут находиться в трех состояниях: они могут быть как отключены вовсе <code>(N)</code>, встроены прямо в ядро <code>(Y)</code>, или собраны в качестве модулей <code>(M)</code>. Модули хранятся вне ядра на файловой системе, в то время как встроенные компоненты встраиваются прямо в образ ядра. 

Между [[Kernel Modules|встроенными и модулями]] существует важное различие: за некоторыми исключениями, ядро не предпринимает каких-либо попыток загрузить внешние модули, если они нужны системе; это задача пользователя решать, когда загружать модуль. В то время как определенные части системы могут иметь возможность загрузки модулей по требованию и доступны несколько утилит для автоматической загрузки модулей, рекомендуется включение поддержки аппаратного обеспечения и функций ядра непосредственно в само ядро. В этом случае, ядро может гарантировать функциональность и поддержку аппаратного обеспечения при необходимости. Это можно сделать, установив <code>(Y)</code> для каждой необходимой функции ядра. Для этого также требуется включить поддержку встраиваемого (firmware) программного обеспечения в ядре. Включите <code>FW_LOADER=y</code> и <code>CONFIG_FIRMWARE_IN_KERNEL=y</code> в конфигурационном файле ядра {{Path|.config}} или следующее в {{c|menuconfig}}:

{{KernelBox|title=Включение firmware в ядро|
Device Drivers  --->
   Generic Driver Options  --->
       -*- Userspace firmware loading support
       [*] Include in-kernel firmware blobs in kernel binary
}}

В некоторых частях конфигурации, встроенные функции это абсолютная необходимость. Например, если раздел root расположен на файловой системе btrfs, система не загрузится, если поддержка btrfs была построена в качестве модуля. Системе потребуется обратиться к разделу root чтобы найти модуль btrfs (если модули хранятся на root разделе), но обращения не произойдет до тех пор, пока модуль btrfs не будет загружен! Если поддержка btrfs не была встроена в ядро, init-процесс потерпит неудачу при поиске корневого устройства.

=== Поддержка аппаратного обеспечения ===

Помимо обнаружения ''типа архитектуры'' системы, утилита конфигурации не предпринимает попыток обнаружить какое аппаратное обеспечение имеется на системе. В то время как для ''некоторого'' типа аппаратного обеспечения имеются настройки по умолчанию, пользователю почти наверняка потребуется найти и выбрать параметры конфигурации, подходящие для аппаратного обеспечения в каждой системе. 

Для правильного выбора опций требует знание внутренних компонентов системы и компонентов, подключенных к компьютеру. В большинстве случаях компоненты могут быть определены без снятия крышки компьютера. Для большинства внутренних компонент, необходимо определить ''чипсет'', используемый для каждого устройства, вместо названия компонента на розничном рынке. Множество карт расширения, продаваемые под определенной торговой маркой, могут использовать чип от другого производителя.

Доступны несколько вспомогательных утилит, которые помогут пользователям определить, какие варианты конфигурации ядра лучше использовать. {{c|lspci}} (часть пакета {{Package|sys-apps/pciutils}}) определяет аппаратное обеспечение, основанное на PCI и AGP, включая компоненты, встроенные в материнскую плату. {{c|lsusb}} (из пакета {{Package|sys-apps/usbutils}}) определяет различные устройства, подсоединенные к USB портам. 

Положение в некотором смысле запутывается изменяющейся степенью стандартизации аппаратного обеспечения. До тех пор, пока не происходит сильных отклонения от значений по умолчанию, жесткие диски IDE должны "просто работать", как и PS/2 или USB-клавиатура и мышь. Базовая поддержка дисплея VGA также будет включена. Однако, некоторые устройства, такие как адаптеры ethernet, едва стандартизированы, поэтому чтобы получить доступ к сети, потребуется идентифицировать чипсет ethernet и выбрать подходящую поддержку для сетевой платы.

Кроме того, в то время как некоторые вещи просто работают с настройками по умолчанию, порой, необходимо выбрать более индивидуальные параметры, чтобы извлечь полный потенциал из системы. Например, если поддержка правильного чипсета IDE отключена, жесткие диски будут работать ''очень'' медленно.

=== Функции ядра ===

Помимо аппаратного обеспечения, необходимо также задуматься об особенностях программного обеспечения, поддержка которого необходима в ядре. Одним из важных примеров такой функции является поддержка файловой системы: необходимо выбрать поддерживаемые файловые системы для использования на жестком диске, а также любые другие файловые системы, которые могут находится на устройствах внешнего хранения (например, VFAT на флеш-накопителях USB). 

Другим распространенным примером функции программного обеспечения является расширенная функциональность сети. При необходимости включить маршрутизацию или межсетевую фильтрацию, соответствующие настройки должны быть включены в файл конфигурации ядра. 

=== Готовы? ===

После ознакомления с базовыми понятиями уже можно достаточно просто определить аппаратное обеспечение, просматривать интерфейс menuconfig и выбирать требуемые параметры ядра для системы. 

Остальная часть этого руководства направлена на разъяснение областей часто вызывающих затруднения и объяснение как избежать общих проблем, с которыми сталкиваются пользователи. Успехов!

== Распространенные проблемы и затруднения ==

=== SATA-диски являются дисками SCSI ===

Большинство современных настольных систем поставляются с запоминающими устройствами (жесткий диск и приводы CD/DVD) на шине [https://en.wikipedia.org/wiki/Serial_ATA Serial ATA], вместо более старой шины [https://en.wikipedia.org/wiki/Parallel_ATA IDE] (резиновый кабель). 

Поддержка SATA в Linux реализована через слой, называемый ''libata'', который располагается уровнем ниже подсистемы SCSI. По этой причине, драйвера SATA находятся в разделе конфигурации с драйверами SCSI. Кроме того, устройства хранения данных могут обрабатываться как SCSI-устройства, а это значит, что необходима поддержка SCSI диска или cdrom. Первый жесткий диск SATA, будет иметь название {{Path|/dev/sda}}, а первый привод CD/DVD — {{Path|/dev/sr0}}. 

Хотя большинство этих драйверов предназначено для контроллеров SATA, libata не была предназначена только для SATA. Все распространенные драйвера IDE будут также портированы на libata в ближайшем будущем, и, на тот момент, вышеупомянутые рассмотрения также будут применимы и к пользователям IDE. 

{{KernelBox|title=Параметры конфигурации для libata|1=
Device Drivers  --->
   SCSI device support  --->
      <*> SCSI device support
      <*> SCSI disk support
      <*> SCSI CDROM support
 
      [ ] SCSI low-level drivers  --->
 
   <*> Serial ATA and Parallel ATA drivers (libata)  --->
}}

{{Note|Не стандартные чипсеты перечислены под <code>SCSI low-level drivers</code> в <code>Serial ATA and Parallel ATA drivers (libata)</code> как показано в примере выше.}}

=== Чипсеты IDE и DMA ===

Вопреки появлению SATA, устройства IDE все еще являются очень распространенными, и от них зависят многие части системы. IDE является достаточно общей технологией и, таким образом, Linux поддерживает почти все контроллеры IDE "из коробки" без необходимости выбирать какие-либо параметры для контроллера. 

Хотя, IDE является старой технологией и в своей первоначальной версии с программным вводом-выводом не может предоставить скорости передачи необходимые для быстрого доступа к современным запоминающим устройствам. Универсальный драйвер IDE ограничен этими режимами передачи программного ввода-вывода, что приводит медленным скоростям передачи данных и гораздо более высокому использованию центрального процессора, когда данные передаются с диска и на диск. 

Если не работаете с системой 1995-го года и ранее, контроллер IDE также может поддерживать альтернативный режим передачи, известный как ''Direct Memory Access (DMA)'' - прямой доступ к памяти. DMA намного быстрее и при передаче данных центральный процессор едва используется. При действительно плохой общей производительности системы и использовании IDE-диска, вероятно, DMA не используется и должен быть выключен.

{{Note|Как упомянуто ранее, libata доступна даже для приводов IDE. Если используется libata, то все приводы, включая приводы IDE, будут использовать DMA. Нет необходимости делать дальнейшую проверку или конфигурацию.}}

Если libata не используется для IDE-дисков, то необходимо включить использование DMA. Следующая команда поможет определить используется ли DMA:

{{RootCmd|hdparm -d /dev/hda|output=<pre>
/dev/hda:
 using_dma    =  0 (off)
</pre>
}}

Для включения DMA на старых устройствах IDE (deprecated (устаревший) параметр), включите следующую функцию ядра.

{{Warning|Включение <var>CONFIG_BLK_DEV_IDE_SATA</var> приведет к конфликту с драйверами libata SATA. Как правило, на контроллерах IDE поддержка SATA отключена, так как они лучше поддерживаются со стороны активно разрабатываемой SCSI подсистемы. Включение <var>CONFIG_BLK_DEV_IDE_SATA</var> вызовет конфликт с поддержкой libata в SATA, что является плохой идеей. Этот драйвер предназначен для работы со старыми устройствами IDE. Оставьте SATA для libata, если это возможно!}}

{{KernelBox|title=Параметры конфигурации для устаревших контроллеров IDE|1=
Device Drivers  --->
   <*> ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
      --- ATA/ATAPI/MFM/RLL support (DEPRECATED)
      [ ]   Support for SATA (deprecated; conflicts with libata SATA driver)
      <*>   generic ATA/ATAPI disk support
      [*]     ATA disk support
      [*]     ATAPI floppy support
      <*>   Include IDE/ATAPI CDROM support
      <*>   Include IDE/ATAPI TAPE support
  
            *** IDE chipset support/bugfixes ***
      <*>   generic/default IDE chipset support
  
            *** PCI IDE chipsets support ***
}}

{{Note|Выберете нужный чипсет(ы) из перечисленных под <code>*** PCI IDE chipset support ***</code> в ''Configuration options for IDE controllers'' как показано в примере выше.}}

=== USB хост-контроллеры ===

[[USB]] — это общепринятая шина для подсоединения внешних периферийных устройств к компьютеру. Одной из причин успеха USB является то, что это стандартизированный протокол. Однако же, устройства хост-контроллера USB (USB ''host controller devices (HCD)''), размещенные на хосте, немного различаются. Имеются 4 главных вида: 

# <code>UHCI</code> - Universal Host Controller Interface (универсальный интерфейс хост-контроллера). Он поддерживает USB 1.1, и обычно имеется на материнских платах, основанных на чипсете VIA или Intel.
# <code>OHCI</code> - Open Host Controller Interface (открытый интерфейс хост-контроллера). Он поддерживает USB 1.1 и обычно имеется на материнских платах, основанных на чипсете Nvidia или SiS.
# <code>EHCI</code> - Extended Host Controller Interface (усовершенствованный интерфейс хост-контроллера). Это единственный распространенный интерфейс хост-контроллера, поддерживающий USB 2.0 и обычно присутствующий на любом компьютере с поддержкой USB 2.0.
# <code>XHCI</code> - eXtensible Host Controller Interface (расширяемый интерфейс хост-контроллера). Это хост-контроллер интерфейс для USB 3.0, который совместим с USB 1.0, 1.1, 2.0, 3.0 и будущими версиями. Включите эту опцию, если ваша плата поддерживает USB 3.0.

Большинство систем поставляются с двумя из перечисленных выше типов интерфейсов: XHCI (USB 3.0) и EHCI (USB 2.0). Для использования USB-устройств не нужно выбирать оба варианта, так как XHCI совместим с более медленными контроллерами USB. Но что бы "обезопасить" себя, пользователь может включить поддержку EHCI; это не причинит вреда, если USB 2.0 контроллер отсутствует в системе.

Если параметры, соответствующие типам USB HCD, отсутствуют в системе, тогда можете получиться эффект 'мертвых' USB-портов. Такой случай определить так: при подключении работающего устройства оно не снабжается питанием или не подает каких-либо признаков жизни. 

С помощью отличной команды {{c|lspci}} (из пакета {{Package|sys-apps/pciutils}}) можно относительно легко обнаружить какие устройства HCD присутствуют на системе. Игнорируя контроллер SATA, который также соответствует запросу, легко обнаружить, что эта система требует поддержку EHCI и XHCI:

{{RootCmd|lspci -v {{!}} grep HCI|output=<pre>
00:14.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB xHCI (rev 04) (prog-if 30 [XHCI])
00:1a.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #2 (rev 04) (prog-if 20 [EHCI])
00:1d.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #1 (rev 04) (prog-if 20 [EHCI])
00:1f.2 SATA controller: Intel Corporation 8 Series/C220 Series Chipset Family 6-port SATA Controller 1 [AHCI mode] (rev 04) (prog-if 01 [AHCI 1.0])
</pre>
}}

Выберите HCD присутствующий в системе. В общем случае, можно выбрать все три варианта для максимальной поддержки, если правильный вариант неизвестен:

{{KernelBox|title=[[USB#Kernel_Configuration|Конфигурация USB HCDs]]|1=
Device Drivers  --->
   USB support  --->
      <*> Support for Host-side USB
      ---   USB Host Controller Drivers
      <*>   xHCI HCD (USB 3.0) support
      <*>   EHCI HCD (USB 2.0) support
      < >   OHCI HCD  (USB 1.1) support
      < >   UHCI HCD (most Intel and VIA) support
}}

В ядре Linux версии 3.12.13 и новее <code>OHCI support for PCI-bus USB controllers</code> (<code>CONFIG_USB_OHCI_HCD_PCI</code>) стоит включить, если USB-контроллер это OHCI и используется USB клавиатура или мышь.

=== Мультипроцессоры, гиперпоточность и многоядерные системы ===

Множество компьютеров основаны на многоядерных процессорах, но это не всегда очевидно. 

* Множество центральных процессоров Intel поддерживают технологию, называемую [https://en.wikipedia.org/wiki/Hyper-threading hyper-threading]. Эта технология позволяет системе задействовать одноядерный процессор как процессор с двумя ''логическими'' процессорами.
* Большинство процессоров Intel и AMD фактически состоят из множества физических процессоров внутри одного корпуса, такие процессоры известны как [https://en.wikipedia.org/wiki/Multi-core_processor многоядерные] процессоры.
* Некоторые дорогие (последней модели) системы в действительности имеют множество физических процессоров, установленных на специализированной материнской плате для значительного увеличения производительности по сравнению с ''однопроцессорной'' системой. Пользователи таких систем, возможно, будут в курсе, что у них такая система, так как они недешевы.

Во всех этих случаях требуется выбрать соответствующие параметры ядра для получения оптимальной производительности для этих установок:

{{KernelBox|title=Конфигурация поддержки мультипроцессорных систем|1=
Processor type and features  --->
 [*] Symmetric multi-processing support
 [*]   SMT (Hyperthreading) scheduler support
 [*]   Multi-core scheduler support (NEW)
}}

Следующая опция предназначена не только для управления питанием, но также может быть необходима для определения всех процессоров, доступных в системе:

{{KernelBox|title=Управление питанием для мультипроцессорных систем|1=
Power management and ACPI options  --->
 [*] ACPI (Advanced Configuration and Power Interface) Support
}}

=== Поддержка High Memory для x86 ===

Вследствие ограничений в 32-битном адресном пространстве на архитектуре {{Keyword|x86}}, ядро с настройками по умолчанию поддерживает только 896 Мб оперативной памяти. Если система обладает большим количеством памяти, будут доступны только первые 896 Мб, если только не включена поддержка "верхней памяти" (high memory support). 

{{Note|Это ограничение характерно для архитектуры {{Keyword|x86}} (IA32). Другие архитектуры свободно поддерживают большие количества памяти без каких-либо настроек.}}

Поддержка верхней памяти по умолчанию не включена, потому что она накладывает небольшую дополнительную нагрузку на систему. Не волнуйтесь, дополнительная нагрузка незначительна по сравнению с подъемом производительности или доступностью большего количества памяти! 

Выберите вариант 4 Гб, если ваша система имеет более 4 ГБ оперативной памяти:

{{KernelBox|title=Включение поддержки верхней памяти для архитектуры x86|1=
Processor type and features  --->
 High Memory Support  --->
  (X) 4GB
  ( ) 64GB
}}

=== Сжатые модули ядра ===

Начиная с версии ядра 3.18.x (и выше) возможно сжатие модулей ядра. Доступно сжатие gzip и xz. Важно установить {{Package|sys-apps/kmod}} с нужными USE-флагами ''перед'' компиляцией ядра со сжатыми модулями:

{{FileBox|filename=/etc/portage/package.use|title=Включение поддержки сжатия для kmod|1=
sys-apps/kmod lzma zlib
}}

Перекомпилируйте {{Package|sys-apps/kmod}}:

{{Emerge|params+=--oneshot --changed-use|sys-apps/kmod}}

Включите сжатие модулей и выберите предпочитаемый метод сжатия:
{{KernelBox|title=Включение сжатие модулей|1=
Enable loadable module support --->
  [*]   Compress modules on installation
  Compression algorithm ()  --->
    <X> GZIP
        XZ
}}

Обычно {{c|make modules_install}} запускает {{c|depmod}}. Если у {{Package|sys-apps/kmod}} не были установлены необходимые USE-флаги (смотрите настройки в {{Path|package.use}} в предыдущем шаге) при первом запуске, то, в этом случае, зависимостей не будет. Система не сможет загрузить какой-либо модуль, который был скомпилирован и сжат.

После перекомпиляции kmod, еще раз запустите {{c|depmod}}, чтобы решить эту проблему:

{{RootCmd|depmod -a
|modprobe <module_name>
}}

== Сокращенное обозначение настроек ядра ==

=== Введение ===

При прочтении о конфигурации ядра, часто настройки описываются как <var>CONFIG_<something></var>. Это сокращенное обозначение является тем, что используется в конфигурации ядра внутренне, и то, что можно обнаружить в файле конфигурации ядра (будь это {{Path|/usr/src/linux/.config}} или автоматически созданный файл {{Path|/proc/config.gz}}). Конечно же, использование сокращенных обозначений бесполезно если их нельзя перевести в действительное местонахождение настроек ядра. Утилита {{c|make menuconfig}} позволяет это сделать.

=== Перевод параметра CONFIG_FOO в действительное местонахождение настроек ===

Предположим, неоходимо включить параметр <var>CONFIG_TMPFS_XATTR<var>. Запустите меню конфигурации ядра ({{c|make menuconfig}}) и нажмите {{Key|/}}. Это откроет поле поиска. В это поле введите <var>CONFIG_TMPFS_XATTR</var>. 

Следующий вывод является результатом этого поиска:

{{KernelBox|title=Результат поиска "CONFIG_TMPFS_XATTR" в menuconfig|1=
Symbol: TMPFS_XATTR [=n]
Type  : boolean
Prompt: Tmpfs extended attributes
  Defined at fs/Kconfig:138
  Depends on: TMPFS [=y]
  Location:
    -> File systems
      -> Pseudo filesystems
(1)     -> Virtual memory file system support (former shm fs) (TMPFS [=y])
  Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
}}

Вывод работы команды содержит много интересной информации.

{| class="table table-condensed table-striped" style="text-align: left;" 
|- 
! Запись
! Описание
|- 
| Symbol: TMPFS_XATTR [=n]
| Это определяет искомый элемент конфигурации ядра. Оно также сообщает, что настройка в данный момент ''отключена'' ([=n]).
|- 
| Type: boolean
| Искомая настройка является булевым значением (что означает, что у нее есть две опции: включена или отключена). Некоторые настройки являются числами или строками.
|- 
| Prompt: Tmpfs extended attributes
| Это текст, который содержится в элементах команды {{c|make menuconfig}}, которые контролирую переменную (<var>TMPFS_XATTR</var>) в файле {{Path|.config}}. По большому счету это имя переменной в более удобном виде для человека.
|- 
| Depends on: TMPFS [=y]
| Перед тем как увидеть эту запись, необходимо включить <var>CONFIG_TMPFS</var>. В данном случае, это сделано (отсюда и [=y]), но если это не так, необходимо сначала найти (и включить) параметр <var>CONFIG_TMPFS</var>.
|- 
| Location: ...
| Это местонахождение в структуре, генерируемой утилитой {{c|make menuconfig}}, где можно найти данную настройку. Вспомните что искомой настройкой является ''Tmpfs extended attributes''.
|- 
| Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
| Если настройки, описанные здесь, включены обе (в данном случае, первая нет), то параметр <var>CONFIG_TMPFS_XATTR</var> будет также включен автоматически и не будет возможности его ''отключить'' пока хотя бы одна из этих настроек не будет отключена.
|-
|}

С помощью этой информации можно довольно легко перевести любые требования <var>CONFIG_*</var>. Вкратце, это означает что пользователю необходимо:

# включить настройки, описанные в поле ''Depends on''
# перейти к указанному местоположению ''Location''
# переключить значение, указанное в ''Prompt:''

{{Tip|Notice the number in parenthesis; users can jump to that option, or as close as possible for enabled menus, by pressing the number while in the search. In the above example, pressing {{Key|1}} on the keyboard will jump to or near that option. }}

== Другая документация по конфигурации ядра ==

До сих пор обсуждались только основные концепции и специфические проблемы, относящиеся к конфигурации ядра, без углубления в подробности; подробности оставлены для изучения пользователю. Однако, другие части документации Gentoo предусматривают специализированные подробности для рассматриваемых тем.

Эти документы могут быть полезны при конфигурации специфичных областей ядра. Хотя это предупреждение было упомянуто ранее в этом руководстве, запомните: пользователям, которые только начали осваивать конфигурацию ядра, не следует смело изменять любые настройки в ядре. Сначала настройте базовое и загружающееся ядро, всегда можно вернуться к настройке позже, чтобы добавить поддержку звука, печати и так далее.

Настройки "базово-рабочего" ядра помогут в последующей конфигурации, поскольку пользователь будет знать, что может нарушить базовую работу систему, а что нет. Разумно будет сохранить базовую (рабочую) конфигурацию ядра в другой каталог, а не в каталог с исходным кодом ядра ''до'' добавления новых функций или поддержки аппаратного обеспечения.  

* [[ALSA|Статья ALSA]] описывает в подробностях параметры, требуемые для звуковой карты. Следует заметить, что ALSA является исключением из предложенной схемы сборки компонентов не в качестве модулей: систему ALSA намного проще сконфигурировать, если компоненты являются модульными.

* [[Bluetooth|Статься Bluetooth]] описывает параметры, необходимые для использования устройств Bluetooth.

* [[IPv6 router guide/ru|Руководство по развертыванию IPv6-маршрутизатора]] описывает как сконфигурировать ядро для маршрутизации, используя схему сетевой адресации нового поколения.

* При использовании закрытых графических драйверов nVidia для улучшенной производительности 3D-графики, в [[NVidia/nvidia-drivers/ru|руководстве по nVidia]] перечисляются параметры, которые требуется выбрать или отключить.

* В числе прочих вещей, в [[Power_management/Guide/ru|руководстве по управлению питанием]] объясняется как настроить ядро для управления частотой центрального процессора и для функций энергосбережения и режима сна.

* Если используется система PowerPC, в [[PPC/FAQ/ru|в списке часто задаваемых вопросов по PPC]] имеются несколько разделов, посвященных конфигурации ядра для PPC.

* [[Printing/ru|Руководство по печати]] перечисляет параметры ядра, необходимые для поддержки печати в Linux.

* [[USB/Guide|Руководство по USB]] описывает конфигурацию, необходимую для использования распространенных USB-устройств, таких как клавиатуры и мыши, запоминающие устройства и USB-принтеры.

== Устранение проблем ==

=== Изменения конфигурации не вступают в силу ===

Среди пользователей весьма распространенной ошибкой является то, что они делают изменения в конфигурации, но затем совершают небольшую ошибку в процессе загрузки в только что настроенное ядро. Они перезагружаются в образ ядра, не являющийся тем, который они только что сконфигурировали, замечают, что проблема, которую они пытались решить, все еще присутствует и приходят к выводу что изменения конфигурации не решили проблему. 

Процесс компиляции и установки ядер находится за рамками этого документа; обратитесь к [[Kernel/Upgrade/ru|руководству по обновлению ядра]]  за общими инструкциями. Вкратце, процесс получения измененного ядра заключается в следующем: 1&#41; конфигурация, 2&#41; компиляция, 3&#41; монтирование раздела {{Path|/boot}} (если он еще не примонтирован), 4&#41; копирование нового образа ядра в {{Path|/boot}}, 5&#41; убедитесь, что загрузчик ссылается на новое ядро, 6&#41; перезагрузка. Если какой-нибудь из финальных шагов пропущен, изменения не вступят в силу.

Можно проверить соответствует ли загруженное ядро с недавно скомпилированным ядром. Это можно сделать, изучив дату и время компиляции ядер. Предполагая, что используется архитектура {{Keyword|x86}} и исходный текст ядра установлены в {{Path|/usr/src/linux}}, можно использовать следующую команду:

{{RootCmd|uname -v|output=<pre>
#4 SMP PREEMPT Sat Jul 15 08:49:26 BST 2006
</pre>}}

Приведенная выше команда отобразит дату и время компиляции ядра, загруженного в настоящий момент.

{{RootCmd|ls -l /usr/src/linux/arch/i386/boot/bzImage|output=<pre>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
</pre>}}

Приведенная выше команда отображает дату и время когда образ ядра был скомпилирован в последний раз.

Если временные отметки из предыдущих команд отличаются более чем на 2 минуты, это означает что в процессе переустановки ядра была сделана ошибка и система загружена не с новым образом ядра.

=== Модули не загружаются автоматически ===

Как указано в этом документе ранее, система конфигурации ядра скрывает под собой большие изменения в поведении при выборе компонента ядра в качестве модуля <code>(M)</code>, вместо встроенного <code>(Y)</code>. Важно повторить это снова, так как много пользователей попадают в эту ловушку.

При встраивании компонента в ядро, код встраивается в образ ядра (bzImage). Когда ядру требуется использовать этот компонент, оно может инициализировать и загрузить его автоматически, без вмешательства пользователя. 

При выборе компонента в качестве модуля, код встраивается в файл модуля ядра и устанавливается на файловую систему. В основном, когда ядру требуется использовать этот компонент, оно не может найти его. За некоторыми исключениями, ядро не совершает попыток загрузки этих модулей — эта задача оставлено пользователю. 

Если поддержка сетевой платы включена в качестве модуля, и затем обнаруживается что сеть не доступна, это, возможно, потому что модуль не загружен — можно, либо сделать это вручную, либо система должно быть настроена для автоматической загрузки модулей во время запуска системы.

Если нет особых причин сделать по-другому, то можно сохранить время компилируя эти компоненты прямо в образ ядра, так чтобы ядро могло автоматически произвести эти небольшие настройки самостоятельно.

== Смотрите также ==

* [[genkernel/ru|genkernel]] — утилита предназначенная для автоматизации компиляции ядра и initramfs.
* [[Security_Handbook/Network_security#The proc filesystem|proc filesystem (Security Handbook)]] — динамическое изменение параметров и переменных ядра на лету.


[[Category:Kernel]] [[Category:Server and Security]] {{Migrated|originalauthors=Daniel Drake, Curtis Napier, Justin Robinson, Lukasz Damentko, Jonathan Smith, nightmorph}}
