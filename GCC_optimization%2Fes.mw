<languages />

{{Metadata|abstract=Esta guía ofrece una introducción al código compilado de forma óptima usando CFLAGS y CXXFLAGS seguras y sanas. También describe la teoría detrás de la optimización en general.}}

Esta guía ofrece una introducción al código compilado de forma óptima usando CFLAGS y CXXFLAGS seguras y sanas. También describe la teoría detrás de la optimización en general.

== Introducción ==

=== ¿Qué son CFLAGS y CXXFLAGS? ===

<code>CFLAGS</code> y <code>CXXFLAGS</code> son variables de entorno usadas para indicar a la Colección de Compiladores de GNU (GCC), qué tipo de opciones usar cuando compila código fuente. La variable <code>CFLAGS</code> se utiliza para compilar código escrito en C, mientras que la variable <code>CXXFLAGS</code> es para código escrito en C++. 

Pueden usarse para disminuir la cantidad de mensajes de depuración
de un programa, aumentar los niveles de aviso de errores, y por supuesto, optimizar el código producido. El [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC manualde GCC] ofrece una lista completa opciones disponibles y sus aplicaciones.

=== ¿Cómo se utilizan? ===

CFLAGS y CXXFLAGS se pueden usar de dos formas. La primera, por programa con los ficheros Makefile generados por el programa <tt>automake</tt>. 

Sin embargo, esto no se debería hacer cuando instalamos paquetes que se encuentran en el árbol Portage. En su lugar, para máquinas basadas en Gentoo, se definen las variables <code>CFLAGS</code> y <code>CXXFLAGS</code> en {{Path|/etc/portage/make.conf}}. De esta forma todos los paquetes se compilarán con las opciones especificadas en {{Path|make.conf}}.

{{CodeBox|title=Ajustar CFLAGS en /etc/portage/make.conf|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important/es|Aunque es posible tener varias líneas en los ajustes '''USE''', hacer lo mismo en CFLAGS puede y '''dará''' problemas con programas como <tt>cmake</tt>. Asegúrese de que la declaración CFLAGS se realiza en una sola línea con el menor número posible de espacios en blanco para evitar estos problemas. Eche un vistazo a la incidencia {{Bug|500034}} a modo de ejemplo.}}

Como se puede observar en el ejemplo de arriba, <code>CXXFLAGS</code> se define para usar todas las opciones presentes en <code>CFLAGS</code>. La mayoría de los sistemas se configurarán de este modo ya que las opciones adicionales para <code>CXXFLAGS</code> son ''extremadamente raras'' en los casos de uso comunes.

=== Confusiones ===

Aunque <code>CFLAGS</code> y <code>CXXFLAGS</code> pueden ser muy efectivos tomando el código fuente para producir binarios pequeños o rápidos, también pueden deteriorar la función del código, inflar su tamaño, ralentizar su tiempo de ejecución. Ajustarlas incorrectamente ¡puede incluso causar errores de compilación! 

<code>CFLAGS</code> no es una solución mágica; no hará que el sistema corra más rápido o se reduzca el tamaño de los binarios en el disco. Añadir demasiadas opciones en un intento de optimización (o "exprimir") el sistema es una receta segura para fracasar. El punto en el que se reduce el redimiento se alcanza más rápidamente si se toquetea <code>CFLAGS</code>. 

A pesar de las recomendaciones y alardeos que se pueden encontrar en Internet, unas variables <code>CFLAGS</code> y <code>CXXFLAGS</code> agresivas están más cerca de dañar los binarios que de hacerles algún bien. Recuerde que la razón principal por la que existen las opciones es porque están diseñadas para usarse en sitios ''específicos'' para propósitos ''específicos''. Hay pocos ajustes que funcionen de forma global tal y como se espera.

=== ¿Preparado? ===

Conociendo los riesgos involucrados, echemos un vistazo a algunas optimizaciones sanas y seguras para su computadora. Esto le será útil y también alentador para los desarrolladores la próxima vez que se informe de un problema en [https://bugs.gentoo.org/ Bugzilla]. (Los desarrolladores suelen pedir al usuario que recompile un paquete con los <code>CFLAGS</code> mínimos para ver si el problema persiste. Recuerde: ¡Las opciones agresivas pueden arruinar el código!) 

== Optimización ==

=== Conceptos básicos ===

El objetivo de usar <code>CFLAGS</code> y <code>CXXFLAGS</code> es crear código específico para su sistema; debería funcionar perfectamente y ser ligero y rápido, si es posible. Algunas veces estás condiciones son mutuamente excluyentes, de modo que esta guía trabaja con combinaciones que se sabe que funcionan bien. Idealmente, las mejores están disponibles para cada arquitectura de CPU. Se cubren más adelante, a modo de información, ajustes más agresivos. No se discute cada opción listada en el manual de GCC, sin embargo se revisarán las opciones más comunes. 

{{Note|Cuando no esté seguro de la función que realiza determinada opción, acuda al capítulo correspondiente del [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-manual de opciones Options de GCC]. Si aún continúa atascado después de mirar en el manual, pruebe con un motor de búsquega o revise las [http://gcc.gnu.org/lists.html listas de correo de GCC]}}

=== -march ===

La primera y más importante opción es <code>-march</code>. Esta le dice al compilador que código debería producir para su [http://es.wikipedia.org/wiki/Microarquitectura arquitectura de procesador] (o ''arch''), le indica a GCC que debería producir código para un cierto tipo de CPU. Diferentes CPUs tienen diferentes características, soportan diferentes conjunto de instrucciones y tienen diferentes formas de ejecutar código. La opción <code>-march</code> indicará al compilador que produzca código específico para la CPU del sistema, tomando en cuenta todas sus capacidades, características,
conjuntos de instrucciones, caprichos y demás. 

A pesar que la variable <code>CHOST</code> en {{Path|/etc/portage/make.conf}} especifica la arquitectura general utilizada, <code>-march</code> también se usa para que los programas se optimicen para el procesador específico del sistema. Las arquitecturas x86 y x86-64 (entre otras) también deberían utilizar la opción <code>-march</code>. 

¿Qué tipo de CPU tiene el sistema? Para averiguarlo, ejecute la siguiente orden: 

{{Cmd|cat /proc/cpuinfo}}

Para obtener más detalles, incluyendo valores <code>march</code> y <code>mtune</code>, utilice:

{{Cmd|<nowiki>gcc -c -Q -march=native --help=target</nowiki>}}

Ahora veamos a <code>-march</code> en acción. Este ejemplo es para un antiguo Pentium III: 

{{CodeBox|filename=/etc/portage/make.conf|title=Ejemplo para Pentium III|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

Aquí hay otro para una CPU AMD de 64 bits: 

{{FileBox|filename=/etc/portage/make.conf|title=Ejemplo para AMD64|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

Si no se puede determinar el tipo de CPU o si e usuario no sabe que ajustes elegir, es posible utilizar el ajuste <code>-march=native</code>. Al usarla, GCC intentará detectar el procesador y automáticamente usará las opciones apropiadas. '''¡Sin embargo, no se debe utilizar esto si se quiere compilar paquetes para CPUs diferentes!''' 

{{Warning/es|'''No''' utilice <code>-march{{=}}native</code> o <code>-mtune{{=}}native</code> en las variables <code>CFLAGS</code> o <code>CXXFLAGS</code> de {{Path|make.conf}} cuando compile con <tt>[[Distcc/es#-march.3Dnative|distcc]]</tt>.}}

Si se está compilando paquetes en una computadora, para ejecutarlos en una computadora diferente (usando, por ejemplo, una computadora rápida para construir paquetes para una máquina más antigua y lenta), entonces ''no'' utilice la opción <code>-march=native</code>. La palabra "native" significa que el código producido podrá ejecutarse ''solamente'' en ese tipo de CPU. Las aplicaciones construidas con <code>-march=native</code> en una CPU AMD Athlon 64 CPU '''''no''''' podrán ejecutarse en una CPU VIA C3 más antigua. 

También están disponibles las opciones <code>-mcpu</code> y <code>-mtune</code>. Cada una de ellas solo se usará cuando no haya otra opción <code>-march</code> disponible. Ciertas arquitecturas de procesador pueden requerir <code>-mtune</code> o incluso de <code>-mcpu</code>. Desgraciadamente, el comportamiento de GCC no es muy consistente con la manera que cada opción se comporta de una arquitectura a otra. 

En CPUs x86 y x86-64, <code>-mcpu</code> se generará código específico para esa CPU usando sus instrucciones disponibles y el ABI correcto; no tendrá compatibilidad hacia atrás para CPUs antiguas o diferentes. Se puede considerar el uso de <code>-mtune</code> cuando se genere código para CPUs antiguas como i386 e i486. <code>-mtune </code> produce un código más genérico que <code>-march</code>; aunque afinará el código para cierta CPU, no se tendrán en cuenta los conjuntos de instrucciones disponibles y ABI. No utilice la opción <code>-mcpu</code> en sistemas x86 o x86-64, ya que es obsoleto para estas arquitecturas. 

Solo las CPUs que no sean x86/x86-64 (como Sparc, Alpha y PowerPC) pueden requerir <code>-mtune </code> o <code>-mcpu</code> en lugar de <code>-march</code>. En estas arquitecturas, <code>-mtune</code>/<code>-mcpu</code> algunas veces se comportará como <code>-march</code> en (x86/x86-64)... pero con un nombre distinto. De nuevo, el comportamiento de GCC y los nombres de las opciones no son consistentes entre arquitecturas, así que asegúrese de revisar el [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] de GCC para determinar cual de ellas se debería utilizar. 

{{Note|Para más sugerencias de configuraciones de <code>-march</code>/<code>-mtune</code>/<code>-mcpu</code>, por favor lea el capítulo 5 del [[HandBook:Main_Page/es|manual de instalación de Gentoo]] para la arquitectura. También, lea el manual de GCC listado en la página de [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options opciones específicas por arquitectura] con explicaciones más detalladas sobre las diferencias entre <code>-march</code>, <code>-mcpu</code>, y <code>-mtune</code>.}}

=== -O ===

Hablaremos ahora de la variable <code>-O</code>. Esta variabe controla el nivel de optimización de todo el código. Al cambiar este valor, la compilación de código tomará algo más de tiempo, y utilizará mucha más memoria, especialmente al incrementar el nivel de optimización. 

Existen siete ajustes para <code>-O</code>: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code> y <code>-Ofast</code>. Se debe utilizar solo uno de ellos en {{Path|/etc/portage/make.conf}}.

A excepción de <code>-O0</code>, la configuración de <code>-O</code> activa varias opciones adicionales, así que asegúrese de leer el capítulo del manual de gcc en[http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options opciones de optimización] para aprender qué opciones se activan en cada nivel <code>-O</code>, así como algunas explicaciones sobre lo que hacen. 

Let us examine each optimization level: 

*  <code>-O0</code>: This level (that is the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in <code>CFLAGS</code> or <code>CXXFLAGS</code>. This reduces compilation time and can improve debugging info, but some applications will not work properly without optimization enabled. This option is not recommended except for debugging purposes.

*  <code>-O1</code>: the most basic optimization level. The compiler will try to produce faster, smaller code without taking much compilation time. It is basic, but it should get the job done all the time.

*  <code>-O2</code>: A step up from <code>-O1</code>. The ''recommended'' level of optimization unless the system has special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code>. With <code>-O2</code>, the compiler will attempt to increase code performance without compromising on size, and without taking too much compilation time.

*  <code>-O3</code>: the highest level of optimization possible. It enables optimizations that are expensive in terms of compile time and memory usage.  Compiling with <code>-O3</code> is not a guaranteed way to improve performance, and in fact, in many cases, can slow down a system due to larger binaries and increased memory usage. <code>-O3</code> is also known to break several packages. Using <code>-O3</code> is not recommended.

*  <code>-Os</code>: optimizes code for size. It activates all <code>-O2</code> options that do not increase the size of the generated code. It can be useful for machines that have extremely limited disk storage space and/or CPUs with small cache sizes.

* <code>-Og</code>: En GCC 4.8 aparece un nuevo nivel del optimización general: <code>-Og</code>. Trata de solucionar la necesidad de realizar compilaciones más rápidas y obtener una experiencia superior en la depuración a la vez que ofrece un nivel razonable de rendimiento en la ejecución. La experiencia global en el desarrollo debería ser mejor que para el nivel de optimización <code>-O0</code>. Observe que <code>-Og</code> no implica <code>-g</code>, éste simplemente deshabilita optimizaciones que podrían interferir con la depuración.

* <code>-Ofast</code>: Nuevo en GCC 4.7. Consiste en el ajuste <code>-O3</code> más las opciones <code>-ffast-math</code>, <code>-fno-protect-parens</code> y <code>-fstack-arrays</code>. Esta opción rompe el cumplimiento de estándares estrictos y no se recomienda su utilización.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and while not using <code>-O2</code>, try rebuilding with that option. As a fallback option, try setting the <code>CFLAGS</code> and <code>CXXFLAGS</code> to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).

=== -pipe ===

A common flag is <code>-pipe</code>. This flag has no effect on the generated code, but it makes the compilation process ''faster''. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, GCC might get killed. In those cases do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but it may need to activated. In that case add it to the flags. Though the GCC manual does not specify all architectures, it is turned on by using the <code>-O</code> option. Use the <code>-O</code> option to explicitly activate it on x86, with GCC up to version 4.6 or when using <code>-Os</code>. However, using this flag will make debugging hard or impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. When not doing software debugging and no other debugging-related CFLAGS such as <code>-ggdb</code> have been used, then try using <code>-fomit-frame-pointer</code>. 

{{Important/es|''No'' combine <code>-fomit-frame-pointer</code> con la opción de nombre similar <code>-momit- leaf-frame-pointer</code>. No se aconseja la utilización de esta última, ya que <code>-fomit-frame-pointer</code> ya hace el trabajo apropiado. Es más, <code>-momit-leaf-frame-pointer</code> ha demostrado que impacta negativamente en el rendimiento del código.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extentions] (SSE), [http://en.wikipedia.org/wiki/SSE2 SSE2], [http://en.wikipedia.org/wiki/SSSE3 SSE3], [http://en.wikipedia.org/wiki/MMX_(instruction_set) MMX], and [http://en.wikipedia.org/wiki/3dnow 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to see if the CPU supports these instruction sets by running <kbd>cat /proc/cpuinfo</kbd>. The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

Normally none of these flags need to be added to {{Path|/etc/portage/make.conf}}, as long as the system is using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code>). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these additional flags will need to be enabled where appropriate after checking {{Path|/proc/cpuinfo}}. 

{{Note|Check the [http://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags] to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then it does not need to be separately specified; it will be turned on by using the proper <code>-march</code> setting.}}

== Preguntas frecuentes sobre optimización ==

=== Sin embargo, ¡Consigo mejor rendimiento con -funroll-loops -fomg-optimize! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt applications when used system-wide. Even the GCC [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> will make code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

La verdad es que son opciones peligrosamente agresivas. Eche un vistazo a los [https://forums.gentoo.org/ Foros de Gentoo] y a [https://bugs.gentoo.org/ Bugzilla] para
ver que hacen estas variables: ¡Nada bueno! 

You do not need to use those flags globally in CFLAGS or CXXFLAGS. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat the code and get your bugs marked INVALID or WONTFIX. 

No necesita opciones peligrosas como estas. '''No las
utilice'''. Quédese con las básicas: <code>-march</code>, <code>-O</code> y <code>-pipe</code>.

=== ¿Qué pasa con los niveles -O mayores que 3 ===

Algunos usuarios alardean de que obtienen mejor rendimiento usando <code>-O4</code>, <code>-O9</code> y similares, pero la realidad es que niveles de <code>-O</code> mayores que 3 no tienen efecto. El compilador puede aceptar CFLAGS como <code>-O4</code>, pero realmente no hace nada con él. Solo realiza la optimización para <code>-O3</code>, nada más. 

¿Necesita más pruebas? Eche un vistazo al [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup código fuente]: 

{{CodeBox|title=Código fuente -O|lang=bash|1=
if (optimize >= 3)
  {
   flag_inline_functions = 1;
   flag_unswitch_loops = 1;
   flag_gcse_after_reload = 1;
   /* Permitir más operadores virtuales. */
   set_param_value ("max-aliased-vops", 1000);
   set_param_value ("avg-aliased-vops", 3);
  }
}}

Como puede observar, cualquier valor mayor que 3 se trata como <code>-O3</code>.

=== ¿Qué ocurre cuando compilamos fuera de la máquina destino? ===

Algunos lectores se pueden preguntar si el hecho de compilar fuera de la máquina destino usando una CPU estrictamente inferior o una subarquitectura en GCC generará unos resultados de optimización inferiores. La respuesta es simple: '''No'''. Independientemente del hardware en el que realmente se realiza la compilación y el CHOST con el que se construyó GCC, si se utilizan los mismos argumentos <small> (excepto para <code>-march=native</code>)</small> y la misma versión de GCC<small> (aunque la versión menor puede ser distinta)</small>, las optimizaciones resultantes son estrictamente las mismas.

Como ejemplo, si Gentoo se instala en una máquina en el que el CHOST de GCC es ''i686-pc-linux-gnu'', y se utiliza un servidor [[Distcc/es]] en otro equipo en el que el CHOST de GCC es ''i486-linux-gnu'' entonces no hay porqué preocuparse de que los resultados sean menos óptimos ya que la subarquitectura del compilador o el hardware del equipo remoto son estrictamente inferiores. El resultado sería igual de óptimo que una construcción en una máquina nativa siempre que se pasen las mismas opciones a ambos compiladores (y no se defina el argumento <code>-march</code> como <code>native</code>). En este caso en particular se necesita especificar la aquitectura destinotal y como se indica en [[Distcc/es#-march.3Dnative|Distcc y -march=native]].

La única diferencia en el comportamiento entre dos versiones de GCC construidas con diferentes subarquitecturas es el valor implícito por defecto para el parámetro <code>-march</code> que se deriva del CHOST de GCC cuando no se ha indicado uno de forma explícita en la línea de órdenes.

=== ¿Qué pasa con las opciones redundantes? ===

A menudo CFLAGS y CXXFLAGS que se han activado en varios niveles de <code>-O</code> están especificadas de forma redundante en {{Path|/etc/portage/make.conf}}. A veces esto ocurre por
ignorancia, pero también se hace para permitir el filtrado o el reemplazo de opciones. 

El filtrado y el reemplazo de opciones se realiza en muchos ebuilds del árbol Portage. Normalmente se realiza debido a que algunos paquetes no compilan con determinados niveles <code>-O</code> o cuando el código fuente es tan sensible que no se pueden utilizar opciones adicionales. El ebuild bien filtrará algunas opciones o todas las opciones CFLAGS y CXXFLAGS, bien reemplazará <code>-O</code> con un nivel diferente. 

El [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Manual del Desarrollador de Gentoo] indica dónde y cómo funciona el filtrado y el reemplazo de opciones. 

Es posible evitar el filtrado de <code>-O</code> filtrando mediante el listado redundante de opciones para un cierto nivel, como <code>-O3</code>, haciendo cosas como: 

{{CodeBox|title=Especificar CFLAGS redundantes|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

Sin embargo, '''hacer esto no es algo acertado'''. ¡Las CFLAGS se filtran por alguna razón! Cuando estas opciones se filtran es porque es inseguro construir paquetes con ellos. Claramente, ''no'' es seguro compilar su sistema completo con <code>-O3</code> si alguna de estas opciones está activada para este nivel causará problemas con ciertos paquetes. Por lo tanto, no debería intentar 
"saber más" que los desarrolladores que mantienen estos paquetes. ''Confíe en ellos''. ¡El filtrado y reemplazo de opciones se hace por su bien!. Si un ebuild especifica opciones alternativas, entonces no intente evitarlas. 

No encontrará más que problemas cuando construya un paquete con opciones inaceptables. Cuando informe de sus problemas en Bugzilla, las opciones que usó en {{Path|/etc/portage/make.conf}} serán fácilmente visibles y se le instará a recompilar sin ellas.
¡Protéjase de los problemas de recompilar evitando el uso de opciones redundantes! No asuma automáticamente que sabe más que los desarrolladores.

=== ¿Qué pasa con LDFLAGS? ===

The Gentoo developers have already set basic, safe LDFLAGS in the base profiles, so they do not need changed. 

=== ¿Puedo usar opciones para cada paquete? ===

{{Warning/es|El uso de opciones específicas de paquetes complica la depuración y el soporte. Asegúrese mencionarlo en los informes de fallos si está usando esta característica y los cambios que haya realizado.}}

Puede encontrarse información acerca de como utilizar las variables de entorno por paquete (incluyendo CFLAGS) en el [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|manual de Gentoo "Variables de entorno por paquete"]].

== Recursos ==

Los siguientes recursos pueden ser de ayuda para comprender la optimización: 

* La [http://gcc.gnu.org/onlinedocs/ documentación en línea de GCC] 

* El capítulo 5 de los [[Handbook:Main_Page/es|manuales de instalación de Gentoo]]

* <kbd>man make.conf</kbd>

* [https://es.wikipedia.org/ Wikipedia]

* Los [https://forums.gentoo.org/ Foros de Gentoo]

{{Migrated|originalauthors=nightmorph}}
