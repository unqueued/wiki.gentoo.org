<languages />

{{Metadata|abstract=Esta guía ofrece una introducción al código compilado de forma óptima usando CFLAGS y CXXFLAGS seguras y sanas. También describe la teoría detrás de la optimización en general.}}

Esta guía ofrece una introducción al código compilado de forma óptima usando CFLAGS y CXXFLAGS seguras y sanas. También describe la teoría detrás de la optimización en general.

== Introducción ==

=== ¿Qué son CFLAGS y CXXFLAGS? ===

CFLAGS y CXXFLAGS son variables de entorno usadas para indicar a la
Colección de Compiladores de GNU, <code>gcc</code>, qué tipo de parámetros usar cuando compila código fuente. Las CFLAGS se aplican al código escrito en C, mientras que CXXFLAGS son para código escrito en C++. 

Pueden usarse para disminuir la cantidad de mensajes de depuración
de un programa, aumentar los niveles de aviso de errores, y por supuesto, optimizar el código producido. El [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC manualde GCC] ofrece una lista completa opciones disponibles y sus aplicaciones. 

=== ¿Cómo se utilizan? ===

CFLAGS y CXXFLAGS se pueden usar de dos formas. La primera, por programa con los ficheros Makefile generados por automake. 

Sin embargo, esto no debería hacerse cuando instalamos paquetes que se encuentran en el árbol Portage. En su lugar, establezca sus CFLAGS y CXXFLAGS en {{Path|/etc/portage/make.conf}}. De esta manera todos los paquetes se compilarán con las opciones que especifique. 

{{Code|CFLAGS en /etc/portage/make.conf|<pre>
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
</pre>
}}

{{Important/es|Aunque es posible tener varias líneas en los ajustes USE, hacer lo mismo en CFLAGS puede y nos dará problemas con programas como  <code>CMake</code>. Asegúrese de que su declaración CFLAGS está en una única línea con el menor número posible de espacios en blanco para evitar estos problemas. Mire la incidencia {{Bug|500034}} a modo de ejemplo.}}

Como puede ver, CXXFLAGS se establece para usar todas las opciones presentes en CFLAGS. Casi seguro que es lo que se desea. Normalmente no necesitará especificar opciones adicionales en CXXFLAGS.

=== Confusiones ===

Aunque CFLAGS y CXXFLAGS pueden ser muy efectivos tomando el código fuente para producir binarios pequeños o rápidos, también pueden deteriorar la función de su código, inflar su tamaño, ralentizar su
ejecución, ¡O incluso causar errores de compilación! 

CFLAGS no es una solución mágica; no hará que su sistema corra más rápido o sus binarios sean más pequeños automáticamente. Añadir más y más parámetros en un intento de optimización (o "apretar") su sistema es una receta segura para fracasar. Hay un punto en el cual alcanzará resultados de peor calidad. 

A pesar de las recomendaciones que se pueden encontrar en Internet, unas variables CFLAGS y CXXFLAGS agresivas están más cerca de dañar sus
programas que de hacerles algún bien. Recuerde que la razón para la cual existen los parámetros en primer lugar es porque están diseñadas para usarse en sitios específicos para propósitos específicos. ¡Solo porque una CFLAG particular sea buena para un fragmento de código no significa que esté diseñada para compilar todo lo que quiera instalar en su máquina! 

=== ¿Preparado? ===

Ahora que le hemos advertido de algunos de los riesgos involucrados, echemos un vistazo a algunas optimizaciones sanas y seguras para su computadora. Esto le será útil y los desarrolladores lo agradecerán  la próxima vez que informe de un problema en [https://bugs.gentoo.org/ Bugzilla]. (Los desarrolladores suelen pedir que recompile un paquete con los CFLAGS mínimos para ver si el problema persiste. Recuerde que los parámetros agresivos pueden arruinar el código.) 

== Optimización ==

=== Conceptos básicos ===

El objetivo de usar CFLAGS y CXXFLAGS es crear código específico para su sistema; debería funcionar perfectamente y ser ligero y rápido, si es posible. Algunas veces estás condiciones son mutuamente
excluyentes, pero nosotros trabajaremos con combinaciones que sabemos que funcionan bien. Idealmente, las mejores están disponibles para cada
arquitectura de CPU. Mencionaremos más adelante ajustes más agresivos para que se sepa con cuales debe tener cuidado. No discutiremos cada opción listada en el manual de <code>GCC</code> (hay 
cientos), pero hablaremos de las básicas, las más comunes. 

{{Note/es|Siempre que no esté seguro de la función que realiza determinada opción, acuda al capítulo correspondiente del [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-manual de opciones Options de GCC]. Si aún continúa atascado, pruebe en Google, o revise las [http://gcc.gnu.org/lists.html listas de correo] de <code>GCC</code>}}

=== -march ===

La primera y más importante opción es <code>-march</code>. Esta le dice al compilador que código debería producir para su [http://es.wikipedia.org/wiki/Microarquitectura arquitectura] de procesador (o ''arch''); dice que debería producir código para un cierto tipo de CPU. Diferentes CPUs tienen diferentes características, soportan diferentes conjunto de instrucciones y
tienen diferentes formas de ejecutar código. La opción <code>-march</code> indicará al compilador que produzca código específico para su CPU, tomando en cuenta todas sus capacidades, características,
conjuntos de instrucciones, caprichos y demás. 

A pesar que la variable CHOST en {{Path|/etc/portage/make.conf}} especifica la arquitectura general utilizada, <code>-march</code> también se
usa para que sus programas sean optimizados para su procesador específico. Las arquitecturas x86 y x86-64 (entre otras) también deberían utilizar la opción <code>-march</code>. 

¿Qué tipo de CPU tiene? Para averiguarlo, ejecute la siguiente orden: 

{{Cmd|cat /proc/cpuinfo}}

Ahora veamos a <code>-march</code> en acción. Este ejemplo es para un antiguo Pentium III: 

{{Code|/etc/portage/make.conf: Pentium III|<pre>
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Aquí hay otro para una CPU AMD de 64 bits: 

{{Code|/etc/portage/make.conf: AMD64|<pre>
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Si todavía no está seguro qué tipo de CPU tiene, tal vez quiera usar la opción <code>-march=native</code>. Al usarla, GCC detectará el procesador y automáticamente usará las opciones apropiadas. '''¡Sin embargo, no use esta opción si la intención es ¡compilar paquetes para un CPU diferente!''' 

De manera que, si está compilando paquetes en una computadora, pero piensa ejecutarlos en una computadora diferente (usando, por ejemplo, una computadora rápida para construir paquetes para una máquina más antigua y lenta), entonces ''no'' utilice la opción <code>-march=native</code>. La palabra "native" significa que el código producido podrá ejecutarse ''solamente'' en ese tipo de CPU. Las aplicaciones construidas con <code>-march=native</code> en una CPU AMD Athlon 64 CPU no podrán ejecutarse en una CPU VIA C3 más antigua. 

También están disponibles las opciones <code>-mcpu</code> y <code>-mtune</code>. Cada una de ellas solo se usará cuando no haya otra opción <code>-march</code> disponible. Ciertas arquitecturas de procesador pueden requerir <code>-mtune</code> o incluso de <code>-mcpu</code>. Desgraciadamente, el comportamiento de <code>GCC</code> no es muy consistente con la manera que cada opción se comporta de una arquitectura a otra. 

En CPUs x86 y x86-64, <code>-mcpu</code> se generará código específico para esa CPU usando todas sus instrucciones disponibles y el ABI correcto; no tendrá compatibilidad hacia atrás para CPUs antiguas o diferentes. Si no necesita ejecutar código en otro sitio que en el sistema que está corriendo Gentoo, continúe con <code>-march</code>. Solo debería
considerar usar <code>-mtune</code> cuando necesite generar código para CPUs antiguas como i386 e i486. <code>-mtune </code> produce un código más genérico que <code>-march</code>; aunque afinará el código para cierta CPU, no tendrá en cuenta los conjuntos de instrucciones disponibles y ABI. No use <code>-mcpu</code> en sistemas x86 o x86-64, ya que es obsoleto para estas arquitecturas. 

Solo las CPUs que no sean x86/x86-64 (como Sparc, Alpha y PowerPC) pueden requerir <code>-mtune </code> o <code>-mcpu</code> en lugar de <code>-march</code>. En estas arquitecturas, <code>-mtune</code>/<code>-mcpu</code> algunas veces se comportará como <code>-march</code> en (x86/x86-64)... pero con un nombre distinto. De nuevo, el comportamiento de <code>GCC</code> y los nombres de las opciones no es consistente entre arquitecturas, así que asegúrese de revisar el [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] de <code>GCC</code> para determinar cual de ellas debería utilizar en su sistema. 

{{Note/es|Para más sugerencias de configuraciones de <code>-march</code>/<code>-mtune</code>/<code>-mcpu</code>, por favor lea el capítulo 5 del [http://www.gentoo.org/doc/es/handbook/ manual de instalación de Gentoo] para su arquitectura. También, lea el manual de <code>GCC</code> listado en la página de [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options opciones específicas por arquitectura] con
explicaciones más detalladas sobre las diferencias entre <code>-march</code>, <code>-mcpu</code>, y <code>-mtune</code>.}}

=== -O ===

Lo siguiente es la variable <code>-O</code>. Controla el nivel de optimización de todo el código. Hace que la compilación de código tome algo más de tiempo, y puede usar mucha más memoria, especialmente al incrementar el nivel de optimización. 

Existen siete ajustes para <code>-O</code>: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code> y <code>-Ofast</code>. Debe utilizar solo uno de ellos en {{Path|/etc/portage/make.conf}}. 

A excepción de <code>-O0</code>, la configuración de <code>-O</code> activa varias opciones adicionales, así que asegúrese de leer el capítulo del manual de gcc en[http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options opciones de optimización] para aprender qué opciones se activan en cada nivel <code>-O</code>, así como algunas explicaciones sobre lo que hacen. 

Examinemos cada nivel de optimización: 

*  <code>-O0</code>: This level (that's the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in CFLAGS or CXXFLAGS.  This reduces compilation time and can improve debugging info, but some applications will not work properly without optimization enabled.  This option is not recommended except for debugging purposes.

*  <code>-O1</code>: This is the most basic optimization level. The compiler will try to produce faster, smaller code without taking much compilation time. It's pretty basic, but it should get the job done all the time.

*  <code>-O2</code>: A step up from <code>-O1</code>. This is the ''recommended'' level of optimization unless you have special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code>. With <code>-O2</code>, the compiler will attempt to increase code performance without compromising on size, and without taking too much compilation time.

*  <code>-O3</code>: This is the highest level of optimization possible.  It enables optimizations that are expensive in terms of compile time and memory usage.  Compiling with <code>-O3</code> is not a guaranteed way to improve performance, and in fact in many cases can slow down a system due to larger binaries and increased memory usage.  <code>-O3</code> is also known to break several packages.  Therefore, using <code>-O3</code> is not recommended.

*  <code>-Os</code>: This option will optimize your code for size. It activates all <code>-O2</code> options that don't increase the size of the generated code. It can be useful for machines that have extremely limited disk storage space and/or have CPUs with small cache sizes.

*  <code>-Og</code>: In GCC 4.8, a new general optimization level, <code>-Og</code>, has been introduced. It addresses the need for fast compilation and a superior debugging experience while providing a reasonable level of runtime performance. Overall experience for development should be better than the default optimization level <code>-O0</code>.  Note that <code>-Og</code> does not imply <code>-g</code>, it simply disables optimizations that may interfere with debugging.

*  <code>-Ofast</code>: New in GCC 4.7, consists of <code>-O3</code> plus <code>-ffast-math</code>, <code>-fno-protect-parens</code>, and <code>-fstack-arrays</code>. This option breaks strict standards compliance, and is not recommended for use.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and you aren't using <code>-O2</code>, try rebuilding with that option.  As a fallback option, try setting your CFLAGS and CXXFLAGS to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).

=== -pipe ===

A common flag is <code>-pipe</code> . This flag actually has no effect on the generated code, but it makes the compilation process faster. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, GCC might get killed. In that case, do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but you may need to activate it yourself by adding it to your flags. Though the <code>GCC</code> manual does not specify all architectures it is turned on by using <code>-O</code>, you will need to explicitly activate it on x86. However, using this flag will make debugging hard to impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. However, if you don't plan to do much software debugging and haven't added any other debugging-related CFLAGS such as <code>-ggdb</code>, then you can try using <code>-fomit-frame-pointer</code>. 

{{Important|Do ''not'' combine <code>-fomit-frame-pointer</code> with the similar flag <code>-momit-leaf-frame-pointer</code>. Using the latter flag is discouraged, as <code>-fomit-frame-pointer</code> already does the job properly. Furthermore, <code>-momit-leaf-frame-pointer</code> has been shown to negatively impact code performance.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE], [http://en.wikipedia.org/wiki/SSE2 SSE2], [http://en.wikipedia.org/wiki/SSSE3 SSE3], [http://en.wikipedia.org/wiki/MMX MMX], and [http://en.wikipedia.org/wiki/3dnow 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to check if your CPU supports these by running <code>cat /proc/cpuinfo</code>. The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

You normally don't need to add any of these flags to {{Path|/etc/portage/make.conf}} as long as you are using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code>). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these you'll need to enable additional flags where appropriate after checking the output of <code>cat /proc/cpuinfo</code>. 

{{Note|You should check the [http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options list] of x86 and x86-64-specific flags to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then you don't need to specify it; it will be turned on by using the proper <code>-march</code> setting.}}

== Optimization FAQs ==

=== But I get better performance with -funroll-loops -fomg-optimize! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt your applications when used system-wide. Even the <code>GCC</code> [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> makes code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

The truth of the matter is that they are dangerously aggressive flags. Take a good look around the [https://forums.gentoo.org/ Gentoo Forums] and [https://bugs.gentoo.org/ Bugzilla] to see what those flags do: nothing good! 

You don't need to use those flags globally in CFLAGS or CXXFLAGS. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat your code and get your bugs marked INVALID or WONTFIX. 

You don't need dangerous flags like these. '''Don't use them'''. Stick to the basics: <code>-march</code>, <code>-O</code>, and <code>-pipe</code>.

=== What about -O levels higher than 3? ===

Some users boast about even better performance obtained by using <code>-O4</code>, <code>-O9</code>, and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept CFLAGS like <code>-O4</code>, but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code>, nothing more. 

Need more proof? Examine the <code>code</code> [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup source code]: 

{{Code|-O source code|<pre>
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>
}}

As you can see, any value higher than 3 is treated as just <code>-O3</code>.

=== What about redundant flags? ===

Oftentimes CFLAGS and CXXFLAGS that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}}. Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all CFLAGS and CXXFLAGS, or it may replace <code>-O</code> with a different level. 

The [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] outlines where and how flag filtering/replacing works. 

It's possible to circumvent <code>-O</code> filtering by redundantly listing the flags for a certain level, such as <code>-O3</code>, by doing things like: 

{{Code|Specifying redundant CFLAGS|<pre>
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>
}}

However, '''this is not a smart thing to do'''. CFLAGS are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers''. Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

You will most likely continue to run into problems when you build a package with unacceptable flags. When you report your troubles on Bugzilla, the flags you use in {{Path|/etc/portage/make.conf}} will be readily visible and you will be told to recompile without those flags. Save yourself the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume that you know better than the developers.

=== What about LDFLAGS? ===

The Gentoo developers have already set basic, safe LDFLAGS in the base profiles, so you don't need to change them. 

=== Can I use per-package flags? ===

{{Warning/es|El uso de parámetros específicos de paquetes complica la depuración y el soporte. Asegúrese mencionarlo en los informes de fallos si está usando esta característica y los cambios que haya realizado.}}

Puede encontrarse información acerca de como utilizar las variables de entorno por paquete (incluyendo CFLAGS) en el [http://www.gentoo.org//doc/en/handbook/handbook-amd64.xml?part=3&chap=6#doc_chap2 Manual de Gentoo, "Variables de entorno por paquete"].

== Recursos ==

Los siguientes recursos pueden ser de ayuda para comprender la optimización: 

* La [http://gcc.gnu.org/onlinedocs/ documentación en línea de GCC] 

* El capítulo 5 de los [http://www.gentoo.org/doc/es/handbook/ manuales de instalación de Gentoo] 

* <code>man make.conf</code>

* [https://es.wikipedia.org/ Wikipedia]

* Los [https://forums.gentoo.org/ Foros de Gentoo]

== Agradecimientos ==

Nos gustaría dar las gracias a los siguientes autores y editores por sus contribuciones a esta guía:

* nightmorph
