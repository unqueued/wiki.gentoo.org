<languages />

{{Metadata|abstract=Esta guía ofrece una introducción al código compilado de forma óptima usando CFLAGS y CXXFLAGS seguras y sanas. También describe la teoría detrás de la optimización en general.}}

Esta guía ofrece [[Article description::una introducción al código compilado de forma óptima usando <var>CFLAGS</var> y <var>CXXFLAGS</var> seguras y sanas]]. También describe la teoría detrás de la optimización en general.

== Introducción ==

=== ¿Qué son CFLAGS y CXXFLAGS? ===

Las variables de entorno<var>CFLAGS</var> y <var>CXXFLAGS</var> son las que se utilizan convencionalmente para especificar opciones de compilación en un sistema de construcción cuando se compila código C y C++. Aunque estas variables no están estandarizadas, su utilización es esencialemente ubicua y cualquier construcción escrita correctamente debería interpretarlas de forma adecuada para el paso de opciones extra o personalizadas cuando se invoca el compilador. Leer la página info de [https://www.gnu.org/software/make/manual/make.html#Implicit-Variables GNU make] para obtener una lista de las variables más comúnmente utilizadas en esta categoría.

Debido a que gran parte de los paquetes que se utilizan en los sistemas Gentoo están escritos en C y C++, existen dos variables que los administradores definitivamente querrán configurar adecuandamente ya que tienen gran influencia en la forma en que se construye el sistema.

Pueden usarse para disminuir la cantidad de mensajes de depuración de un programa, aumentar los niveles de aviso de errores, y por supuesto, optimizar el código producido. El [https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC manual de GCC] ofrece una lista completa opciones disponibles y sus aplicaciones.

=== ¿Cómo se utilizan? ===

Normalmente, se deberían definir <var>CFLAGS</var> y <var>CXXFLAGS</var> en el entorno cuando se invoque un guión o en los ficheros makefile generados por el programa {{c|automake}}. En los sistemas basados en Gentoo, se la variables <var>CFLAGS</var> y <var>CXXFLAGS</var> se definen en {{Path|/etc/portage/make.conf}}. Las variables definidas en este fichero se exportarán al entorno de los programas invocados por portage de modo que todos los paquetes se compilarán usando estas opciones como base.

{{CodeBox|title=Ajustar CFLAGS en /etc/portage/make.conf|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important|Aunque es posible tener varias líneas en los ajustes '''USE''', hacer lo mismo en <var>CFLAGS</var> puede y '''dará''' problemas con programas como {{c|cmake}}. Asegúrese de que la declaración de <var>CFLAGS</var> se realiza en una sola línea con el menor número posible de espacios en blanco para evitar estos problemas. Eche un vistazo a la incidencia {{Bug|500034}} a modo de ejemplo.}}

Como se puede observar en el ejemplo de arriba, <var>CXXFLAGS</var> se define para usar todas las opciones presentes en <var>CFLAGS</var>. La mayoría de los sistemas se configurarán de este modo. Las opciones adicionales de <var>CXXFLAGS</var> son menos comunes y normalmente no se aplican de modo tan general como para ser definidas globalmente.

{{Tip|El artículo [[Safe_CFLAGS|Ajustes CFLAGS seguros]] puede ser de ayuda para principiantes que comience a optimizar sus sistemas.}}

=== Confusiones ===

Aunque el hecho de activar algunas optimizaciones de la compilación en <var>CFLAGS</var> puede ser muy efectivo a la hora de producir binarios pequeños o más rápidos, pueden también deteriorar la función del código, inflar su tamaño, ralentizar su tiempo de ejecución o simplemente causar un fallo en la construcción. El momento en el que se empieza a notar la bajada en el rendimiento se alcanza más rápidamente cuando se modifica <var>CFLAGS</var>. No ajuste estas opciones de forma arbitraria.

Recuerde, la variable global <var>CFLAGS</var> configurada en {{Path|/etc/portage/make.conf}} se aplicará a todo paquete del sistema de modo que los administradores normalmente definirán opciones generales de amplia aplicación. Los paquetes individuales modificarán a continuación estas opciones bien en su ebuild o en el propio ebuild del sistema para generar el conjunto de ajustes que se utilizarán cuando se lance el compilador.

=== ¿Preparado? ===

Conociendo los riesgos involucrados, echemos un vistazo a algunas optimizaciones sanas y seguras para su computadora. Esto le será útil y también alentador para los desarrolladores la próxima vez que se informe de un problema en [https://bugs.gentoo.org/ Bugzilla]. (Los desarrolladores suelen pedir al usuario que recompile un paquete con los <var>CFLAGS</var> mínimos para ver si el problema persiste. Recuerde: ¡Las opciones agresivas pueden arruinar el código!) 

== Optimización ==

=== Conceptos básicos ===

El objetivo de usar <var>CFLAGS</var> y <var>CXXFLAGS</var> es crear código específico para el sistema; debería funcionar perfectamente y ser ligero y rápido, si es posible. Algunas veces estás condiciones son mutuamente excluyentes, de modo que esta guía trabaja con combinaciones que se sabe que funcionan bien. Idealmente, las mejores están disponibles para cada arquitectura de CPU. Se cubren más adelante, a modo de información, ajustes más agresivos. No se discuten todas las opciones listadas en el manual de GCC, sin embargo se revisarán las opciones más comunes. 

{{Note|Cuando no esté seguro de la función que realiza determinada opción, acuda al capítulo correspondiente del [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-manual de opciones Options de GCC]. Si aún continúa atascado después de mirar en el manual, pruebe con un motor de búsquega o revise las [https://gcc.gnu.org/lists.html listas de correo de GCC]}}

=== -march ===

La primera y más importante opción es <code>-march</code>. Esta le dice al compilador que código debería producir para su [http://es.wikipedia.org/wiki/Microarquitectura arquitectura de procesador] (o ''arch''), le indica a GCC que debería producir código para un cierto tipo de CPU. Diferentes CPUs tienen diferentes características, soportan diferentes conjunto de instrucciones y tienen diferentes formas de ejecutar código. La opción <code>-march</code> indicará al compilador que produzca código específico para la CPU del sistema, tomando en cuenta todas sus capacidades, características,
conjuntos de instrucciones, caprichos y demás teniendo en cuenta que el código fuente está preparado para usarlos. Por ejemplo, para poder utilizar instrucciones AVX, se debe adaptar el código fuente para ofrecer soporte.

<code>-march=</code> is an ISA selection option; it tells the compiler that it may use the instructions from the ISA. On an Intel/AMD64 platform with <code>-march=native -O2</code> or lower OPT level, the code will likely end up with AVX instructions used but using shorter SSE XMM registers. To take full advantage of AVX YMM registers, the <code>-ftree-vectorize</code>, <code>-O3</code> or <code>-Ofast</code> options should be used as well<ref>GNU GCC Bugzilla, [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57952#c8 AVX/AVX2 no ymm registers used in a trivial reduction]. Retrieved on 2017/07/18.</ref>.

<code>-ftree-vectorize</code> is an optimization option (default at <code>-O3</code> and <code>-Ofast</code>), which attempts to vectorize loops using the selected ISA if possible.  The reason it isn't enabled at <code>-O2</code> is that it doesn't always improve code, it can make code slower as well, and usually makes the code larger; it really depends on the loop etc. 

Even though the <var>CHOST</var> variable in {{Path|/etc/portage/make.conf}} specifies the general architecture used, <code>-march</code> should still be used so that programs can be optimized for the system specific processor. x86 and x86-64 CPUs (among others) should make use of the <code>-march</code> flag. 

¿Qué tipo de CPU tiene el sistema? Para averiguarlo, ejecute la siguiente orden: 

{{Cmd|cat /proc/cpuinfo}}

or even install {{Package|app-portage/cpuinfo2cpuflags}} and add the available CPU-specific options to the {{Path|make.conf}} file, which the tool does through e.g. the [[CPU FLAGS X86|CPU_FLAGS_X86]] variable:

{{Cmd|cpuinfo2cpuflags-x86 >> /etc/portage/make.conf}}

Para obtener más detalles, incluyendo valores <code>march</code> y <code>mtune</code> se pueden utilizar dos órdenes.

* La primera orden le indica al compilador que no realice ningún enlazado (<code>-c</code>) y en lugar de interpretar la opción <code>--help</code> para clarificar las opciones de la línea órdenes, ahora muestra si ciertas opciones están habilitadas o deshabilitadas (<code>-Q</code>). En este caso, las opciones mostradas son las que se han habilitado para el objetivo seleccionado
: {{Cmd|gcc -c -Q -march{{=}}native --help{{=}}target}}

* La segunda orden muestra las directivas de compilación para construir el fichero cabecera pero sin realmente realizar los pasos y en su lugar mostrarlos en pantalla (<code>-###</code>). La línea de salida final es la orden que mantiene todas las opciones de optimización y selección de arquitectura:
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

Ahora veamos a <code>-march</code> en acción. Este ejemplo es para un antiguo Pentium III: 

{{CodeBox|filename=/etc/portage/make.conf|title=Ejemplo para Pentium III|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

Aquí hay otro para una CPU AMD de 64 bits: 

{{FileBox|filename=/etc/portage/make.conf|title=Ejemplo para AMD64|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

Si no se puede determinar el tipo de CPU o si e usuario no sabe que ajustes elegir, es posible utilizar el ajuste <code>-march=native</code>. Al usarla, GCC intentará detectar el procesador y automáticamente usará las opciones apropiadas. '''¡Sin embargo, no se debe utilizar esto si se quiere compilar paquetes para CPUs diferentes!''' 

{{Warning|'''No''' utilice <code>-march{{=}}native</code> o <code>-mtune{{=}}native</code> en las variables <var>CFLAGS</var> o <var>CXXFLAGS</var> de {{Path|make.conf}} cuando compile con {{c|[[Distcc/es#-march.3Dnative|distcc]]}}.}}

Si se está compilando paquetes en una computadora, para ejecutarlos en una computadora diferente (usando, por ejemplo, una computadora rápida para construir paquetes para una máquina más antigua y lenta), entonces ''no'' utilice la opción <code>-march=native</code>. La palabra "native" significa que el código producido podrá ejecutarse ''solamente'' en ese tipo de CPU. Las aplicaciones construidas con <code>-march=native</code> en una CPU AMD Athlon 64 CPU '''no''' podrán ejecutarse en una CPU VIA C3 más antigua. 

También están disponibles las opciones <code>-mcpu</code> y <code>-mtune</code>. Cada una de ellas solo se usará cuando no haya otra opción <code>-march</code> disponible. Ciertas arquitecturas de procesador pueden requerir <code>-mtune</code> o incluso de <code>-mcpu</code>. Desgraciadamente, el comportamiento de GCC no es muy consistente con la manera que cada opción se comporta de una arquitectura a otra. 

En CPUs x86 y x86-64, <code>-mcpu</code> se generará código específico para esa CPU usando sus instrucciones disponibles y el ABI correcto; no tendrá compatibilidad hacia atrás para CPUs antiguas o diferentes. Se puede considerar el uso de <code>-mtune</code> cuando se genere código para CPUs antiguas como i386 e i486. <code>-mtune </code> produce un código más genérico que <code>-march</code>; aunque afinará el código para cierta CPU, no se tendrán en cuenta los conjuntos de instrucciones disponibles y ABI. No utilice la opción <code>-mcpu</code> en sistemas x86 o x86-64, ya que es obsoleto para estas arquitecturas. 

Solo las CPUs que no sean x86/x86-64 (como SPARC, Alpha y PowerPC) pueden requerir <code>-mtune </code> o <code>-mcpu</code> en lugar de <code>-march</code>. En estas arquitecturas, <code>-mtune</code>/<code>-mcpu</code> algunas veces se comportará como <code>-march</code> en (x86/x86-64)... pero con un nombre distinto. De nuevo, el comportamiento de GCC y los nombres de las opciones no son consistentes entre arquitecturas, así que asegúrese de revisar el [https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] de GCC para determinar cual de ellas se debería utilizar. 

{{Note|Para más sugerencias de configuraciones de <code>-march</code>/<code>-mtune</code>/<code>-mcpu</code>, por favor lea el capítulo 5 del [[HandBook:Main_Page/es|manual de instalación de Gentoo]] para la arquitectura. También, lea el manual de GCC listado en la página de [https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options opciones específicas por arquitectura] con explicaciones más detalladas sobre las diferencias entre <code>-march</code>, <code>-mcpu</code>, y <code>-mtune</code>.}}

=== -O ===

Hablaremos ahora de la variable <code>-O</code>. Esta variabe controla el nivel de optimización de todo el código. Al cambiar este valor, la compilación de código tomará algo más de tiempo, y utilizará mucha más memoria, especialmente al incrementar el nivel de optimización. 

Existen siete ajustes para <code>-O</code>: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code> y <code>-Ofast</code>. Se debe utilizar solo uno de ellos en {{Path|/etc/portage/make.conf}}.

A excepción de <code>-O0</code>, la configuración de <code>-O</code> activa varias opciones adicionales, así que asegúrese de leer el capítulo del manual de gcc en [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options opciones de optimización] para aprender qué opciones se activan en cada nivel <code>-O</code>, así como algunas explicaciones sobre lo que hacen. 

Examinemos cada nivel de optimización: 

* <code>-O0</code>: Este nivel (que consiste en la letra "O" seguida de un cero) desconecta por completo la optimización y es el predeterminado si no se especifica ningún nivel <code>-O</code> en <var>CFLAGS</var> o <var>CXXFLAGS</var>. El código no se optimizará. Esto, normalmente, no es lo que se desea.

* <code>-O1</code>: El nivel de optimización más básico. El compilador intentará producir un código rápido y pequeño sin tomar mucho tiempo de compilación. Es básico, pero conseguirá realizar correctamente el trabajo.

* <code>-O2</code>: Un paso delante de <code>-O1</code>. Es el nivel ''recomendado'' de optimización, a no ser que el sistema tenga necesidades especiales. <code>-O2</code> activará algunas opciones añadidas a las que se activan con <code>-O1</code>. Con <code>-O2</code>, el compilador intentará aumentar el rendimiento del código sin comprometer el tamaño y sin tomar mucho más tiempo de compilación. Se puede utilizar SSE o AVX en este nivel pero no se utilizarán registros YMM a menos que también se habilite <code>ftree-vectorize</code>.

* <code>-O3</code>: El nivel más alto de optimización posible. Activa optimizaciones que son caras en términos de tiempo de compilación y uso de memoria. El hecho de compilar con <code>-O3</code> no garantiza una forma de mejorar el rendimiento y, de hecho, en muchos casos puede ralentizar un sistema debido al uso de binarios de gran tamaño y mucho uso de la memoria. También se sabe que <code>-O3</code> puede romper algunos paquetes. No se recomienda utilizar <code>-O3</code>. Sin embargo, también habilita <code>-ftree-vectorize</code> de modo que los bucles dentro del código se vectorizarán y se utilizarán los registros AVX YMM.

* <code>-Os</code>: Optimizará el tamaño del código. Activa todas las opciones de <code>-O2</code> que no incrementan el tamaño del código generado. Es útil para máquinas con capacidad limitada de disco o con CPUs que tienen poca caché.

* <code>-Og</code>: En GCC 4.8 aparece un nuevo nivel del optimización general: <code>-Og</code>. Trata de solucionar la necesidad de realizar compilaciones más rápidas y obtener una experiencia superior en la depuración a la vez que ofrece un nivel razonable de rendimiento en la ejecución. La experiencia global en el desarrollo debería ser mejor que para el nivel de optimización <code>-O0</code>. Observe que <code>-Og</code> no implica <code>-g</code>, éste simplemente deshabilita optimizaciones que podrían interferir con la depuración.

* <code>-Ofast</code>: Nuevo en GCC 4.7. Consiste en el ajuste <code>-O3</code> más las opciones <code>-ffast-math</code>, <code>-fno-protect-parens</code> y <code>-fstack-arrays</code>. Esta opción rompe el cumplimiento de estándares estrictos y no se recomienda su utilización.

Como se comentó anteriormente, <code>-O2</code> es el nivel de optimización recomendado. Si un paquete muestra errores de compilación, se debe comprobar que no se está usando <code>-O3</code>. Como otra opción se puede probar a configurar <var>CFLAGS</var> y <var>CXXFLAGS</var> a un nivel de optimización inferior, como <code>-O1</code> o incluso <code>-O0 -g2 -ggdb</code> (para informar de errores y comprobar posibles problemas).

=== -pipe ===

Una opción común es <code>-pipe</code>. No tiene efecto sobre el código que se produce, pero hace que el proceso de compilación sea ''más rápido''. Indica al compilador que use tuberías en lugar de archivos temporales durante los diferentes estados de compilación, lo cual usa más memoria. En sistemas con poca memoria, el proceso GCC se podría terminar por el sistema En estos casos no se debe utilizar esta opción. 

=== -fomit-frame-pointer ===

Esta es una opción muy común diseñada para reducir el tamaño del código generado. Está activada para todos los niveles de <code>-O</code> (excepto <code>-O0</code>) en arquitecturas donde no interfiera con la depuración (como x86-64), pero puede que haga falta activarla. En ese caso, se debe añadir a las opciones. Aunque el manual de GCC no especifica todas las arquitecturas, se activa mediante la opción <code>-O</code>. Todavía es necesario habilitar explícitamente la opción <code>-fomit-frame-pointer</code>. Para activarla en una arquitectura x86-32 con GCC hasta la versión 4.6 o cuando se utilice <code>-Os</code> en x86-32 con cualquier versión de GCC. Sin embargo, al usar <code>-fomit-frame-pointer</code> la depuración será algo difícil o incluso resultará imposible. 

En particular, provoca que la localización de problemas en aplicaciones escritas en Java sea mucho más complicada, aunque Java no es el único código afectado al usar esta opción. Así, aunque esta opción puede ayudar, la depuración será complicada. En particular, las trazas de ejecución (backtraces) no servirán de mucho. Cuando no se haga depuración de software y no se ha añadido ninguna otro ajuste <var>CFLAGS</var> relacionado con la depuración como <code>-ggdb</code> entonces intente usar <code>-fomit-frame-pointer</code>. 

{{Important|''No'' combine <code>-fomit-frame-pointer</code> con la opción de nombre similar <code>-momit- leaf-frame-pointer</code>. No se aconseja la utilización de esta última, ya que <code>-fomit-frame-pointer</code> ya hace el trabajo apropiado. Es más, <code>-momit-leaf-frame-pointer</code> ha demostrado que impacta negativamente en el rendimiento del código.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

Estas opciones activan los conjuntos de instrucciones
[https://es.wikipedia.org/wiki/SSE Streaming SIMD Extensions] (SSE), [https://es.wikipedia.org/wiki/SSE2 SSE2], [https://es.wikipedia.org/wiki/SSSE3 SSE3], [https://es.wikipedia.org/wiki/MMX MMX] y [https://es.wikipedia.org/wiki/3DNow! 3DNow!]
para arquitecturas x86-64. Son útiles principalmente en multimedia, juegos y otras tareas intensivas de computación en punto flotante, aunque también contienen muchos otros realces matemáticos. Estos conjuntos de instrucciones se encuentran en las CPUs más modernas. 

{{Important|Asegúrese de comprobar si la CPU ofrece soporte para estos conjuntos de instrucciones lanzando la orden {{c|cat/proc/cpuinfo}}. La salida incluirá cualquier conjunto de instrucciones adicionales. Observe que '''pni''' es solo otro nombre para SSE3.}}

Normalmente no se necesita añadir ninguna de estas opciones a {{Path|/etc/portage/make.conf}} mientras el sistema esté utilizando la <code>-march</code> correcta (por ejemplo, <code>-march= nocona</code> implica <code>-msse3</code>). Algunas excepciones notables son las nuevas CPUs VIA y AMD64 que soportan instrucciones no implicadas por <code>-march</code> (como SSE3). Para CPUs como estas, se  necesita habilitar opciones adicionales donde sea necesario después de verificar la salida de {{Path|/proc/cpuinfo}}. 

{{Note|Revisar la [https://gcc.gnu.org/onlinedocs/gcc/i386-and-x86-64-Options.html#i386-and-x86-64-Options lista de opciones específicas para x86 y x86-64] para ver cuales de estos conjuntos de instrucciones los activa la propia configuración del tipo de CPU. Si aparece una instrucción, entonces no se necesita especificar de forma independiente, se activará al usar la configuración de <code>-march </code> apropiada.}}

== Preguntas frecuentes sobre optimización ==

=== Sin embargo, ¡Consigo mejor rendimiento con -funroll-loops -fomg-optimize! ===

No, la gente ''piensa'' que lo hacen porque alguien les ha convencido de que es mejor utilizar el mayor número de opciones. Las opciones agresivas  solo dañarán las aplicaciones cuando use un sistema completo. Incluso 
el [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] de GCC dice que usar <code>-funroll-loops </code> y <code>-funroll-all-loops</code> hará que el código ocupe más espacio y que corre más lento. Aunque por alguna razón, estas dos opciones, junto con <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, y similares, continúan siendo muy populares entre pardillos que creen saber más que nadie. 

La verdad es que son opciones peligrosamente agresivas. Eche un vistazo a los [https://forums.gentoo.org/ Foros de Gentoo] y a [https://bugs.gentoo.org/ Bugzilla] para
ver que hacen estas variables: ¡Nada bueno! 

Estos ajustes no son necesarios globalmente en <var>CFLAGS</var> o en <var>CXXFLAGS</var>. Solo dañarán el rendimiento. Podría incluso dar pie a pensar de que se está corriendo un sistema de alto rendimiento con el software más actual, pero no hará más que inflar el código y marcar sus informes de error como INVALID o WONTFIX. 

No se necesitan opciones peligrosas como estas. '''No las utilice'''. Quédese con las básicas: <code>-march</code>, <code>-O</code> y <code>-pipe</code>.

=== ¿Qué pasa con los niveles -O mayores que 3 ===

Algunos usuarios alardean de que obtienen mejor rendimiento usando <code>-O4</code>, <code>-O9</code> y similares, pero la realidad es que niveles de <code>-O</code> mayores que 3 no tienen efecto. El compilador puede aceptar <var>CFLAGS</var> como <code>-O4</code>, pero realmente no hace nada con él. Solo realiza la optimización para <code>-O3</code>, nada más. 

¿Necesita más pruebas? Eche un vistazo al [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup código fuente]: 

{{CodeBox|title=Código fuente -O|lang=bash|1=
if (optimize >= 3)
  {
   flag_inline_functions = 1;
   flag_unswitch_loops = 1;
   flag_gcse_after_reload = 1;
   /* Permitir más operadores virtuales. */
   set_param_value ("max-aliased-vops", 1000);
   set_param_value ("avg-aliased-vops", 3);
  }
}}

Como se puede observar, cualquier valor mayor que 3 se trata como <code>-O3</code>.

=== ¿Qué ocurre cuando compilamos fuera de la máquina destino? ===

Algunos lectores se pueden preguntar si el hecho de compilar fuera de la máquina destino usando una CPU estrictamente inferior o una subarquitectura en GCC generará unos resultados de optimización inferiores. La respuesta es simple: '''No'''. Independientemente del hardware en el que realmente se realiza la compilación y el CHOST con el que se construyó GCC, si se utilizan los mismos argumentos <small> (excepto para <code>-march=native</code>)</small> y la misma versión de GCC<small> (aunque la versión menor puede ser distinta)</small>, las optimizaciones resultantes son estrictamente las mismas.

Como ejemplo, si Gentoo se instala en una máquina en el que el CHOST de GCC es ''i686-pc-linux-gnu'', y se utiliza un servidor [[Distcc/es]] en otro equipo en el que el CHOST de GCC es ''i486-linux-gnu'' entonces no hay porqué preocuparse de que los resultados sean menos óptimos ya que la subarquitectura del compilador o el hardware del equipo remoto son estrictamente inferiores. El resultado sería igual de óptimo que una construcción en una máquina nativa siempre que se pasen las mismas opciones a ambos compiladores (y no se defina el argumento <code>-march</code> como <code>native</code>). En este caso en particular se necesita especificar la aquitectura destinotal y como se indica en [[Distcc/es#-march.3Dnative|Distcc y -march=native]].

La única diferencia en el comportamiento entre dos versiones de GCC construidas con diferentes subarquitecturas es el valor implícito por defecto para el parámetro <code>-march</code> que se deriva del CHOST de GCC cuando no se ha indicado uno de forma explícita en la línea de órdenes.

=== ¿Qué pasa con las opciones redundantes? ===

A menudo <var>CFLAGS</var> y <var>CXXFLAGS</var> que se han activado en varios niveles de <code>-O</code> están especificadas de forma redundante en {{Path|/etc/portage/make.conf}}. A veces esto ocurre por ignorancia, pero también se hace para permitir el filtrado o el reemplazo de opciones. 

El filtrado y el reemplazo de opciones se realiza en muchos ebuilds del árbol Portage. Normalmente se realiza debido a que algunos paquetes no compilan con determinados niveles <code>-O</code> o cuando el código fuente es tan sensible que no se pueden utilizar opciones adicionales. El ebuild bien filtrará algunas opciones o todas las opciones <var>CFLAGS</var> y <var>CXXFLAGS</var>, bien reemplazará <code>-O</code> con un nivel diferente. 

El [https://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Manual del Desarrollador de Gentoo] indica dónde y cómo funciona el filtrado y el reemplazo de opciones. 

Es posible evitar el filtrado de <code>-O</code> filtrando mediante el listado redundante de opciones para un cierto nivel, como <code>-O3</code>, haciendo cosas como: 

{{CodeBox|title=Especificar CFLAGS redundantes|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

Sin embargo, '''hacer esto no es algo acertado'''. ¡Las <var>CFLAGS</var> se filtran por alguna razón! Cuando estas opciones se filtran es porque es inseguro construir paquetes con ellos. Claramente, ''no'' es seguro compilar el sistema completo con <code>-O3</code> si alguna de estas opciones está activada para este nivel causará problemas con ciertos paquetes. Por lo tanto, no intente "saber más" que los desarrolladores que mantienen estos paquetes. ''Confíe en ellos''. ¡El filtrado y reemplazo se realiza para garantizar la estabilidad del sistema y de las aplicaciones!. Si un ebuild especifica opciones alternativas, entonces no intente evitarlas. 

Si se construyen paquetes con ajustes inaceptables lo más probable es que aparezcan los problemas. Cuando se informe de problemas en Bugzilla, los ajustes que se utilizan en {{Path|/etc/portage/make.conf}} serán visibles rápidamente y los desarrolladores pedirán la recompilación sin esos ajustes. ¡Evite el engorro que supone recompilar no utilizando ajustes redundantes!. No asuma automáticamente que sabe más que los desarrolladores.

=== ¿Qué pasa con LDFLAGS? ===

Los desarrolladores de Gentoo ya han configurado <var>LDFLAGS</var> básicas y seguras en los perfiles base, de tal manera que no se necesita cambiarlas.

=== ¿Puedo usar opciones para cada paquete? ===

{{Warning|El uso de opciones específicas de paquetes complica la depuración y el soporte. Asegúrese de mencionarlo en los informes de fallos junto a los cambios que haya realizado.}}

Puede encontrarse información acerca de como utilizar las variables de entorno por paquete (incluyendo <var>CFLAGS</var>) en el [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|manual de Gentoo "Variables de entorno por paquete"]].

== Véase también ==

* [[Handbook:AMD64/Installation/Stage#Configuring_compile_options|Configuring compile options]] (AMD64 Handbook)

== Recursos Externos ==

Los siguientes recursos pueden ser de ayuda para comprender la optimización: 

* La [https://gcc.gnu.org/onlinedocs/ documentación en línea de GCC] 

* {{c|man make.conf}}

* [https://es.wikipedia.org/ Wikipedia]

* Los [https://forums.gentoo.org/ Foros de Gentoo]

== Referencias ==

{{reflist}}

{{Migrated|originalauthors={{Dev|nightmorph}}}}


[[Category:Compilation]]
