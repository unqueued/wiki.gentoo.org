<languages />

{{Metadata|abstract=Esta guía ofrece una introducción al código compilado de forma óptima usando CFLAGS y CXXFLAGS seguras y sanas. También describe la teoría detrás de la optimización en general.}}

Esta guía ofrece una introducción al código compilado de forma óptima usando <var>CFLAGS</var> y <var>CXXFLAGS</var> seguras y sanas. También describe la teoría detrás de la optimización en general.

== Introducción ==

=== ¿Qué son CFLAGS y CXXFLAGS? ===

<var>CFLAGS</var> and <var>CXXFLAGS</var> are environment variables that are used to tell the GNU Compiler Collection (GCC) what kinds of switches to use when compiling source code. The <var>CFLAGS</var> variable is used for compiling code written in C, while the <var>CXXFLAGS</var> variable is for code written in C++. 

Pueden usarse para disminuir la cantidad de mensajes de depuración
de un programa, aumentar los niveles de aviso de errores, y por supuesto, optimizar el código producido. El [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC manualde GCC] ofrece una lista completa opciones disponibles y sus aplicaciones.

=== ¿Cómo se utilizan? ===

<var>CFLAGS</var> and <var>CXXFLAGS</var> can be used in two ways. First, they can be used per-program with Makefiles generated by the {{c|automake}} program. 

However, this should not be done when installing packages found in the Portage tree. Instead, for Gentoo-based machines, set the <var>CFLAGS</var> and <var>CXXFLAGS</var> variables in {{Path|/etc/portage/make.conf}} This way all packages will be compiled using the options specified in {{Path|make.conf}}

{{CodeBox|title=Ajustar CFLAGS en /etc/portage/make.conf|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important|While it is possible to have multiple lines in '''USE''' flags, having multiple lines in <var>CFLAGS</var> can and ''will'' result in problems with programs such as {{c|cmake}}. Make sure the CFLAGS declaration is on a single line, with as little whitespace as possible to avoid issues. See {{Bug|500034}} as an example.}}

As seen in the example above the <var>CXXFLAGS</var> variable is set to use all the options present in <var>CFLAGS</var>. Most every system should be configured in this manner; additional options for <var>CXXFLAGS</var> are ''extremely rare'' in common use cases.

=== Confusiones ===

While <var>CFLAGS</var> and <var>CXXFLAGS</var> can be very effective means of getting source code to produce smaller and/or faster binaries, they can also impair the function of the code, bloat its size, slow down its execution time. Setting them incorrectly can even cause compilation failures! 

<var>CFLAGS</var> are not a magic bullet; they will not automatically make the system run faster or reduce the size of binaries on the disk. Adding too many flags in an attempt to optimize (or "rice") the system is a sure recipe for failure. The point of diminishing returns is reached rather quickly when dealing with <var>CFLAGS</var>. 

Despite the boasts and brags found on the internet, aggressive <var>CFLAGS</var> and <var>CXXFLAGS</var> are far more likely to harm binaries than to do any good. Keep in mind the flags are designed to be used at ''specific'' places for ''specific'' purposes. Few flags work as intended globally.

=== ¿Preparado? ===

Being aware of the risks involved, take a look at some sane, safe optimizations. These will hold in good stead and will be endearing to developers the next time a problem  is reported on [https://bugs.gentoo.org/ Bugzilla]. (Developers will usually request the user to recompile a package with minimal <var>CFLAGS</var> to see if the problem persists. Remember: aggressive flags can ruin code!) 

== Optimización ==

=== Conceptos básicos ===

The goal behind <var>CFLAGS</var> and <var>CXXFLAGS</var> is to create code tailor-made to your system; it should function perfectly while being lean and fast, if possible. Sometimes these conditions are mutually exclusive, so this guide will stick to combinations known to work well. Ideally, they are the best available for any CPU architecture. For informational purposes, aggressive flag use will be covered later. Not every option listed on the GCC manual (there are hundreds) will be discussed, but basic, most common flags will be reviewed. 

{{Note|Cuando no esté seguro de la función que realiza determinada opción, acuda al capítulo correspondiente del [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-manual de opciones Options de GCC]. Si aún continúa atascado después de mirar en el manual, pruebe con un motor de búsquega o revise las [http://gcc.gnu.org/lists.html listas de correo de GCC]}}

=== -march ===

La primera y más importante opción es <code>-march</code>. Esta le dice al compilador que código debería producir para su [http://es.wikipedia.org/wiki/Microarquitectura arquitectura de procesador] (o ''arch''), le indica a GCC que debería producir código para un cierto tipo de CPU. Diferentes CPUs tienen diferentes características, soportan diferentes conjunto de instrucciones y tienen diferentes formas de ejecutar código. La opción <code>-march</code> indicará al compilador que produzca código específico para la CPU del sistema, tomando en cuenta todas sus capacidades, características,
conjuntos de instrucciones, caprichos y demás. 

A pesar que la variable <code>CHOST</code> en {{Path|/etc/portage/make.conf}} especifica la arquitectura general utilizada, <code>-march</code> también se usa para que los programas se optimicen para el procesador específico del sistema. Las arquitecturas x86 y x86-64 (entre otras) también deberían utilizar la opción <code>-march</code>. 

¿Qué tipo de CPU tiene el sistema? Para averiguarlo, ejecute la siguiente orden: 

{{Cmd|cat /proc/cpuinfo}}

Para obtener más detalles, incluyendo valores <code>march</code> y <code>mtune</code>, utilice:

{{Cmd|<nowiki>gcc -c -Q -march=native --help=target</nowiki>}}

Ahora veamos a <code>-march</code> en acción. Este ejemplo es para un antiguo Pentium III: 

{{CodeBox|filename=/etc/portage/make.conf|title=Ejemplo para Pentium III|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

Aquí hay otro para una CPU AMD de 64 bits: 

{{FileBox|filename=/etc/portage/make.conf|title=Ejemplo para AMD64|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

Si no se puede determinar el tipo de CPU o si e usuario no sabe que ajustes elegir, es posible utilizar el ajuste <code>-march=native</code>. Al usarla, GCC intentará detectar el procesador y automáticamente usará las opciones apropiadas. '''¡Sin embargo, no se debe utilizar esto si se quiere compilar paquetes para CPUs diferentes!''' 

{{Warning|Do '''not''' use <code>-march{{=}}native</code> or <code>-mtune{{=}}native</code> in the <var>CFLAGS</var> or <var>CXXFLAGS</var> variables of {{Path|make.conf}} when compiling with {{c|[[Distcc#-march.3Dnative|distcc]]}}.}}

Si se está compilando paquetes en una computadora, para ejecutarlos en una computadora diferente (usando, por ejemplo, una computadora rápida para construir paquetes para una máquina más antigua y lenta), entonces ''no'' utilice la opción <code>-march=native</code>. La palabra "native" significa que el código producido podrá ejecutarse ''solamente'' en ese tipo de CPU. Las aplicaciones construidas con <code>-march=native</code> en una CPU AMD Athlon 64 CPU '''''no''''' podrán ejecutarse en una CPU VIA C3 más antigua. 

También están disponibles las opciones <code>-mcpu</code> y <code>-mtune</code>. Cada una de ellas solo se usará cuando no haya otra opción <code>-march</code> disponible. Ciertas arquitecturas de procesador pueden requerir <code>-mtune</code> o incluso de <code>-mcpu</code>. Desgraciadamente, el comportamiento de GCC no es muy consistente con la manera que cada opción se comporta de una arquitectura a otra. 

En CPUs x86 y x86-64, <code>-mcpu</code> se generará código específico para esa CPU usando sus instrucciones disponibles y el ABI correcto; no tendrá compatibilidad hacia atrás para CPUs antiguas o diferentes. Se puede considerar el uso de <code>-mtune</code> cuando se genere código para CPUs antiguas como i386 e i486. <code>-mtune </code> produce un código más genérico que <code>-march</code>; aunque afinará el código para cierta CPU, no se tendrán en cuenta los conjuntos de instrucciones disponibles y ABI. No utilice la opción <code>-mcpu</code> en sistemas x86 o x86-64, ya que es obsoleto para estas arquitecturas. 

Solo las CPUs que no sean x86/x86-64 (como Sparc, Alpha y PowerPC) pueden requerir <code>-mtune </code> o <code>-mcpu</code> en lugar de <code>-march</code>. En estas arquitecturas, <code>-mtune</code>/<code>-mcpu</code> algunas veces se comportará como <code>-march</code> en (x86/x86-64)... pero con un nombre distinto. De nuevo, el comportamiento de GCC y los nombres de las opciones no son consistentes entre arquitecturas, así que asegúrese de revisar el [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] de GCC para determinar cual de ellas se debería utilizar. 

{{Note|Para más sugerencias de configuraciones de <code>-march</code>/<code>-mtune</code>/<code>-mcpu</code>, por favor lea el capítulo 5 del [[HandBook:Main_Page/es|manual de instalación de Gentoo]] para la arquitectura. También, lea el manual de GCC listado en la página de [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options opciones específicas por arquitectura] con explicaciones más detalladas sobre las diferencias entre <code>-march</code>, <code>-mcpu</code>, y <code>-mtune</code>.}}

=== -O ===

Hablaremos ahora de la variable <code>-O</code>. Esta variabe controla el nivel de optimización de todo el código. Al cambiar este valor, la compilación de código tomará algo más de tiempo, y utilizará mucha más memoria, especialmente al incrementar el nivel de optimización. 

Existen siete ajustes para <code>-O</code>: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code> y <code>-Ofast</code>. Se debe utilizar solo uno de ellos en {{Path|/etc/portage/make.conf}}.

A excepción de <code>-O0</code>, la configuración de <code>-O</code> activa varias opciones adicionales, así que asegúrese de leer el capítulo del manual de gcc en[http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options opciones de optimización] para aprender qué opciones se activan en cada nivel <code>-O</code>, así como algunas explicaciones sobre lo que hacen. 

Examinemos cada nivel de optimización: 

*  <code>-O0</code>: This level (that is the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in <var>CFLAGS</var> or <var>CXXFLAGS</var>. This reduces compilation time and can improve debugging info, but some applications will not work properly without optimization enabled. This option is not recommended except for debugging purposes.

* <code>-O1</code>: El nivel de optimización más básico. El compilador intentará producir un código rápido y pequeño sin tomar mucho tiempo de compilación. Es básico, pero conseguirá realizar correctamente el trabajo.

* <code>-O2</code>: Un paso delante de <code>-O1</code>. Es el nivel ''recomendado'' de optimización, a no ser que el sistema tenga necesidades especiales. <code>-O2</code> activará algunas opciones añadidas a las que se activan con <code>-O1</code>. Con <code>-O2</code>, el compilador intentará aumentar el rendimiento del código sin comprometer el tamaño y sin tomar mucho más tiempo de compilación.

* <code>-O3</code>: El nivel más alto de optimización posible. Activa opitimizaciones que son caras en términos de tiempo de compilación y uso de memoria. El hecho de compilar con <code>-O3</code> no garantiza una forma de mejorar el rendimiento y, de hecho, en muchos casos puede ralentizar un sistema debido al uso de binarios de gran tamaño y mucho uso de la memoria. También se sabe que <code>-O3</code> puede romper algunos paquetes. No se recomienda utilizar <code>-O3</code>.

* <code>-Os</code>: Optimizará el tamaño del código. Activa todas las opciones de <code>-O2</code> que no incrementan el tamaño del código generado. Es útil para máquinas con capacidad limitada de disco o con CPUs que tienen poca caché.

* <code>-Og</code>: En GCC 4.8 aparece un nuevo nivel del optimización general: <code>-Og</code>. Trata de solucionar la necesidad de realizar compilaciones más rápidas y obtener una experiencia superior en la depuración a la vez que ofrece un nivel razonable de rendimiento en la ejecución. La experiencia global en el desarrollo debería ser mejor que para el nivel de optimización <code>-O0</code>. Observe que <code>-Og</code> no implica <code>-g</code>, éste simplemente deshabilita optimizaciones que podrían interferir con la depuración.

* <code>-Ofast</code>: Nuevo en GCC 4.7. Consiste en el ajuste <code>-O3</code> más las opciones <code>-ffast-math</code>, <code>-fno-protect-parens</code> y <code>-fstack-arrays</code>. Esta opción rompe el cumplimiento de estándares estrictos y no se recomienda su utilización.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and while not using <code>-O2</code>, try rebuilding with that option. As a fallback option, try setting the <var>CFLAGS</var> and <var>CXXFLAGS</var> to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).

=== -pipe ===

Una opción común es <code>-pipe</code>. No tiene efecto sobre el código que se produce, pero hace que el proceso de compilación sea ''más rápido''. Indica al compilador que use tuberías en lugar de archivos temporales durante los diferentes estados de compilación, lo cual usa más memoria. En sistemas con poca memoria, el proceso GCC se podría terminar por el sistema En estos casos no se debe utilizar esta opción. 

=== -fomit-frame-pointer ===

Esta es una opción muy común diseñada para reducir el tamaño del código generado. Está activada para todos los niveles de <code>-O</code> (excepto <code>-O0</code>) en arquitecturas donde no interfiera con la depuración (como x86-64), pero puede que haga falta activarla. En ese caso, se debe añadir a las opciones. Aunque el manual de GCC no especifica todas las arquitecturas, se activa mediante la opción <code>-O</code>. Todavía es necesario habilitar explícitamente la opción <code>-fomit-frame-pointer</code>. Para activarla en una arquitectura x86-32 con GCC hasta la versión 4.6 o cuando se utilice <code>-Os</code> en x86-32 con cualquier versión de GCC. Sin embargo, al usar <code>-fomit-frame-pointer</code> la depuración será algo difícil o incluso resultará imposible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. When not doing software debugging and no other debugging-related <var>CFLAGS</var> such as <code>-ggdb</code> have been used, then try using <code>-fomit-frame-pointer</code>. 

{{Important/es|''No'' combine <code>-fomit-frame-pointer</code> con la opción de nombre similar <code>-momit- leaf-frame-pointer</code>. No se aconseja la utilización de esta última, ya que <code>-fomit-frame-pointer</code> ya hace el trabajo apropiado. Es más, <code>-momit-leaf-frame-pointer</code> ha demostrado que impacta negativamente en el rendimiento del código.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

Estas opciones activan los conjuntos de instrucciones
[http://es.wikipedia.org/wiki/SSE Streaming SIMD Extensions] (SSE), [http://es.wikipedia.org/wiki/SSE2 SSE2], [http://es.wikipedia.org/wiki/SSSE3 SSE3], [http://es.wikipedia.org/wiki/MMX MMX] y [http://es.wikipedia.org/wiki/3DNow! 3DNow!]
para arquitecturas x86-64. Son útiles principalmente en multimedia, juegos y otras tareas intensivas de computación en punto flotante, aunque también contienen muchos otros realces matemáticos. Estos conjuntos de instrucciones se encuentran en las CPUs más modernas. 

{{Important|Asegúrese de comprobar si la CPU ofrece soporte para estos conjuntos de instrucciones lanzando la orden <kbd>cat/proc/cpuinfo</kbd>. La salida incluirá cualquier conjunto de instrucciones adicionales. Observe que '''pni''' es solo otro nombre para SSE3.}}

Normalmente no se necesita añadir ninguna de estas opciones a {{Path|/etc/portage/make.conf}} mientras el sistema esté utilizando la <code>-march</code> correcta (por ejemplo, <code>-march= nocona</code> implica <code>-msse3</code>). Algunas excepciones notables son las nuevas CPUs VIA y AMD64 que soportan instrucciones no implicadas por <code>-march</code> (como SSE3). Para CPUs como estas, se  necesita habilitar opciones adicionales donde sea necesario después de verificar la salida de {{Path|/proc/cpuinfo}}. 

{{Note|Revisar la [http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86-64-Options.html#i386-and-x86-64-Options lista de opciones específicas para x86 y x86-64] para ver cuales de estos conjuntos de instrucciones los activa la propia configuración del tipo de CPU. Si aparece una instrucción, entonces no se necesita especificar de forma independiente, se activará al usar la configuración de <code>-march </code> apropiada.}}

== Preguntas frecuentes sobre optimización ==

=== Sin embargo, ¡Consigo mejor rendimiento con -funroll-loops -fomg-optimize! ===

No, solo ''piensa'' que lo hace porque alguien le ha convencido que es mejor utilizar el mayor número de opciones. Las opciones agresivas  solo dañarán las aplicaciones cuando use un sistema completo. Incluso 
el [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] de GCC dice que usar <code>-funroll-loops </code> y <code>-funroll-all-loops</code> hará que el código ocupe más espacio y que corre más lento. Aunque por alguna razón, estas dos opciones, junto con <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, y similares, continúan siendo muy populares entre pardillos que creen saber más que nadie. 

La verdad es que son opciones peligrosamente agresivas. Eche un vistazo a los [https://forums.gentoo.org/ Foros de Gentoo] y a [https://bugs.gentoo.org/ Bugzilla] para
ver que hacen estas variables: ¡Nada bueno! 

You do not need to use those flags globally in <var>CFLAGS</var> or <var>CXXFLAGS</var>. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat the code and get your bugs marked INVALID or WONTFIX. 

No necesita opciones peligrosas como estas. '''No las
utilice'''. Quédese con las básicas: <code>-march</code>, <code>-O</code> y <code>-pipe</code>.

=== ¿Qué pasa con los niveles -O mayores que 3 ===

Some users boast about even better performance obtained by using <code>-O4</code>, <code>-O9</code>, and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept <var>CFLAGS</var> like <code>-O4</code>, but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code>, nothing more. 

¿Necesita más pruebas? Eche un vistazo al [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup código fuente]: 

{{CodeBox|title=Código fuente -O|lang=bash|1=
if (optimize >= 3)
  {
   flag_inline_functions = 1;
   flag_unswitch_loops = 1;
   flag_gcse_after_reload = 1;
   /* Permitir más operadores virtuales. */
   set_param_value ("max-aliased-vops", 1000);
   set_param_value ("avg-aliased-vops", 3);
  }
}}

Como puede observar, cualquier valor mayor que 3 se trata como <code>-O3</code>.

=== ¿Qué ocurre cuando compilamos fuera de la máquina destino? ===

Algunos lectores se pueden preguntar si el hecho de compilar fuera de la máquina destino usando una CPU estrictamente inferior o una subarquitectura en GCC generará unos resultados de optimización inferiores. La respuesta es simple: '''No'''. Independientemente del hardware en el que realmente se realiza la compilación y el CHOST con el que se construyó GCC, si se utilizan los mismos argumentos <small> (excepto para <code>-march=native</code>)</small> y la misma versión de GCC<small> (aunque la versión menor puede ser distinta)</small>, las optimizaciones resultantes son estrictamente las mismas.

Como ejemplo, si Gentoo se instala en una máquina en el que el CHOST de GCC es ''i686-pc-linux-gnu'', y se utiliza un servidor [[Distcc/es]] en otro equipo en el que el CHOST de GCC es ''i486-linux-gnu'' entonces no hay porqué preocuparse de que los resultados sean menos óptimos ya que la subarquitectura del compilador o el hardware del equipo remoto son estrictamente inferiores. El resultado sería igual de óptimo que una construcción en una máquina nativa siempre que se pasen las mismas opciones a ambos compiladores (y no se defina el argumento <code>-march</code> como <code>native</code>). En este caso en particular se necesita especificar la aquitectura destinotal y como se indica en [[Distcc/es#-march.3Dnative|Distcc y -march=native]].

La única diferencia en el comportamiento entre dos versiones de GCC construidas con diferentes subarquitecturas es el valor implícito por defecto para el parámetro <code>-march</code> que se deriva del CHOST de GCC cuando no se ha indicado uno de forma explícita en la línea de órdenes.

=== ¿Qué pasa con las opciones redundantes? ===

Oftentimes <var>CFLAGS</var> and <var>CXXFLAGS</var> that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}}. Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all <var>CFLAGS</var> and <var>CXXFLAGS</var>, or it may replace <code>-O</code> with a different level. 

El [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Manual del Desarrollador de Gentoo] indica dónde y cómo funciona el filtrado y el reemplazo de opciones. 

Es posible evitar el filtrado de <code>-O</code> filtrando mediante el listado redundante de opciones para un cierto nivel, como <code>-O3</code>, haciendo cosas como: 

{{CodeBox|title=Especificar CFLAGS redundantes|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

However, '''this is not a smart thing to do'''. <var>CFLAGS</var> are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers''. Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

No encontrará más que problemas cuando construya un paquete con opciones inaceptables. Cuando informe de sus problemas en Bugzilla, las opciones que usó en {{Path|/etc/portage/make.conf}} serán fácilmente visibles y se le instará a recompilar sin ellas.
¡Protéjase de los problemas de recompilar evitando el uso de opciones redundantes! No asuma automáticamente que sabe más que los desarrolladores.

=== ¿Qué pasa con LDFLAGS? ===

The Gentoo developers have already set basic, safe <var>LDFLAGS</var> in the base profiles, so they do not need to be changed.

=== ¿Puedo usar opciones para cada paquete? ===

{{Warning/es|El uso de opciones específicas de paquetes complica la depuración y el soporte. Asegúrese mencionarlo en los informes de fallos si está usando esta característica y los cambios que haya realizado.}}

Information on how to use per-package environment variables (including <var>CFLAGS</var>) is described in the [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]].

== Recursos ==

Los siguientes recursos pueden ser de ayuda para comprender la optimización: 

* La [http://gcc.gnu.org/onlinedocs/ documentación en línea de GCC] 

* El capítulo 5 de los [[Handbook:Main_Page/es|manuales de instalación de Gentoo]]

* <kbd>man make.conf</kbd>

* [https://es.wikipedia.org/ Wikipedia]

* Los [https://forums.gentoo.org/ Foros de Gentoo]

{{Migrated|originalauthors=nightmorph}}
