{{InfoBox stack
|{{InfoBox homepage|http://haskell.org/haskellwiki/Haskell|header=true}}
|{{InfoBox wikipedia|Haskell (programming language)}}
}}
'''Haskell''' is a purely-functional programming language.

== Gentoo and Haskell ==
* [[Project:Haskell|Gentoo Project: Gentoo Resources for Haskell]]
* [https://github.com/gentoo-haskell/gentoo-haskell/blob/master/README.rst Gentoo Haskell Overlay README]
: The most important part is that this overlay requires a specific unmasking procedure to prevent blockers.

== Compiler and interpreter ==
* The probably most important and up-to-date Haskell-implementation is the [http://www.haskell.org/ghc/ '''Glasgow Haskell Compiler'''] (GHC). You can install it with:
: {{Emerge|dev-lang/ghc}}
: The package also includes an interpreter called GHCI (except on the ARM-architecture).
* Furthermore, there's [http://www.haskell.org/hugs/ '''Hugs'''], an (meanwhile (almost) out-dated) interpreter for Haskell98. You can install it with:
: {{Emerge|dev-lang/hugs98}}

== Cabal ==
With [http://www.haskell.org/cabal/ '''cabal'''] you can package and build libraries and programs. Install it with:
{{Emerge|dev-haskell/cabal-install}}

== Updating Haskell packages ==
Sometimes:

{{Emerge|params=-auvDN --keep-going|@world}}

has trouble figuring out how to update Haskell packages. Providing emerge with the full list of dev-haskell packages that have upgrades available can sometimes help:
{{RootCmd|eix-update}}
{{Emerge|params=-av --oneshot --keep-going|`eix --only-names --upgrade -C dev-haskell`}}
{{RootCmd|haskell-updater}}

Unless EAPI="6" is approved sometimes we have sub-slot blockers (when updating ghc or some specific package there are a list of blockers) this issue
could be solved via running
{{RootCmd|haskell-updater -all -- dev-lang/ghc-7.6.2}}

== Hoogle with local installation ==
The Hoogle ebuild is currently only available in the offical ''gentoo-haskell'' [[overlay]]. So add that first.
{{Important|Remember to unmask the overlay packages as described in the [https://github.com/gentoo-haskell/gentoo-haskell/blob/master/README.rst overlay README]}}
{{RootCmd|layman -a haskell}}

In order to get the an offline installation of all hoogle data, you need to enable the "doc", "hscolour" and "hoogle" USE flag.
{{RootCmd|echo "dev-haskell/* doc hoogle hscolour" >> /etc/portage/package.use}}

Enable the relevant USE flags for hoogle to store all data local, and emerge hoogle
{{RootCmd|echo "dev-haskell/hoogle fetchdb fetchdb-ghc localdb" >> /etc/portage/package.use}}
{{Emerge|dev-haskell/hoogle}}

After emerging haskell packages, the hoogle database of the locally installed packages is updated by running:
{{RootCmd|hoogle-build-localdb}}

(It's normal for <code>hoogle-build-localdb</code> to output a bunch of junk. Redirect {{Path|stdout}} to {{Path|/dev/null}} if you add it to your e.g. {{Path|/etc/cron.daily}}.)

At this point, you should be able to use Hoogle from the command-line. For example, the following will search for the <code>splitOn</code> function:

{{Cmd|$ hoogle splitOn
|output=<pre>
Data.Text.Lazy splitOn :: Text -> Text -> [Text]
Data.Text splitOn :: Text -> Text -> [Text]
Data.List.Extra splitOn :: Eq a => [a] -> [a] -> [[a]]
Extra splitOn :: Eq a => [a] -> [a] -> [[a]]
Data.List.Split.Internals splitOn :: Eq a => [a] -> [a] -> [[a]]
Data.List.Split splitOn :: Eq a => [a] -> [a] -> [[a]]
Data.List.Split.Internals splitOneOf :: Eq a => [a] -> [a] -> [[a]]
Data.List.Split splitOneOf :: Eq a => [a] -> [a] -> [[a]]</pre>}}

=== Integration with GHCi ===

If you'd like to use Hoogle within GHCi, you can do it with a little modification to your local {{Path|~/.ghci}} file. Add the following:

{{FileBox|filename=~/.ghci|lang=haskell|1=
-- Surround a string in single quotes.
let single_quote s = concat ["'", s, "'"]

-- Escape a single quote in the shell. (This mess actually works.)
let escape_single_quote c = if c == '\'' then "'\"'\"'" else [c]

-- Simple heuristic to escape shell command arguments.
let simple_shell_escape = single_quote . (concatMap escape_single_quote)

:def hoogle \x -> return $ ":!hoogle --color " ++ (simple_shell_escape x)
:def doc \x -> return $ ":!hoogle --info --color " ++ (simple_shell_escape x)
}}

Now, within GHCi, you should have access to two new commands, <code>:hoogle</code> and <code>:doc</code>. The first will perform a normal Hoogle search and print the output:

{{Cmd|ghci
|output=<pre>
ghci> :hoogle splitOn
Searching for: splitOn
Data.Text.Lazy splitOn :: Text -> Text -> [Text]
Data.Text splitOn :: Text -> Text -> [Text]
Data.List.Extra splitOn :: Eq a => [a] -> [a] -> [[a]]
Extra splitOn :: Eq a => [a] -> [a] -> [[a]]
Data.List.Split.Internals splitOn :: Eq a => [a] -> [a] -> [[a]]
Data.List.Split splitOn :: Eq a => [a] -> [a] -> [[a]]
Data.List.Split.Internals splitOneOf :: Eq a => [a] -> [a] -> [[a]]
Data.List.Split splitOneOf :: Eq a => [a] -> [a] -> [[a]]
</pre>}}

The second will display the Haddock documentation for the method:

{{Cmd|ghci
|output=<pre>
ghci> :doc splitOn
Searching for: splitOn
Data.Text.Lazy splitOn :: Text -> Text -> [Text]

O(m+n) Break a Text into pieces separated by the first Text argument (which cannot be an empty string), consuming the delimiter. An empty delimiter is invalid, and will cause an error to be raised.

Examples:

> splitOn "\r\n" "a\r\nb\r\nd\r\ne" == ["a","b","d","e"]
> splitOn "aaa"  "aaaXaaaXaaaXaaa"  == ["","X","X","X",""]
> splitOn "x"    "x"                == ["",""]

and

> intercalate s . splitOn s         == id
> splitOn (singleton c)             == split (==c)

(Note: the string s to split on above cannot be empty.)

This function is strict in its first argument, and lazy in its second.

In (unlikely) bad cases, this function's time complexity degrades towards O(n*m). 

From package text
splitOn :: Text -> Text -> [Text]
</pre>}}

== HLint ==
[http://community.haskell.org/~ndm/hlint/ '''HLint'''] checks and simplifies your haskell source code! Install it with:
{{RootCmd|layman -a haskell}}
{{Emerge|dev-haskell/hlint}}

== Editor plugins ==

=== Emacs ===

==== Haskell Mode ====
The [http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs Haskell-Mode] for (X)Emacs makes programming easier; install it with
{{Emerge|app-emacs/haskell-mode}}
for GNU Emacs, or with
{{Emerge|app-xemacs/haskell-mode}}
for XEmacs.

Then, you can configure it with <code>M-x customize-group RET haskell RET</code>.

==== ghc-mod ====
The official gentoo haskell overlay provides an ebuild for ghc-mod, an extension of Haskell mode. Add the overlay with
{{RootCmd|layman -a haskell}}

Then, install the ebuild
{{Emerge|app-emacs/ghc-mod}}

=== Haskell-Mode for Vim ===
[http://projects.haskell.org/haskellmode-vim/ There]'s also a Haskell-Mode for [[Vim]].

== IRC ==
For further information and individual help, visit <code>#haskell</code> or <code>#gentoo-haskell</code> on <code>chat.freenode.net</code>.

[[Category:Haskell]]
