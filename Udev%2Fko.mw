<languages />
{{Metadata|abstract=udev는 리눅스 커널의 장치 관리자입니다. /dev의 장치 노드를 관리하며, 장치를 추가/제거할 때 모든 사용자 영역 동작을 관리합니다.}}

{{InfoBox stack
|{{InfoBox homepage|http://www.freedesktop.org/wiki/Software/systemd/|header=true}}
|{{InfoBox gdoc|Udev}}
|{{InfoBox wikipedia}}
|{{InfoBox gitweb|http://cgit.freedesktop.org/systemd/systemd/tree/src/udev|raw=true}}
}}

'''udev'''는 리눅스 커널용 장치 관리자입니다. {{Path|/dev}}의 장치 노드를 관리하며 장치를 추가하고 제거할 때 모든 사용자 공간 처리 동작을 관리합니다. 이 글의 독자 여러분은 udev의 포크 버전인 [[Eudev | eudev]]도 살펴보셔야 합니다.

== udev란 무엇인가요? ==

=== /dev 디렉터리 ===

리눅스를 바이러스의 한 종류거나 커피 브랜드의 한 종류로 아는 리눅스 사용자 계층이 시스템의 하드웨어에 대해 이야기할 때, ''슬래시 dev 슬래시 foo''라고 하면 이상하게 살펴볼 겁니다. 그러나 {{Path|/dev/sda1}}를 활용하는 운이 좋은(그리고 이 글을 보고 있는 독자 여러분도) 사용자는 프라이머리 첫번째 SATA의, 첫번째 분할 공간이라고 빠르게 알아채실겁니다. 참 쉽죠? 

대부분의 리눅스 사용자는 [[device file|장치 파일]]이 뭔지 압니다. 게다가 장치 파일에 특별한 숫자가 붙는 이유도 압니다. {{Path|/dev}} 폴더에서 {{c|ls -l}}을 실행하면 바로 장치 목록을 볼 수 있습니다. 어떤 사용자는 프라이머리 SATA 디스크를 {{Path|/dev/sda}}로 참조했음을 볼 수 있고, 어떤 사용자는 이런 방식으로 볼 수 없지만, 이건 설계상 결함일 뿐입니다. 

USB, IEEE1394, 실시간 착탈 가능한 PCI 등과 같은 착탈 가능 장치에 대해 생각해보도록 하죠. 어떤 장치가 첫번째 장치일까요? 그리고 얼마나 붙어있을까요? 첫번째 장치를 빼면 다른 장치에는 어떻게 이름을 붙일까요? 트랜잭션에 어떻게 영향을 미칠까요? 누군가의 엄마가 레이저 프린터 전원 코드를 뽑기로 작정한게 첫번째 프린터에 일어난 ''일'' 이어서 완전 새 레이저 프린터에 넣었던 작업을 거의 맛이간 매트릭스 프린터로 갑작스럽게 옮긴다면 재밌는 일이 되지 않을까요? 

{{c|udev}}를 입력하십시오. udev 프로젝트의 목표는 흥미와 필요성 때문입니다. Udev는:

* 사용자 영역에서 실행합니다
* 동적으로 장치 파일을 만들고 제거합니다
* 일관된 이름을 제공합니다
* 사용자 영역 프로그램 인터페이스(API)를 제공합니다.

Every time a change happens within the device structure, the kernel emits a ''uevent'' which gets picked up by {{c|udev}}. {{c|udev}} then follows the rules as declared in the {{Path|/etc/udev/rules.d}}, {{Path|/run/udev/rules.d}} and {{Path|/lib/udev/rules.d}} directories. Based on the information contained within the uevent, it finds the rule or rules it needs to trigger and performs the required actions. These actions can be creating or deleting device files, but can also trigger the loading of particular firmware files into kernel memory.

== 설치 ==

{{Important|udev를 업데이트할 때 시스템을 부팅하지 못하게 하는 상황으로 못가도록 막을 수 있는 정보를 보려면 [[Udev/Upgrade Guide|udev 업그레이드 안내서]] 를 확인하십시오.}}

=== 커널 ===

{{c|udev}} 에서는 다음 커널 옵션이 필요합니다:

<!-- See http://git.kernel.org/?p=linux/hotplug/udev.git;a=blob_plain;f=README -->
{{KernelBox|1=
General setup  --->
    [*] Configure standard kernel features (expert users)  --->
        [ ] Enable deprecated sysfs features to support old userspace tools
        [*] Enable signalfd() system call
Enable the block layer  --->
    [*] Block layer SG support v4
Networking support  --->
    Networking options  --->
        <*> Unix domain sockets
Device Drivers  --->
    Generic Driver Options  --->
        ()  path to uevent helper
        [*] Maintain a devtmpfs filesystem to mount at /dev
    < > ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
File systems  --->
    [*] Inotify support for userspace
    Pseudo filesystems --->
        [*] /proc file system support
        [*] sysfs file system support
}}

=== USE 플래그 ===

포티지는 다른 꾸러미에서 udev 기능을 지원하는 <code>udev</code> 전역 USE 플래그를 인지합니다. 이 USE 플래그 값을 USE 플래그 목록에 추가(모든 리눅스 [[Profile (Portage)|프로파일]] 기본값)하면 {{Package|sys-fs/udev}} 꾸러미를 자동으로 끌어옵니다:

{{FileBox|filename=/etc/portage/make.conf|lang=bash|1=
USE="udev"
}}

{{USEflag|package=sys-fs/udev}}

=== Emerge ===

USE 변수를 설정한 후, 시스템을 업데이트하여 바뀐 설정을 적용하십시오:

{{Emerge|params+=--changed-use --deep|@world}}

== 설정 ==

=== 서비스 ===

부팅 시간에 udev를 시작하려면 sysinit 럴레벨에 추가하십시오. 다음 명령을 루트 권한으로 실행하면 처리할 수 있습니다:

{{RootCmd|rc-update add udev sysinit}}

== 고급 설정 ==

=== 규칙 ===

udev provides a set of rules that match against exported values of uevents (events sent by the kernel) and properties of the discovered device. A matching rule will possibly name and create a device node and run configured programs to setup and configure the device.

정의 규칙은 다음 두군데에 저장합니다:

# '''{{Path|/lib/udev/rules.d/}}''' - 이 디렉터리의 규칙은 각각의 꾸러미가 설치하며, 보통 사용자가 바꾸어선 안됩니다.
# '''{{Path|/etc/udev/rules.d/}}''' - 이 폴더에는 최종 사용자가 설정한 규칙이 있습니다. 어떤 새로운 규칙이든 이 디렉터리에 추가해야합니다.

이 디렉터리에서 ({{Path|.rules}}로 끝나는) 여러 규칙 파일은 알파벳 및 숫자 순서대로 확인합니다. 규칙 파일 안에서 udev는 uevent와 상태가 일치(장치를 추가하거나 제거하기 때문에 uevent가 됩니다)하는 조건 설정과 실행할 명령을 찾습니다.

이벤트 비교는 다음과 같은 정보를 기반으로 합니다:

* uevent ''SUBSYSTEM'' (uevent의 어떤 형식의 장치를 실행했는가)
* 취한 ''ACTION'' (추가, 변경, 제거)
* 장치 클래스, 제조사, 다른 장치 정보 등의 하나 이상의 속성(''ATTR'' 또는 ''ATTRS'')
* sd* (SCSI/SATA 디스크) 또는 input* (마우스, 키보드 같은 입력 장치)과 같은 커널 제공 이름 (''KERNEL''), 
* 여러 규칙에 정보를 보낼 때 활용할 하나 이상의 환경 변수 설정(''ENV'')

이 정보를 기반으로 다음의 조건에 따라, 규칙을 세울 수 있습니다:

# 일부 정보는 (환경 변수로)최종 이벤트와 공유해야 합니다
# {{Path|/dev}}에 링크를 만들어야 합니다
# 명령을 실행해야 합니다

udev는 유연한 장치 관리 방식을 허용하는 모든 규칙(첫번째 일치 요소가 있다고 해서 멈추진 않음)에 대해 이러한 동작을 수행합니다.

=== 영속 장치 이름 ===

커널은 장치를 순차적으로 발견하고 udev는 커널의 [[sysfs]] 파일 시스템을 미러링하며, 장치에 이름과 숫자를 발견한 순서대로 부여합니다. 따라서 기본적으로 udev에서는 비영속적 장치 이름을 제공합니다. 허나 일부 장치 클래스에 대한 기법에는 다음과 같은 특징이 있습니다:

* udev는 장치 ID, [[Removable_media#UUIDs_and_labels|label, UUID]], 경로를 기반으로 저장장치 추가 심볼릭 링크를 만듭니다. {{Path|/dev/disk/by-*}} 디렉터리를 살펴보십시오. 따라서, 장치 파일 {{Path|/dev/sda}} 을 사용하는 대신 {{Path|/dev/disk/by-label/SOME_LABEL}} 파일을 활용합니다.

* {{Path|/dev/input}} 디렉터리의 입력 장치는 동일합니다.

* 사용자 규칙을 활용은 사용자로 하여금 자체 장치 파일을 만들 수 있습니다.

== 사용법 ==

몇가지 쓸모있는 명령이 있습니다.

* 주어진 장치에 대한 모든 메시지를 보여줍니다;
: {{RootCmd|udevadm info --query{{=}}all --name{{=}}/dev/DEVICE_FILE}}

* udev 활동을 감시합니다:
: {{RootCmd|udevadm monitor}}

더 많은 정보는 ''udevadm'' [[man page|맨 페이지]]<sup style="color:#ff0077">en</sup>를 참고하십시오

== 문제 해결 ==

* {{Bug|udev|search=package}}

=== 감시 메시지 기록 ===

{{c|udevadm monitor}}를 실행할 때 모든 메시지를 기록하려면 다음 설정 파일을 수정하십시오:

{{FileBox|filename=/etc/conf.d/udev|lang=bash|1=
udev_monitor="YES"
}}

{{Path|/run/udev/udevmonitor.log}}에 새 로그 파일을 만듭니다

=== 디버깅 모드 ===

디버깅 모드를 활성화하면 더 많은 기록 메시지를 출력합니다:

{{FileBox|filename=/etc/conf.d/udev|lang=bash|1=
udev_debug="YES"
}}

기록 우선순위를 설정하십시오:

{{FileBox|filename=/etc/udev/udev.conf|lang=bash|1=
udev_log="debug"
}}

{{Path|/run/udevdebug.log}} 기록 파일을 만들겠지만 어떤 메시지도 기록하지 않습니다. 최근의 udev 버전에서는 {{c|dmesg}}에 모든 메시지를 기록합니다.

=== {{Path|/dev/null}} 과 {{Path|/dev/console}} 장치가 빠졌다고 합니다 ===

일부 udev 버전에서는 udev가 제대로 동작하려면 {{Path|/dev/null}}과 {{Path|/dev/console}}이 필요합니다. 그러나 자체적으로 만들 수는 없습니다. 이 파일을 직접 만들려면 루트 권한으로 다음 명령을 실행하십시오:

{{RootCmd
|mkdir test
|mount --bind / test
|cd test/dev
|mknod -m 660 console c 5 1
|mknod -m 660 null c 1 3
|cd ../..
|umount test
|rmdir test
}}

===  NIC에 eth0을 할당했는데 eth1으로 바뀌네요 ===

Those having dual network cards on their motherboards may run into a situation where {{c|ifconfig}} may show no eth0 or eth1. {{c|dmesg}} may show their NIC detected as eth0, and later moved to eth1. Performing a {{c|ifconfig -a}} will also show the NIC as eth1. This is caused by using the kernel assigned names in the first place. Users should write custom rules like {{Path|/etc/udev/rules.d/70-my-network.rules}} to use free names like lan0 or wireless0 or use predictable interface names (which have been enabled by default since udev version 197).

또한 이전 버전의 udev에 있던 오래된 파일의 제거를 잊지 마십시오.

{{RootCmd|rm /etc/udev/rules.d/70-persistent-net.rules}}

== 추가 참조 ==

[[Eudev|eudev]] - 젠투에서 관리하는 udev 포크 버전.


[[Category:Core system]]
[[Category:Daemons]]
