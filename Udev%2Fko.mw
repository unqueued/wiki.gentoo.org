<languages />
{{Metadata|abstract=udev는 리눅스 커널의 장치 관리자입니다. /dev의 장치 노드를 관리하며, 장치를 추가/제거할 때 모든 사용자 영역 동작을 관리합니다.}}

{{InfoBox stack
|{{InfoBox homepage|http://www.freedesktop.org/wiki/Software/systemd/|header=true}}
|{{InfoBox gdoc|Udev}}
|{{InfoBox wikipedia}}
|{{InfoBox gitweb|http://cgit.freedesktop.org/systemd/systemd/tree/src/udev|raw=true}}
}}

'''udev'''는 리눅스 커널용 장치 관리자입니다. {{Path|/dev}}의 장치 노드를 관리하며 장치를 추가하고 제거할 때 모든 사용자 공간 처리 동작을 관리합니다. 이 글의 독자 여러분은 udev의 포크 버전인 [[Eudev | eudev]]도 살펴보셔야 합니다.

== udev란 무엇인가요? ==

=== /dev 디렉터리 ===

리눅스를 바이러스의 한 종류거나 커피 브랜드의 한 종류로 아는 리눅스 사용자 부류에게 시스템 하드웨어에 대해 이야기할 때, ''슬래시 dev 슬래시 foo''라고 하면 이상하다는 듯 볼 겁니다. 그러나 {{Path|/dev/sda1}}를 활용하는 운이 좋은(그리고 이 글을 보고 있는 독자 여러분도) 사용자는 프라이머리 첫번째 SATA의, 첫번째 분할 공간이라고 빠르게 알아채실겁니다. 참 쉽죠? 

대부분의 리눅스 사용자는 [[device file|장치 파일]]이 뭔지 압니다. 게다가 장치 파일에 특별한 숫자가 붙는 이유도 압니다. {{Path|/dev}} 폴더에서 {{c|ls -l}}을 실행하면 바로 장치 목록을 볼 수 있습니다. 어떤 사용자는 프라이머리 SATA 디스크를 {{Path|/dev/sda}}로 참조했음을 볼 수 있고, 어떤 사용자는 이런 방식으로 볼 수 없지만, 이건 설계상 결함일 뿐입니다. 

USB, IEEE1394, 실시간 착탈 가능한 PCI 등과 같은 착탈 가능 장치에 대해 생각해보도록 하죠. 어떤 장치가 첫번째 장치일까요? 그리고 얼마나 붙어있을까요? 첫번째 장치를 빼면 다른 장치에는 어떻게 이름을 붙일까요? 트랜잭션에 어떻게 영향을 미칠까요? 누군가의 엄마가 레이저 프린터 전원 코드를 뽑기로 작정한게 첫번째 프린터에 일어난 ''일'' 이어서 완전 새 레이저 프린터에 넣었던 작업을 거의 맛이간 매트릭스 프린터로 갑작스럽게 옮긴다면 재밌는 일이 되지 않을까요? 

{{c|udev}}를 입력하십시오. udev 프로젝트의 목표는 흥미와 필요성 때문입니다. Udev는:

* 사용자 영역에서 실행합니다
* 동적으로 장치 파일을 만들고 제거합니다
* 일관된 이름을 제공합니다
* 사용자 영역 프로그램 인터페이스(API)를 제공합니다.

항상 변경은 장치 구조내에서 일어나며 커널에서는 {{c|udev}}에서 받을 ''uevent''를 쏴보냅니다. {{c|udev}} 는 {{Path|/etc/udev/rules.d}}, {{Path|/run/udev/rules.d}}, {{Path|/lib/udev/rules.d}} 디렉터리에 선언한 규칙을 따릅니다. uevent에 들어간 정보를 기반으로 규칙 또는 실행이 필요한 규칙을 찾고 요구한 동작을 수행합니다. 이 동작은 장치 파일을 만들거나 삭제하는 행위가 될 수 있겠지만 펌웨어 파일을 커널 메모리로 불러오는 작업을 실행하는 동작이 될 수도 있습니다.

== 설치 ==

{{Important|udev를 업데이트할 때 시스템을 부팅하지 못하게 하는 상황으로 못가도록 막을 수 있는 정보를 보려면 [[Udev/Upgrade Guide|udev 업그레이드 안내서]] 를 확인하십시오.}}

=== 커널 ===

{{c|udev}} 에서는 다음 커널 옵션이 필요합니다:

<!-- See http://git.kernel.org/?p=linux/hotplug/udev.git;a=blob_plain;f=README -->
{{KernelBox|1=
General setup  --->
    [*] Configure standard kernel features (expert users)  --->
        [ ] Enable deprecated sysfs features to support old userspace tools
        [*] Enable signalfd() system call
Enable the block layer  --->
    [*] Block layer SG support v4
Networking support  --->
    Networking options  --->
        <*> Unix domain sockets
Device Drivers  --->
    Generic Driver Options  --->
        ()  path to uevent helper
        [*] Maintain a devtmpfs filesystem to mount at /dev
    < > ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
File systems  --->
    [*] Inotify support for userspace
    Pseudo filesystems --->
        [*] /proc file system support
        [*] sysfs file system support
}}

=== USE 플래그 ===

포티지는 다른 꾸러미에서 udev 기능을 지원하는 <code>udev</code> 전역 USE 플래그를 인지합니다. 이 USE 플래그 값을 USE 플래그 목록에 추가(모든 리눅스 [[Profile (Portage)|프로파일]] 기본값)하면 {{Package|sys-fs/udev}} 꾸러미를 자동으로 끌어옵니다:

{{FileBox|filename=/etc/portage/make.conf|lang=bash|1=
USE="udev"
}}

{{USEflag|package=sys-fs/udev}}

=== Emerge ===

USE 변수를 설정한 후, 시스템을 업데이트하여 바뀐 설정을 적용하십시오:

{{Emerge|params+=--changed-use --deep|@world}}

== 설정 ==

=== 서비스 ===

부팅 시간에 udev를 시작하려면 sysinit 럴레벨에 추가하십시오. 다음 명령을 루트 권한으로 실행하면 처리할 수 있습니다:

{{RootCmd|rc-update add udev sysinit}}

== 고급 설정 ==

=== 규칙 ===

udev에서는 uevents(커널에서 보낸 이벤트)에서 내보낸 값과 발견한 장치의 속성에 일치하는 규칙 모음을 제공합니다. 일치하는 규칙은 아마도 이름일 것이며, 장치 노드를 만들고, 장치를 설치하고 설정할, 조건을 미리 갖춰놓은 프로그램을 실행합니다.

정의 규칙은 다음 두군데에 저장합니다:

# '''{{Path|/lib/udev/rules.d/}}''' - 이 디렉터리의 규칙은 각각의 꾸러미가 설치하며, 보통 사용자가 바꾸어선 안됩니다.
# '''{{Path|/etc/udev/rules.d/}}''' - 이 폴더에는 최종 사용자가 설정한 규칙이 있습니다. 어떤 새로운 규칙이든 이 디렉터리에 추가해야합니다.

이 디렉터리에서 ({{Path|.rules}}로 끝나는) 여러 규칙 파일은 알파벳 및 숫자 순서대로 확인합니다. 규칙 파일 안에서 udev는 uevent와 상태가 일치(장치를 추가하거나 제거하기 때문에 uevent가 됩니다)하는 조건 설정과 실행할 명령을 찾습니다.

이벤트 비교는 다음과 같은 정보를 기반으로 합니다:

* uevent ''SUBSYSTEM'' (uevent의 어떤 형식의 장치를 실행했는가)
* 취한 ''ACTION'' (추가, 변경, 제거)
* 장치 클래스, 제조사, 다른 장치 정보 등의 하나 이상의 속성(''ATTR'' 또는 ''ATTRS'')
* sd* (SCSI/SATA 디스크) 또는 input* (마우스, 키보드 같은 입력 장치)과 같은 커널 제공 이름 (''KERNEL''), 
* 여러 규칙에 정보를 보낼 때 활용할 하나 이상의 환경 변수 설정(''ENV'')

이 정보를 기반으로 다음의 조건에 따라, 규칙을 세울 수 있습니다:

# 일부 정보는 (환경 변수로)최종 이벤트와 공유해야 합니다
# {{Path|/dev}}에 링크를 만들어야 합니다
# 명령을 실행해야 합니다

udev는 유연한 장치 관리 방식을 허용하는 모든 규칙(첫번째 일치 요소가 있다고 해서 멈추진 않음)에 대해 이러한 동작을 수행합니다.

=== 영속 장치 이름 ===

커널은 장치를 순차적으로 발견하고 udev는 커널의 [[sysfs]] 파일 시스템을 미러링하며, 장치에 이름과 숫자를 발견한 순서대로 부여합니다. 따라서 기본적으로 udev에서는 비영속적 장치 이름을 제공합니다. 허나 일부 장치 클래스에 대한 기법에는 다음과 같은 특징이 있습니다:

* udev는 장치 ID, [[Removable_media#UUIDs_and_labels|label, UUID]], 경로를 기반으로 저장장치 추가 심볼릭 링크를 만듭니다. {{Path|/dev/disk/by-*}} 디렉터리를 살펴보십시오. 따라서, 장치 파일 {{Path|/dev/sda}} 을 사용하는 대신 {{Path|/dev/disk/by-label/SOME_LABEL}} 파일을 활용합니다.

* {{Path|/dev/input}} 디렉터리의 입력 장치는 동일합니다.

* 사용자 규칙을 활용은 사용자로 하여금 자체 장치 파일을 만들 수 있습니다.

== 사용법 ==

몇가지 쓸모있는 명령이 있습니다.

* 주어진 장치에 대한 모든 메시지를 보여줍니다;
: {{RootCmd|udevadm info --query{{=}}all --name{{=}}/dev/DEVICE_FILE}}

* udev 활동을 감시합니다:
: {{RootCmd|udevadm monitor}}

더 많은 정보는 ''udevadm'' [[man page|맨 페이지]]<sup style="color:#ff0077">en</sup>를 참고하십시오

== 문제 해결 ==

* {{Bug|udev|search=package}}

=== 감시 메시지 기록 ===

{{c|udevadm monitor}}를 실행할 때 모든 메시지를 기록하려면 다음 설정 파일을 수정하십시오:

{{FileBox|filename=/etc/conf.d/udev|lang=bash|1=
udev_monitor="YES"
}}

{{Path|/run/udev/udevmonitor.log}}에 새 로그 파일을 만듭니다

=== 디버깅 모드 ===

디버깅 모드를 활성화하면 더 많은 기록 메시지를 출력합니다:

{{FileBox|filename=/etc/conf.d/udev|lang=bash|1=
udev_debug="YES"
}}

기록 우선순위를 설정하십시오:

{{FileBox|filename=/etc/udev/udev.conf|lang=bash|1=
udev_log="debug"
}}

{{Path|/run/udevdebug.log}} 기록 파일을 만들겠지만 어떤 메시지도 기록하지 않습니다. 최근의 udev 버전에서는 {{c|dmesg}}에 모든 메시지를 기록합니다.

=== {{Path|/dev/null}} 과 {{Path|/dev/console}} 장치가 빠졌다고 합니다 ===

일부 udev 버전에서는 udev가 제대로 동작하려면 {{Path|/dev/null}}과 {{Path|/dev/console}}이 필요합니다. 그러나 자체적으로 만들 수는 없습니다. 이 파일을 직접 만들려면 루트 권한으로 다음 명령을 실행하십시오:

{{RootCmd
|mkdir test
|mount --bind / test
|cd test/dev
|mknod -m 660 console c 5 1
|mknod -m 660 null c 1 3
|cd ../..
|umount test
|rmdir test
}}

===  NIC에 eth0을 할당했는데 eth1으로 바뀌네요 ===

메인 보드에 네트워크 카드가 둘 있는 상황은 {{c|ifconfig}}에서 eth0 또는 eth1을 보여주지 못하는 상호아에 갈 수도 있습니다. {{c|dmesg}}는 eth0으로 발견한 NIC 카드를 보여주고 그 다음 eth1으로 옮깁니다. {{c|ifconfig -a}} 를 실행하면 NIC를 eth1으로 보여줍니다. 이러한 현상은 처음에 커널에서 부여한 이름 때문에 일어납니다. 사용자는  lan0 또는 wireless0 처럼 자유로운 이름을 사용하거나 (udev 197 버전부터 기본값으로 활성화한) 유추 가능 인터페이스 이름을 사용하도록 {{Path|/etc/udev/rules.d/70-my-network.rules}}와 같은 개별 설정 규칙 파일을 작성해야 합니다.

또한 이전 버전의 udev에 있던 오래된 파일의 제거를 잊지 마십시오.

{{RootCmd|rm /etc/udev/rules.d/70-persistent-net.rules}}

== 추가 참조 ==

[[Eudev|eudev]] - 젠투에서 관리하는 udev 포크 버전.


[[Category:Core system]]
[[Category:Daemons]]
