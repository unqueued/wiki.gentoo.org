<languages />
{{Metadata|abstract=udev는 리눅스 커널의 장치 관리자입니다. /dev의 장치 노드를 관리하며, 장치를 추가/제거할 때 모든 사용자 영역 동작을 관리합니다.}}

{{InfoBox stack
|{{InfoBox homepage|http://www.freedesktop.org/wiki/Software/systemd/|header=true}}
|{{InfoBox gdoc|Udev}}
|{{InfoBox wikipedia}}
|{{InfoBox gitweb|http://cgit.freedesktop.org/systemd/systemd/tree/src/udev|raw=true}}
}}

'''udev'''는 리눅스 커널용 장치 관리자입니다. {{Path|/dev}}의 장치 노드를 관리하며 장치를 추가하고 제거할 때 모든 사용자 공간 처리 동작을 관리합니다. 이 글의 독자 여러분은 udev의 포크 버전인 [[Eudev | eudev]]도 살펴보셔야 합니다.

== udev란 무엇인가요? ==

=== /dev 디렉터리 ===

When Linux users talk about the hardware on their system in the vicinity of people who believe Linux is some sort of virus or brand of coffee, the use of "slash dev slash foo" will return strange looks for sure. But for the fortunate user (and that includes the reader of this article) using {{Path|/dev/sda1}} is just a fast way of referring to the primary master SATA, first partition. That's pretty easy, right? 

Most Linux users know what a [[device file]] is. Some even know why device files have special numbers. Take a close look at device list when {{c|ls -l}} is issued in the {{Path|/dev}} folder. What users take for granted is that the primary SATA disk is referred to as {{Path|/dev/sda}} Some users might not see it this way, but this is a flaw by design. 

Think about hotpluggable devices like USB, IEEE1394, hot-swappable PCI, etc. What is the first device? And for how long? What will the other devices be named when the first one disappears? How will that affect ongoing transactions? Wouldn't it be fun that a printing job is suddenly moved from a super-new laser printer to an almost-dead matrix printer because someone's mom decided to pull the plug of the laser printer which just so ''happened'' to be the first printer? 

Enter {{c|udev}}. The goals of the udev project are both interesting and needed. Udev:

* Runs in userspace;
* Dynamically creates and removes device files;
* Provides consistent naming;
* Provides a userspace application program interface (API).

Every time a change happens within the device structure, the kernel emits a ''uevent'' which gets picked up by {{c|udev}}. {{c|udev}} then follows the rules as declared in the {{Path|/etc/udev/rules.d}}, {{Path|/run/udev/rules.d}} and {{Path|/lib/udev/rules.d}} directories. Based on the information contained within the uevent, it finds the rule or rules it needs to trigger and performs the required actions. These actions can be creating or deleting device files, but can also trigger the loading of particular firmware files into kernel memory.

== 설치 ==

{{Important|When updating udev, check the [[Udev/Upgrade Guide|udev upgrade guide]] for information that can prevent unbootable systems.}}

=== 커널 ===

{{c|udev}} 에서는 다음 커널 옵션이 필요합니다:

<!-- See http://git.kernel.org/?p=linux/hotplug/udev.git;a=blob_plain;f=README -->
{{KernelBox|1=
General setup  --->
    [*] Configure standard kernel features (expert users)  --->
        [ ] Enable deprecated sysfs features to support old userspace tools
        [*] Enable signalfd() system call
Enable the block layer  --->
    [*] Block layer SG support v4
Networking support  --->
    Networking options  --->
        <*> Unix domain sockets
Device Drivers  --->
    Generic Driver Options  --->
        ()  path to uevent helper
        [*] Maintain a devtmpfs filesystem to mount at /dev
    < > ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
File systems  --->
    [*] Inotify support for userspace
    Pseudo filesystems --->
        [*] /proc file system support
        [*] sysfs file system support
}}

=== USE 플래그 ===

Portage knows the <code>udev</code> global USE flag for enabling support for udev in other packages. Adding this USE flag value to the USE flag list (default in all Linux [[Profile (Portage)|profiles]]) will pull in the {{Package|sys-fs/udev}} package automatically:

{{FileBox|filename=/etc/portage/make.conf|lang=bash|1=
USE="udev"
}}

{{USEflag|package=sys-fs/udev}}

=== Emerge ===

USE 변수를 설정한 후, 시스템을 업데이트하여 바뀐 설정을 적용하십시오:

{{Emerge|params+=--changed-use --deep|@world}}

== 설정 ==

=== 서비스 ===

부팅 시간에 udev를 시작하려면 sysinit 럴레벨에 추가하십시오. 다음 명령을 루트 권한으로 실행하면 처리할 수 있습니다:

{{RootCmd|rc-update add udev sysinit}}

== 고급 설정 ==

=== 규칙 ===

udev provides a set of rules that match against exported values of uevents (events sent by the kernel) and properties of the discovered device. A matching rule will possibly name and create a device node and run configured programs to setup and configure the device.

정의 규칙은 다음 두군데에 저장합니다:

# '''{{Path|/lib/udev/rules.d/}}''' - Rules in this directory are installed by certain packages, they generally should not be changed by users;
# '''{{Path|/etc/udev/rules.d/}}''' - This folder is for end-user specified rules. Any new rules should be added in this directory;

In these directories, multiple rule files (with suffix {{Path|.rules}}) are traversed in alphanumerical order. Inside the rules files, udev will find expressions that might match a uevent together with the state to match (is the uevent because a device is added or removed) and the command to execute.

이벤트 비교는 다음과 같은 정보를 기반으로 합니다:

* uevent ''SUBSYSTEM'' (uevent의 어떤 형식의 장치를 실행했는가)
* 취한 ''ACTION'' (추가, 변경, 제거)
* 장치 클래스, 제조사, 다른 장치 정보 등의 하나 이상의 속성(''ATTR'' 또는 ''ATTRS'')
* sd* (SCSI/SATA 디스크) 또는 input* (마우스, 키보드 같은 입력 장치)과 같은 커널 제공 이름 (''KERNEL''), 
* 여러 규칙에 정보를 보낼 때 활용할 하나 이상의 환경 변수 설정(''ENV'')

이 정보를 기반으로 다음의 조건에 따라, 규칙을 세울 수 있습니다:

# 일부 정보는 (환경 변수로)최종 이벤트와 공유해야 합니다
# {{Path|/dev}}에 링크를 만들어야 합니다
# 명령을 실행해야 합니다

Udev does this for every rule that matches (it does not stop after the first match) to allow a flexible device management approach.

=== 영속 장치 이름 ===

The kernel detects devices asynchronously, udev mirrors the kernel's [[sysfs]] filesystem and so the devices are named and numbered in order of detection. So by default udev provides no persistent device names. However there are mechanisms for some device classes to provide these:

* Udev creates for storage devices additional symlinks based on the device's ID, [[Removable_media#UUIDs_and_labels|label, UUID]] and path. See the {{Path|/dev/disk/by-*}} directory. So instead of using e.g. the device file {{Path|/dev/sda}} use the file {{Path|/dev/disk/by-label/SOME_LABEL}}.

* {{Path|/dev/input}} 디렉터리의 입력 장치는 동일합니다.

* 사용자 규칙을 활용은 사용자로 하여금 자체 장치 파일을 만들 수 있습니다.

== 사용법 ==

몇가지 쓸모있는 명령이 있습니다.

* 주어진 장치에 대한 모든 메시지를 보여줍니다;
: {{RootCmd|udevadm info --query{{=}}all --name{{=}}/dev/DEVICE_FILE}}

* udev 활동을 감시합니다:
: {{RootCmd|udevadm monitor}}

더 많은 정보는 ''udevadm'' [[man page|맨 페이지]]<sup style="color:#ff0077">en</sup>를 참고하십시오

== 문제 해결 ==

* {{Bug|udev|search=package}}

=== 감시 메시지 기록 ===

{{c|udevadm monitor}}를 실행할 때 모든 메시지를 기록하려면 다음 설정 파일을 수정하십시오:

{{FileBox|filename=/etc/conf.d/udev|lang=bash|1=
udev_monitor="YES"
}}

{{Path|/run/udev/udevmonitor.log}}에 새 로그 파일을 만듭니다

=== 디버깅 모드 ===

디버깅 모드를 활성화하면 더 많은 기록 메시지를 출력합니다:

{{FileBox|filename=/etc/conf.d/udev|lang=bash|1=
udev_debug="YES"
}}

기록 우선순위를 설정하십시오:

{{FileBox|filename=/etc/udev/udev.conf|lang=bash|1=
udev_log="debug"
}}

{{Path|/run/udevdebug.log}} 기록 파일을 만들겠지만 어떤 메시지도 기록하지 않습니다. 최근의 udev 버전에서는 {{c|dmesg}}에 모든 메시지를 기록합니다.

=== {{Path|/dev/null}} 과 {{Path|/dev/console}} 장치가 빠졌다고 합니다 ===

일부 udev 버전에서는 udev가 제대로 동작하려면 {{Path|/dev/null}}과 {{Path|/dev/console}}이 필요합니다. 그러나 자체적으로 만들 수는 없습니다. 이 파일을 직접 만들려면 루트 권한으로 다음 명령을 실행하십시오:

{{RootCmd
|mkdir test
|mount --bind / test
|cd test/dev
|mknod -m 660 console c 5 1
|mknod -m 660 null c 1 3
|cd ../..
|umount test
|rmdir test
}}

===  NIC에 eth0을 할당했는데 eth1으로 바뀌네요 ===

Those having dual network cards on their motherboards may run into a situation where {{c|ifconfig}} may show no eth0 or eth1. {{c|dmesg}} may show their NIC detected as eth0, and later moved to eth1. Performing a {{c|ifconfig -a}} will also show the NIC as eth1. This is caused by using the kernel assigned names in the first place. Users should write custom rules like {{Path|/etc/udev/rules.d/70-my-network.rules}} to use free names like lan0 or wireless0 or use predictable interface names (which have been enabled by default since udev version 197).

또한 이전 버전의 udev에 있던 오래된 파일의 제거를 잊지 마십시오.

{{RootCmd|rm /etc/udev/rules.d/70-persistent-net.rules}}

== 추가 참조 ==

[[Eudev|eudev]] - 젠투에서 관리하는 udev 포크 버전.


[[Category:Core system]]
[[Category:Daemons]]
