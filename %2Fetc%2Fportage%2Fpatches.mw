User patches provides users with an integrated method of applying site-specific patches.
This is often preferable to forking the ebuild in a local overlay, since the latter will require ongoing maintenance to keep up with the Gentoo tree.

To apply user patches to an ebuild that supports them, save the patch in {{Path|1=/etc/portage/patches/$CATEGORY/$PN/}} (for example {{Path|1=/etc/portage/patches/app-emulation/wine/}}.
Note that the patch file's name <i>must</i> end with in <code>.patch</code>.
A few other folders will also be checked for user patches, see the snippet from {{Path|1=eclass/eutils.eclass}} below for full details.

== <code>epatch_user</code> ==

User patches is not a feature provided by the package manager directly, but is implemented by calling the <code>epatch_user</code> function (from {{Path|1=eutils.eclass}}) in many individual ebuilds, often through eclass-defined <code>src_prepare</code> functions.
This has the advantage of letting the maintainer of a package determine the most appropriate place for applying user patches, for example prior to calling <code>eautoreconf</code>.
Current Gentoo policy does not require ebuilds to use <code>epatch_user</code>, its usage is at the package maintainer's discretion.

Different ebuilds and eclasses have their own conventions, for example, {{Path|1=qt4-build.eclass}} calls <code>epatch_user</code> after applying other patches in the eclass' <code>src_prepare</code>.
<code>epatch_user</code> can be called multiple times without causing issues, it creates a file {{Path|1=${T}/epatch_user.log}} and exits early if this file already exists.

{{File|1=eclass/eutils.eclass|2=epatch_user documentation and code as of 2014-06-02|3=<nowiki>
# @FUNCTION: epatch_user
# @USAGE:
# @DESCRIPTION:
# Applies user-provided patches to the source tree. The patches are
# taken from /etc/portage/patches/<CATEGORY>/<P-PR|P|PN>[:SLOT]/, where the first
# of these three directories to exist will be the one to use, ignoring
# any more general directories which might exist as well. They must end
# in ".patch" to be applied.
#
# User patches are intended for quick testing of patches without ebuild
# modifications, as well as for permanent customizations a user might
# desire. Obviously, there can be no official support for arbitrarily
# patched ebuilds. So whenever a build log in a bug report mentions that
# user patches were applied, the user should be asked to reproduce the
# problem without these.
#
# Not all ebuilds do call this function, so placing patches in the
# stated directory might or might not work, depending on the package and
# the eclasses it inherits and uses. It is safe to call the function
# repeatedly, so it is always possible to add a call at the ebuild
# level. The first call is the time when the patches will be
# applied.
#
# Ideally, this function should be called after gentoo-specific patches
# have been applied, so that their code can be modified as well, but
# before calls to e.g. eautoreconf, as the user patches might affect
# autotool input files as well.
epatch_user() {
    [[ $# -ne 0 ]] && die "epatch_user takes no options"

    # Allow multiple calls to this function; ignore all but the first
    local applied="${T}/epatch_user.log"
    [[ -e ${applied} ]] && return 2

    # don't clobber any EPATCH vars that the parent might want
    local EPATCH_SOURCE check base=${PORTAGE_CONFIGROOT%/}/etc/portage/patches
    for check in ${CATEGORY}/{${P}-${PR},${P},${PN}}{,:${SLOT}}; do
        EPATCH_SOURCE=${base}/${CTARGET}/${check}
        [[ -r ${EPATCH_SOURCE} ]] || EPATCH_SOURCE=${base}/${CHOST}/${check}
        [[ -r ${EPATCH_SOURCE} ]] || EPATCH_SOURCE=${base}/${check}
        if [[ -d ${EPATCH_SOURCE} ]] ; then
            EPATCH_SOURCE=${EPATCH_SOURCE} \
            EPATCH_SUFFIX="patch" \
            EPATCH_FORCE="yes" \
            EPATCH_MULTI_MSG="Applying user patches from ${EPATCH_SOURCE} ..." \
            epatch
            echo "${EPATCH_SOURCE}" > "${applied}"
            return 0
        fi
    done
    echo "none" > "${applied}"
    return 1
}</nowiki>}}

== Calling <code>epatch_user</code> with a hook in Portage's bashrc ==

If an ebuild does not call <code>epatch_user</code>, and you still wish to apply user patches; this can be accomplished using bashrc hooks provided by Portage, provided the ebuild inherits {{Path|1=eutils.eclass}}.

Typically, one might use the <code>post_src_unpack</code> or <code>post_src_prepare</code> hooks.
However, the latter is run <i>after</i> the ebuild's <code>src_prepare</code> phase, which causes issues if for example <code>eautoreconf</code> should be run after patches are applied.

{{file|1=/etc/portage/bashrc|2=Example use of <code>epatch_user</code> in post_src_unpack hook|3=<nowiki>
post_src_unpack() {
    if [[ $(type -t epatch_user) == function ]]; then
        if pushd -- "$S" 2>&3; then
            epatch_user
            popd 2>&3
        else
            epatch_user
        fi 3>/dev/null
    fi
}</nowiki>}}

== See Also ==
* [http://www.funtoo.org/Localpatch_%28Tutorial%29 Localpatch tutorial] (from Funtoo wiki)
* [http://dilfridge.blogspot.com/2012/04/neat-trick-for-testing-patches-in.html A neat trick for testing patches in Gentoo] (from dilfridge's blog)
* [[:/etc/portage/env|/etc/portage/env/**]] and [[:/etc/portage/bashrc]] can be used to define hooks which either call epatch_user or epatch directly

[[Category:Portage]]
