{{InfoBox stack
|{{InfoBox gitweb|https://gitweb.gentoo.org/repo/gentoo.git/log/eclass/eutils.eclass|raw=true|header=true}}
}}

User patches provide a way for users to apply patches to ebuilds. This is useful for the rare cases of site-specific patches, but also for testing patches before sending them to upstream or to the Gentoo bug tracker. The feature is provided by many ebuilds prior to EAPI=6, either by calling <code>epatch_user</code> explicitly or by inheriting an eclass and relying on its default implementation of <code>src_prepare</code>.  Starting with EAPI=6, <code>eapply_user</code>, the EAPI=6 replacement for <code>epatch_user</code>, is required in all <code>src_prepare</code> phases. Current Gentoo policy does not require ebuilds to use <code>epatch_user</code> in EAPIs before EAPI=6, its usage is at the package maintainer's discretion. But there is also a way to enable it for all ebuilds that don't explicitly allow user patching.

== Enabling /etc/portage/patches for all ebuilds ==

If an ebuild does not call <code>epatch_user</code>, but user patches are still needed to be applied, it is possible to use [[_/etc/portage/bashrc|/etc/portage/bashrc]] and hooks provided by [[Portage]]. Candidates are <code>post_src_unpack</code>, <code>pre_src_prepare</code> or <code>post_src_prepare</code>. The first two have the advantage of being run before <code>eautoreconf</code> (or similar) and the last two have the advantage of being run in the right directory, so only <code>pre_src_prepare</code> shares those advantages.

Normally only ebuilds inheriting <code>eutils</code> can access <code>epatch_user</code>, so one would need to test for its presence and non-eutils ebuilds would not get patched at all. There is a trick of pulling in only the necessary bits from {{Path|eutils.eclass}}, running <code>epatch_user</code> and dropping them.

With <code>pre_src_prepare</code> and the above trick, changing directories do not need to be played with, all ebuilds can be supported whether they import <code>eutils</code> or not, and the patches will applied as soon as possible in the chain. While it might still be better to have this feature as part of Portage, the following snippet should cover everyday needs pretty well.

{{FileBox|filename=/etc/portage/bashrc|lang=bash|1=
pre_src_prepare() {
    [[ ${EAPI:-0} {{=}}{{=}} [012345] ]] {{!}}{{!}} return
    if ! type epatch_user > /dev/null 2>&1; then
        local names="EPATCH_USER_SOURCE epatch_user epatch evar_push evar_push_set evar_pop estack_push estack_pop"
        source <(awk "/^# @(FUNCTION{{!}}VARIABLE): / { p {{=}} 0 } /^# @(FUNCTION{{!}}VARIABLE): (${names// /{{!}}})\$/ { p {{=}} 1 } p { print }" ${PORTDIR}/eclass/eutils.eclass)
    fi

    epatch_user

    for name in $names; do
        unset $name
    done
}
}}

== Adding user patches ==

First choose the location for the patches, depending on the package name and the version(s) it is intended for. Use the following locations and optionally append <code>:${SLOT}</code> to any of them:

* {{Path|/etc/portage/patches/${CATEGORY}/${P} }}
* {{Path|/etc/portage/patches/${CATEGORY}/${PN} }}
* {{Path|/etc/portage/patches/${CATEGORY}/${P}-${PR} }}

Examples:

* {{Path|/etc/portage/patches/dev-lang/python}}
* {{Path|/etc/portage/patches/dev-lang/python:3.4}}
* {{Path|/etc/portage/patches/dev-lang/python-3.4.2}}
* {{Path|/etc/portage/patches/dev-lang/python-3.3.5-r1}}

The next example shows a very simple patch for {{bug|593604}} of {{package|sys-fs/udev-init-scripts}}. 

The package that needs a patch will be unpacked using the {{c|ebuild}} command:

{{Cmd|ebuild $(portageq get_repo_path / gentoo)/sys-fs/udev-init-scripts/udev-init-scripts-27.ebuild unpack|output=<pre>
 * udev-init-scripts-27.tar.bz2 SHA256 SHA512 WHIRLPOOL size ;-) ...                                                                              [ ok ]
 * checking ebuild checksums ;-) ...                                                                                                              [ ok ]
 * checking miscfile checksums ;-) ...                                                                                                            [ ok ]
>>> Unpacking source...
>>> Unpacking udev-init-scripts-27.tar.bz2 to /var/tmp/portage/sys-fs/udev-init-scripts-27/work
>>> Source unpacked in /var/tmp/portage/sys-fs/udev-init-scripts-27/work
</pre>}}

Any {{c|diff}} for the user patch needs to refer to the just created directory, so cd into it:

{{Cmd|cd /var/tmp/portage/sys-fs/udev-init-scripts-27/work/
|tree|output=<pre>
└── udev-init-scripts-27
    ├── Makefile
    ├── README
    ├── conf.d
    │   └── udev
    └── init.d
        └── udev
</pre>}}

Say {{path|init.d/udev}} were the file to be changed. So it should be copied to {{path|/tmp}} (or somwere else):

{{Cmd|cp init.d/udev /tmp/}}

After having modified the copy, check the {{c|diff}}:

{{Cmd|cd /var/tmp/portage/sys-fs/udev-init-scripts-27/work/
|diff -u init.d/udev /tmp/udev|output=<pre>
--- udev-init-scripts-27/init.d/udev 2014-08-08 18:14:52.000000000 +0200
+++ /tmp/udev   2016-11-25 14:08:05.000000000 +0100
@@ -1,4 +1,4 @@
-#!/sbin/runscript
+#!/sbin/openrc-run
 # Copyright 1999-2013 Gentoo Foundation
 # Distributed under the terms of the GNU General Public License v2
</pre>}}

Of course, still the directory for the patch needs to be created:

{{RootCmd|mkdir -p /etc/portage/patches/sys-fs/udev-init-scripts-27}}

Now the directory is ready drop in the patches. Only files with {{Path|.patch}} suffix are considered and they are applied in the order determined by their name.

Repeat the {{c|diff}} and create the patch file:

{{RootCmd|cd /var/tmp/portage/sys-fs/udev-init-scripts-27/work/
|diff -u init.d/udev /tmp/udev > /etc/portage/patches/sys-fs/udev-init-scripts-27/somefunnyname.patch}}

{{FileBox|filename=/etc/portage/patches/sys-fs/udev-init-scripts-27/somefunnyname.patch|lang=diff|1=
--- udev-init-scripts-27/init.d/udev 2014-08-08 18:14:52.000000000 +0200
+++ /tmp/udev   2016-11-25 14:08:05.000000000 +0100
@@ -1,4 +1,4 @@
-#!/sbin/runscript
+#!/sbin/openrc-run
 # Copyright 1999-2013 Gentoo Foundation
 # Distributed under the terms of the GNU General Public License v2
}}

It is imporant that the first line of the {{path|.patch}} file refers to the [https://devmanual.gentoo.org/ebuild-writing/variables/ S directory] created by unpacking.

Note that <code>epatch_user</code> attempts to apply them repeatedly with a prefix stripped up to a different number of slashes.

== Using a git directory as a source of patches ==

Instead of creating the directory, a symlink can be created to a git directory on the system.

{{RootCmd|mkdir -p /etc/portage/patches/sys-libs && ln -s /home/user/projects/glibc /etc/portage/patches/sys-libs/glibc}}

{{Note| When using <code>userpriv</code> as a <var>FEATURES</var> value in Portage (eg. in {{Path|/etc/portage/make.conf}}), Portage drops root privileges to <code>portage:portage</code> which means that the folder that the symlink points to must be accessible by the user or group ''portage'' otherwise the patches will be silently ignored and not applied (file {{Path|epatch_user.log}} contains the string ''none''); 
ie. in this case, all the folders of {{Path|/home/user/projects/glibc}} are already accessible due to <code>o+rx</code> permissions but in the case of root and using this path {{Path|/root/projects/glibc}} then {{Path|/root}}, unlike {{Path|/home}}, is inaccessible due to <code>u+rx</code> permissions...}}

Now, in the git directory, perform the usual work. After finishing remove all patches from the previous run and use <tt>git format-patch</tt> to create a patchset from the branch based on another known branch.

{{Cmd|rm -f *.patch && git format-patch origin/master}}

This solution relies on the fact that only files ending with {{Path|.patch}} are processed in the patch directory.

== Adding support for user patches to ebuilds ==

It is up to the maintainer of the ebuild to decide when exactly <code>epatch_user</code> is called. It would typically be in <code>src_prepare</code> together with patches specified in the ebuild itself and the build system actions like <code>eautoreconf</code>. To best accommodate user patches that would later be suitable for submitting upstream, it should be the very first action. Note that without changing the ebuild, the user can only force it to be called earlier, not later.

As a maintainer, often <code>epatch_user</code> is provided for free by inheriting an eclass. Then it can either be forced to run earlier or the eclass can be relied upon to do the work. For example, {{Path|qt4-build.eclass}} calls <code>epatch_user</code> after applying other patches in its implementation of <code>src_prepare</code>.

When the ebuild ends up calling <code>epatch_user</code> multiple times (e.g. because the maintainer called it explicitly but also used an eclass that calls it), the first call creates {{Path|${T}/epatch_user.log}} and subsequent calls have no effect.

In EAPI=6, the default src_prepare calls <code>eapply_user</code>, and all src_prepare phases written by a maintainer must call <code>eapply_user</code>, either directly, through calling <code>default</code>, or by inheriting and using the <code>src_prepare</code> phase of an EAPI=6 compatible eclass.

== See also ==

* [[Handbook:AMD64/Portage/Advanced#Using_epatch_user|Using epatch_user (AMD64 Handbook)]]

== External resources ==

* [https://gitweb.gentoo.org/repo/gentoo.git/commit/eclass/eutils.eclass?id=324c60a90afb8c34ba05b5b4f5814ce72e835c48 eutils.eclass: Disable epatch_user in EAPI 6.] - EAPI 6 has eapply_user which should be used instead. 
* [https://blogs.gentoo.org/mgorny/2015/11/13/the-ultimate-guide-to-eapi-6/ The Ultimate Guide to EAPI 6]
* [https://devmanual.gentoo.org/ebuild-writing/functions/src_prepare/epatch Patching with epatch] - Patching within ebuilds, from devmanual.gentoo.org

[[Category:Portage]]
