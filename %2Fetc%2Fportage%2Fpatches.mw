User patches provides users with an integrated method of applying site-specific patches.
This is often preferable to forking the ebuild in a local overlay, since the latter will require ongoing maintenance to keep up with the Gentoo tree.

To apply user patches to an ebuild that supports them, save the patch in {{Path|1=/etc/portage/patches/$CATEGORY/$PN/}} (for example {{Path|1=/etc/portage/patches/app-emulation/wine/}}.
Note that the patch file's name <i>must</i> end with in <code>.patch</code>.
A few other folders will also be checked for user patches, see the snippet from {{Path|1=eclass/eutils.eclass}} below for full details.

== <code>epatch_user</code> ==

User patches is not a feature provided by the package manager directly, but is implemented by calling the <code>epatch_user</code> function (from {{Path|1=eutils.eclass}}) in many individual ebuilds, often through eclass-defined <code>src_prepare</code> functions.
This has the advantage of letting the maintainer of a package determine the most appropriate place for applying user patches, for example prior to calling <code>eautoreconf</code>.
Current Gentoo policy does not require ebuilds to use <code>epatch_user</code>, its usage is at the package maintainer's discretion.

Different ebuilds and eclasses have their own conventions, for example, {{Path|1=qt4-build.eclass}} calls <code>epatch_user</code> after applying other patches in the eclass' <code>src_prepare</code>.
<code>epatch_user</code> can be called multiple times without causing issues, it creates a file {{Path|1=${T}/epatch_user.log}} and exits early if this file already exists.

{{File|1=eclass/eutils.eclass|2=epatch_user documentation and code as of 2014-06-02|3=<nowiki>
# @FUNCTION: epatch_user
# @USAGE:
# @DESCRIPTION:
# Applies user-provided patches to the source tree. The patches are
# taken from /etc/portage/patches/<CATEGORY>/<P-PR|P|PN>[:SLOT]/, where the first
# of these three directories to exist will be the one to use, ignoring
# any more general directories which might exist as well. They must end
# in ".patch" to be applied.
#
# User patches are intended for quick testing of patches without ebuild
# modifications, as well as for permanent customizations a user might
# desire. Obviously, there can be no official support for arbitrarily
# patched ebuilds. So whenever a build log in a bug report mentions that
# user patches were applied, the user should be asked to reproduce the
# problem without these.
#
# Not all ebuilds do call this function, so placing patches in the
# stated directory might or might not work, depending on the package and
# the eclasses it inherits and uses. It is safe to call the function
# repeatedly, so it is always possible to add a call at the ebuild
# level. The first call is the time when the patches will be
# applied.
#
# Ideally, this function should be called after gentoo-specific patches
# have been applied, so that their code can be modified as well, but
# before calls to e.g. eautoreconf, as the user patches might affect
# autotool input files as well.
epatch_user() {
    [[ $# -ne 0 ]] && die "epatch_user takes no options"

    # Allow multiple calls to this function; ignore all but the first
    local applied="${T}/epatch_user.log"
    [[ -e ${applied} ]] && return 2

    # don't clobber any EPATCH vars that the parent might want
    local EPATCH_SOURCE check base=${PORTAGE_CONFIGROOT%/}/etc/portage/patches
    for check in ${CATEGORY}/{${P}-${PR},${P},${PN}}{,:${SLOT}}; do
        EPATCH_SOURCE=${base}/${CTARGET}/${check}
        [[ -r ${EPATCH_SOURCE} ]] || EPATCH_SOURCE=${base}/${CHOST}/${check}
        [[ -r ${EPATCH_SOURCE} ]] || EPATCH_SOURCE=${base}/${check}
        if [[ -d ${EPATCH_SOURCE} ]] ; then
            EPATCH_SOURCE=${EPATCH_SOURCE} \
            EPATCH_SUFFIX="patch" \
            EPATCH_FORCE="yes" \
            EPATCH_MULTI_MSG="Applying user patches from ${EPATCH_SOURCE} ..." \
            epatch
            echo "${EPATCH_SOURCE}" > "${applied}"
            return 0
        fi
    done
    echo "none" > "${applied}"
    return 1
}</nowiki>}}

== Calling <code>epatch_user</code> with a hook in Portage's bashrc ==

If an ebuild does not call <code>epatch_user</code>, and you still wish to apply user patches; this can be accomplished using bashrc hooks provided by Portage. Candidates are <code>post_src_unpack</code>, <code>pre_src_prepare</code> or <code>post_src_prepare</code>. The first two have the advantage of being run before
any <code>eautoreconf</code> and the last two have the advantage of being run in the right directory, so only <code>pre_src_prepare</code> shares those advantages.

Normally only ebuilds inheriting <code>eutils</code> can access <code>epatch_user</code>, so you would need to test for its presence and non-eutils ebuilds wouldn't get patched at all. There's a trick of pulling in only the necessary bits from <code>eutils.eclass</code>, running <code>epatch_user</code> and dropping them.

With <code>pre_src_prepare</code> and the above trick, you don't need to play with changing directories, you can support all ebuilds whether they import <code>eutils</code> or not, and you get your patches applied as soon as possible in the chain. While it might still be better to have this feature as
part of portage, the following snippet should cover everyday needs pretty well.

{{File|/etc/portage/bashrc||<pre>
pre_src_prepare() {
    if ! type epatch_user > /dev/null 2>&1; then
        local names="epatch_user epatch evar_push evar_push_set evar_pop estack_push estack_pop"
        source <(awk "/^# @FUNCTION: / { p = 0 } /^# @FUNCTION: (${names// /|})\$/ { p = 1; } p { print  }" /usr/portage/eclass/eutils.eclass)
    fi

    epatch_user || die

    for name in $names; do
        unset $name
    done
}
</pre>}}

== See Also ==
* [http://www.funtoo.org/Localpatch_%28Tutorial%29 Localpatch tutorial] (from Funtoo wiki)
* [http://dilfridge.blogspot.com/2012/04/neat-trick-for-testing-patches-in.html A neat trick for testing patches in Gentoo] (from dilfridge's blog)
* [[:/etc/portage/env|/etc/portage/env/**]] and [[:/etc/portage/bashrc]] can be used to define hooks which either call epatch_user or epatch directly

[[Category:Portage]]
