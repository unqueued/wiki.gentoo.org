User patches provide a way for users to apply patches to ebuilds. This is useful for the rare cases of site-specific patches, but also for testing patches before sending them to upstream or to the Gentoo bug tracker. The feature is provided by many ebuilds, either by calling <code>epatch_user</code> explicitly or by inheriting an eclass and relying on its default implementation of <code>src_prepare</code>. Current Gentoo policy does not require ebuilds to use <code>epatch_user</code>, its usage is at the package maintainer's discretion. But there is also a way to enable it for all ebuilds.

== Enabling /etc/portage/patches for all ebuilds ==

If an ebuild does not call <code>epatch_user</code>, but user patches are still needed to be applied, it is possible to use [[_/etc/portage/bashrc|/etc/portage/bashrc]] and hooks provided by [[Portage]]. Candidates are <code>post_src_unpack</code>, <code>pre_src_prepare</code> or <code>post_src_prepare</code>. The first two have the advantage of being run before <code>eautoreconf</code> (or similar) and the last two have the advantage of being run in the right directory, so only <code>pre_src_prepare</code> shares those advantages.

Normally only ebuilds inheriting <code>eutils</code> can access <code>epatch_user</code>, so one would need to test for its presence and non-eutils ebuilds would not get patched at all. There is a trick of pulling in only the necessary bits from <code>eutils.eclass</code>, running <code>epatch_user</code> and dropping them.

With <code>pre_src_prepare</code> and the above trick, changing directories do not need to be played with, all ebuilds can be supported whether they import <code>eutils</code> or not, and the patches will applied as soon as possible in the chain. While it might still be better to have this feature as part of Portage, the following snippet should cover everyday needs pretty well.

{{FileBox|filename=/etc/portage/bashrc|1=<nowiki>
pre_src_prepare() {
    if ! type epatch_user > /dev/null 2>&1; then
        local names="epatch_user epatch evar_push evar_push_set evar_pop estack_push estack_pop"
        source <(awk "/^# @FUNCTION: / { p = 0 } /^# @FUNCTION: (${names// /|})\$/ { p = 1; } p { print  }" /usr/portage/eclass/eutils.eclass)
    fi

    epatch_user

    for name in $names; do
        unset $name
    done
}</nowiki>
}}

Note: While so far it was safe to attempt to apply patches several times (subsequent times would be ignored), there are rumours that EAPI6 will break the above workflow!

== Adding user patches ==

First choose the location for the patches, depending on the package name and the version(s) it is intended for. Use the following locations and optionally append <code>:${SLOT}</code> to any of them:

* {{Path|/etc/portage/patches/${CATEGORY}/${P} }}
* {{Path|/etc/portage/patches/${CATEGORY}/${PN} }}
* {{Path|/etc/portage/patches/${CATEGORY}/${P}-${PR} }}

Examples:

* {{Path|/etc/portage/patches/dev-lang/python}}
* {{Path|/etc/portage/patches/dev-lang/python:3.4}}
* {{Path|/etc/portage/patches/dev-lang/python-3.4.2}}
* {{Path|/etc/portage/patches/dev-lang/python-3.3.5-r1}}

Create the directory:

{{RootCmd|mkdir -p /etc/portage/patches/dev-lang/python-3.3.5-r1}}

Now that the directory is ready drop in the patches. Only files with {{Path|.patch}} suffix are considered and they are applied in the order determined by their name.

An example of using this method is given in the [[Dwm#Patches_in_.2Fetc.2Fportage.2Fpatches.2Fcategory.2Fapplication|dwm]] article.

Note that <code>epatch_user</code> attempts to apply them repeatedly with a prefix stripped up to a different number of slashes.

== Using a git directory as a source of patches ==

Instead of creating the directory, a symlink can be created to a git directory on the system.

{{RootCmd|mkdir -p /etc/portage/patches/sys-libs && ln -s /home/user/projects/glibc /etc/portage/patches/sys-libs/glibc}}

{{Note| When using <code>userpriv</code> as a <var>FEATURES</var> value in Portage (eg. in {{Path|/etc/portage/make.conf}}), Portage drops root privileges to <code>portage:portage</code> which means that the folder that the symlink points to must be accessible by the user or group ''portage'' otherwise the patches will be silently ignored and not applied (file {{Path|epatch_user.log}} contains the string ''none''); 
ie. in this case, all the folders of {{Path|/home/user/projects/glibc}} are already accessible due to <code>o+rx</code> permissions but in the case of root and using this path {{Path|/root/projects/glibc}} then {{Path|/root}}, unlike {{Path|/home}}, is inaccessible due to <code>u+rx</code> permissions...}}

Now, in the git directory, perform the usual work. After finishing remove all patches from the previous run and use <tt>git format-patch</tt> to create a patchset from the branch based on another known branch.

{{Cmd|rm -f *.patch && git format-patch origin/master}}

This solution relies on the fact that only files ending with {{Path|.patch}} are processed in the patch directory.

== Adding support for user patches to ebuilds ==

It is up to the maintainer of the ebuild to decide when exactly <code>epatch_user</code> is called. It would typically be in <code>src_prepare</code> together with patches specified in the ebuild itself and the build system actions like <code>eautoreconf</code>. To best accommodate user patches that would later be suitable for submitting upstream, it should be the very first action. Note that without changing the ebuild, the user can only force it to be called earlier, not later.

As a maintainer, often <code>epatch_user</code> is provided for free by inheriting an eclass. Then it can either be forced to run earlier or the eclass can be relied upon to do the work. For example, <code>qt4-build.eclass</code> calls <code>epatch_user</code> after applying other patches in its implementation of <code>src_prepare</code>.

When the ebuild ends up calling <code>epatch_user</code> multiple times (e.g. because the maintainer called it explicitly but also used an eclass that calls it), the first call creates {{Path|${T}/epatch_user.log}} and subsequent calls have no effect.

== See also ==

* [[Handbook:Parts/Portage/Advanced#Using_epatch_user]]
