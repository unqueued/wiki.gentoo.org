<languages />


Все больше и больше систем требуют initramfs для правильной загрузки. В этом руководстве мы займемся рассмотрением основных понятий initramfs, в том числе и того, как должным образом создать и управлять initramfs на отдельных примерах.

== Основные понятия initramfs ==

=== Введение ===

Для большинства пользователей initramfs не является чем то необходимым. Их система использует простую схему разбиения жесткого диска без эзотических драйверов или установок (таких как зашифрованные файловые системы), поэтому ядро Linux вполне способно передать управление двоичному файлу <code>init</code> на их системе. Но для большинства систем, использование initramfs обязательно. 

Основной ключ к пониманию того, чем является initramfs (или для чего она необходима) - это понимание того, как работает процесс загрузки Linux, даже в достаточно высокоуровневом подходе. 

=== Процесс загрузки Linux ===

Как только ядро Linux получает контроль над системой (который был передан ему после загрузки загрузчиком), оно подготавливает свои области памяти и драйвера настолько, насколько способно. Затем оно передает управление приложению (обычно файлу <code>init</code>), чьей задачей является дальнейшая подготовка системы и проверка того, что в конце процесса загрузки, все необходимые сервисы запущены и пользователь способен войти в систему. Приложение <code>init</code> делает это с помощью запуска, в числе прочих сервисов, демона <code>udev</code>, который далее загружает и подготавливает систему, основываясь на обнаруженных устройствах. Когда <code>udev</code> запущен, все оставшиеся файловые системы, которые не были примонтированы, монтируются, и запускаются остальные сервисы. 

Для систем, где все необходимые файлы и инструменты располагаются на той же самой файловой системе, приложение <code>init</code> может в совершенстве управлять дальнейшим процессом загрузки. Но когда определяются множественные файловые системы (или в случае более экзотических установок), этот процесс может стать немного более усложненным: 

* В случае, когда раздел {{Path|/usr}} размещается на отдельной файловой системе, инструменты и драйвера, чьи файлы хранятся на {{Path|/usr}} не могут использоваться, пока раздел {{Path|/usr}} не станет доступным. Если эти инструменты требуются для предоставления доступа к разделу {{Path|/usr}}, то мы не сможем загрузить систему.

* Если корневой каталог root зашифрован, то ядро Linux не сможет найти приложение <code>init</code>, что приведет к незагружаемой системе.

С давних пор решением для этой проблемы является использование "initrd" (initial root device). 

=== Корневой диск для начальной инициализации (initial root disk) ===

''initrd'' - это дисковая структура в оперативной памяти (ramdisk), которая содержит необходимые инструменты и сценарии для монтирования требуемых файловых систем перед тем как управление передается приложению <code>init</code> на корневой файловой системе. Ядро Linux запускает сценарий настройки (обычно называемый <code>linuxrc</code>, но это не обязательно так) на этом корневом диске, который подготавливает систему, переключается к действительной корневой файловой системе и затем вызывает <code>init</code>. 

Хотя способ, включающий в себя initrd - все, что требуется, он имеет несколько недостатков: 

* Это полноценное блочное устройство, требующее дополнительные расходы на целую файловую систему, располагающуюся на нем, и оно имеет фиксированный размер. Выберите initrd достаточно маленьким, и Вы не сможете уместить все требуемые сценарии. Сделайте его слишком большим, и Вы растратите память впустую.

* По той причине, что это действительной устройство, оно также требует кэш-память ядра Linux и подлежит используемым методам управления памятью и файлами (таким как подкачка страниц), что делает расходы памяти еще более худшими.

Для решения этих (для кого-то едва-ли) проблем, была создана initramfs. 

=== Файловая система в памяти для начальной инициализации (initramfs) ===

''initramfs'' - это начальная файловая система в оперативной памяти, основанная на ''tmpfs'' (легковесной файловой системой в памяти с изменяемым размером), которая также не использовала отдельное блочное устройство (чтобы отсутствовало кэширование и все накладные расходы, упомянутые ранее, исчезли). Так же как и initrd, она содержит инструменты и сценарии, требуемые для монтирования файловых систем перед вызовом двоичного файла <code>init</code>, располагающегося на действительной корневой файловой системе. Эти инструменты могут быть уровнями абстракции расшифровывающих процедур (для зашифрованных файловых систем), менеджерами логических томов, программными (software) raid массивами, загрузчиками файловых систем, основанными на драйверах bluetooth, и т.д. 

Содержимое initramfs делается путем создания <code>cpio</code>-архива. <code>cpio</code> - это старое (но проверенное) решение для архивирования файлов (архивы, получаемые в результате его работы называются ''cpio-архивы''). Вы определенно можете сравнить его с <code>tar</code>. Здесь <code>cpio</code> был выбран потому, что проще создать (с программной точки зрения) и поддерживать (на то время) файлы устройств (тогда как <code>tar</code> этого не мог). 

All files, tools, libraries, configuration settings (if applicable), etc. are put into the cpio archive. This archive is then compressed using the <code>gzip</code> utility and stored alongside the Linux kernel. The boot loader will then offer it to the Linux kernel at boot time so the kernel knows an initramfs is needed. 

Once detected, the Linux kernel will create a tmpfs file system, extract the contents of the archive on it, and then launches the <code>init</code> script located in the root of the tmpfs file system. This script will then mount the real root file system (after making sure it can mount it, for instance by loading additional modules, preparing an encryption abstraction layer, etc.) as well as vital other file systems (such as {{Path|/usr}} and {{Path|/var}} ). 

Once the root file system and the other vital file systems are mounted, the <code>init</code> script from the initramfs will switch the root towards the real root file system and finally call the <code>/sbin/init</code> on that system to continue the boot process. 

== Creating an initramfs ==

=== Introduction and bootloader configuration ===

To create an initramfs, it is important that you know what additional drivers, scripts and tools you need to boot your system. For instance, if you use LVM, then you will need to support LVM tools on the initramfs. Likewise, if you use software RAID, you need <code>mdadm</code>, etc. 

Some tools exist that help you create initramfs' (compressed cpio archives) for your system. But for those that want total control, you can easily create your own initramfs as well. 

Once created, you will need to adjust the bootloader configuration to tell it that an initramfs is to be used. For instance, if the initramfs file is stored as {{Path|/boot/initramfs-3.2.2-gentoo-r5}} , then the configuration in {{Path|/boot/grub/grub.conf}} could look like so: 

{{File|grub.conf|Example entry in grub.conf for booting with an initramfs|<pre>
title Gentoo Linux 3.2.2-r5
root (hd0,0)
kernel /boot/kernel-3.2.2-gentoo-r5
initrd /boot/initramfs-3.2.2-gentoo-r5
</pre>
}}

=== Using genkernel ===

Gentoo's kernel building utility, <code>genkernel</code>, can be used to generate an initramfs, even if you didn't use <code>genkernel</code> to configure and build your kernel. 

To use <code>genkernel</code> for generating an initramfs, it is recommended that you include all necessary drivers and code that is needed to mount your {{Path|/}} and {{Path|/usr}} file systems in the kernel (and not as modules). Then, call <code>genkernel</code> as follows: 

{{RootCmd|genkernel --install --no-ramdisk-modules initramfs}}

Depending on your system, you might want to add one or more of the following options: 

{| class="wikitable" style="text-align: left;" 
|- 
! Option
! Description
|- 
| --disklabel
| Add support for <code>LABEL=</code> settings in your {{Path|/etc/fstab}} 
|- 
| --dmraid
| Add support for fake hardware RAID
|- 
| --firmware
| Add in firmware code found on the system
|- 
| --gpg
| Add in GnuPG support
|- 
| --iscsi
| Add support for iSCSI
|- 
| --luks
| Add support for luks encryption containers
|- 
| --lvm
| Add support for LVM
|- 
| --mdadm
| Add support for software RAID
|- 
| --multipath
| Add support for multiple I/O access towards a SAN
|- 
| --zfs
| Add support for ZFS
|-
|}

When finished, the resulting initramfs file will be stored in your {{Path|/boot}} . 

=== Using dracut ===

{{Warning|At the time of writing, dracut is not marked stable yet, so you might need to unmask it before continuing.}}

The <code>dracut</code> utility is created for the sole purpose of managing initramfs files. It uses a highly modular approach on which support you want to include and which not. 

When you install <code>dracut</code>, you will need to take care to include support for the correct <code>DRACUT_MODULES</code> . This is a variable you can set in {{Path|/etc/portage/make.conf}} to include support for specific setups: 

{{File|make.conf|Preparing to install dracut|<pre>
DRACUT_MODULES="dmraid lvm syslog -biosdevname -btrfs -caps -crypt -crypt-gpg
-dmsquash-live -gensplash -iscsi -livenet -mdraid -multipath -nbd -nfs -plymouth
-ssh-client"
</pre>
}}

It is advisable to set (or unset) those modules you need (and don't need). Afterwards, <code>emerge dracut</code> to install the utility on your system. 

The next step is to configure <code>dracut</code> by editing {{Path|/etc/dracut.conf}}. In the configuration file, which is well commented, you can add in support for specific modules where needed. 

Once configured, create an initramfs by calling <code>dracut</code> as follows: 

{{RootCmd|dracut}}

The resulting image supports generic system boots based on the configuration in {{Path|/etc/dracut.conf}}. You can also opt to generate an initramfs specifically tailored to your system (in which <code>dracut</code> tries to detect the needed tools, drivers, etc. from your existing system). If you know that the needed support (code and drivers) is built in in your kernel (and not as module), then you can even add in <code>--no-kernel</code>: 

{{RootCmd|dracut --host-only --no-kernel}}

For more information, check out the <code>dracut</code> and <code>dracut.cmdline</code> manual pages. 

== Additional resources ==

=== Gentoo-specific ===

* [http://en.gentoo-wiki.com/wiki/Initramfs Initramfs] on Gentoo-wiki.com
* [[Initramfs]] on the official Gentoo Wiki
* [[Dracut]] on the official Gentoo Wiki

=== General resources ===

* [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt ramfs-rootfs-initramfs.txt] within the Linux kernel documentation

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:


* Sven Vermeulen
