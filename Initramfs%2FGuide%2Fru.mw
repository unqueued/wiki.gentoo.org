<languages />


{{Metadata|abstract=Все больше и больше систем требуют initramfs для правильной загрузки. В этом руководстве мы займемся рассмотрением основных понятий initramfs, в том числе и того, как должным образом создать и управлять initramfs на отдельных примерах.}}

Все больше и больше систем требуют '''initramfs''' для правильной загрузки. В этом руководстве будет рассмотрены основные понятия initramfs, а также как правильно создать и управлять initramfs на отдельных примерах.

== Основные понятия initramfs ==

=== Введение ===

Для большинства пользователей initramfs не является чем-то необходимым. Их система использует простую схему разбиения жесткого диска без экзотических драйверов или установок (таких как зашифрованные файловые системы), поэтому ядро Linux вполне способно передать управление двоичному файлу {{c|init}} на их системе. Но для большинства систем, использование initramfs почти обязательно. 

Основной ключ к пониманию того, чем является initramfs (или для чего она необходима) - это понимание того, как работает процесс загрузки Linux, даже в достаточно высокоуровневом подходе. 

=== Процесс загрузки Linux ===

Как только ядро Linux получает контроль над системой (который был передан ему после загрузки загрузчиком), оно подготавливает свои области памяти и драйвера. Затем оно передает управление приложению (обычно {{c|init}}), чьей задачей является дальнейшая подготовка системы и проверка того, что в конце процесса загрузки, все необходимые сервисы запущены и пользователь способен войти в систему. Приложение {{c|init}} делает это с помощью запуска, в числе прочих сервисов, демона {{c|udev}}, который далее загружает и подготавливает систему, основываясь на обнаруженных устройствах. Когда {{c|udev}} запущен, все оставшиеся файловые системы, которые не были примонтированы, монтируются, и запускаются остальные сервисы. 

Для систем, где все необходимые файлы и инструменты располагаются на той же самой файловой системе, приложение {{c|init}} может в совершенстве управлять дальнейшим процессом загрузки. Но когда определены множественные файловые системы (или в случае более неординарных установок), этот процесс может стать немного более усложненным: 

* В случае, когда раздел {{Path|/usr}} размещается на отдельной файловой системе, инструменты и драйвера, чьи файлы хранятся на {{Path|/usr}} не могут использоваться, пока раздел {{Path|/usr}} не станет доступным. Если эти инструменты требуются для предоставления доступа к разделу {{Path|/usr}}, то мы не сможем загрузить систему.

* Если файловая система root зашифрована, то ядро Linux не сможет найти приложение {{c|init}} и это приведет к тому что система не сможет загрузиться.

С давних пор решением для этой проблемы является использование "initrd" (initial root device). 

=== Корневой диск для начальной инициализации (initial root disk) ===

'''initrd''' — это дисковая структура в оперативной памяти (ramdisk), которая содержит необходимые инструменты и скрипты для монтирования требуемых файловых систем ''перед'' тем как управление передается приложению {{c|init}} на корневой файловой системе. Ядро Linux запускает скрипт настройки (обычно называемый {{Path|linuxrc}}, но не обязательно такое имя) на этом корневом диске, который подготавливает систему, переключается к действительной корневой файловой системе и затем вызывает {{c|init}}. 

Хотя способ, включающий в себя initrd - это все, что требуется, он имеет несколько недостатков: 

* Это полноценное блочное устройство, требующее дополнительные расходы на целую файловую систему, и оно имеет фиксированный размер. Если выбрать initrd достаточно маленьким, то все требуемые скрипты не поместятся. Если сделайте его слишком большим, то растратите память впустую.

* По той причине, что это действительное устройство, оно также требует кэш-память ядра Linux и подлежит используемым методам управления памятью и файлами (таким как подкачка страниц), что делает расходы памяти еще более худшими.

Чтобы решить эти вопросы, была создана initramfs.

=== Файловая система в памяти для начальной инициализации (initramfs) ===

'''initramfs''' - это начальная файловая система в оперативной памяти, основанная на ''tmpfs'' (легковесной файловой системе в памяти с изменяемым размером), которая также не использовала отдельное блочное устройство (чтобы отсутствовало кэширование и все накладные расходы, упомянутые ранее, исчезли). Так же как и initrd, она содержит утилиты и скрипты, требуемые для монтирования файловых систем перед вызовом бинарного файла {{c|init}}, располагающегося на действительной корневой файловой системе. Эти утилиты могут быть уровнями абстракции расшифровывающих процедур (для зашифрованных файловых систем), менеджерами логических томов, программными (software) raid массивами, загрузчиками файловых систем, основанными на драйверах bluetooth, и так далее. 

Содержимое initramfs делается путем создания cpio-архива. {{c|cpio}} — это старое (но проверенное) решение для архивирования файлов (архивы, получаемые в результате его работы называются ''cpio-архивы''). Безусловно cpio можно сравнить с {{c|tar}} архиватором. Здесь {{c|cpio}} был выбран потому, что проще создать (с программной точки зрения) и поддерживать (на то время) файлы устройств (тогда как {{c|tar}} этого не мог). 

Все файлы, утилиты, библиотеки, настройки конфигурации (если они применимы), и т.д. помещаются в cpio-архив. Этот архив затем сжимается с использованием утилиты {{c|gzip}} и сохраняется в том же месте, что и ядро Linux. Далее, загрузчик передаст его ядру Linux во время загрузки, чтобы ядро знало о том, что требуется initramfs. 

При его обнаружении, ядро Linux создаст файловую систему tmpfs, извлечет на нее содержимое архива и затем запустит сценарий <code>init</code>, расположенный в корневом каталоге файловой системы tmpfs. Этот сценарий затем примонтирует действительную корневую файловую систему (после того, как убедится, что он может ее примонтировать, например, с помощью загрузки дополнительных модулей, подготовки уровней абстракции шифрования, и т.д.), также как и другие существенно важные файловые системы (такие как {{Path|/usr}} и {{Path|/var}}). 

Как только корневая файловая система и другие существенные файловые системы примонтированы, сценарий <code>init</code> из initramfs затем переключает root на действительную корневую файловую систему и, в завершение, вызывает <code>/sbin/init</code> на этой системе, для продолжения процесса загрузки.

== Создание initramfs ==

=== Введение и настройка загрузчика ===

Для создания initramfs, важно знать какие дополнительные драйверы, сценарии и инструменты необходимы для загрузки системы. Например, если используется LVM, то потребуется инструменты LVM в initramfs. Таким же образом, если используется программный RAID, будут нужна утилита {{c|mdadm}}, и так далее. 

Существуют несколько инструментов, которые помогут создать initramfs (сжатые {{c|cpio}}-архивы) для системы. Тем, кому требуется полный контроль, также могут легко создать собственный, пользовательский образ initramfs. 

После создания initramfs, Вам необходимо настроить конфигурацию загрузчика для сообщения загрузчику, что будет использоваться initramfs. Например, если файл initramfs сохранен как {{Path|/boot/initramfs-3.2.2-gentoo-r5}}, то конфигурация в {{Path|/boot/grub/grub.conf}} будет выглядеть следующим образом: 

{{FileBox|filename=grub.conf|title=Пример записи в grub.conf для загрузки с initramfs|1=
title Gentoo Linux 3.2.2-r5
root (hd0,0)
kernel /boot/kernel-3.2.2-gentoo-r5
initrd /boot/initramfs-3.2.2-gentoo-r5
}}

=== Использование genkernel ===

Утилита для сборки ядра Gentoo, {{c|genkernel}}, может использоваться для генерирования initramfs, даже если не использовался {{c|genkernel}} для конфигурации и сборки ядра. 

Чтобы использовать {{c|genkernel}} для генерации initramfs, рекомендуется все необходимые драйверы и код, который требуется для монтирования {{Path|/}} и {{Path|/usr}} файловых систем, включить в ядро (а не как модули). Затем, вызвать команду {{c|genkernel}} следующим образом: 

{{RootCmd|genkernel --install --no-ramdisk-modules initramfs}}

В зависимости от Вашей системы, Вы можете пожелать добавить одну или более из следующих опций: 

{| class="table" style="text-align: left;" 
|- 
! Опция
! Описание
|- 
| <code>--disklabel</code>
| Включить поддержку <code>LABEL=</code> настроек в файл {{Path|/etc/fstab}} 
|- 
| <code>--dmraid</code>
| Включить поддержку fake hardware RAID
|- 
| <code>--firmware</code>
| Включить firmware code, найденный на системе
|- 
| <code>--gpg</code>
| Включить поддержку GnuPG
|- 
| <code>--iscsi</code>
| Включить поддержку iSCSI
|- 
| <code>--luks</code>
| Включить поддержку зашифрованных контейнеров luks
|- 
| <code>--lvm</code>
| Включить поддержку LVM
|- 
| <code>--mdadm</code>
| Включить поддержку программного (software) RAID
|- 
| <code>--multipath</code>
| Включить поддержку множественного I/O-доступа к SAN
|- 
| <code>--zfs</code>
| Включить поддержку ZFS
|-
|}

По завершении, файл initramfs, полученный в результате, будет сохранен в каталоге {{Path|/boot}}.

=== Использование dracut ===

{{Warning|На время написания, dracut не был отмечен в качестве стабильного пакета, поэтому, перед тем как продолжить, возможно потребуется размаскировать его.}}

Утилита {{c|dracut}} создана с единственной целью управления файлами initramfs. Она использует весьма модульный подход в плане выбора поддержку чего требуется включить, а чего нет. 

Чтобы установить {{c|dracut}} нужно проявить осторожность в настройки корректного значения(ий) в переменной <var>DRACUT_MODULES</var>. Чтобы включить поддержку специфичных для системы настроек, переменную можно установить в файле {{Path|/etc/portage/make.conf}}: 

{{FileBox|filename=make.conf|title=Подготовка к установке dracut|lang=bash|1=<pre>
DRACUT_MODULES="dmraid lvm syslog -biosdevname -btrfs -caps -crypt -crypt-gpg
-dmsquash-live -gensplash -iscsi -livenet -mdraid -multipath -nbd -nfs -plymouth
-ssh-client"
</pre>
}}

Рекомендуется установить (или убрать) необходимые модули. После настройки переменной <var>DRACUT_MODULES</var> в файле {{Path|/etc/portage/make.conf}} запустите команду {{c|emerge dracut}} для установки утилиты Dracut. 

Далее необходимо настроить {{c|dracut}} посредством редактирования {{Path|/etc/dracut.conf}}. В файле конфигурации, который хорошо прокомментирован, включите поддержку необходимых модулей.

После конфигурации, создайте initramfs вызовом {{c|dracut}} следующим образом: 

{{RootCmd|dracut}}

Образ, полученный в результате, поддерживает общую загрузку системы, основанную на конфигурации в {{Path|/etc/dracut.conf}}. Также, можно выбрать генерирование initramfs специально приспособленной под ''вашу'' систему (в которой {{c|dracut}} пытается определить необходимые инструменты, драйверы, и так далее из существующей системы). Если модули и драйверы встроены в ядро (не отдельными модулями и ссылками на firmware), то можно добавить опцию <code>--no-kernel</code>: 

{{RootCmd|dracut --host-only --no-kernel}}

Чтобы найти больше информации, проконсультируйтесь с man-страницами <code>dracut</code> и <code>dracut.cmdline</code> .

== Смотрите также ==

* [[Initramfs]] на официальной Gentoo Wiki
* [[Dracut]] на официальной Gentoo Wiki

== Ссылки ==

* [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt ramfs-rootfs-initramfs.txt] файл в документации ядра Linux.


[[Category:Initramfs]]
