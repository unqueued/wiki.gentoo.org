<languages />


{{Metadata|abstract=Все больше и больше систем требуют initramfs для правильной загрузки. В этом руководстве мы займемся рассмотрением основных понятий initramfs, в том числе и того, как должным образом создать и управлять initramfs на отдельных примерах.}}

Все больше и больше систем требуют '''initramfs''' для правильной загрузки. В этом руководстве будет рассмотрены основные понятия initramfs, а также как правильно создать и управлять initramfs на отдельных примерах.

== Основные понятия initramfs ==

=== Введение ===

Для большинства пользователей initramfs не является чем-то необходимым. Их система использует простую схему разбиения жесткого диска без экзотических драйверов или установок (таких как зашифрованные файловые системы), поэтому ядро Linux вполне способно передать управление двоичному файлу {{c|init}} на их системе. Но для большинства систем, использование initramfs почти обязательно. 

Основной ключ к пониманию того, чем является initramfs (или для чего она необходима) - это понимание того, как работает процесс загрузки Linux, даже в достаточно высокоуровневом подходе. 

=== Процесс загрузки Linux ===

Once the Linux kernel has control over the system (which it gets after being loaded by the boot loader), it prepares its memory structures and drivers. It then hands over control to an application (usually {{c|init}}) whose task it is to further prepare the system and make sure that, at the end of the boot process, all necessary services are running and the user is able to log on. The {{c|init}} application does that by launching, among other services, the {{c|udev}} daemon who will further load up and prepare the system based on the detected devices. When {{c|udev}} is launched, all remaining file systems that have not been mounted are mounted, and the remainder of services is started. 

Для систем, где все необходимые файлы и инструменты располагаются на той же самой файловой системе, приложение {{c|init}} может в совершенстве управлять дальнейшим процессом загрузки. Но когда определены множественные файловые системы (или в случае более неординарных установок), этот процесс может стать немного более усложненным: 

* В случае, когда раздел {{Path|/usr}} размещается на отдельной файловой системе, инструменты и драйвера, чьи файлы хранятся на {{Path|/usr}} не могут использоваться, пока раздел {{Path|/usr}} не станет доступным. Если эти инструменты требуются для предоставления доступа к разделу {{Path|/usr}}, то мы не сможем загрузить систему.

* Если файловая система root зашифрована, то ядро Linux не сможет найти приложение {{c|init}} и это приведет к тому что система не сможет загрузиться.

С давних пор решением для этой проблемы является использование "initrd" (initial root device). 

=== Корневой диск для начальной инициализации (initial root disk) ===

The '''initrd''' is an in-memory disk structure (ramdisk) that contains the necessary tools and scripts to mount the needed file systems ''before'' control is handed over to the {{c|init}} application on the root file system. The Linux kernel triggers the setup script (usually called {{Path|linuxrc}} but that name is not mandatory) on this root disk, which prepares the system, switches to the real root file system and then calls {{c|init}}. 

Хотя способ, включающий в себя initrd - это все, что требуется, он имеет несколько недостатков: 

* Это полноценное блочное устройство, требующее дополнительные расходы на целую файловую систему, располагающуюся на нем, и оно имеет фиксированный размер. Выберите initrd достаточно маленьким, и Вы не сможете уместить все требуемые сценарии. Сделайте его слишком большим, и Вы растратите память впустую.

* По той причине, что это действительное устройство, оно также требует кэш-память ядра Linux и подлежит используемым методам управления памятью и файлами (таким как подкачка страниц), что делает расходы памяти еще более худшими.

Для решения этих (для кого-то едва-ли) проблем, была создана initramfs. 

=== Файловая система в памяти для начальной инициализации (initramfs) ===

An '''initramfs''' is an initial ram file system based on ''tmpfs'' (a size-flexible, in-memory lightweight file system), which also did not use a separate block device (so no caching was done and all overhead mentioned earlier disappears). Just like the initrd, it contains the tools and scripts needed to mount the file systems before the {{c|init}} binary on the real root file system is called. These tools can be decryption abstraction layers (for encrypted file systems), logical volume managers, software raid, bluetooth driver based file system loaders, etc. 

The content of the initramfs is made by creating a cpio archive. {{c|cpio}} is an old (but proven) file archiver solution (and its resulting archive files are called cpio files). cpio is definitely comparable to the {{c|tar}} archiver. The choice of {{c|cpio}} here was because it was easier to implement (code-wise) and supported (back then) device files which <code>tar</code> could not. 

All files, tools, libraries, configuration settings (if applicable), etc. are put into the cpio archive. This archive is then compressed using the {{c|gzip}} utility and stored alongside the Linux kernel. The boot loader will then offer it to the Linux kernel at boot time so the kernel knows an initramfs is needed. 

При его обнаружении, ядро Linux создаст файловую систему tmpfs, извлечет на нее содержимое архива и затем запустит сценарий <code>init</code>, расположенный в корневом каталоге файловой системы tmpfs. Этот сценарий затем примонтирует действительную корневую файловую систему (после того, как убедится, что он может ее примонтировать, например, с помощью загрузки дополнительных модулей, подготовки уровней абстракции шифрования, и т.д.), также как и другие существенно важные файловые системы (такие как {{Path|/usr}} и {{Path|/var}}). 

Как только корневая файловая система и другие существенные файловые системы примонтированы, сценарий <code>init</code> из initramfs затем переключает root на действительную корневую файловую систему и, в завершение, вызывает <code>/sbin/init</code> на этой системе, для продолжения процесса загрузки.

== Создание initramfs ==

=== Введение и настройка загрузчика ===

To create an initramfs, it is important to know what additional drivers, scripts and tools will be needed to boot the system. For instance, if LVM is used, then LVM tools will be needed in the initramfs. Likewise, if software RAID is used, {{c|mdadm}} utilities will be needed, etc. 

Some tools exist that help users create initramfs' (compressed {{c|cpio}} archives) for their system. But for those who want total control can easily create personal, custom initramfs' as well. 

После создания initramfs, Вам необходимо настроить конфигурацию загрузчика для сообщения загрузчику, что будет использоваться initramfs. Например, если файл initramfs сохранен как {{Path|/boot/initramfs-3.2.2-gentoo-r5}}, то конфигурация в {{Path|/boot/grub/grub.conf}} будет выглядеть следующим образом: 

{{FileBox|filename=grub.conf|title=Пример записи в grub.conf для загрузки с initramfs|1=
title Gentoo Linux 3.2.2-r5
root (hd0,0)
kernel /boot/kernel-3.2.2-gentoo-r5
initrd /boot/initramfs-3.2.2-gentoo-r5
}}

=== Использование genkernel ===

Gentoo's kernel building utility, {{c|genkernel}}, can be used to generate an initramfs, even if {{c|genkernel}} was not used to configure and build the kernel. 

To use {{c|genkernel}} for generating an initramfs, it is recommended all necessary drivers and code that is needed to mount the {{Path|/}} and {{Path|/usr}} file systems be included in the kernel (not as modules). Then, call {{c|genkernel}} as follows: 

{{RootCmd|genkernel --install --no-ramdisk-modules initramfs}}

В зависимости от Вашей системы, Вы можете пожелать добавить одну или более из следующих опций: 

{| class="table" style="text-align: left;" 
|- 
! Option
! Description
|- 
| <code>--disklabel</code>
| Add support for <code>LABEL=</code> settings in {{Path|/etc/fstab}} 
|- 
| <code>--dmraid</code>
| Add support for fake hardware RAID.
|- 
| <code>--firmware</code>
| Add in firmware code found on the system.
|- 
| <code>--gpg</code>
| Add in GnuPG support.
|- 
| <code>--iscsi</code>
| Add support for iSCSI.
|- 
| <code>--luks</code>
| Add support for LUKS encryption containers.
|- 
| <code>--lvm</code>
| Add support for LVM.
|- 
| <code>--mdadm</code>
| Add support for software RAID.
|- 
| <code>--multipath</code>
| Add support for multiple I/O access towards a SAN.
|- 
| <code>--zfs</code>
| Add support for ZFS.
|-
|}

По завершении, файл initramfs, полученный в результате, будет сохранен в {{Path|/boot}} .

=== Использование dracut ===

{{Warning|На время написания, dracut не был отмечен в качестве стабильного пакета, поэтому, перед тем как продолжить, возможно потребуется размаскировать его.}}

The {{c|dracut}} utility is created for the sole purpose of managing initramfs files. It uses a highly modular approach on what support is to be included and what is not to be included. 

To install {{c|dracut}}, make special care to include support for the correct value(s) in the <var>DRACUT_MODULES</var> variable. This variable can be set in {{Path|/etc/portage/make.conf}} to include support for system specific setups: 

{{FileBox|filename=make.conf|title=Подготовка к установке dracut|lang=bash|1=<pre>
DRACUT_MODULES="dmraid lvm syslog -biosdevname -btrfs -caps -crypt -crypt-gpg
-dmsquash-live -gensplash -iscsi -livenet -mdraid -multipath -nbd -nfs -plymouth
-ssh-client"
</pre>
}}

It is advisable to set (or unset) the modules needed. After configuring the <var>DRACUT_MODULES</var> variable in {{Path|/etc/portage/make.conf}}, {{c|emerge dracut}} to install the Dracut utility. 

The next step is to configure {{c|dracut}} by editing {{Path|/etc/dracut.conf}}. In the configuration file, which is well commented, in order to add support for needed modules.

Once configured, create an initramfs by calling {{c|dracut}} as follows: 

{{RootCmd|dracut}}

The resulting image supports generic system boots based on the configuration in {{Path|/etc/dracut.conf}}. It is also possible to generate an initramfs specifically tailored to ''your'' system (which {{c|dracut}} tries to detect the needed tools, drivers, etc. from the existing system). If the modules and drivers are built into the kernel (not as separate modules and references to the firmware), then the <code>--no-kernel</code> option can be added: 

{{RootCmd|dracut --host-only --no-kernel}}

Чтобы найти больше информации, проконсультируйтесь с man-страницами <code>dracut</code> и <code>dracut.cmdline</code> .

== Смотрите также ==

* [[Initramfs]] на официальной Gentoo Wiki
* [[Dracut]] на официальной Gentoo Wiki

== Ссылки ==

* The [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt ramfs-rootfs-initramfs.txt] file within the Linux kernel documentation.


[[Category:Initramfs]]
