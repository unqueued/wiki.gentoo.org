This is a working page for collecting the different proposals how the EAPI should be specified in future. See also the [http://archives.gentoo.org/gentoo-dev/msg_288fa260bf4c9242a33380fd4bfce0f8.xml previous discussion].

== Parse the EAPI assignment statement ==

This first proposal would require that the syntax of the EAPI assignment statement in ebuilds matches a well defined regular expression. A scan of the Portage tree shows that the statement only occurs in the following variations (using EAPI 4 as example):
: EAPI=4
: EAPI="4"
: EAPI='4'
Sometimes this is followed by whitespace or a comment (starting with a # sign). Also, with very few exceptions the EAPI assignment occurs within the first few lines of the ebuild. For the vast majority of ebuilds it is in line 5.

Written in a more formal way, appropriate for a specification:
* Ebuilds must contain at most one EAPI assignment statement.
* It must occur within the first N lines of the ebuild (N=10 and N=30 have been suggested).
* The statement must match the following regular expression (extended regexp syntax):
*: <nowiki>^[ \t]*EAPI=(['"]?)([A-Za-z0-9._+-]*)\1[ \t]*(#.*)?$</nowiki>

Note: The first and the third point are already fulfilled by all ebuilds in the Portage tree. The second point will require very few ebuilds to be changed (9 packages for N=10, or 2 packages for N=30).

The package manager would determine the EAPI by parsing the assignment with above regular expression. A sanity check would be added. [https://bugs.gentoo.org/show_bug.cgi?id=402167 Citing Zac Medico:] "The fact that we can compare the probed EAPI to the actual EAPI variable after the ebuild is sourced seems like a perfect sanity check. We could easily detect inconsistencies and flag such ebuilds as invalid, providing a reliable feedback mechanism to ebuild developers."

=== Upgrade path ===
* For a transition period, new ebuilds must still be parseable by old package managers. Changes of global scope behaviour must account for this.

=== Pros ===
* No modifications to the tree required.
* Uniform style of assignment throughout all EAPIs.

=== Cons ===
* Cannot be used in other languages than bash (unless they allow for multiline comments).
* Gets complex and can subtly fail when dealing w/ double assigns in the ebuild- has to choose the last it sees to match what any eclasses/later code would see while sourcing the ebuild.
* Slight performance hit

== EAPI in header comment ==

A different approach would be to specify the EAPI in a specially formatted comment in the first line of the ebuild's header. The syntax could be one of the following:
* The word "ebuild", followed by whitespace, followed by the EAPI, followed by end-of-line or whitespace. Corresponding regexp:
*: <nowiki>\<ebuild[ \t]([A-Za-z0-9._+-]*)($|[ \t])</nowiki>
* The word "EAPI", followed by an equals sign ("="), followed by the EAPI, followed by end-of-line or whitespace. Corresponding regexp:
*: <nowiki>\<EAPI=([A-Za-z0-9._+-]*)($|[ \t])</nowiki>

=== Upgrade path ===
* The usual EAPI assignment statement in the ebuild would be still required for a transition period. A sanity check similar to the one [[#Parse the EAPI assignment statement|mentioned above]] would be added.
* Alternatively, the EAPI variable could be made read-only immediately, if a statement like one of the following was added to ebuilds:
*: <nowiki>: ${EAPI=5}</nowiki>
*: <nowiki>[[ ${EAPI} ]] || { EAPI=-1; return; }</nowiki>

=== Pros ===
* Clean and well-defined solution when the transition is finished.
* Allows for changes of global scope behaviour,
* Can be used not only for bash, but also for other languages.

=== Cons ===
* Duplicate EAPI specification (header comment and bash assignment) in ebuilds during a transition period.
* Once past the transition period, any old PM (PMs from today for example) will interpret the new format as EAPI=0 if they see it.
* Very slight performance hit from having to read the first few characters.
* It involves using a magic identifier. Magic is bad, and the fact that messing with a comment can break your PM is counter-intuitive.

== EAPI in header comment and one-time change of file extension ==

[[#EAPI in header comment|As before]], but combined with a one time change of the file extension, like .ebuild → .eb. (Note: It was pointed out that "eb" should be avoided because of its [[wikt:ёб|meaning in Russian]].)

The EAPI variable could be made read-only in bash before sourcing the ebuild.

=== Pros ===
* Allows for changes of global scope behaviour,
* Can be used not only for bash, but also for other languages.
* The transition period is effectively close ended, rather than open ended as the [[#EAPI_in_header_comment|previous form]] is.

=== Cons ===
* Two different file extensions for ebuilds. (But in principle, we could move everything to the new extension later.)
* Very slight performance hit from having to read the first few characters.
* It involves using a magic identifier. Magic is bad, and the fact that messing with a comment can break your PM is counter-intuitive.

== EAPI specified by a function ==

=== Pros ===
* Uses standard bash syntax.

=== Cons ===
* Performance hit from sourcing the ebuild once to get the EAPI.
* Redundant definition of EAPI during the transition.
* Old package managers will crash on new features after the transition period.
* New package managers will crash if the ebuild uses new features before the 'eapi' function is called.

== EAPI in filename ==

[http://www.gentoo.org/proj/en/glep/glep-0055.html]
[http://www.gentoo.org/proj/en/council/meeting-logs/20100823-summary.txt]

=== Pros ===
* Best performance of all the solutions.
* Can be used immediately due to the implied extension change.
* Some people think the EAPI rightfully belongs in the filename.

=== Cons ===
* ''ebuild'' is a simple and attractive extension
* Was already rejected by a previous council
* Some people think the EAPI rightfully belongs within the ebuild
