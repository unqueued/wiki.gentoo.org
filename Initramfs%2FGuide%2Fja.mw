<languages />


{{Metadata|abstract=ますます多くのシステムで、正しくブートするために initramfs が必要になってきています。このガイドでは initramfs を適切に作成、管理する方法だけでなく、 initramfs のコンセプトについても対象とします。}}

ますます多くのシステムで、正しくブートするために initramfs が必要になってきています。このガイドでは initramfs を適切に作成、管理する方法だけでなく、 initramfs のコンセプトについても対象とします。

== initramfs のコンセプト ==

=== はじめに ===

多くのユーザーにとって、initramfs を使ったシステムは無関係です。そうした人々のシステムは単純なパーティションスキーマを採用しており、また(暗号化ファイルシステムのような)変わったドライバーや構成を使っていないため、Linux カーネルが {{c|init}} バイナリに制御を渡すことが確実にできるのです。しかしながら、多くのシステムにおいて、initramfs は必須です。 

initramfs とは何か(そして何のために必要なのか)を理解する上で鍵となるコンセプトは、レベルの高いアプローチではありますが、Linux のブートプロセスが動作する仕組みを理解するということです。 

=== Linux のブートプロセス ===

Linux カーネルが(ブートローダーによって読み込まれた後に)システムの制御を得ると、自身のメモリー構造とドライバーを準備します。それから、制御をあるアプリケーション(通常は {{c|init}})に渡します。そのアプリケーションの役割は、さらにシステムの準備をすることと、ブートプロセスが終わった時点ですべての必要なサービスが実行されユーザーがログインできる状態にすることです。{{c|init}} アプリケーションはサービスの中でも、検出されたデバイスをもとにシステムのさらなる読み込みや準備を行う {{c|udev}} デーモンを起動することによってその作業を行います。{{c|udev}} が起動されるとまだマウントされていない残りのファイルシステムがすべてマウントされ、それから残りのサービスが開始されます。 

必要なファイルやツールがすべて同じファイルシステムにあるシステムでは、{{c|init}} アプリケーションは以降のブートプロセスを完全に制御できます。しかし複数のファイルシステムが定義されている(またはもっと風変わりなインストールがなされている)場合には、事はもう少しトリッキーになります: 

* {{Path|/usr}} パーティションが別のファイルシステムにある場合、{{Path|/usr}} の中に保存されているツールやドライバーは {{Path|/usr}} が利用可能になるまで使えません。そうしたツールが {{Path|/usr}} を利用可能にするために必要な場合、システムをブートすることができなくなります。

* ルートファイルシステムが暗号化されている場合、Linux カーネルは {{c|init}} アプリケーションを見つけることができないため、ブートできないシステムになってしまいます。

この問題への古くからある解決策が ''initrd'' (initial root device) を使うことです。 

=== initial root disk ===

'''initrd''' は、ルートファイルシステムの {{c|init}} アプリケーションに制御を渡す''前に''必要なファイルシステムをマウントするのに必要なツールやスクリプトを含む、メモリー内ディスク構造 (ramdisk) です。Linux カーネルはこのルートディスクにあるセットアップスクリプト(通常は {{Path|linuxrc}} と呼ばれますが、その名前である必要はありません)を起動します。セットアップスクリプトはシステムの準備や真のルートファイルシステムへの切り替えを行い、そして {{c|init}} を実行します。 

initrd を使う方法は必要なことをすべて行えますが、いくつか欠点もあります: 

* これはれっきとしたブロックデバイスであり、ファイルシステム全体でオーバーヘッドが必要です; 固定サイズになります。initrd があまり小さすぎると必要なスクリプトがすべて収まりません。大きくしすぎるとメモリを浪費してしまいます。

* これは真の、静的なデバイスなので Linux カーネル内のキャッシュメモリーを消費しますし、(ページングのような)メモリーやファイルを管理するメソッドを使用しがちになります。これにより、initrd はますます多くのメモリーを消費することになります。

こうした問題点を解決するために initramfs が作られました。

=== initial ram file system ===

'''initramfs''' は ''tmpfs'' (サイズを柔軟に設定できる軽量なメモリ内ファイルシステム)をもとにした初期 RAM ファイルシステムで、特別のブロックデバイスを使用しません(したがってキャッシュは起こらず、前に述べたオーバーヘッドはすべて無くなります)。initrd と同様に、initramfs には真のルートファイルシステム上にある {{c|init}} バイナリが呼び出される前にファイルシステムをマウントするために必要なツールやスクリプトが含まれています。これらのツールは(暗号化ファイルシステム用の)復号化抽象レイヤー、論理ボリュームマネージャー、ソフトウェア RAID、Bluetooth ドライバーベースのファイルシステムローダー等の場合があります。 

initramfs の内容は cpio アーカイブを作ることで作成します。{{c|cpio}} は古い(しかし実績のある)ファイルアーカイバーです(そして、アーカイブファイルは cpio ファイルと呼ばれます)。cpio は {{c|tar}} アーカイバーと完全に同等です。ここで {{c|cpio}} が選ばれた理由は、コードの観点から実装がしやすく、また(当時は) {{c|tar}} がサポートしていなかったデバイスファイルをサポートしていたためです。 

すべてのファイル、ツール、ライブラリ、(あれば)構成設定などは cpio アーカイブに収められます。このアーカイブはその後 {{c|gzip}} ユーティリティーを使って圧縮され、Linux カーネルとともに保管されます。ブートローダーは、カーネルが initramfs が必要であると知ることができるように、ブートする際に Linux カーネルに initramfs を提示します。 

initramfs が検出されると、Linux カーネルは tmpfs ファイルシステムを作成してアーカイブの内容をそこに展開し、それから tmpfs ファイルシステムのルートにある {{Path|init}} スクリプトを起動します。このスクリプトは(たとえば追加モジュールの読み込み、暗号化抽象レイヤーの準備などを行ってマウントができるようにしてから)真のルートファイルシステムとその他の重要なファイルシステム(たとえば {{Path|/usr}} や {{Path|/var}} など)をマウントします。 

ルートファイルシステムやその他の重要なファイルシステムがマウントされると、initramfs の {{Path|init}} スクリプトはルートを真のルートファイルシステムに切り替え、ブートプロセスを続けるためにシステムの {{Path|/sbin/init}} バイナリを起動します。

== initramfs の作成 ==

=== 導入とブートローダーの設定 ===

initramfs を作成するには、どのような追加ドライバー、スクリプト、ツールがシステムをブートするために必要なのか知っておくことが重要です。たとえば LVM を使用している場合には initramfs 内に LVM ツールが必要です。同様に、ソフトウェア RAID を使用している場合には {{c|mdadm}} ユーティリティーが必要、等々。 

ユーザーのシステム用の initramfs (圧縮された {{c|cpio}} アーカイブ)作成を支援するツールがいくつかあります。同様に、完全なコントロールを望むユーザーは個人用のカスタム initramfs を簡単に作成することができます。 

作成が済んだら、initramfs を使用することを知らせるためにブートローダーの設定を調整する必要があります。たとえば initramfs ファイルが {{Path|/boot/initramfs-3.2.2-gentoo-r5}} に保管されている場合、{{Path|/boot/grub/grub.conf}} の設定は以下のようになるでしょう: 

{{FileBox|filename=grub.conf|title=Example entry in grub.conf for booting with an initramfs|1=
title Gentoo Linux 3.2.2-r5
root (hd0,0)
kernel /boot/kernel-3.2.2-gentoo-r5
initrd /boot/initramfs-3.2.2-gentoo-r5
}}

=== genkernel を用いる ===

Gentoo's kernel building utility, {{c|genkernel}}, can be used to generate an initramfs, even if {{c|genkernel}} was not used to configure and build the kernel. 

To use {{c|genkernel}} for generating an initramfs, it is recommended all necessary drivers and code that is needed to mount the {{Path|/}} and {{Path|/usr}} file systems be included in the kernel (not as modules). Then, call {{c|genkernel}} as follows: 

{{RootCmd|genkernel --install --no-ramdisk-modules initramfs}}

Depending on the system, one or more of the following options may be needed: 

{| class="table" style="text-align: left;" 
|- 
! Option
! Description
|- 
| <code>--disklabel</code>
| Add support for <code>LABEL=</code> settings in {{Path|/etc/fstab}} 
|- 
| <code>--dmraid</code>
| Add support for fake hardware RAID.
|- 
| <code>--firmware</code>
| Add in firmware code found on the system.
|- 
| <code>--gpg</code>
| Add in GnuPG support.
|- 
| <code>--iscsi</code>
| Add support for iSCSI.
|- 
| <code>--luks</code>
| Add support for LUKS encryption containers.
|- 
| <code>--lvm</code>
| Add support for LVM.
|- 
| <code>--mdadm</code>
| Add support for software RAID.
|- 
| <code>--multipath</code>
| Add support for multiple I/O access towards a SAN.
|- 
| <code>--zfs</code>
| Add support for ZFS.
|-
|}

When finished, the resulting initramfs file will be stored in {{Path|/boot}}.

=== dracut を用いる ===

{{Warning|At the time of writing, dracut is not marked stable yet, so it may need unmasked before continuing.}}

The {{c|dracut}} utility is created for the sole purpose of managing initramfs files. It uses a highly modular approach on what support is to be included and what is not to be included. 

To install {{c|dracut}}, make special care to include support for the correct value(s) in the <var>DRACUT_MODULES</var> variable. This variable can be set in {{Path|/etc/portage/make.conf}} to include support for system specific setups: 

{{FileBox|filename=make.conf|title=Preparing to install Dracut|lang=bash|1=<pre>
DRACUT_MODULES="dmraid lvm syslog -biosdevname -btrfs -caps -crypt -crypt-gpg
-dmsquash-live -gensplash -iscsi -livenet -mdraid -multipath -nbd -nfs -plymouth
-ssh-client"
</pre>
}}

It is advisable to set (or unset) the modules needed. After configuring the <var>DRACUT_MODULES</var> variable in {{Path|/etc/portage/make.conf}}, {{c|emerge dracut}} to install the Dracut utility. 

The next step is to configure {{c|dracut}} by editing {{Path|/etc/dracut.conf}}. In the configuration file, which is well commented, in order to add support for needed modules.

Once configured, create an initramfs by calling {{c|dracut}} as follows: 

{{RootCmd|dracut}}

The resulting image supports generic system boots based on the configuration in {{Path|/etc/dracut.conf}}. It is also possible to generate an initramfs specifically tailored to ''your'' system (which {{c|dracut}} tries to detect the needed tools, drivers, etc. from the existing system). If the modules and drivers are built into the kernel (not as separate modules and references to the firmware), then the <code>--no-kernel</code> option can be added: 

{{RootCmd|dracut --host-only --no-kernel}}

For more information, check out the dracut and dracut.cmdline manual pages:
{{Cmd
|man dracut
|man dracut.cmdline
}}

== さらなる情報 ==

* [[Initramfs]] on the official Gentoo Wiki.
* [[Dracut]] on the official Gentoo Wiki.

== 外部の情報 ==

* The [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt ramfs-rootfs-initramfs.txt] file within the Linux kernel documentation.


[[Category:Initramfs]]
