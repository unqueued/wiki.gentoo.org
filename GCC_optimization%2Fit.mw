<languages />

{{Metadata|abstract=Questa guida costituisce un'introduzione all'ottimizzazione del codice compilato utilizzando valori sicuri per le variabili CFLAGS e CXXFLAGS. Inoltre viene descritta la teoria a fondamento dell'ottimizzazione in generale.}}

Questa guida costituisce un'introduzione all'ottimizzazione del codice compilato utilizzando valori sicuri per le variabili CFLAGS e CXXFLAGS. Inoltre viene descritta la teoria a fondamento dell'ottimizzazione in generale.

== Introduzione ==

=== Cosa sono CFLAGS e CXXFLAGS? ===

CFLAGS e CXXFLAGS sono variabili d'ambiente che vengono utilizzate per comunicare alla GNU Compiler Collection (<code>GCC</code>) quali sono le opzioni da attivare quando viene compilato del codice sorgente. Le CFLAGS si riferiscono al codice sorgente scritto in C mentre le CXXFLAGS si riferiscono al codice sorgente scritto in C++. 

Possono essere usate per ridurre la quantità di messaggi per il debug, per incrementare i livelli dei messaggi di avvertimento e ovviamente per ottimizzare il codice prodotto. Il [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC manuale GCC] contiene una lista completa delle opzioni disponibili, e per ciascuna di esse viene fornita una spiegazione del motivo per cui vengono usate. 

=== Come vengono usate? ===

Le CFLAGS e le CXXFLAGS possono essere utilizzate in due modi. Il primo modo consiste nell'utilizarle a livello di programmi singoli con i Makefile generati da automake. 

Tuttavia ciò non dovrebbe essere fatto quando si installano pacchetti di Portage. È preferibile invece impostare le CFLAGS e le CXXFLAGS nel file {{Path|/etc/portage/make.conf}}. In questo modo tutti i pacchetti vengono compilati usando le stesse impostazioni. 

{{Code|CFLAGS in /etc/portage/make.conf|<pre> CFLAGS="-march=athlon64 -O2 -pipe" CXXFLAGS="${CFLAGS}"
</pre>
}}

{{Important|While it is possible to have multiple lines in USE flags, doing the same in CFLAGS can and will result in problems with programs such as <code>CMake</code>. Make sure your CFLAGS declaration is on a single line, with as little whitespace as possible to avoid those issues. See {{Bug|500034}} as an example.}}

Come è possibile vedere le CXXFLAGS sono state impostate con le stesse opzioni presenti nelle CFLAGS. Si tratta della configurazione più sicura, e in genere non dovrebbe mai sorgere la necessità di specificare opzioni diverse per le CXXFLAGS.

=== Convinzioni errate ===

Anche se le CFLAGS e le CXXFLAGS possono essere un modo molto valido per ottenere codice binario più piccolo o più veloce esse, se utilizzate in modo errato, possono anche compromettere la funzionalità del codice stesso, aumentare a dismisura le sue dimensioni, ridurre drasticamente le prestazioni o anche provocare errori di compilazione! 

Le CFLAGS non sono una panacea ad ogni male: non rendono sempre il sistema dell'utente più veloce e non riducono sempre le dimensioni del codice binario. Aggiungere sempre più flag nell'intento di ottimizzare sempre più il sistema conduce sicuramente al fallimento. C'è un punto oltre al quale si ottengono miglioramenti ogni volta più scarsi. 

A dispetto di certe informazioni che è possibile trovare su Internet, CFLAGS e CXXFLAGS aggressive fanno solitamente più male che bene alla maggior parte dei programmi. Occorre tenere presente che molte opzioni sono state progettate per essere usate in situazioni particolari e per ragioni specifiche. Il fatto che una certa opzione sia positiva per una determinata porzione di codice non significa che tale opzione sia per questo adatta ad essere utilizzata globalmente per compilare tutti i programmi del sistema! 

=== Pronto? ===

Adesso che il lettore è stato informato dei possibili rischi è possibile esaminare alcune ottimizzazioni sicure, utilizzando le quali si ha l'approvazione degli sviluppatori quando si segnala un problema su [http://bugs.gentoo.org Bugzilla]. Gli sviluppatori di solito richiedono all'utente di ricompilare il pacchetto problematico con un insieme ridotto di CFLAGS per vedere se il problema persiste. Si ricordi che opzioni aggressive possono rovinare il codice. 

== Ottimizzazione ==

=== Le basi ===

Lo scopo che ci si pone utilizzando le CFLAGS e le CXXFLAGS è di creare codice su misura per il sistema dell'utente; tale sistema dovrebbe funzionare perfettamente ed essere anche snello e veloce, se possibile. Alcune volte queste ultime due condizioni si escludono a vicenda, e pertanto ci si limiterà ad utilizzare una combinazione nota per funzionare molto bene. Idealmente si tratta della migliore combinazione per ogni architettura di CPU. Verrà fatta menzione delle opzioni aggressive più tardi in modo tale che l'utente possa sapere cosa bisogna evitare. Non verrà discussa ogni opzione presente nel manuale di <code>GCC</code> (ce ne sono centinaia) ma verranno spiegate solo le opzioni fondamentali e quelle più comuni. 

{{Note/it|Qualora non si fosse sicuri del significato di una certa opzione si consulti il capitolo giusto del [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manuale GCC]. Se si fosse ancora incerti provare ad effettuare una ricerca con Google oppure controllare le  [http://gcc.gnu.org/lists.html mailing list] di GCC.}}

=== -march ===

La più importante opzione è <code>-march</code>. Questa comunica al compilatore di produrre codice per una certa [http://it.wikipedia.org/wiki/Microarchitettura architettura] di processori. CPU diverse possiedono diverse funzionalità, supportano diversi insiemi di istruzioni e hanno diverse modalità di eseguire il codice. L'opzione <code>-march</code> indica al compilatore di produrre codice specifico per una data CPU, considerando tutte le sue funzionalità, gli insiemi di istruzioni e le modalità di eseguire il codice. 

Anche se la variabile CHOST nel file {{Path|/etc/portage/make.conf}} specifica già l'architettura generica da utilizzare, <code>-march</code> dovrebbe comunque essere utilizzata anch'essa in modo da ottimizzare il codice per uno specifico processore. In particolare sono le CPU x86 e x86-64 che dovrebbero utilizzare l'opzione <code>-march</code>. 

Quale CPU si possiede? Per scoprirlo, si esegua il seguente comando: 

{{Cmd|cat /proc/cpuinfo}}

Questo è un esempio per un vecchio Pentium III: 

{{Code|/etc/portage/make.conf: Pentium III|<pre>
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Questo è invece un esempio per una CPU AMD a 64-bit: 

{{Code|/etc/portage/make.conf: AMD64|<pre>
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Se non si è sicuri di sapere quale CPU si possiede ci si può semplicemente limitare ad utilizzare l'opzione <code>-march=native</code>. Con questa opzione GCC determina automaticamente di quale processore si dispone e imposta di conseguenza le opzioni più appropriate. '''Questa opzione, tuttavia, non dovrebbe essere utilizzata qualora si intenda compilare pacchetti per una CPU differente!''' 

Se il lettore sta compilando pacchetti su un certo computer ma intende eseguirli su un computer diverso (ad esempio nel caso in cui si dispone di un computer veloce che compila pacchetti da utilizzare su un'altro computer più lento) ''non'' bisogna utilizzare l'opzione <code>-march=native</code>. ''Native'' significa che il codice prodotto da una certa CPU potrà essere eseguito ''solo'' su quel tipo di CPU. Le applicazioni compilate con <code>-march=native</code> su una CPU AMD Athlon 64 non potranno essere eseguite su una vecchia CPU VIA C3. 

Esistono anche le opzioni <code>-mtune</code> e <code>-mcpu</code>. Esse sono normalmente utilizzate quando l'opzione <code>-march</code> non è disponibile; i processori di alcune architetture possono richiedere <code>-mtune</code> o addirittura <code>-mcpu</code>. Sfortunatamente il comportamento di <code>GCC</code> non è molto consistente se ci si sposta da un'architettura ad un'altra. 

Per CPU x86 o x86-64 <code>-march</code> genera codice specifico per una data CPU usando gli insiemi di istruzioni disponibili e la corretta ABI; non viene garantita la compatibilità con CPU diverse o con CPU più vecchie. Se non si necessita di eseguire codice su un sistema diverso da quello sul quale è presente Gentoo si può continuare ad utilizzare <code>-march</code>. Il lettore dovrebbe considerare l'utilizzo di <code>-mtune</code> solamente se abbia la necessità di generare codice per CPU quali i386 o i486. <code>-mtune</code> produce codice più generico che nel caso di <code>-march</code>; anche se ottimizza il codice per una certa CPU non prende in considerazione gli insiemi di istruzioni o l'ABI disponibile. Non utilizzare <code>-mcpu</code> su sistemi x86 o x86-64 in quanto è obsoleta su queste architetture. 

Solo CPU diverse da x86/x86-64 (come Sparc, Alpha e PowerPC) possono richiedere <code>-mtune</code> o <code>-mcpu</code> invece che <code>-march</code>. Su queste architetture <code>-mtune</code> e <code>-mcpu</code> si comportano a volte allo stesso modo di <code>-march</code> su architettura x86/x86-64, e cambia solo il nome. Si ricordi ancora una volta che il comportamento di <code>GCC</code> non è consistente su tutte le architetture, e che pertanto occorre controllare il [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manuale] per determinare quali opzioni bisogna utilizzare sul proprio sistema. 

{{Note/it|Per ulteriori esempi relativi all'impostazione di <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> si legga il capitolo 5 del [http://www.gentoo.org/doc/it/handbook/ manuale Gentoo] corrispondende alla propria architettura. Si legga anche la [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options lista] delle opzioni che dipendono dall'architettura sul manuale di <code>GCC</code>.}}

=== -O ===

La prossima variabile da considerare è <code>-O</code>. Essa permette di controllare il livello complessivo di ottimizzazione. Con <code>-O</code> la compilazione del codice richiede un po' più di tempo e potrebbe richiedere molta più memoria, specialmente se si innalza il livello di ottimizzazione. 

Esistono sette possibili impostazioni per <code>-O</code>: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code> e <code>-Ofast</code>. Occorre scegliere solo una tra le precendenti impostazioni e applicarla nel file {{Path|/etc/portage/make.conf}}. 

Con la sola eccezione di <code>-O0</code>, ciascuna delle impostazioni <code>-O</code> attiva alcune opzioni aggiuntive. Assicurarsi quindi di leggere il capitolo del manuale GCC sulle [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options opzioni per l'ottimizzazione] per capire quali opzioni vengono attivate per ciascuno dei livelli <code>-O</code> e qual'è la loro funzione. 

Esaminiamo assieme ciascuno dei livelli di ottimizzazione: 

* <code>-O0</code>: Si noti che si tratta della lettera "O" seguita da uno zero. Questo livello disattiva del tutto l'ottimizzazione del codice ed è la scelta predefinita qualora nessuna opzione <code>-O</code> venga specificata tra le CFLAGS o le CXXFLAGS. <code>-O0</code> riduce i tempi per la compilazione e può migliorare le informazioni per il debug, ma alcune applicazioni potrebbero non funzionare correttamente se l'ottimizzazione è disattivata completamente. Questa opzione non è pertanto consigliata, a meno che la si scelga per effettuare il debug delle applicazioni.

* <code>-O1</code>: Questo è il livello di ottimizzazione base. Con <code>-O1</code> il compilatore prova a produrre codice più veloce e più snello senza richiedere troppo tempo per la compilazione. Si tratta di una opzione piuttosto basilare, ma dovrebbe funzionare in qualsiasi circostanza.

* <code>-O2</code>: È il passo successivo rispetto a <code>-O1</code>. Si tratta del livello di ottimizzazione "raccomandato" a meno di esigenze particolari. <code>-O2</code> attiva alcune ulteriori opzioni rispetto a quelle utilizzate da <code>-O1</code>. Con <code>-O2</code> il compilatore prova ad incrementare le prestazioni del codice prodotto senza richiedere troppo tempo per la compilazione.

* <code>-O3</code>: Questo è il più alto livello di ottimizzazione possibile. Vengono attivate ottimizzazioni che sono costose dal punto di vista del tempo di compilazione e dell'utilizzo di memoria. Compilare con <code>-O3</code> non è un modo sicuro di migliorare le prestazioni del codice; in molti casi si ottiene il rallentamento del sistema a causa del codice binario più grande e dell'utilizzo maggiore di memoria. <code>-O3</code> è anche nota per causare la corruzione di alcuni pacchetti. Per queste ragioni l'utilizzo di <code>-O3</code> non è consigliato.

* <code>-Os</code>: Questa opzione ottimizza il codice dal punto di vista delle sue dimensioni. Essa attiva tutte le opzioni di <code>-O2</code> che non causano l'incrementano delle dimensioni del codice prodotto. <code>-Os</code> può essere utile per macchine che hanno una capacità di archiviazione su disco estremamente limitata o CPU con cache dalla dimensione ridotta.

* <code>-Og</code>: Questa opzione è stata introdotta con GCC 4.8. Essa soddisfa il bisogno di ridurre i tempi della compilazione e quello di migliorare la capacità di effettuare il debug mantenendo però un ragionevole livello prestazionale in fase di esecuzione. Complessivamente con <code>-Og</code> l'attività di sviluppo dovrebbe risultare migliore rispetto a <code>-O0</code>. Si noti che <code>-Og</code> non implica <code>-g</code>; <code>-Og</code> si limita semplicemente a disattivare le ottimizzazioni che hanno ripercussioni negative sull'attività di debug.

* <code>-Ofast</code>: Si tratta di un'opzione introdotta con GCC 4.7. Essa consiste della somma di <code>-O3</code> con <code>-ffast-math</code>, <code>-fno-protect-parens</code> e <code>-fstack-arrays</code>. <code>-Ofast</code> viola la conformità stretta agli standard e pertanto non è consigliata.

Come menzionato precedentemente <code>-O2</code> è il livello di ottimizzazione consigliato. Se un pacchetto crea problemi in fase di compilazione e non si sta utilizzando <code>-O2</code> si riprovi attivando questa opzione. In alternativa provare ad impostare le variabili CFLAGS e CXXFLAGS ad un livello di ottimizzazione più basso, come ad esempio <code>-O1</code> o addirittura <code>-O0 -g2 -ggdb</code>.

=== -pipe ===

Un'opzione piuttosto comune è <code>-pipe</code>. Essa non ha effetti sul codice generato ma rende più rapido il processo di compilazione. <code>-pipe</code> comunica al compilatore di utilizzare pipe al posto di file temporanei durante le varie fasi della compilazione, con la conseguenza di richiedere maggiore memoria. Tale opzione potrebbe causare problemi su sistemi con una disponibilità bassa di memoria perché GCC potrebbe venire terminato. In questo caso si consiglia di non utilizzare questa opzione. 

=== -fomit-frame-pointer ===

Questa è un'opzione molto comune che ha lo scopo di ridurre le dimensioni del codice generato. Essa viene attivata a tutti i livelli <code>-O</code> (eccetto <code>-O0</code>) su quelle architetture, quali x86-64, per le quali questa scelta non ha ripercussioni sull'attività di debug. Il manuale di <code>GCC</code> non spiega su quali architetture <code>-O</code> implichi <code>-fomit-frame-pointer</code>, ma è noto che questa debba essere attivata esplicitamente su x86. In questo caso però il debug del codice diventa difficile o addirittura impossibile da svolgersi. 

In particolare <code>-fomit-frame-pointer</code> rende molto più difficile l'attività di diagnostica delle applicazioni scritte in Java, ma questo non è l'unico linguaggio interessato. Inoltre attivando <code>-fomit-frame-pointer</code> l'attività di debug attraverso le backtrace è impossibile da svolgersi in quanto esse sono del tutto inutilizzabili. Ad ogni modo questa opzione può essere utilizzata se non si ha la necessità di svolgere il debug del software e non si è scelto di attivare opzioni per il debug quale ad esempio <code>-ggdb</code>. 

{{Important/it|''Non'' combinare <code>-fomit-frame-pointer</code> con l'opzione <code>-momit-leaf-frame-pointer</code>. L'uso di quest'ultima è scoraggiato in quanto la prima svolge già da sola la propria funzione in modo corretto. Inoltre <code>-momit-leaf-frame-pointer</code> è nota per avere conseguenze negative sulle prestazioni del codice.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

Queste opzioni attivano sulle architetture x86 e x86-64 gli insiemi di istruzioni [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE], [http://en.wikipedia.org/wiki/SSE2 SSE2], [http://en.wikipedia.org/wiki/SSSE3 SSE3], [http://en.wikipedia.org/wiki/MMX MMX] e [http://en.wikipedia.org/wiki/3dnow 3DNow!]. Tali opzioni sono utili principalmente in ambito multimediale o ludico e per svolgere compiti che richiedono un utilizzo intensivo della virgola mobile. Questi insiemi di istruzioni si trovano soprattutto nelle CPU più moderne. 

{{Important/it|Per assicurarsi che la propria CPU supporti queste opzioni è possibile eseguire il comando <code>cat /proc/cpuinfo</code>. Nell'output vi è la lista degli insiemi di istruzioni supportati. Si noti che '''pni''' sta per SSE3.}}

Normalmente non è necessario aggiungere alcuna di queste opzioni al file {{Path|/etc/portage/make.conf}} a patto di utilizzare l'opzione <code>-march</code> corretta (ad esempio <code>-march=nocona</code> implica <code>-msse3</code>). Alcune eccezioni rilevanti a questa regola sono le CPU VIA e AMD64 più recenti, in quanto esse supportano insiemi di istruzioni, quali SSE3, che <code>-march</code> non include. Se si possiedono tali CPU si consiglia di controllare l'output di <code>cat /proc/cpuinfo</code> e di attivare le opzioni aggiuntive del caso. 

{{Note/it|Il lettore dovrebbe controllare la [http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options lista] delle opzioni specifiche per x86 e x86-64 in modo da capire quali di questi insiemi di istruzioni vengono attivati selezionando l'opzione corretta per la propria CPU. Se un insieme di istruzioni compare nella lista non è necessario specificarlo a mano perché viene attivato automaticamente utilizzando l'impostazione corretta di <code>-march</code>.}}

== Domande frequenti ==

=== Ma ottengo migliori prestazioni con -funroll-loops -fomg-optimize! ===

Non è vero. Si pensa questo solo perché qualcuno ci ha convinto che più opzioni si utilizzano meglio è. Le opzioni aggressive danneggiano le applicazioni se usate globalmente per tutto il sistema. Anche il [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manuale] di <code>GCC</code> dice che usare <code>-funroll-loops</code> e <code>-funroll-all-loops</code> rendono il codice più grosso e più lento. Nonostante ciò queste due opzioni, assieme a <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code> e simili, continuano ad essere molto popolari tra coloro che si vantano delle presunte prestazioni del proprio sistema. 

La verità è che si tratta di opzioni aggressive e pericolose. Si invita il lettore a controllare il [[https://forums.gentoo.org/ forum]] e il [[https://bugs.gentoo.org/ bugzilla]] di Gentoo per vedere quali sono le conseguenze di queste opzioni. Niente di buono! 

Non bisogna aggiungere queste opzioni alle CFLAGS o alle CXXFLAGS. Esse possono indurre il lettore a credere di avere un sistema ad alte prestazioni e all'avanguardia, ma la realtà è che esse danneggiano il codice e costringono gli sviluppatori a chiudere i bug come INVALID o WONTFIX. 

Non c'è bisogno di utilizzare tali opzioni. '''Non usarle'''. Limitarsi alle opzioni di base: <code>-march</code>, <code>-O</code> e <code>-pipe</code>.

=== Livelli per -O maggiori di 3 ===

Alcuni utenti si vantano di ottenere prestazioni maggiori usando <code>-O4</code>, <code>-O9</code> e simili. In realtà i livelli per <code>-O</code> maggiori di 3 non hanno alcun effetto. Il compilatore accetta CFLAGS come <code>-O4</code>, ma in questi casi esso si limita ad applicare le ottimizzazioni del livello <code>-O3</code> e niente di più. 

Per una dimostrazione si esamini il [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup codice sorgente]: 

{{Code|codice sorgente per -O|<pre>
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>
}}

Il lettore può osservare che i valori maggiori di 3 sono trattati allo stesso modo che per <code>-O3</code>.

=== Opzioni ridondanti ===

Spesso le CFLAGS e le CXXFLAGS che sono attivate ai vari livelli di <code>-O</code> vengono specificate in modo ridondante nel file {{Path|/etc/portage/make.conf}}. Alcune volte lo si fa per ignoranza, ma in altri casi lo scopo è quello di aggirare la sostituzione o il filtraggio delle opzioni. 

Il filtraggio e la sostituzione delle opzioni vengono svolti da molti ebuild. Solitamente lo si fa perché alcuni pacchetti non possono essere compilati a determinati livelli di <code>-O</code>, oppure perché il codice sorgente è troppo sensibile per permettere l'uso di opzioni aggiuntive. Tali ebuild possono filtrare alcune CFLAGS/CXXFLAGS o possono sostituire <code>-O</code> con un livello differente. 

Il [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] spiega nel dettaglio in che modo funziona il filtraggio e la sostituzione delle opzioni e dove essi hanno luogo. 

È possibile aggirare il filtraggio delle opzioni attivate ad un certo livello di <code>-O</code>, come ad esempio <code>-O3</code>, nel seguente modo: 

{{Code|Specificare CFLAGS ridondanti|<pre>
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>
}}

Questa, tuttavia, '''non è affatto una buona idea'''. Le CFLAGS sono filtrate per una ragione ben precisa! Tali opzioni vengono filtrate perché altrimenti non si è sicuri di riuscire a compilare un pacchetto correttamente. Ovviamente ''non'' è sicuro compilare l'intero sistema con <code>-O3</code> se alcune delle opzioni attivate da tale livello causano problemi con certi pacchetti. Il lettore non dovrebbe cercare di "raggirare" gli sviluppatori che mantengono questi pacchetti. ''Occorre fidarsi degli sviluppatori''. Il filtraggio e la sostituzione delle opzioni viene fatto ad esclusivo vantaggio dell'utente finale. Se un ebuild specifica opzioni alternative non bisogna pertanto provare ad aggirarle. 

Se si sceglie di compilare un pacchetto con opzioni inaccettabili è molto probabile che si avranno ulteriori problemi successivamente. Quando l'utente segnala un problema sul Bugzilla le opzioni che si usano in {{Path|/etc/portage/make.conf}} sono chiaramente visibili a tutti e gli sviluppatori chiederanno senz'altro di ricompilare il pacchetto senza le opzioni problematiche. Si può evitare il fastidio di dover ricompilare tali pacchetti se si evita in primo luogo di utilizzare opzioni ridondanti in questa maniera. Non si deve assumere di saperne di più rispetto agli sviluppatori.

=== LDFLAGS ===

Gli sviluppatori Gentoo hanno già scelto un insieme minimo e sicuro di LDFLAGS nei profili di base, pertanto non è necessario che l'utente vada a modificarle. 

=== Opzioni specifiche per un singolo pacchetto ===

{{Warning/it|Utilizzare opzioni specifiche per un singolo pacchetto rende più complicato il debug e l'assistenza. Se si sceglie di continuare per questa strada e si vuole segnalare un problema agli sviluppatori si faccia esplicito riferimento al fatto che si sta utilizzando questa funzionalità, e si indichino inoltre le modifiche che sono state apportate.}}

Le informazioni su come sia possibile applicare variabili d'ambiente (inclusa CFLAGS) ai singoli pacchetti sono descritte nel [http://www.gentoo.org/doc/it/handbook/handbook-amd64.xml?part=3&chap=6#doc_chap2 manuale Gentoo ("Variabili d'ambiente per pacchetto")].

== Risorse ==

Le seguenti risorse sono utili per approfondire ulteriormente il tema dell'ottimizzazione: 

* La [http://gcc.gnu.org/onlinedocs/ documentazione per GCC] 

* Capitolo 5 del [http://www.gentoo.org/doc/it/handbook/ Manuale Gentoo] 

* <code>man make.conf</code>

* [https://it.wikipedia.org/ Wikipedia]

* I [https://forums.gentoo.org/ forum Gentoo]

== Ringraziamenti ==

Si ringraziano le seguenti persone per i contributi apportati a questa guida:

* nightmorph
