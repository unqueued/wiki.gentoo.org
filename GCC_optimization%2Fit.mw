<languages />

{{Metadata|abstract=Questa guida costituisce un'introduzione all'ottimizzazione del codice compilato utilizzando valori sicuri per le variabili CFLAGS e CXXFLAGS. Inoltre viene descritta la teoria a fondamento dell'ottimizzazione in generale.}}

Questa guida costituisce un'introduzione all'ottimizzazione del codice compilato utilizzando valori sicuri per le variabili <var>CFLAGS</var> e <var>CXXFLAGS</var>. Inoltre viene descritta la teoria a fondamento dell'ottimizzazione in generale.

== Introduzione ==

=== Cosa sono CFLAGS e CXXFLAGS? ===

<var>CFLAGS</var> and <var>CXXFLAGS</var> are among the environment variables conventionally used to specify compiler options to a build system when compiling C and C++ code. While these variables are not standardized, their use is essentially ubiquitous and any correctly written build should understand these for passing extra or custom options when it invokes the compiler. See the [https://www.gnu.org/software/make/manual/make.html#Implicit-Variables GNU make] info page for a list of some of the commonly used variables in this category.

Because such a large proportion of the packages that make up most Gentoo systems are written in C and C++, these are two variables administrators will definitely want to set correctly as they will greatly influence the way much of the system is built.

They can be used to decrease the amount of debug messages for a program, increase error warning levels, and, of course, to optimize the code produced. The [https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC manual] maintains a complete list of available options and their purposes.

=== Come vengono usate? ===

Normally, <var>CFLAGS</var> and <var>CXXFLAGS</var> would be set in the environment when invoking a configure script or with makefiles generated by the {{c|automake}} program. In Gentoo-based systems, set the <var>CFLAGS</var> and <var>CXXFLAGS</var> variables in {{Path|/etc/portage/make.conf}}. Variables set in this file will be exported to the environment of programs invoked by portage such that all packages will be compiled using these options as a base.

{{CodeBox|title=Impstazioni CFLAGS in /etc/portage/make.com|lang=bash|1=CFLAGS="-march=athlon64 -O2 -pipe" CXXFLAGS="${CFLAGS}"
}}

{{Important|While it is possible to have multiple lines in '''USE''' flags, having multiple lines in <var>CFLAGS</var> can and ''will'' result in problems with programs such as {{c|cmake}}. Make sure the <var>CFLAGS</var> declaration is on a single line, with as little whitespace as possible to avoid issues. See {{Bug|500034}} as an example.}}

As seen in the example above the <var>CXXFLAGS</var> variable is set to use all the options present in <var>CFLAGS</var>. Almost every system should be configured in this manner. Additional options for <var>CXXFLAGS</var> are less common and don't usually apply generally enough to deserve setting them globally.

{{Tip|[[Safe_CFLAGS|Safe CFLAGS]] article might help beginners start optimizing their systems.}}

=== Convinzioni errate ===

While compiler optimizations enabled by various <var>CFLAGS</var> can be an effective means of producing smaller and/or faster binaries, they can also impair the function of the code, bloat its size, slow down its execution time, or simply cause a build failure. The point of diminishing performance returns is reached rather quickly when dealing with <var>CFLAGS</var>. Don't set them arbitrarily.

Remember, the global <var>CFLAGS</var> configured in {{Path|/etc/portage/make.conf}} will be applied to every package on the system so administrators typically only set general, widely-applicable options. Individual packages further modify these options either in the ebuild or the build system itself to generate the final set of flags used when invoking the compiler.

=== Pronto? ===

Being aware of the risks involved, take a look at some sane, safe optimizations. These will hold in good stead and will be endearing to developers the next time a problem  is reported on [https://bugs.gentoo.org/ Bugzilla]. (Developers will usually request the user to recompile a package with minimal <var>CFLAGS</var> to see if the problem persists. Remember: aggressive flags can ruin code!) 

== Ottimizzazione ==

=== Le basi ===

The goal behind <var>CFLAGS</var> and <var>CXXFLAGS</var> is to create code tailor-made to the system; it should function perfectly while being lean and fast, if possible. Sometimes these conditions are mutually exclusive, so this guide will stick to combinations known to work well. Ideally, they are the best available for any CPU architecture. For informational purposes, aggressive flag use will be covered later. Not every option listed on the GCC manual (there are hundreds) will be discussed, but basic, most common flags will be reviewed. 

{{Note|When unaware of what a flag does refer to the relevant chapter of the [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual]. If still stumped after viewing the manual, try a search engine or check out the [https://gcc.gnu.org/lists.html GCC mailing lists].}}

=== -march ===

The first and most important option is <code>-march</code>. This tells the compiler what code it should produce for the system's [https://en.wikipedia.org/wiki/Microarchitecture processor architecture] (or ''arch''); it tells GCC that it should produce code for a certain kind of CPU. Different CPUs have different capabilities, support different instruction sets, and have different ways of executing code. The <code>-march</code> flag will instruct the compiler to produce specific code for the system's CPU, with all its capabilities, features, instruction sets, quirks, and so on provided the source code is prepared to use them. For instance, to take benefit from AVX instructions, the source code needs to be adapted to support it.

<code>-march=</code> is an ISA selection option; it tells the compiler that it may use the instructions from the ISA. On an Intel/AMD64 platform with <code>-march=native -O2</code> or lower OPT level, the code will likely end up with AVX instructions used but using shorter SSE XMM registers. To take full advantage of AVX YMM registers, the <code>-ftree-vectorize</code>, <code>-O3</code> or <code>-Ofast</code> options should be used as well<ref>GNU GCC Bugzilla, [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57952#c8 AVX/AVX2 no ymm registers used in a trivial reduction]. Retrieved on 2017/07/18.</ref>.

<code>-ftree-vectorize</code> is an optimization option (default at <code>-O3</code> and <code>-Ofast</code>), which attempts to vectorize loops using the selected ISA if possible.  The reason it isn't enabled at <code>-O2</code> is that it doesn't always improve code, it can make code slower as well, and usually makes the code larger; it really depends on the loop etc. 

Even though the <var>CHOST</var> variable in {{Path|/etc/portage/make.conf}} specifies the general architecture used, <code>-march</code> should still be used so that programs can be optimized for the system specific processor. x86 and x86-64 CPUs (among others) should make use of the <code>-march</code> flag. 

What kind of CPU does the system have? To find out, run the following command: 

{{Cmd|cat /proc/cpuinfo}}

or even install {{Package|app-portage/cpuinfo2cpuflags}} and add the available CPU-specific options to the {{Path|make.conf}} file, which the tool does through e.g. the [[CPU FLAGS X86|CPU_FLAGS_X86]] variable:

{{Cmd|cpuinfo2cpuflags-x86 >> /etc/portage/make.conf}}

Per ottenere maggiori dettagli, inclusi i valori di <code>march</code> e <code>mtune</code>, si possono usare due comandi:

* Il primo comanda dice al compilatore di non effettuare alcun link (<code>-c</code>), ed invece di interpretare l'opzione <code>--help</code> per dettagliare le opzioni della linea di comando, mostra se certe opzioni sono abilitate o disabilitate (<code>-Q</code>). In questo caso, le opzioni mostrate sono abilitate per il target selezionato.:
: {{Cmd|gcc -c -Q -march{{=}}native --help{{=}}target}}

* The second command will show the compiler directives for building the header file, but without actually performing the steps and instead showing them on the screen (<code>-###</code>). The final output line is the command that holds all the optimization options and architecture selection:
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

Si veda <code>-march</code> in azione. Questo è un esempio per un vecchio processore Pentium III: 

{{FileBox|filename=/etc/portage/make.conf|title=Esempio Pentium III|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

Questo è invece un esempio per una CPU AMD a 64-bit: 

{{FileBox|filename=/etc/portage/make.conf|title=Esempio AMD64|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

Se il tipo di CPU è indeterminato, o se l'utente non sa quali impostazioni scegliere, è possibile usare l'opzione <code>-march=native</code>. Con questa opzione GCC proverà a determinare automaticamente di quale processore si dispone, impostando di conseguenza le opzioni più appropriate. '''Questa opzione, tuttavia, non dovrebbe essere utilizzata qualora si intenda compilare pacchetti per una CPU differente!''' 

{{Warning|Do '''not''' use <code>-march{{=}}native</code> or <code>-mtune{{=}}native</code> in the <var>CFLAGS</var> or <var>CXXFLAGS</var> variables of {{Path|make.conf}} when compiling with {{c|[[Distcc#-march.3Dnative|distcc]]}}.}}

If compiling packages on one computer in order to run them on a different computer (such as when using a fast computer to build for an older, slower machine), then ''do not'' use <code>-march=native</code>. "Native" means that the code produced will run ''only'' on that type of CPU. The applications built with <code>-march=native</code> on an AMD Athlon 64 CPU will '''not''' be able to run on an old VIA C3 CPU. 

Also available are the <code>-mtune</code> and <code>-mcpu</code> flags. These flags are normally only used when there is no available <code>-march</code> option; certain processor architectures may require <code>-mtune</code> or even <code>-mcpu</code>. Unfortunately, GCC's behavior isn't very consistent with how each flag behaves from one architecture to the next. 

On x86 and x86-64 CPUs, <code>-march</code> will generate code specifically for that CPU using its available instruction sets and the correct ABI; it will have no backwards compatibility for older/different CPUs. Consider using <code>-mtune</code> when generating code for older CPUs such as i386 and i486. <code>-mtune</code> produces more generic code than <code>-march</code>; though it will tune code for a certain CPU, it does not take into account available instruction sets and ABI. Do not use <code>-mcpu</code> on x86 or x86-64 systems, as it is deprecated for those arches. 

Only non-x86/x86-64 CPUs (such as SPARC, Alpha, and PowerPC) may require <code>-mtune</code> or <code>-mcpu</code> instead of <code>-march</code>. On these architectures, <code>-mtune</code> / <code>-mcpu</code> will sometimes behave just like <code>-march</code> (on x86/x86-64) but with a different flag name. Again, GCC's behavior and flag naming is not consistent across architectures, so be sure to check the GCC [https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] to determine which one should be used. 

{{Note|For more suggested <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> settings, please read chapter 5 of the appropriate [[HandBook:Main_Page|Gentoo Installation Handbook]] for the arch. Also, read the GCC manual's list of [https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options], as well as more detailed explanations about the differences between <code>-march</code>, <code>-mcpu</code>, and <code>-mtune</code>.}}

=== -O ===

Next up is the <code>-O</code> variable. This variable controls the overall level of optimization. Changing this value will make the code compilation take more time and will use much more memory, especially as the level of optimization is increased. 

There are seven <code>-O</code> settings: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code>, and <code>-Ofast</code>. Only use one of them in {{Path|/etc/portage/make.conf}}.

With the exception of <code>-O0</code>, the <code>-O</code> settings each activate several additional flags, so be sure to read the GCC manual's chapter on [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimization options] to learn which flags are activated at each <code>-O</code> level, as well as some explanations as to what they do. 

Let us examine each optimization level: 

*  <code>-O0</code>: This level (that is the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in <var>CFLAGS</var> or <var>CXXFLAGS</var>. This reduces compilation time and can improve debugging info, but some applications will not work properly without optimization enabled. This option is not recommended except for debugging purposes.

*  <code>-O1</code>: the most basic optimization level. The compiler will try to produce faster, smaller code without taking much compilation time. It is basic, but it should get the job done all the time.

*  <code>-O2</code>: A step up from <code>-O1</code>. The ''recommended'' level of optimization unless the system has special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code>. With <code>-O2</code>, the compiler will attempt to increase code performance without compromising on size, and without taking too much compilation time. SSE or AVX may be be utilized at this level but no YMM registers will be used unless <code>-ftree-vectorize</code> is also enabled.

*  <code>-O3</code>: the highest level of optimization possible. It enables optimizations that are expensive in terms of compile time and memory usage.  Compiling with <code>-O3</code> is not a guaranteed way to improve performance, and in fact, in many cases, can slow down a system due to larger binaries and increased memory usage. <code>-O3</code> is also known to break several packages. Using <code>-O3</code> is not recommended. However, it also enables <code>-ftree-vectorize</code> so that loops in the code get vectorized and will use AVX YMM registers.

*  <code>-Os</code>: optimizes code for size. It activates all <code>-O2</code> options that do not increase the size of the generated code. It can be useful for machines that have extremely limited disk storage space and/or CPUs with small cache sizes.

* <code>-Og</code>: Questa opzione è stata introdotta con GCC 4.8. Essa soddisfa il bisogno di ridurre i tempi della compilazione e quello di migliorare la capacità di effettuare il debug mantenendo però un ragionevole livello prestazionale in fase di esecuzione. Complessivamente con <code>-Og</code> l'attività di sviluppo dovrebbe risultare migliore rispetto a <code>-O0</code>. Si noti che <code>-Og</code> non implica <code>-g</code>; <code>-Og</code> si limita semplicemente a disattivare le ottimizzazioni che hanno ripercussioni negative sull'attività di debug.

* <code>-Ofast</code>: Si tratta di un'opzione introdotta con GCC 4.7. Essa consiste della somma di <code>-O3</code> con <code>-ffast-math</code>, <code>-fno-protect-parens</code> e <code>-fstack-arrays</code>. <code>-Ofast</code> viola la conformità stretta agli standard e pertanto non è consigliata.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and while not using <code>-O2</code>, try rebuilding with that option. As a fallback option, try setting the <var>CFLAGS</var> and <var>CXXFLAGS</var> to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).

=== -pipe ===

A common flag is <code>-pipe</code>. This flag has no effect on the generated code, but it makes the compilation process ''faster''. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, GCC might get killed. In those cases do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but it may need to be activated. In that case add it to the flags. Though the GCC manual does not specify all architectures, it is turned on by using the <code>-O</code> option. It's still necessary to explicitly enable the <code>-fomit-frame-pointer</code> option, to activate it on x86-32 with GCC up to version 4.6, or when using <code>-Os</code> on x86-32 with any version of GCC. However, using <code>-fomit-frame-pointer</code> will make debugging hard or impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. When not doing software debugging and no other debugging-related <var>CFLAGS</var> such as <code>-ggdb</code> have been used, then try using <code>-fomit-frame-pointer</code>. 

{{Important/it|''Non'' combinare <code>-fomit-frame-pointer</code> con l'opzione <code>-momit-leaf-frame-pointer</code>. L'uso di quest'ultima è scoraggiato in quanto la prima svolge già da sola la propria funzione in modo corretto. Inoltre <code>-momit-leaf-frame-pointer</code> è nota per avere conseguenze negative sulle prestazioni del codice.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extensions] (SSE), [https://en.wikipedia.org/wiki/SSE2 SSE2], [https://en.wikipedia.org/wiki/SSSE3 SSE3], [https://en.wikipedia.org/wiki/MMX_(instruction_set) MMX], and [https://en.wikipedia.org/wiki/3DNow! 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to see if the CPU supports these instruction sets by running {{c|cat /proc/cpuinfo}}. The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

Normally none of these flags need to be added to {{Path|/etc/portage/make.conf}}, as long as the system is using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code>). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these additional flags will need to be enabled where appropriate after checking {{Path|/proc/cpuinfo}}. 

{{Note|Check the [https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags] to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then it does not need to be separately specified; it will be turned on by using the proper <code>-march</code> setting.}}

== Domande frequenti ==

=== Ma ottengo migliori prestazioni con -funroll-loops -fomg-optimize! ===

No, people only ''think'' they do because someone has convinced them that more flags are better. Aggressive flags will only hurt applications when used system-wide. Even the GCC [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> will make code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

La verità è che si tratta di opzioni aggressive e pericolose. Si invita il lettore a controllare il [[https://forums.gentoo.org/ forum]] e il [[https://bugs.gentoo.org/ bugzilla]] di Gentoo per vedere quali sono le conseguenze di queste opzioni. Niente di buono! 

These flags are not needed globally in <var>CFLAGS</var> or <var>CXXFLAGS</var>. They will only hurt performance. They might bring on the idea of having a high-performance system running on the bleeding edge, but they don't do anything but bloat the code and get bugs marked INVALID or WONTFIX. 

Dangerous flags like these are not needed. '''Don't use them'''. Stick to the basics: <code>-march</code>, <code>-O</code>, and <code>-pipe</code>.

=== Livelli per -O maggiori di 3 ===

Some users boast about even better performance obtained by using <code>-O4</code>, <code>-O9</code>, and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept <var>CFLAGS</var> like <code>-O4</code>, but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code>, nothing more. 

Need more proof? Examine the [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup source code]: 

{{CodeBox|title=-O source code|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

As can be seen, any value higher than 3 is treated as just <code>-O3</code>.

=== What about compiling outside the target machine? ===

Some readers might wonder if compiling outside the target machine with a strictly inferior CPU or GCC sub-architecture will result in inferior optimization results (compared to a native compilation). The answer is simple: '''No'''.  Regardless of the actual hardware on which the compilation takes place and the CHOST for which GCC was built, as long as the same arguments are used <small>(except for <code>-march=native</code>)</small> and the same version of GCC is used <small>(although minor version might be different)</small>, the resulting optimizations are strictly the same.

To exemplify, if Gentoo is installed on a machine whose GCC's CHOST is ''i686-pc-linux-gnu'', and a [[Distcc]] server is setup on another computer whose GCC's CHOST is ''i486-linux-gnu'', then there is no need to be afraid that the results would be less optimal because of the strictly inferior sub-architecture of the remote compiler and/or hardware. The result would be as optimized as a native build, as long as the same options are passed to both compilers (and the <code>-march</code> parameter doesn't get a <code>native</code> argument).  In this particular case the target architecture needs to be specified explicitly as explained in [[Distcc#-march.3Dnative|Distcc and -march=native]].

The only difference in behavior between two GCC versions built targeting different sub-architectures is the implicit default argument for the <code>-march</code> parameter, which is derived from the GCC's CHOST when not explicitly provided in the command line.

=== Opzioni ridondanti ===

Oftentimes <var>CFLAGS</var> and <var>CXXFLAGS</var> that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}}. Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all <var>CFLAGS</var> and <var>CXXFLAGS</var>, or it may replace <code>-O</code> with a different level. 

The [https://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] outlines where and how flag filtering/replacing works. 

È possibile aggirare il filtraggio delle opzioni attivate ad un certo livello di <code>-O</code>, come ad esempio <code>-O3</code>, nel seguente modo: 

{{CodeBox|title=Specifying redundant CFLAGS|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

However, '''this is not a smart thing to do'''. <var>CFLAGS</var> are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile the whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, don't try to "outsmart" the developers who maintain those packages. ''Trust the developers''. Flag filtering and replacing is done to ensure stability of the system and application! If an ebuild specifies alternative flags, then don't try to get around it. 

Building packages with unacceptable flags will most likely lead to problems. When reporting problems on Bugzilla, the flags that are used in {{Path|/etc/portage/make.conf}} will be readily visible and developers will ask to recompile without those flags. Save the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume to be more knowledgeable than the developers.

=== LDFLAGS ===

The Gentoo developers have already set basic, safe <var>LDFLAGS</var> in the base profiles, so they do not need to be changed.

=== Opzioni specifiche per un singolo pacchetto ===

{{Warning|Using per-package flags complicates debugging and support. Make sure to mention the use of this feature in the bug reports together with the changes made.}}

Information on how to use per-package environment variables (including <var>CFLAGS</var>) is described in the [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]].

== See also ==

* [[Handbook:AMD64/Installation/Stage#Configuring_compile_options|Configuring compile options]] (AMD64 Handbook)

== Risorse ==

Le seguenti risorse sono utili per approfondire ulteriormente il tema dell'ottimizzazione: 

* The [https://gcc.gnu.org/onlinedocs/ GCC online documentation] 

* <kbd>man make.conf</kbd>

* [https://it.wikipedia.org/ Wikipedia]

* I [https://forums.gentoo.org/ forum Gentoo]

== References ==

{{reflist}}

{{Migrated|originalauthors={{Dev|nightmorph}}}}


[[Category:Compilation]]
