<languages />

{{Metadata|abstract=Questa guida fornisce un'introduzione all'ottimizzazione del codice compilato utilizzando valori sicuri per le variabili CFLAGS e CXXFLAGS. Inoltre, descrive la teoria a fondamento dell'ottimizzazione in generale.}}

Questa guida fornisce un'introduzione all'ottimizzazione del codice compilato utilizzando valori sicuri per le variabili <var>CFLAGS</var> e <var>CXXFLAGS</var>. Inoltre viene descritta la teoria a fondamento dell'ottimizzazione in generale.

== Introduzione ==

=== Cosa sono CFLAGS e CXXFLAGS? ===

<var>CFLAGS</var> e <var>CXXFLAGS</var> sono due tra le variabili d'ambiente che vengono convenzionalmente utilizzate per specificare opzioni di compilazione ad un sistema in via di costruzione quando si compila codice C e C++. Benché queste variabili non siano standardizzate, il loro uso è essenzialmente ubiquitario e qualunque build scritta corettamente dovrebbe capire queste variabili per passare opzioni extra o personalizzate quando invoca il compilatore. Vedere la pgina di informazioni [https://www.gnu.org/software/make/manual/make.html#Implicit-Variables GNU make] per una lista di alcune delle variabili più usate inq uesta categoria.

Poiché la maggior parte dei pacchetti che costituiscono i sistemi Gentoo sono scritti in C e C++, queste sono due variabili che gli amministratori dovranno impostare correttamente, in quanto eserciteranno una grande influenza su come il sistema verrà costruito.

Possono essere usate per ridurre la quantità di messaggi per il debug per un programma, per incrementare i livelli dei messaggi di avvertimento e, ovviamente, per ottimizzare il codice prodotto. Il [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC manuale GCC] contiene una lista completa delle opzioni disponibili, e per ciascuna di esse viene fornita una spiegazione del motivo per cui vengono usate.

=== Come vengono usate? ===

Normalmente, <var>CFLAGS</var> e <var>CXXFLAGS</var> verrebbero inizializzate nell'ambiente al momento dell'invocazione di uno script configure o con Makefile generati da {{c|automake}}. Nei sistemi basati su Gentoo, le variabili <var>CFLAGS</var> e <var>CXXFLAGS</var> vengono impostate nel file {{Path|/etc/portage/make.conf}}. Le variabili impostate in questo file verranno esportate nell'ambiente dei programmi invocati da portage, in modo tale che tutti i pacchetti vengano compilati usano quelle opzioni come base.

{{CodeBox|title=Impostazioni CFLAGS in /etc/portage/make.conf|lang=bash|1=CFLAGS="-march=athlon64 -O2 -pipe" CXXFLAGS="${CFLAGS}"
}}

{{Important/it|Nonostante sia consentito scrivere le '''USE''' flag su più righe, lo stesso non si può dire per quanto riguarda le <var>CFLAGS</var>, perché ciò può portare a problemi vari, per esempio con programmi com {{c|cmake}}. Per evitare tali problemi occorre assicurarsi che la dichiarazione delle <var>CFLAGS</var> sia posta su una singola riga e che non vi siano troppi spazi bianchi. Vedere ad esempio il {{Bug|500034}}.}}

Come è possibile vedere nell'esempio di cui sopra, la variabile <var>CXXFLAGS</var> è configurata in modo da usare le stesse opzioni presenti nelle <var>CFLAGS</var>. La maggior parte dei sistemi dovrebbe essere configurata in questa maniera. Le opzioni aggiuntive in <var>CXXFLAGS</var> sono meno comuni e non si dovrebbe configurarle globalmente.

{{Tip|L'articolo [[Safe_CFLAGS|CFLAGS sicure]] potrebbe essere di aiuto ai principianti per iniziare ad ottimizzare i loro sistemi.}}

=== Convinzioni errate ===

Anche se le variabili <var>CFLAGS</var> e <var>CXXFLAGS</var> possono essere un modo molto valido per produrre codice binario più piccolo o più veloce, se utilizzate in modo errato, possono anche compromettere la funzionalità del codice stesso, aumentare a dismisura le sue dimensioni, ridurre drasticamente le prestazioni. La loro configurazione errata può anche provocare errori di compilazione. La soglia di diminuzione delle prestazioni viene raggiunta piuttosto velocemente quando si ha a che fare con le <var>CFLAGS</var>. Non è consigliabile configurarle arbitrarialmente.

È bene ricordare che la variabile globale <var>CFLAGS</var> configurata in {{Path|/etc/portage/make.conf}} verrà applicata ad ogni pacchetto nel sistema, pertanto gli amministratori configureranno solo opzioni generali e applicabili su vasta scala. I pacchetti modificano ulteriormente queste opzioni individualmente nell'ebuild o nel sistema compilato stesso per generare l'insieme di flag finale usato quando si invoca il compilatore.

=== Pronto? ===

Adesso che il lettore è stato informato dei possibili rischi, è possibile esaminare alcune ottimizzazioni sicure, utilizzando le quali si ha l'approvazione degli sviluppatori quando si segnala un problema su [http://bugs.gentoo.org Bugzilla]. (Gli sviluppatori di solito richiedono all'utente di ricompilare il pacchetto problematico con un insieme ridotto di CFLAGS per vedere se il problema persiste. Si ricordi che opzioni aggressive possono rovinare il codice!) 

== Ottimizzazione ==

=== Le basi ===

Lo scopo che ci si pone utilizzando le CFLAGS e le CXXFLAGS è di creare codice su misura per il sistema dell'utente; tale sistema dovrebbe funzionare perfettamente ed essere anche snello e veloce, se possibile. Alcune volte queste ultime due condizioni si escludono a vicenda, e pertanto questa guida si limiterà ad utilizzare combinazioni note per funzionare bene. Idealmente, si tratta delle migliori combinazioni per ogni architettura di CPU. Verrà fatta menzione delle opzioni aggressive più in là, in modo tale che l'utente possa sapere cosa bisogna evitare. Non verrà discussa ogni opzione presente nel manuale di <code>GCC</code> (ce ne sono centinaia) ma verranno spiegate solo le opzioni fondamentali e quelle più comuni. 

{{Note/it|Qualora non si fosse sicuri del significato di una certa opzione si consulti il capitolo giusto del [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manuale GCC]. Se si fosse ancora incerti, provare ad effettuare una ricerca su Internet oppure controllare le  [http://gcc.gnu.org/lists.html mailing list] di GCC.}}

=== -march ===

La prima e più importante opzione è <code>-march</code>. Questa comunica al compilatore di produrre codice per una certa [https://it.wikipedia.org/wiki/Microarchitettura architettura] di processori (o "arch"); essenzialmente, dice a GCC di produrre codice per un certo tipo di CPU. CPU diverse possiedono diverse funzionalità, supportano diversi insiemi di istruzioni e hanno diverse modalità di esecuzione del codice. L'opzione <code>-march</code> indica al compilatore di produrre codice specifico per una data CPU, considerando tutte le sue funzionalità, caratteristiche, insiemi di istruzioni, stranezze, e così via, a patto che il codice sorgente sia pronto per utilizzarle. Per esempio, per sfruttare al meglio le istruzioni AVX, il codice sorgente deve essere adattato per supportarle.

<code>-march=</code> è un'opzione di selezione ISA; indica al compilatore che potrebbe usare le istruzioni dall'ISA. Su una piattaforma Intel/AMD64 con <code>-march=native -O2</code> o livello OPT inferiore, il codice finirà per utilizzare istruzioni AVX con registri SSE XMM più brevi. Per sfruttare al meglio i registri AVX YMM, si dovrebbero usare anche le opzioni <code>-ftree-vectorize</code>, <code>-O3</code> o <code>-Ofast</code><ref>GNU GCC Bugzilla, [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57952#c8 AVX/AVX2 nessun registro ymm usato in una riduzione banale]. Consultato il 18/07/2017.</ref>.

<code>-ftree-vectorize</code> è un'opzione di ottimizzazione (predefinita a <code>-O3</code> e <code>-Ofast</code>), che tenta di vettorializzare i cicli usando l'ISA selezionata se possibile. La ragione per cui non viene abilitata con <code>-O2</code> è che non sempre migliora il codice: infatti, può renderlo più lento, e solitamente più grande; dipende da vari fattori, come ad esempio dal tipo di ciclo, etc. 

Anche se la variabile <var>CHOST</var> nel file {{Path|/etc/portage/make.conf}} specifica già l'architettura generica da utilizzare, <code>-march</code> dovrebbe comunque essere utilizzata anch'essa in modo da ottimizzare il codice per uno specifico processore. In particolare sono le CPU x86 e x86-64 (fra le altre) che dovrebbero utilizzare l'opzione <code>-march</code>. 

Quale CPU è presente nel sistema? Per scoprirlo, si esegua il seguente comando: 

{{Cmd|cat /proc/cpuinfo}}

oppure installare {{Package|app-portage/cpuid2cpuflags}} e aggiungere le opzioni specifiche della CPU al file {{Path|make.conf}}, cosa che viene fatta dallo strumento  per esempio tramite la variabile [[CPU FLAGS X86|CPU_FLAGS_X86]]:

{{RootCmd|cpuinfo2cpuflags-x86|output=<pre>
CPU_FLAGS_X86: aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3</pre>}}

{{RootCmd|echo "CPU_FLAGS_X86{{=}}'aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3'" >> /etc/portage/make.conf}}

Per ottenere maggiori dettagli, compresi i valori di <code>march</code> e <code>mtune</code>, si possono usare due comandi.

* Il primo comando dice al compilatore di non effettuare alcun link (<code>-c</code>), e invece di interpretare l'opzione <code>--help</code> per dettagliare le opzioni della linea di comando, mostra se certe opzioni sono abilitate o disabilitate (<code>-Q</code>). In questo caso, le opzioni mostrate sono abilitate per il target selezionato:
: {{Cmd|gcc -c -Q -march{{=}}native --help{{=}}target}}

* Il secondo comando mostra le direttive del compilatore per la costruzione del file header, ma senza effettuare effettivamente le operazioni e mostrandole invece sullo schermo (<code>-###</code>). L'output completo è il comando che contiene tutte le opzioni di ottimizzazione e la selezione dell'architettura: 
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

Si veda ora <code>-march</code> in azione. Questo è un esempio per un vecchio processore Pentium III: 

{{FileBox|filename=/etc/portage/make.conf|title=Esempio Pentium III|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

Questo è invece un esempio per una CPU AMD a 64 bit: 

{{FileBox|filename=/etc/portage/make.conf|title=Esempio AMD64|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

Se il tipo di CPU è indeterminato, o se l'utente non sa quali impostazioni scegliere, è possibile usare l'opzione <code>-march=native</code>. Quando viene usata questa ozpione, GCC proverà a determinare automaticamente di quale processore si dispone, impostando di conseguenza le opzioni più appropriate. '''Questa opzione, tuttavia, non dovrebbe essere utilizzata qualora si intenda compilare pacchetti per CPU diverse!''' 

{{Warning|'''Non''' usare <code>-march{{=}}native</code> o <code>-mtune{{=}}native</code> nelle variabili <var>CFLAGS</var> o <var>CXXFLAGS</var> del file {{Path|make.conf}} quando si compila con {{c|[[Distcc#-march.3Dnative|distcc]]}}.}}

Se si compilano pacchetti su un computer per poi eseguirli su un computer diverso (ad esempio nel caso in cui si dispone di un computer veloce che compila pacchetti da utilizzare su un vecchio computer più lento), ''non'' bisogna utilizzare l'opzione <code>-march=native</code>. ''Native'' significa che il codice prodotto da una certa CPU potrà essere eseguito ''solo'' su quel tipo di CPU. Le applicazioni compilate con <code>-march=native</code> su una CPU AMD Athlon 64 '''non''' potranno essere eseguite su una vecchia CPU VIA C3. 

Esistono anche le opzioni <code>-mtune</code> e <code>-mcpu</code>. Esse sono normalmente utilizzate quando l'opzione <code>-march</code> non è disponibile; i processori di alcune architetture possono richiedere <code>-mtune</code> o addirittura <code>-mcpu</code>. Sfortunatamente il comportamento di <code>GCC</code> non è molto consistente se ci si sposta da un'architettura ad un'altra. 

Per CPU x86 o x86-64 <code>-march</code> genera codice specifico per una data CPU usando gli insiemi di istruzioni disponibili e la corretta ABI; non viene garantita la compatibilità con CPU diverse o con CPU più vecchie. Si consideri l'utilizzo di <code>-mtune</code> quando si genera codice per CPU più vecchie come le i386 e le i486. <code>-mtune</code> produce codice più generico che nel caso di <code>-march</code>; anche se ottimizza il codice per una certa CPU non prende in considerazione gli insiemi di istruzioni o l'ABI disponibile. Non utilizzare <code>-mcpu</code> su sistemi x86 o x86-64 in quanto è obsoleta su queste architetture. 

Solo CPU diverse da x86/x86-64 (come SPARC, Alpha e PowerPC) possono richiedere <code>-mtune</code> o <code>-mcpu</code> invece che <code>-march</code>. Su queste architetture <code>-mtune</code> e <code>-mcpu</code> si comportano a volte allo stesso modo di <code>-march</code> su architettura x86/x86-64, e cambia solo il nome. Si ricordi ancora una volta che il comportamento di GCC non è consistente su tutte le architetture, e che pertanto occorre controllare il [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manuale] per determinare quali opzioni si dovrebbero usare. 

{{Note/it|Per ulteriori esempi relativi all'impostazione di <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> si legga il capitolo 5 del [[HandBook:Main_Page|Manuale di installazione di Gentoo]] corrispondende alla propria architettura. Si legga anche la lista del manuale di[https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options opzioni specifiche dell'architettura], e anche le spiegazioni dettagliate circa le differenze tra <code>-march</code>, <code>-mcpu</cpu>, e <code>-mtune</code>.}}

=== -O ===

La prossima variabile da considerare è <code>-O</code>. Questa variabile permette di controllare il livello complessivo di ottimizzazione. Cambiare questo valore risulterà in un tempo di compilazione maggiore e in un utilizzo maggiore di memoria, specialmente se si innalza il livello di ottimizzazione. 

Esistono sette possibili impostazioni per <code>-O</code>: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code> e <code>-Ofast</code>. Sceglierne solamente una tra esse nel file {{Path|/etc/portage/make.conf}}.

Con la sola eccezione di <code>-O0</code>, ciascuna delle impostazioni <code>-O</code> attiva alcune opzioni aggiuntive. Assicurarsi quindi di leggere il capitolo del manuale GCC sulle [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options opzioni per l'ottimizzazione] per capire quali opzioni vengono attivate per ciascuno dei livelli <code>-O</code> e qual è la loro funzione. 

Esaminiamo ora ciascuno dei livelli di ottimizzazione: 

* <code>-O0</code>: Questo livello (che consiste nella lettera "O" seguita da uno zero) disattiva interamente l'ottimizzazione del codice ed è la scelta predefinita qualora nessuna opzione <code>-O</code> venga specificata in <var>CFLAGS</var> o <var>CXXFLAGS</var>. Ciò riduce i tempi per la compilazione e può migliorare le informazioni per il debug, ma alcune applicazioni potrebbero non funzionare correttamente se l'ottimizzazione è disattivata completamente. Questa opzione non è pertanto consigliata, a meno che la si scelga per effettuare il debug delle applicazioni.

* <code>-O1</code>: Questo è il livello di ottimizzazione base. Con <code>-O1</code> il compilatore prova a produrre codice più veloce e più snello senza richiedere troppo tempo per la compilazione. Si tratta di una opzione basilare, ma che dovrebbe funzionare in qualsiasi circostanza.

* <code>-O2</code>: È il passo successivo rispetto a <code>-O1</code>. Si tratta del livello di ottimizzazione "raccomandato" a meno di esigenze particolari. <code>-O2</code> attiva alcune ulteriori opzioni rispetto a quelle utilizzate da <code>-O1</code>. Con <code>-O2</code> il compilatore prova ad incrementare le prestazioni del codice prodotto senza richiedere troppo tempo per la compilazione. In questo livello potrebbero essere utilizzate SSE o AVX ma nessun registro YMM verrà usato a meno che non venga abilitato anche <code>-ftree-vectorize</code>.

* <code>-O3</code>: Questo è il più alto livello di ottimizzazione possibile. Vengono attivate ottimizzazioni che sono costose dal punto di vista del tempo di compilazione e dell'utilizzo di memoria. Compilare con <code>-O3</code> non è un modo sicuro di migliorare le prestazioni del codice; in molti casi si ottiene il rallentamento del sistema a causa del codice binario più grande e dell'utilizzo maggiore di memoria. <code>-O3</code> è anche nota per causare la corruzione di alcuni pacchetti. Usare <code>-O3</code> non è raccomandato. Tuttavia, abilita anche <code>-ftree-vectorize</code> in modo tale che i cicli nel codice diventino vettorializzati e userà i registri AVX YMM.

* <code>-Os</code>: ottimizza il codice dal punto di vista delle dimensioni. Attiva tutte le opzioni di <code>-O2</code> che non causano l'incrementano delle dimensioni del codice prodotto. <code>-Os</code> può essere utile per macchine che hanno una capacità di archiviazione su disco estremamente limitata o CPU con cache dalla dimensione ridotta.

* <code>-Og</code>: Questa opzione è stata introdotta con GCC 4.8. Essa soddisfa il bisogno di ridurre i tempi della compilazione e quello di migliorare la capacità di effettuare il debug mantenendo però un ragionevole livello prestazionale in fase di esecuzione. Complessivamente con <code>-Og</code> l'attività di sviluppo dovrebbe risultare migliore rispetto a <code>-O0</code>. Si noti che <code>-Og</code> non implica <code>-g</code>; <code>-Og</code> si limita semplicemente a disattivare le ottimizzazioni che hanno ripercussioni negative sull'attività di debug.

* <code>-Ofast</code>: Si tratta di un'opzione introdotta con GCC 4.7. Essa consiste della somma di <code>-O3</code> con <code>-ffast-math</code>, <code>-fno-protect-parens</code> e <code>-fstack-arrays</code>. <code>-Ofast</code> viola la conformità stretta agli standard e pertanto non è consigliata.

Come menzionato precedentemente <code>-O2</code> è il livello di ottimizzazione consigliato. Se la compilazione di un pacchetto fallisce e non si sta utilizzando <code>-O2</code>, si riprovi attivando questa opzione. In alternativa, provare ad impostare le variabili <var>CFLAGS</var> e <var>CXXFLAGS</var> ad un livello di ottimizzazione più basso, come ad esempio <code>-O1</code> o addirittura <code>-O0 -g2 -ggdb</code> (per la segnalazione di errori e il controllo di possibili problemi).

=== -pipe ===

Un'opzione piuttosto comune è <code>-pipe</code>. Essa non ha effetti sul codice generato ma rende ''più rapido'' il processo di compilazione. <code>-pipe</code> comunica al compilatore di utilizzare pipe al posto di file temporanei durante le varie fasi della compilazione, con la conseguenza di richiedere maggiore memoria. Tale opzione potrebbe causare problemi su sistemi con una disponibilità bassa di memoria, perché GCC potrebbe venire terminato. In questo caso si consiglia di non utilizzare questa opzione. 

=== -fomit-frame-pointer ===

Questa è un'opzione molto comune che ha lo scopo di ridurre le dimensioni del codice generato. Essa viene attivata a tutti i livelli <code>-O</code> (eccetto <code>-O0</code>) su quelle architetture, quali x86-64, per le quali questa scelta non ha ripercussioni sull'attività di debug. Benché il manuale di GCC non specifichi tutte le architetture, è attivato utilizzando  l'opzione <code>-O</code>. È necessario esplicitare <code>-fomit-frame-pointer</code>, per attivarlo su x86-32 con GCC fino alla versione 4.6, o quando si usa <code>-Os</code> su x86-32 con qualunque versione di GCC. Tuttavia, utilizzando <code>-fomit-frame-pointer</code>, il debug del codice diventa difficile o addirittura impossibile da svolgersi. 

In particolare, rende molto più difficile l'attività di diagnostica delle applicazioni scritte in Java, ma questo non è l'unico linguaggio interessato. Inoltre attivando <code>-fomit-frame-pointer</code> l'attività di debug attraverso le backtrace è impossibile da svolgersi in quanto esse sono del tutto inutilizzabili. Se non si effettua il debug di programmi e non vengono usate altre variabili <var>CFLAGS</var> relative al debug, come per esempio <code>-ggdb</code>, allora si può tentare di usare <code>-fomit-frame-pointer</code>. 

{{Important/it|''Non'' combinare <code>-fomit-frame-pointer</code> con l'opzione <code>-momit-leaf-frame-pointer</code>. L'uso di quest'ultima è scoraggiato in quanto la prima svolge già da sola la propria funzione in modo corretto. Inoltre <code>-momit-leaf-frame-pointer</code> è nota per avere conseguenze negative sulle prestazioni del codice.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extensions] (SSE), [https://en.wikipedia.org/wiki/SSE2 SSE2], [https://en.wikipedia.org/wiki/SSSE3 SSE3], [https://en.wikipedia.org/wiki/MMX_(instruction_set) MMX], and [https://en.wikipedia.org/wiki/3DNow! 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to see if the CPU supports these instruction sets by running {{c|cat /proc/cpuinfo}}. The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

Normally none of these flags need to be added to {{Path|/etc/portage/make.conf}}, as long as the system is using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code>). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these additional flags will need to be enabled where appropriate after checking {{Path|/proc/cpuinfo}}. 

{{Note|Check the [https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags] to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then it does not need to be separately specified; it will be turned on by using the proper <code>-march</code> setting.}}

== Domande frequenti ==

=== Ma ottengo migliori prestazioni con -funroll-loops -fomg-optimize! ===

No, people only ''think'' they do because someone has convinced them that more flags are better. Aggressive flags will only hurt applications when used system-wide. Even the GCC [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> will make code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

La verità è che si tratta di opzioni aggressive e pericolose. Si invita il lettore a controllare il [[https://forums.gentoo.org/ forum]] e il [[https://bugs.gentoo.org/ bugzilla]] di Gentoo per vedere quali sono le conseguenze di queste opzioni. Niente di buono! 

These flags are not needed globally in <var>CFLAGS</var> or <var>CXXFLAGS</var>. They will only hurt performance. They might bring on the idea of having a high-performance system running on the bleeding edge, but they don't do anything but bloat the code and get bugs marked INVALID or WONTFIX. 

Dangerous flags like these are not needed. '''Don't use them'''. Stick to the basics: <code>-march</code>, <code>-O</code>, and <code>-pipe</code>.

=== Livelli per -O maggiori di 3 ===

Some users boast about even better performance obtained by using <code>-O4</code>, <code>-O9</code>, and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept <var>CFLAGS</var> like <code>-O4</code>, but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code>, nothing more. 

Need more proof? Examine the [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup source code]: 

{{CodeBox|title=-O source code|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

As can be seen, any value higher than 3 is treated as just <code>-O3</code>.

===Che dire della compilazione all'esterno della macchina bersaglio?===

Alcuni lettori potrebbero chiedersi se compilare fuori dalla macchina bersaglio con una CPU od un'architettura GCC strettamente inferiori possa portare a risultati di ottimizzazione inferiori (in confronto ad una compilazione nativa). La risposta è semplicemente: '''No'''. A prescindere dall'hardware effettivo su cui avviene la compilazione e dal CHOST per cui GCC è stato costruito, finché vengono usati gli stessi argomenti <small>(eccezion fatta per <code>-march=native</code>)</small> e la stessa versione di GCC <small>(benché la versione minore possa essere diversa)</small>, le ottimizzazioni risultatni sono esattamente le stesse.

Per riportare un esempio, se Gentoo viene installato su una macchina il cui CHOST GCC è ''i686-pc-linux-gnu'', e viene installato un server [[Distcc]] su un altro computer il cui CHOST GCC è ''i486-linux-gnu'', allora non c'è bisogno di aver timore di ottenere risultati meno ottimali, a causa della sub-architettura strettamente inferiore del compilatore e/o dell'hardware remoti. Il risultato sarebbe ottimizzato al pari di una compilazione nativa, a patto che vengano passate le stesse opzioni ad ambo i compilatori (e che il parametro <code>-march</code> non riceva un argomento <code>native</code>). In questo caso particolare, è necessario specificare esplicitamente  l'architettura bersaglio, come spiegato in [[Distcc#-march.3Dnative|Distcc e -march=native]].

La sola differenza nel comportamento tra le due versioni di GCC costruite avendo come bersaglio diverse sub-architetture consiste nell'argometno implicito predefinito per il parametro <code>-march</code>, che è derivato dal CHOST di GCC quando non è esplicitamente fornito da linea di comando.

=== Opzioni ridondanti ===

Spesso le <var>CFLAGS</var> e le <var>CXXFLAGS</var> che sono attivate ai vari livelli di <code>-O</code> vengono specificate in modo ridondante nel file {{Path|/etc/portage/make.conf}}. Alcune volte lo si fa per ignoranza, ma in altri casi lo scopo è quello di aggirare la sostituzione o il filtraggio delle opzioni. 

Il filtraggio e la sostituzione delle opzioni vengono svolti da molti ebuild. Solitamente lo si fa perché alcuni pacchetti non possono essere compilati a determinati livelli di <code>-O</code>, oppure perché il codice sorgente è troppo sensibile per permettere l'uso di opzioni aggiuntive. Tali ebuild possono filtrare alcune <var>CFLAGS</var> e <var>CXXFLAGS</var> o possono sostituire <code>-O</code> con un livello differente. 

Il [https://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] spiega nel dettaglio in che modo funziona il filtraggio e la sostituzione delle opzioni e dove essi hanno luogo. 

È possibile aggirare il filtraggio delle opzioni attivate ad un certo livello di <code>-O</code>, come ad esempio <code>-O3</code>, nel seguente modo: 

{{CodeBox|title=Specificare CFLAGS ridondanti|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

Questa, tuttavia, '''non è affatto una buona idea'''. Le <var>CFLAGS</var> sono filtrate per una ragione ben precisa! Tali opzioni vengono filtrate perché altrimenti non si è sicuri di riuscire a compilare un pacchetto correttamente. Ovviamente ''non'' è sicuro compilare l'intero sistema con <code>-O3</code> se alcune delle opzioni attivate da tale livello causano problemi con certi pacchetti. Il lettore non deve cercare di "raggirare" gli sviluppatori che mantengono questi pacchetti. ''Occorre fidarsi degli sviluppatori''. Il filtraggio e la sostituzione delle opzioni viene fatto per assicurare la stabilità del sistema e delle applicazioni. Se un'ebuild specifica opzioni alternative non bisogna pertanto provare ad aggirarle. 

Se si sceglie di compilare un pacchetto con opzioni inaccettabili è molto probabile che si avranno ulteriori problemi successivamente. Quando l'utente segnala un problema su Bugzilla, le opzioni che si usano in {{Path|/etc/portage/make.conf}} sono chiaramente visibili a tutti e gli sviluppatori chiederanno senz'altro di ricompilare il pacchetto senza le opzioni problematiche. Si può evitare il fastidio di dover ricompilare tali pacchetti se si evita in primo luogo di utilizzare opzioni ridondanti in questa maniera! Non si deve assumere di saperne di più rispetto agli sviluppatori.

=== LDFLAGS ===

Gli sviluppatori Gentoo hanno già scelto un insieme minimo e sicuro di <var>LDFLAGS</var> nei profili di base, pertanto non è necessario modificarle.

=== Opzioni specifiche per un singolo pacchetto ===

{{Warning/it|Utilizzare opzioni specifiche per un singolo pacchetto rende più complicato il debug e l'assistenza. Se si sceglie di continuare per questa strada e si vuole segnalare un problema agli sviluppatori si faccia esplicito riferimento al fatto che si sta utilizzando questa funzionalità, e si indichino inoltre le modifiche che sono state apportate.}}

Information on how to use per-package environment variables (including <var>CFLAGS</var>) is described in the [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]].

== Vedere anche ==

* [[Handbook:AMD64/Installation/Stage#Configuring_compile_options|Configurazione delle opzioni di compilazione]] (Manuale AMD64)

== Risorse esterne ==

Le seguenti risorse sono utili per approfondire ulteriormente il tema dell'ottimizzazione: 

* La [http://gcc.gnu.org/onlinedocs/ documentazione online per GCC] 

* {{c|man make.conf}}

* [https://it.wikipedia.org/ Wikipedia]

* I [https://forums.gentoo.org/ forum Gentoo]

== Riferimenti ==

{{reflist}}

{{Migrated|originalauthors={{Dev|nightmorph}}}}


[[Category:Compilation]]
