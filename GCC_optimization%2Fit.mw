<languages />

{{Metadata|abstract=Questa guida fornisce un'introduzione all'ottimizzazione del codice compilato utilizzando valori sicuri per le variabili CFLAGS e CXXFLAGS. Inoltre, descrive la teoria a fondamento dell'ottimizzazione in generale.}}

Questa guida fornisce un'introduzione all'ottimizzazione del codice compilato utilizzando valori sicuri per le variabili <var>CFLAGS</var> e <var>CXXFLAGS</var>. Inoltre viene descritta la teoria a fondamento dell'ottimizzazione in generale.

== Introduzione ==

=== Cosa sono CFLAGS e CXXFLAGS? ===

<var>CFLAGS</var> e <var>CXXFLAGS</var> sono due tra le variabili d'ambiente che vengono convenzionalmente utilizzate per specificare opzioni di compilazione ad un sistema in via di costruzione quando si compila codice C e C++. Benché queste variabili non siano standardizzate, il loro uso è essenzialmente ubiquitario e qualsiasi build (compilazione) scritta correttamente dovrebbe venire a conoscenza di queste variabili per fornire opzioni extra o personalizzazioni quando si invoca il compilatore. Vedere la pagina delle informazioni [https://www.gnu.org/software/make/manual/make.html#Implicit-Variables GNU make] per una lista di alcune delle variabili più usate in questa categoria.

Poiché la maggior parte dei pacchetti che costituiscono i sistemi Gentoo sono scritti in C e C++, queste sono due variabili che gli amministratori dovranno impostare correttamente, in quanto eserciteranno una grande influenza sul modo in cui verrà costruito il sistema.

Possono essere usate per ridurre la quantità di messaggi di debug per un programma, per incrementare i livelli dei messaggi di avvertimento e, ovviamente, per ottimizzare il codice prodotto. Il [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC manuale GCC] contiene una lista completa delle opzioni disponibili e dei loro scopi.

=== Come vengono usate? ===

Normalmente, <var>CFLAGS</var> e <var>CXXFLAGS</var> verrebbero inizializzate nell'ambiente al momento dell'invocazione di uno script configure o con Makefile generati da {{c|automake}}. Nei sistemi basati su Gentoo, le variabili <var>CFLAGS</var> e <var>CXXFLAGS</var> vengono impostate nel file {{Path|/etc/portage/make.conf}}. Le variabili impostate in questo file verranno esportate nell'ambiente dei programmi invocati da portage, in modo tale che tutti i pacchetti vengano compilati usando quelle opzioni di base.

{{CodeBox|title=Impostazioni CFLAGS in /etc/portage/make.conf|lang=bash|1=CFLAGS="-march=athlon64 -O2 -pipe" CXXFLAGS="${CFLAGS}"
}}

{{Important/it|Nonostante sia consentito scrivere le '''USE''' flag su più righe, fare altrettanto con <var>CFLAGS</var> può comportare problemi e ''sarà'' problematico per quei programmi come {{c|cmake}}. Per evitare problemi occorre assicurarsi che la dichiarazione delle <var>CFLAGS</var> stia su un'unica riga, con il minor numero di spazi possibile. Vedere ad esempio il {{Bug|500034}}.}}

Come è possibile vedere nell'esempio sopra, la variabile <var>CXXFLAGS</var> è configurata in modo da usare le stesse opzioni presenti su <var>CFLAGS</var>. La maggior parte dei sistemi dovrebbe essere configurato in questa maniera. Le opzioni aggiuntive in <var>CXXFLAGS</var> sono meno comuni e non si dovrebbero impostare globalmente.

{{Tip|L'articolo [[Safe_CFLAGS|CFLAGS sicure]] potrebbe essere di aiuto ai principianti per iniziare ad ottimizzare i loro sistemi.}}

=== Fraintendimenti ===

Anche se le variabili <var>CFLAGS</var> e <var>CXXFLAGS</var> possono essere un modo valido per produrre codice binario più piccolo o più veloce, se utilizzate in modo errato, possono compromettere la funzionalità del codice stesso, aumentare a dismisura le sue dimensioni, ridurre drasticamente le prestazioni. La loro configurazione errata può anche provocare errori di compilazione. La soglia di riduzione delle prestazioni viene raggiunta piuttosto rapidamente quando si armeggia con le <var>CFLAGS</var>. Non si impostino arbitrariamente.

È bene ricordare che la variabile globale <var>CFLAGS</var> configurata in {{Path|/etc/portage/make.conf}} verrà applicata ad ogni pacchetto del sistema, pertanto gli amministratori configureranno solo opzioni generali e applicabili su vasta scala. I singoli pacchetti modificano ulteriormente queste opzioni sia nell'ebuild che nel sistema compilato stesso per generare l'insieme finale di flag da usare quando si invoca il compilatore.

=== Pronto? ===

Ora che si è stati avvisati dei possibili rischi, diamo uno sguardo ad alcune equilibrate e sicure ottimizzazioni. Queste vi manterranno entro condizioni ottimali e saranno gradite agli sviluppatori quando ci sarà occasione di segnalare un problema su [http://bugs.gentoo.org Bugzilla]. (Gli sviluppatori di solito richiedono all'utente di ricompilare il pacchetto con un insieme ridotto di <var>CFLAGS</var> per vedere se il problema persiste. Si ricordi che opzioni aggressive possono rovinare il codice!) 

== Ottimizzazione ==

=== Le basi ===

Lo scopo che ci si pone utilizzando le CFLAGS e le CXXFLAGS è di creare codice su misura per il sistema dell'utente; tale sistema dovrebbe funzionare perfettamente ed essere anche snello e veloce, se possibile. Alcune volte queste ultime due condizioni si escludono a vicenda, e pertanto questa guida si limiterà ad utilizzare combinazioni note per funzionare bene. Idealmente, si tratta delle migliori combinazioni per ogni architettura di CPU. Verrà fatta menzione delle opzioni aggressive più in là, in modo tale che l'utente possa sapere cosa bisogna evitare. Non verrà discussa ogni opzione presente nel manuale di <code>GCC</code> (ce ne sono centinaia) ma verranno spiegate solo le opzioni fondamentali e quelle più comuni. 

{{Note/it|Qualora non si fosse sicuri del significato di una certa opzione si consulti il capitolo giusto del [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manuale GCC]. Se si fosse ancora incerti, provare ad effettuare una ricerca su Internet oppure controllare le  [http://gcc.gnu.org/lists.html mailing list] di GCC.}}

=== -march ===

La prima e più importante opzione è <code>-march</code>. Questa comunica al compilatore di produrre codice per una certa [https://it.wikipedia.org/wiki/Microarchitettura architettura di processori] (o ''arch''); essenzialmente dice a GCC di produrre codice per un certo tipo di CPU. CPU diverse possiedono diverse funzionalità, supportano diversi insiemi di istruzioni e hanno diverse modalità di esecuzione del codice. L'opzione <code>-march</code> indica al compilatore di produrre codice specifico per la CPU del sistema, con tutte le sue funzionalità, caratteristiche, insiemi di istruzioni, stranezze, e così via, purché il codice sorgente sia pronto per utilizzarle. Per esempio, per trarre beneficio dalle istruzioni AVX, il codice sorgente deve essere adattato per supportarle.

<code>-march=</code> è un'opzione di selezione ISA; indica al compilatore che potrebbe usare le istruzioni dall'ISA. Su una piattaforma Intel/AMD64 con <code>-march=native -O2</code> o un livello OPT inferiore, il codice probabilmente verrà concluso con le istruzioni AVX presenti ma servendosi di registri SSE XMM più brevi. Per sfruttare al meglio i registri AVX YMM, si dovrebbero usare anche le opzioni <code>-ftree-vectorize</code>, <code>-O3</code> o <code>-Ofast</code><ref>GNU GCC Bugzilla, [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57952#c8 AVX/AVX2 nessun registro YMM usato in una riduzione banale]. Consultato il 18/07/2017.</ref>.

<code>-ftree-vectorize</code> è un'opzione di ottimizzazione (predefinita con <code>-O3</code> e <code>-Ofast</code>), che tenta di vettorializzare i cicli usando l'ISA selezionata se possibile. La ragione per cui non viene abilitata con <code>-O2</code> è che non sempre migliora il codice, può renderlo anche più lento, e solitamente più grande; ciò dipende da vari fattori, come anche dal tipo di ciclo, ecc. 

Anche se la variabile <var>CHOST</var> nel file {{Path|/etc/portage/make.conf}} specifica l'architettura generale utilizzata, <code>-march</code> dovrebbe comunque essere utilizzata così che i programmi possano essere ottimizzati per il processore specifico sul sistema. In particolare, le CPU x86 e x86-64 (fra le altre) dovrebbero utilizzare l'opzione <code>-march</code>. 

Quale CPU è presente nel sistema? Per scoprirlo, si esegua il seguente comando: 

{{Cmd|cat /proc/cpuinfo}}

oppure installare {{Package|app-portage/cpuid2cpuflags}} e aggiungere le opzioni specifiche della CPU al file {{Path|make.conf}}, cosa che viene fatta dallo strumento  per esempio tramite la variabile [[CPU FLAGS X86|CPU_FLAGS_X86]]:

{{RootCmd|cpuinfo2cpuflags-x86|output=<pre>
CPU_FLAGS_X86: aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3</pre>}}

{{RootCmd|echo "CPU_FLAGS_X86{{=}}'aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3'" >> /etc/portage/make.conf}}

Per ottenere maggiori dettagli, compresi i valori di <code>march</code> e <code>mtune</code>, si possono usare due comandi.

* Il primo comando dice al compilatore di non effettuare alcun collegamento (<code>-c</code>), ed invece di interpretare l'opzione <code>--help</code> per fornire chiarimenti sulle opzioni da linea di comando, mostra quali opzioni sono abilitate o disabilitate (<code>-Q</code>). In questo caso, le opzioni mostrate sono quelle abilitate per l'obiettivo (target) selezionato:
: {{Cmd|gcc -c -Q -march{{=}}native --help{{=}}target}}

* Il secondo comando mostrerà le direttive del compilatore per la costruzione del file header, ma senza effettuare le operazioni piuttosto mostrandole solamente sullo schermo (<code>-###</code>). La linea dell'output finale è il comando che contiene tutte le opzioni di ottimizzazione più l'architettura selezionata:
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

Si veda ora <code>-march</code> in azione. Questo è un esempio per un vecchio processore Pentium III: 

{{FileBox|filename=/etc/portage/make.conf|title=Esempio Pentium III|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

Invece questo esempio è per una CPU AMD a 64 bit: 

{{FileBox|filename=/etc/portage/make.conf|title=Esempio AMD64|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

Se il tipo di CPU è indeterminato, o se l'utente non sa quale impostazione scegliere, è possibile usare l'opzione <code>-march=native</code>. Quando viene usata questa opzione, GCC proverà a rilevare il processore ed impostare automaticamente le opzioni più appropriate. '''Tuttavia, questa opzione non deve essere usata se l'intento è quello di compilare pacchetti per CPU diverse!''' 

{{Warning/it|'''Non''' usare <code>-march{{=}}native</code> o <code>-mtune{{=}}native</code> nelle variabili <var>CFLAGS</var> o <var>CXXFLAGS</var> del file {{Path|make.conf}} quando si compila con {{c|[[Distcc#-march.3Dnative|distcc]]}}.}}

Se si compilano pacchetti su un computer per poi eseguirli su un altro computer (ad esempio nel caso in cui si dispone di un computer veloce che compila pacchetti da utilizzare su un computer più datato e lento), ''non'' bisogna utilizzare l'opzione <code>-march=native</code>. ''Native'' significa che il codice prodotto da una certa CPU potrà essere eseguito ''solo'' su quel tipo di CPU. Le applicazioni compilate con <code>-march=native</code> su una CPU AMD Athlon 64 '''non''' potranno essere eseguite su una vecchia CPU VIA C3. 

Esistono anche le opzioni <code>-mtune</code> e <code>-mcpu</code>. Esse sono solitamente utilizzate solo quando l'opzione <code>-march</code> non è disponibile; le architetture di alcuni processori possono richiedere <code>-mtune</code> o addirittura <code>-mcpu</code>. Sfortunatamente il comportamento di GCC non è molto coerente nel modo in cui ciascuna opzione si comporta passando da un'architettura all'altra. 

Su CPU x86 e x86-64, <code>-march</code> genererà codice specifico per quella CPU usando il suo insieme di istruzioni disponibile ed il corretto ABI; non ci sarà retro compatibilità con CPU più vecchie o differenti. Si consideri l'uso di <code>-mtune</code> quando si genera codice per CPU più vecchie come le i386 e le i486. <code>-mtune</code> produce codice più generico rispetto a <code>-march</code>; sebbene possa accordare il codice per una certa CPU, non tiene conto dell'insieme di istruzioni disponibili e dell'ABI. Non utilizzare <code>-mcpu</code> su sistemi x86 o x86-64 in quanto è deprecato per quelle architetture. 

Solo CPU diverse da x86/x86-64 (come SPARC, Alpha e PowerPC) possono richiedere <code>-mtune</code> o <code>-mcpu</code> invece di <code>-march</code>. Su queste architetture <code>-mtune</code> e <code>-mcpu</code> si comporteranno talvolta come <code>-march</code> (su architettura x86/x86-64) ma con un differente nome opzione. Nuovamente, il comportamento di GCC e la denominazione delle opzioni non è coerente attraverso le varie architetture, dunque per essere sicuri controllare il [https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manuale] di GCC per stabilire ciò che si dovrebbe usare. 

{{Note/it|Per ulteriori suggerimenti sulle impostazioni <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> si legga il capitolo 5 del [[HandBook:Main_Page|Manuale di installazione di Gentoo]] relativo alla propria architettura. Si legga anche la lista dal manuale GCC delle [https://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options opzioni specifiche per le architetture], ed anche le spiegazioni dettagliate riguardo le differenze tra <code>-march</code>, <code>-mcpu</cpu>, e <code>-mtune</code>.}}

=== -O ===

La prossima variabile da considerare è <code>-O</code>. Questa permette di controllare il livello complessivo di ottimizzazione. Cambiare questo valore comporterà un tempo di compilazione maggiore ed un utilizzo di memoria molto più grande, specialmente con l'innalzamento del livello di ottimizzazione. 

Esistono sette possibili impostazioni per <code>-O</code>: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code> e <code>-Ofast</code>. Si scelga solo una tra esse nel file {{Path|/etc/portage/make.conf}}.

Con la sola eccezione di <code>-O0</code>, ciascuna delle impostazioni di <code>-O</code> attiva alcune opzioni aggiuntive. Assicurarsi quindi di leggere il capitolo del manuale GCC sulle [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options opzioni per l'ottimizzazione] per capire quali opzioni vengano attivate con ciascuno dei livelli di <code>-O</code> e qual sia la loro funzione. 

Esaminiamo ora ciascuno dei livelli di ottimizzazione: 

* <code>-O0</code>: questo livello (che consiste nella lettera "O" seguita da uno zero) disattiva interamente l'ottimizzazione del codice ed è la scelta predefinita qualora nessuna opzione <code>-O</code> venga specificata in <var>CFLAGS</var> o <var>CXXFLAGS</var>. Ciò riduce i tempi per la compilazione e può migliorare le informazioni per il debug, ma alcune applicazioni potrebbero non funzionare correttamente se nessuna ottimizzazione è attiva. Pertanto questa scelta è sconsigliata, a meno che lo scopo sia proprio il debug delle applicazioni.

* <code>-O1</code>: è il livello di ottimizzazione base. Il compilatore proverà a produrre codice più veloce e più snello, senza richiedere troppo tempo per la compilazione. Si tratta di un'opzione base, ma dovrebbe fare un buon lavoro in ogni circostanza.

* <code>-O2</code>: è il passo successivo rispetto a <code>-O1</code>. È il livello di ottimizzazione ''raccomandato'', salvo esigenze particolari. <code>-O2</code> attiva alcune ulteriori opzioni rispetto a quelle utilizzate da <code>-O1</code>. Con <code>-O2</code> il compilatore proverà ad incrementare le prestazioni del codice senza comprometterne le dimensioni, e senza richiedere un tempo eccessivo. In questo livello SSE o AVX potrebbero essere utilizzate, ma nessun registro YMM verrà usato a meno che non sia abilitato anche <code>-ftree-vectorize</code>.

* <code>-O3</code>: è il livello di ottimizzazione più alto possibile. Vengono attivate ottimizzazioni costose dal punto di vista del tempo di compilazione e dell'utilizzo di memoria. Compilare con <code>-O3</code> non è un modo sicuro di migliorare le prestazioni del codice; in molti casi si ottiene il rallentamento del sistema a causa di codice binario più grande e dell'utilizzo maggiore di memoria. <code>-O3</code> è anche noto per causare la corruzione di alcuni pacchetti. Usare <code>-O3</code> non è raccomandato. Tuttavia, abilita anche <code>-ftree-vectorize</code> così che i cicli nel codice diventino vettorializzati e saranno usati i registri AVX YMM.

* <code>-Os</code>: ottimizza il codice dal punto di vista delle dimensioni. Attiva tutte le opzioni di <code>-O2</code> che non comportino l'incrementano delle dimensioni del codice prodotto. <code>-Os</code> può essere utile per macchine che hanno una capacità di archiviazione su disco estremamente limitata o CPU con una piccola cache.

* <code>-Og</code>: questa opzione è stata introdotta con GCC 4.8. Essa soddisfa il bisogno di ridurre i tempi della compilazione e quello di migliorare la capacità di effettuare il debug mantenendo però un ragionevole livello prestazionale in fase di esecuzione. Complessivamente con <code>-Og</code> l'attività di sviluppo dovrebbe risultare migliore rispetto a <code>-O0</code>. Si noti che <code>-Og</code> non implica <code>-g</code>; piuttosto si limita semplicemente a disattivare le ottimizzazioni che hanno ripercussioni negative sull'attività di debug.

* <code>-Ofast</code>: si tratta di un'opzione introdotta con GCC 4.7. Essa consiste della somma di <code>-O3</code> con <code>-ffast-math</code>, <code>-fno-protect-parens</code> e <code>-fstack-arrays</code>. Questa opzione viola la rigorosa conformità agli standard e pertanto non è consigliata.

Come menzionato precedentemente <code>-O2</code> è il livello di ottimizzazione raccomandato. Se la compilazione di un pacchetto fallisce e non si stava usando <code>-O2</code>, si riprovi attivando questa opzione. In alternativa, provare ad impostare le variabili <var>CFLAGS</var> e <var>CXXFLAGS</var> ad un livello di ottimizzazione più basso, come ad esempio <code>-O1</code> o addirittura <code>-O0 -g2 -ggdb</code> (per la segnalazione degli errori ed il controllo di possibili problemi).

=== -pipe ===

Un'opzione piuttosto comune è <code>-pipe</code>. Essa non ha effetti sul codice generato ma rende ''più rapido'' il processo di compilazione. Comunica al compilatore di utilizzare le pipe (trasferimento dati) al posto di file temporanei durante le varie fasi della compilazione, la qual cosa utilizzerà più memoria. Tale opzione potrebbe causare problemi su sistemi con poca memoria, perché GCC potrebbe essere terminato. In quest'ultimo caso si sconsiglia di utilizzare tale opzione. 

=== -fomit-frame-pointer ===

Questa è un'opzione molto comune che ha lo scopo di ridurre le dimensioni del codice generato. Essa viene attivata a tutti i livelli di <code>-O</code> (eccetto <code>-O0</code>) su quelle architetture dove ciò non interferisce con il debug (per esempio x86-64), ma potrebbe essere necessario attivare. Benché il manuale di GCC non specifichi tutte le architetture, ciò si attiva usando l'opzione <code>-O</code>. È necessario esplicitare <code>-fomit-frame-pointer</code> per attivarlo su x86-32 con GCC fino alla versione 4.6, o quando si usa <code>-Os</code> su x86-32 con qualunque versione di GCC. Tuttavia, utilizzando <code>-fomit-frame-pointer</code>, il debug del codice diventa molto difficile o addirittura impossibile. 

In particolare, rende la risoluzione dei problemi molto più difficile per le applicazioni scritte in Java, sebbene questo non sia l'unico linguaggio influenzato. Dunque, pur potendo l'opzione essere utile, rende il debug più arduo; in particolare il backtrace (tracciamento dei passi precedenti) risulterà inutilizzabile. Se non si effettua il debug dei programmi e non vengono usate altre variabili <var>CFLAGS</var> relative al debug, come per esempio <code>-ggdb</code>, allora si può tentare di usare <code>-fomit-frame-pointer</code>. 

{{Important/it|''Non'' combinare <code>-fomit-frame-pointer</code> con l'opzione <code>-momit-leaf-frame-pointer</code>. Quest'ultima è sconsigliata in quanto la prima già da sola svolge correttamente il lavoro. Inoltre <code>-momit-leaf-frame-pointer</code> è nota per avere conseguenze negative sulle prestazioni del codice.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

Queste opzioni attivano gli insiemi di istruzioni [https://it.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extensions] (SSE), [https://it.wikipedia.org/wiki/SSE2 SSE2], [https://it.wikipedia.org/wiki/SSSE3 SSE3], [https://it.wikipedia.org/wiki/MMX_(instruction_set) MMX], e [https://it.wikipedia.org/wiki/3DNow! 3DNow!] per le architetture x86 e x86-64. Tali opzioni sono principalmente utili per la multimedialità, i giochi ed altri intensi compiti di calcolo a virgola mobile. Questi insiemi di istruzioni si trovano nelle CPU più moderne. 

{{Important/it|Assicurarsi che la propria CPU supporti queste opzioni eseguendo il comando {{c|cat /proc/cpuinfo}}. L'output include ogni aggiuntivo insieme di istruzioni supportato. Si noti che '''pni''' è solo un nome differente per indicare SSE3.}}

Normalmente nessuna di queste opzioni è necessario aggiungere al file {{Path|/etc/portage/make.conf}}, a patto che il sistema utilizzi l'opzione <code>-march</code> corretta (ad esempio <code>-march=nocona</code> implica <code>-msse3</code>). Alcune eccezioni rilevanti a questa regola sono le CPU VIA e AMD64 più recenti, le quali supportano insiemi di istruzioni non incluse con <code>-march</code> (per esempio SSE3). Per CPU come queste, sarà necessario abilitare opzioni aggiuntive appropriate dopo aver controllato {{Path|/proc/cpuinfo}}. 

{{Note/it|Controllare l'[https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html elenco delle opzioni (flag) specifiche per x86 e x86-64] per vedere quali di questi insiemi di istruzioni vengono correttamente attivati dal tipo di opzione (flag) per la CPU. Se un insieme di istruzioni compare nella lista, non serve specificarlo separatamente; verrà abilitato attraverso la corretta impostazione di <code>-march</code>.}}

== Domande frequenti ==

=== Ma ottengo migliori prestazioni con -funroll-loops -fomg-optimize! ===

Non è vero. Si ''pensa'' questo solo perché qualcuno ci ha convinto che più opzioni si utilizzano meglio è. Le opzioni aggressive danneggiano le applicazioni se usate globalmente per tutto il sistema. Anche il [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manuale] di GCC dice che usare <code>-funroll-loops</code> e <code>-funroll-all-loops</code> rendono il codice più grosso e più lento. Nonostante ciò queste due opzioni, assieme a <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code> e simili, continuano ad essere molto popolari tra coloro che si vantano delle presunte prestazioni del proprio sistema. 

La verità è che si tratta di opzioni aggressive e pericolose. Si invita il lettore a controllare il [https://forums.gentoo.org/ forum] e il [https://bugs.gentoo.org/ bugzilla] di Gentoo per vedere quali sono le conseguenze di queste opzioni. Niente di buono! 

Non bisogna aggiungere queste opzioni alle <var>CFLAGS</var> o alle <var>CXXFLAGS</var>. Esse possono indurre il lettore a credere di avere un sistema ad alte prestazioni e all'avanguardia, ma la realtà è che esse danneggiano il codice e costringono gli sviluppatori a chiudere i bug come INVALID o WONTFIX. 

Opzioni pericolose come queste non sono necessarie. '''Non si usino'''. Limitarsi alle opzioni di base: <code>-march</code>, <code>-O</code> e <code>-pipe</code>.

=== Riguardo ai livelli per -O maggiori di 3? ===

Alcuni utenti si vantano di ottenere prestazioni maggiori usando <code>-O4</code>, <code>-O9</code> e simili. In realtà i livelli per <code>-O</code> maggiori di 3 non hanno alcun effetto. Il compilatore accetta <var>CFLAGS</var> come <code>-O4</code>, ma in questi casi esso si limita ad applicare le ottimizzazioni del livello <code>-O3</code> e niente di più. 

Per una dimostrazione si esamini il [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup codice sorgente]: 

{{CodeBox|title=Codice sorgente di -O|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>
}}

Il lettore può osservare che i valori maggiori di 3 sono trattati allo stesso modo di <code>-O3</code>.

=== Riguardo la compilazione esterna alla macchina di destinazione? ===

Alcuni lettori potrebbero chiedersi se compilare fuori dalla macchina bersaglio con una CPU od un'architettura GCC strettamente inferiori possa portare a risultati di ottimizzazione inferiori (in confronto ad una compilazione nativa). La risposta è semplicemente: '''No'''. A prescindere dall'hardware effettivo su cui avviene la compilazione e dal CHOST per cui GCC è stato costruito, finché vengono usati gli stessi argomenti <small>(eccezion fatta per <code>-march=native</code>)</small> e la stessa versione di GCC <small>(benché la versione minore possa essere diversa)</small>, le ottimizzazioni risultatni sono esattamente le stesse.

Per riportare un esempio, se Gentoo viene installato su una macchina il cui CHOST GCC è ''i686-pc-linux-gnu'', e viene installato un server [[Distcc]] su un altro computer il cui CHOST GCC è ''i486-linux-gnu'', allora non c'è bisogno di aver timore di ottenere risultati meno ottimali, a causa della sub-architettura strettamente inferiore del compilatore e/o dell'hardware remoti. Il risultato sarebbe ottimizzato al pari di una compilazione nativa, a patto che vengano passate le stesse opzioni ad ambo i compilatori (e che il parametro <code>-march</code> non riceva un argomento <code>native</code>). In questo caso particolare, è necessario specificare esplicitamente  l'architettura bersaglio, come spiegato in [[Distcc#-march.3Dnative|Distcc e -march=native]].

La sola differenza nel comportamento tra le due versioni di GCC costruite avendo come bersaglio diverse sub-architetture consiste nell'argometno implicito predefinito per il parametro <code>-march</code>, che è derivato dal CHOST di GCC quando non è esplicitamente fornito da linea di comando.

=== Riguardo le opzioni ridondanti? ===

Spesso le <var>CFLAGS</var> e le <var>CXXFLAGS</var> che sono attivate ai vari livelli di <code>-O</code> vengono specificate in modo ridondante nel file {{Path|/etc/portage/make.conf}}. Alcune volte lo si fa per ignoranza, ma in altri casi lo scopo è quello di aggirare la sostituzione o il filtraggio delle opzioni. 

Il filtraggio e la sostituzione delle opzioni vengono svolti da molti ebuild. Solitamente lo si fa perché alcuni pacchetti non possono essere compilati a determinati livelli di <code>-O</code>, oppure perché il codice sorgente è troppo sensibile per permettere l'uso di opzioni aggiuntive. Tali ebuild possono filtrare alcune <var>CFLAGS</var> e <var>CXXFLAGS</var> o possono sostituire <code>-O</code> con un livello differente. 

Il [https://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] spiega nel dettaglio in che modo funziona il filtraggio e la sostituzione delle opzioni e dove essi hanno luogo. 

È possibile aggirare il filtraggio delle opzioni attivate ad un certo livello di <code>-O</code>, come ad esempio <code>-O3</code>, nel seguente modo: 

{{CodeBox|title=Specificare CFLAGS ridondanti|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

Questa, tuttavia, '''non è affatto una buona idea'''. Le <var>CFLAGS</var> sono filtrate per una ragione ben precisa! Tali opzioni vengono filtrate perché altrimenti non si è sicuri di riuscire a compilare un pacchetto correttamente. Ovviamente ''non'' è sicuro compilare l'intero sistema con <code>-O3</code> se alcune delle opzioni attivate da tale livello causano problemi con certi pacchetti. Il lettore non deve cercare di "raggirare" gli sviluppatori che mantengono questi pacchetti. ''Occorre fidarsi degli sviluppatori''. Il filtraggio e la sostituzione delle opzioni viene fatto per assicurare la stabilità del sistema e delle applicazioni. Se un'ebuild specifica opzioni alternative non bisogna pertanto provare ad aggirarle. 

Se si sceglie di compilare un pacchetto con opzioni inaccettabili è molto probabile che si avranno ulteriori problemi successivamente. Quando l'utente segnala un problema su Bugzilla, le opzioni che si usano in {{Path|/etc/portage/make.conf}} sono chiaramente visibili a tutti e gli sviluppatori chiederanno senz'altro di ricompilare il pacchetto senza le opzioni problematiche. Si può evitare il fastidio di dover ricompilare tali pacchetti se si evita in primo luogo di utilizzare opzioni ridondanti in questa maniera! Non si deve assumere di saperne di più rispetto agli sviluppatori.

=== LDFLAGS ===

Gli sviluppatori Gentoo hanno già scelto un insieme minimo e sicuro di <var>LDFLAGS</var> nei profili di base, pertanto non è necessario modificarle.

=== Opzioni specifiche per un singolo pacchetto ===

{{Warning/it|Utilizzare opzioni specifiche per un singolo pacchetto rende più complicato il debug e l'assistenza. Se si sceglie di continuare per questa strada e si vuole segnalare un problema agli sviluppatori si faccia esplicito riferimento al fatto che si sta utilizzando questa funzionalità, e si indichino inoltre le modifiche che sono state apportate.}}

Le informazioni su come sia possibile applicare variabili d'ambiente (compresa <var>CFLAGS</var>) ai singoli pacchetti sono descritte nel [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|manuale Gentoo ("Variabili d'ambiente per pacchetto")]].

== Vedere anche ==

* [[Handbook:AMD64/Installation/Stage#Configuring_compile_options|Configurazione delle opzioni di compilazione]] (Manuale AMD64)

== Risorse esterne ==

Le seguenti risorse sono utili per approfondire ulteriormente il tema dell'ottimizzazione: 

* La [http://gcc.gnu.org/onlinedocs/ documentazione online per GCC] 

* {{c|man make.conf}}

* [https://it.wikipedia.org/ Wikipedia]

* I [https://forums.gentoo.org/ forum Gentoo]

== Riferimenti ==

{{reflist}}

{{Migrated|originalauthors={{Dev|nightmorph}}}}


[[Category:Compilation]]
