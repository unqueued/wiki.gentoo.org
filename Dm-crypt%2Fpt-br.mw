<languages />


{{Metadata|abstract=DM-Crypt é um sistema de criptografia de disco usando a estrutura de API de criptografia do kernel do Linux e o device mapper como subsistema.}}

{{InfoBox stack
|{{InfoBox homepage|https://gitlab.com/cryptsetup/cryptsetup|header=true}}
|{{InfoBox wikipedia}}
}}

'''dm-crypt''' É um sistema de criptografia de disco usando a estrutura de criptografia de kernels e device mapper como subsistema. Com o dm-crypt, os administradores podem criptografar discos inteiros, volumes lógicos, partições, mas também arquivos únicos.

O subsistema dm-crypt suporta o ''Linux Unified Key Setup (LUKS)'' estrutura, que permite várias chaves acessar os dados criptografados, bem como manipular as chaves (como alterar as chaves, adicionando frases adicionais, etc.) Embora dm-crypt suporte configurações não-LUKS também, este artigo irá focar a funcionalidade LUKS, principalmente devido à sua flexibilidade, capacidade de gestão, bem como amplo apoio na comunidade.

== Configuração ==

Existem dois pré-requisitos antes que se possa começar a usar dm-crypt:

# Configuração do Kernel do Linux
# Instalação do pacote {{Package|sys-fs/cryptsetup}}

=== Configuração do Kernel ===

Para usar dm-crypt há um número de entradas de configuração que são necessárias.

Em primeiro lugar, o suporte à infra-estrutura ''device mapper'', bem como ''crypt target'' deve ser incluído:

{{KernelBox|title=Enabling device mapper and crypt target|1=
[*] Enable loadable module support
Device Drivers --->
    [*] Multiple devices driver support (RAID and LVM) --->
        <*> Device mapper support
        <*>   Crypt target support
}}

Em seguida, o kernel do Linux precisa suportar o conjunto de APIs criptográficas que o administrador deseja usar para criptografia. Estes podem ser: ''Cryptographic API''

{{KernelBox|title=Enabling cryptographic API functions|1=
[*] Cryptographic API --->
    <*> XTS support
    <*> SHA224 and SHA256 digest algorithm
    <*> AES cipher algorithms
    <*> AES cipher algorithms (x86_64)
    <*> User-space interface for symmetric key cipher algorithms
}}

Se o sistema de arquivos root também será criptografado, será necessário criar um sistema de arquivos ram inicial no qual o sistema de arquivos root será descriptografado antes de ser montado. Assim, isso também requer suporte a initramfs:

{{KernelBox|title=Enabling initramfs support|1=
General setup  --->
    [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support
}}

=== Instalação do Cryptsetup ===

O pacote {{Package|sys-fs/cryptsetup}} fornece o comando {{c|cryptsetup}}, que é usado para abrir ou fechar o armazenamento criptografado, bem como gerenciar as senhas ou chaves associadas a ele.

{{Emerge|sys-fs/cryptsetup}}

== Armazenamento Criptografado ==

=== Arquivo chave ou Frase de Acesso ===

Para começar com o armazenamento criptografado, o administrador precisará decidir qual método usar para a chave de criptografia. Com {{c|cryptsetup}} a escolha é uma frase de acesso ou um arquivo chave. No caso de um arquivo chave, este pode ser qualquer arquivo, mas recomenda-se usar um arquivo com dados aleatórios que esteja devidamente protegido (considerando que o acesso a este arquivo de chave significará acesso aos dados criptografados).

Para criar o arquivo chave, utilize o comando: {{c|dd}}

{{RootCmd|dd if{{=}}/dev/urandom of{{=}}/etc/keys/enc.key bs{{=}}1 count{{=}}4096}}

Nas próximas seções, mostraremos todos os comandos para ambas as situações - frase de acesso e arquivo chave. É claro que apenas um método é necessário.

=== Criando uma plataforma de armazenamento criptografada ===

Para criar uma plataforma de armazenamento criptografada (que pode ser um disco, partição, arquivo, ...) use o comando {{c|cryptsetup}} com o <code>luksFormat</code>.

Por exemplo, ter {{Path|/dev/vdb2}} como o meio de armazenamento para os dados criptografados:

{{RootCmd|cryptsetup -s 512 luksFormat /dev/vdb2|output=<pre>
This will overwrite data on /dev/vdb2 irrevocably.
  
Are you sure? (Type uppercase yes): YES
Enter LUKS passphrase: ...
Verify passphrase: ...
</pre>}}

Para usar um arquivo de chaves em vez de uma frase secreta:

{{RootCmd|cryptsetup -s 512 luksFormat /dev/vdb2 /etc/keys/enc.key|output=<pre>
This will overwrite data on /dev/vdb2 irrevocably.
  
Are you sure? (Type uppercase yes): YES
</pre>}}

O <code>-s 512</code> diz {{c|cryptsetup}} Qual keylength usar para a chave de criptografia real (ao contrário da frase secreta ou arquivo chave, que são usados para acessar essa chave de criptografia real).

=== Abrindo o armazenamento criptografado ===

A fim de abrir o armazenamento criptografado (isto é, tornar os dados reais acessíveis através de decodificação transparente), utilize <code>luksOpen</code>.

{{RootCmd|cryptsetup luksOpen /dev/vdb2 myname|output=<pre>
Enter passphrase for /dev/vdb2: ...
</pre>}}

Se um arquivo chave for usado, então o comando ficará assim:

{{RootCmd|cryptsetup luksOpen -d /etc/keys/enc.key /dev/vdb2 myname}}

Quando o comando termina com êxito, um novo arquivo de dispositivo chamado {{Path|/dev/mapper/myname}} será disponibilizado. 

Se esta é a primeira vez que este dispositivo criptografado é usado, ele precisa ser formatado. O exemplo a seguir utiliza o sistema de arquivos [[Btrfs]] Mas é claro que qualquer outro sistema de arquivos fará:

{{RootCmd|mkfs.btrfs /dev/mapper/myname}}

Uma vez que o sistema de arquivos é formatado ou a formatação já foi feita no passado, o arquivo do dispositivo pode ser montado no sistema:

{{RootCmd|mount /dev/mapper/myname /home}}

=== Fechando o armazenamento criptografado ===

In order to close the encrypted storage (i.e. ensure that the real data is no longer accessible through transparent decryption), use the <code>luksClose</code> action:

{{RootCmd|cryptsetup luksClose myname}}

Of course, make sure that the device is no longer in use.

== Manipulating LUKS keys ==

LUKS keys are used to access the real encryption key. They are stored in slots in the header of the (encrypted) partition, disk or file.

=== Listing the slots ===

With the <code>luksDump</code> action, information about the encrypted partition, disk or file can be shown. This includes the slots:

{{RootCmd|cryptsetup luksDump /dev/vdb2|output=<pre>
LUKS header information for /dev/vdb2
  
Version:        1
Cipher name:    aes
Cipher mode:    xts-plain64
Hash spec:      sha1
Payload offset: 4096
MK bits:        512
MK digest:      34 3b ec ac 10 af 19 e7 e2 d4 c8 90 eb a8 da 3c e4 4f 2e ce
MK salt:        ff 7c 7f 53 db 53 48 02 a4 32 dc e0 22 fc a3 51
                06 ba b3 48 b3 28 13 a8 7a 68 43 d6 46 79 14 fe
MK iterations:  59375
UUID:           2921a7c9-7ccb-4300-92f4-38160804e08c
  
Key Slot 0: ENABLED
        Iterations:             241053
        Salt:                   90 0f 0f db cf 66 ea a9 6c 7c 0c 0d b0 28 05 2f
                                8a 5c 14 54 98 62 1a 29 f3 08 25 0c ec c2 b1 68
        Key material offset:    8
        AF stripes:             4000
Key Slot 1: ENABLED
        Iterations:             273211
        Salt:                   01 4c 26 ed ff 18 75 31 b9 89 5d a6 e0 b5 f4 14
                                48 d0 23 47 a9 85 78 fb 76 c4 a9 d0 cd 63 fb d7
        Key material offset:    512
        AF stripes:             4000
Key Slot 2: DISABLED
Key Slot 3: DISABLED
Key Slot 4: DISABLED
Key Slot 5: DISABLED
Key Slot 6: DISABLED
Key Slot 7: DISABLED
</pre>}}

In the above example, two slots are used. Note that <code>luksDump</code> does not give away anything sensitive - it is merely displaying the LUKS header content. No decryption key has to be provided in order to call <code>luksDump</code>.

=== Adding a keyfile or passphrase ===

In order to add an additional keyfile or passphrase to access the encrypted storage, use the <code>luksAddKey</code> action:

{{RootCmd|cryptsetup luksAddKey /dev/vdb2|output=<pre>
Enter any passphrase: (Enter a valid, previously used passphrase to unlock the key)
Enter new passphrase for key slot: ... 
Verify passphrase: ...
</pre>}}

To use a keyfile to unlock the key (but still add in a passphrase):

{{RootCmd|cryptsetup luksAddKey -d /etc/keys/enc.key /dev/vdb2|output=<pre>
Enter new passphrase for key slot: ...
Verify passphrase: '''
</pre>}}

If a keyfile is to be added (say {{Path|/etc/keys/backup.key}}):

{{RootCmd|cryptsetup luksAddKey /dev/vdb2 /etc/keys/backup.key}}

Or, to use the first keyfile to unlock the main key:

{{RootCmd|cryptsetup luksAddKey -d /etc/keys/enc.key /dev/vdb2 /etc/keys/backup.key}}

=== Removing a keyfile or passphrase ===

With the <code>luksRemoveKey</code> action, a keyfile or passphrase can be removed (so they can no longer be used to decrypt the storage):

{{RootCmd|cryptsetup luksRemoveKey /dev/vdb2|output=<pre>
Enter LUKS passphrase to be deleted: ...
</pre>}}

Or to remove a keyfile:

{{RootCmd|cryptsetup luksRemoveKey -d /etc/keys/backup.key /dev/vdb2}}

Make sure that at least one method for accessing the data is still available. Once a passphrase or keyfile is removed for use, this cannot be recovered again.

=== Emptying a slot ===

Suppose the passphrase or keyfile is no longer known, then the slot can be freed. Of course, this does require prior knowledge of which slot that the passphrase or keyfile was stored in.

For instance, to empty out slot 2 (which is the third slot as slots are numbered starting from 0):

{{RootCmd|cryptsetup luksKillSlot /dev/vdb2 2}}

This command will ask for a valid passphrase before continuing. Or one can pass on the keyfile to use:

{{RootCmd|cryptsetup luksKillSlot -d /etc/keys/enc.key /dev/vdb2 2}}

== Additional resources ==

* [[Dm-crypt full disk encryption]] on the Gentoo Wiki provides supplementary information on using encrypted file systems for Gentoo Linux installations
* The [https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions cryptsetup FAQ] hosted on GitLab covers a wide range of frequently asked questions.


[[Category:Core system]]
