<languages />


{{Metadata|abstract=Ce document vise à introduire les concepts d'une configuration manuelle du noyau, et à en détailler les pièges les plus courants. .}}

Le but de ce document est d'introduire les concepts d'une configuration manuelle du noyau, et de détailler les pièges les plus courant de la configuration.

== Introduction ==

Gentoo met à votre disposition deux moyens d'installation et de mise à jour du noyau : ''automatique'' (genkernel) et ''manuel''. Bien que la méthode automatique puisse être considérée comme ''plus facile'' pour l'utilisateur, il y a plusieurs raisons pour lesquelles un grand nombre d'utilisateurs de Gentoo choisit de configure le noyau à la main : plus grande flexibilité, noyau plus compact, temps de compilation plus court, expérience didactique, ennui sérieux, etc. 

Ce guide ne parle pas de la méthode automatique (avec genkernel). Si vous préférez utiliser genkernel pour compiler et installer votre noyau, reportez-vous à la documentation de  [[Genkernel/fr|Genkernel ]]. 

Ce guide n'a pas l'ambition de documenter la configuration manuelle de A à Z -- le processus de configuration s'appuie sur un large degré de bon sens, et un niveau de connaissance technique relativement élevé de votre système. Au lieu de cela, ce document vous présente les concepts de la configuration manuelle et détaille les pièges les plus courants que l'utilisateur doit éviter. 

Ce document a été écrit avec les noyaux récents à l'esprit, pour les architectures les plus courantes. Quelques détails peuvent différer pour les noyaux plus anciens et les architectures plus exotiques, mais la majeure partie du contenu reste pertinente. 

À ce stade, nous supposons que les sources du noyau Linux sont dépaquetées sur votre disque dur (de façon générale sous {{Path|/usr/src}}), et que vous connaissez comment lancer l'utilitaire de configuration <code>menuconfig</code> et vous déplacer dans ses menus. Si vous n'en êtes pas encore là, nous mettons à votre disposition d'autres documentations pour vous aider. 

* Le [[Kernel/Overview/fr| Guide du noyau]] présente les différents paquets des sources du noyau disponibles.
* La page [[Kernel/Upgrade/fr|Noyau/mise à jour]] explique comment mettre votre noyau à jour ou comment commuter vers un autre noyau.
* Le  [http://www.gentoo.org/doc/fr/handbook/index.xml manuel de Gentoo ] couvre également quelques aspects de l'installation du noyau.

== Concepts de la configuration  ==

=== Les bases ===

Le processus général est plutôt simple : une série d'options vous est présentée, sous forme de menus et sous-menus, et vous sélectionnez la prise en charge du matériel et les fonctionnalités du noyau pertinentes pour votre système. 

Le noyau comprend une ''configuration par défaut'', qui vous est présentée la première fois que vous exécutez <code>menuconfig</code> sur un jeu de sources particulier. Les choix par défaut sont en général à large portée et raisonnables, ce qui veut dire qu'une majorité d'utilisateurs n'auront que peu de changements à faire à cette configuration de base. Si vous décidez de désactiver une option, assurez-vous que vous avez une compréhension relativement bonne de ce que cette option fait exactement et des conséquence de son inactivation. 

Si c'est la première fois que vous configurez un noyau Linux, vous devriez rester conservateur : ne soyez pas trop aventurier, et contentez-vous de faire aussi peu de modification aux réglages par défaut que possible. En même temps, pensez bien qu'il y a une partie de la configuration que vous devez absolument adapter à votre système pour qu'il démarre !

=== Compilé en dur  vs compilé en tant que module ===

Majoritairement, les options de configuration sont ''à trois état'' : elles peuvent être non compilées du tout (N), compilées en dur dans le noyau (Y) ou compilées sous forme de module (M). Les modules sont stockés en externe sur le système de fichiers, alors que les options compilées en dur sont incluses dans l'image du noyau elle-même. 

Il y a une différence importante entre compilée en dur et compilée sous forme de module : sauf quelques exceptions, le noyau n'essaye pas de charger un module externe quand vous en avez besoin (ceci est laissé à l'initiative de l'utilisateur). Alors que certaines autres parties du système peuvent disposer de mécanismes de ''chargement à la demande'', et qu'il y ait quelques mécanismes de chargement automatique de module, il est recommandé que vous compiliez la prise en charge du matériel et les fonctionnalités du noyau directement dans le noyau. Le noyau est ainsi assuré de disposer des fonctionnalités et de la prise en charge du matériel quand il en a besoin. 

Bien entendu, pour quelques parties de la configuration, ''compilée en dur'' est une absolue nécessité. Par exemple, si votre partition root porte un système de fichiers <code>ext2</code>, votre système ne démarrera pas si la prise en charge de ext2 a été compilée en tant que module (le système devrait regarder dans la partition root pour trouver le module ext2, alors que la prise en charge de ext2 ne serait pas encore chargée !)

=== Prise en charge du matériel ===

Au delà de détecter le ''type d'architecture'' de votre système, l'utilitaire de configuration ne cherche pas à identifier quel matériel est réellement présent sur votre système. Bien qu'il existe des réglages par défaut pour la prise en charge de quelques matériels, il vous faudra trouver et sélectionner les options pertinentes pour votre configuration matérielle. 

Ceci nécessite simplement la connaissance des composants à l'intérieur, et connectés, à votre ordinateur, ou pour vous d'identifier ces composants. Pour la plupart des composants, vous devez identifier le ''jeu de circuits'' (chipset) utilisé par chacun d'entre-eux, plutôt que leur nom commercial. 

Quelques utilitaires sont là pour vous y aider. <code>lspci</code> (partie du paquet {{Package|sys-apps/pciutils}}) identifiera votre matériel PCI et AGP, ce qui inclut les composants construits sur la carte mère elle-même.  <code>lsusb</code> (du paquet {{Package|sys-apps/usbutils}} ) identifiera les périphériques au ports USB. 

La situation est quelque peu confuse à cause des degrés variables de normalisation dans le monde des fabricants de matériel. Sauf si vous vous écartez réellement des standards, vos disques IDE, votre clavier PS/2 ou USB et votre souris devraient ''simplement fonctionner''. Vous obtiendrez une prise en charge VGA de base  pour l'écran. Néanmoins, certains périphériques tels que les les adaptateurs Ethernet sont à peine normalisés, c'est pourquoi vous devrez identifier leur ''jeu de circuits'' et sélectionner la prise en charge matérielle appropriée pour votre carte spécifique pour disposer d'un accès au réseau. 

De plus, alors que certains matériels fonctionnent tout simplement avec les réglages par défaut, vous pouvez être forcé de sélectionner des options plus spécialisées pour tirer le meilleur de votre système. Par exemple, si vous n'activez pas la prise en charge de jeu de circuits approprié pour votre disque IDE, votre disque sera très lent en accès.

=== Fonctionnalités du noyau ===

Tout comme pour la prise en charge du matériel, vous devez également penser aux fonctionnalités logicielles dont vous avez besoin dans votre noyau. Un exemple important d'une telle fonctionnalité est la prise en charge des systèmes de fichiers : vous devez sélectionner la prise en charge des systèmes de fichiers utilisés sur vos disques durs et sur vos supports amovibles (par exemple VFAT sur des disques USB flash): 

Un autre exemple courant est la fonctionnalité avancé de réseau. Si vous voulez effectuer du routage ou du pare-feu, vous devez vous assurer que les items pertinents de la configuration sont inclus dans votre noyau. 

=== Prêt ? ===

Maintenant que les concepts ont été présentés, vous devriez être capable d'identifier votre matériel et de naviguer dans les menus de configuration pour sélectionner les options requises du noyau pour votre système. 

La suite de cette page vise à éclaircir certaines zones de confusion fréquente, et à fournir des conseils sur la manière d'éviter les problèmes les plus couramment rencontrés par les utilisateurs. Bonne chance ! 

== Problèmes courants et zones de confusion ==

=== Les disques SATA sont SCSI ===

La plupart des ordinateurs de bureau modernes sont livrés avec des unités de stockage (disques durs et lecteurs de CD/DVD) sur un bus [https://en.wikipedia.org/wiki/SATA Serial ATA], plutôt que sur l'ancien bus [https://en.wikipedia.org/wiki/IDE Parallel_ATA ](câble en ruban). 

La prise en charge de SATA dans  Linux est mise en œuvre dans une couche connue sous le nom de ''libata'', qui siège en dessous du sous-système SCSI. Pour cette raison, les pilotes SATA sont trouvés dans la section des pilotes SCSI dans la configuration.  En outre, vos périphériques de stockage seront traités comme des périphériques SCSC, ce qui veut dire que la prise en charge des disques/CDROM SCSI est également requise.  Votre disque dur SATA sera nommé  will be named as (e.g.) {{Path|/dev/sda}} et votre lecteur CD/DVD SATA sera nommé (e.g.) {{Path|/dev/sr0}}. 

Bien que la majorité de ces pilotes soit peur les contrôleurs SATA, ''libata'' n'a pas été conçue pour être spécifique à SATA. Tous les pilotes courant IDE seront aussi portés dans ''libata'' dans un futur proche, et après cela, les considérations évoquées plus haut, s'appliqueront aussi aux utilisateurs d'IDE. 

{{Code|Options de configuration pour libata|<pre>
Device Drivers  --->
 SCSI device support  --->
  <*> SCSI device support
  <*>   SCSI disk support
  <*>   SCSI CDROM support
  
  SCSI low-level drivers  --->
   <*> Serial ATA (SATA) support
    Select your chipset from the choices listed below the above option
</pre>
}}

=== Jeux de circuits IDE et DMA ===

Malgré l'introduction de SATA, les périphériques IDE sont encore courants et beaucoup en dépendent. IDE est une technologie parfaitement générique et,grâce à cela,  Linux prend en charge presque tous les contrôleurs IDE directement à l'installation sans qu'aucune options spécifique au contrôleur ait besoin d'être activée. 

Cependant, IDE est une technologie ancienne, et dans son incarnation originale ''entrées/sorties programmées'', elle est incapable de procurer les débits requis pars les accès rapides aux périphériques des stockage modernes. Le pilote IDE générique est limité à ces modes de transfert PIO, qui conduisent à des débits de transfert bas, et à une utilisation significative de CPU lors du transfert des données vers/du disque. 

Sauf si vous avez affaire à un système pré-1995, votre contrôleur IDE prend également en charge un mode de transfert alternatif, connu sous le nom de ''Direct Memory Access'' (accès direct à la mémoire - DMA) DMA est beaucoup plus rapide, et l'utilisation du CPU est à peine affectée lors des transferts de données. Si vous souffrez d'une performance système générale faible et que vous utilisez un disque IDE, il est fort probable que vous n'utilisez pas le mode DMA. 


{{Note|Comme nous l'avons mentionné auparavant, libata est disponible y compris pour les pilotes IDE. Si vous utilisez libata, alors tous vos contrôleurs, y compris les  IDE, utiliseront  DMA. Il n'y a pas lieu de procéder à des vérifications plus poussées ou à de la configuration.}}

If you're not using libata for your IDE disks, then you'll need to check for DMA usage and enable it. 

{{RootCmd|hdparm -d /dev/hda|output=<pre>
/dev/hda:
 using_dma    =  0 (off)
</pre>
}}

To enable DMA on your IDE devices, you simply need to enable the configuration option for your IDE controller. 

{{Kernel|Configuration options for IDE controllers|<pre>
Device Drivers  --->
 ATA/ATAPI/MFM/RLL support  --->
  <*> ATA/ATAPI/MFM/RLL support
  <*>   Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
  [*]     PCI IDE chipset support
  Select your chipset from the choices listed below the above option
</pre>
}}

=== USB Host Controllers ===

[http://en.wikipedia.org/wiki/USB USB] is a widely adopted bus for connecting external peripherals to your computer. One of the reasons behind the success of USB is that it is a standardised protocol, however the USB ''host controller devices'' (HCDs) implemented on the host computer do vary a little. There are 3 main types: 

* <code>UHCI</code> is the Universal Host Controller Interface. It supports USB 1.1, and is usually found on motherboards based on a VIA or Intel chipset.
* <code>OHCI</code> is the Open Host Controller Interface. It supports USB 1.1 and is usually found on motherboards based on an Nvidia or SiS chipset.
* <code>EHCI</code> is the Extended Host Controller Interface. It is the only common host controller to support USB 2.0, and can typically be found on any computer that supports USB 2.0.

Most systems will come with two of the above interface types: EHCI (USB 2.0), plus either UHCI or OHCI (USB 1.1). It is important that you select both types present on your system. While all USB 2.0 devices are backwards compatible with USB 1.1, a large proportion of USB devices (even the ones being manufactured today) are based on the USB 1.1 interface - why would a USB mouse need more than 1.5Mb/s? 

If you do not select the relevant options corresponding to the USB HCD types present on your system, you may experience 'dead' USB ports: you plug a device in, but it does not get power or respond in any way. 

A neat <code>lspci</code> trick (from the {{Package|sys-apps/pciutils}} package) makes it relatively easy to detect which HCDs are present in your system. Ignoring the FireWire controller which was also matched, it is easy to spot that my system requires OHCI and EHCI support: 

{{RootCmd|lspci -v {{!}} grep HCI|output=<pre>
00:02.0 USB Controller: nVidia Corporation CK804 USB Controller (rev a2) (prog-if 10 [OHCI])
00:02.1 USB Controller: nVidia Corporation CK804 USB Controller (rev a3) (prog-if 20 [EHCI])
01:0b.0 FireWire (IEEE 1394): Agere Systems FW323 (rev 61) (prog-if 10 [OHCI])
</pre>
}}

{{Kernel|Configuration for USB HCDs|<pre>
Device Drivers  --->
 USB support  --->
  <*> Support for Host-side USB
  ---   USB Host Controller Drivers
  <*>   EHCI HCD (USB 2.0) support
  <*>   OHCI HCD support
  <*>   UHCI HCD (most Intel and VIA) support
  Select the HCDs present on your system, or all 3 if you are unsure.
</pre>
}}

In Linux kernel 3.12.13 and later, ''OHCI support for PCI-bus USB controllers'' (<code>CONFIG_USB_OHCI_HCD_PCI</code>) has to be enabled if the USB controller is OHCI and a USB keyboard or mouse is used.

=== Multiprocessor, Hyper-Threading and Multi-Core systems ===

Many computer systems are based on multiple processors, but not always in immediately obvious ways. 

* Many of Intel's CPUs support a technology which they call [https://en.wikipedia.org/wiki/Hyperthreading hyper-threading], which is where the CPU is actually viewed by the system as two ''logical'' processors.
* Most Intel/AMD CPUs actually consist of multiple physical processors inside a single package, these are known as [https://en.wikipedia.org/wiki/Multi-core_processor multi-core] processors.
* Some high-end computer systems actually have multiple physical processors installed on specialised motherboards to provide a significant performance increase over a ''uniprocessor'' system. You'll probably know if you have such a system, since they aren't cheap.

In all of these cases, you need to select the appropriate kernel options to obtain optimum performance from these setups. 

{{Kernel|Configuration for multi-processing|<pre>
Processor type and features  --->
 [*] Symmetric multi-processing support
 Select the above option if you are on a multi-processor system (of any type)
 [*]   SMT (Hyperthreading) scheduler support
 Select the above option if you are on an Intel Hyper-Threading CPU
 [*]   Multi-core scheduler support (NEW)
 Select the above option if your CPU is multi-core
Power management and ACPI options  --->
 [*] ACPI (Advanced Configuration and Power Interface) Support
 The above option not only enables power management features, but might
 also be a requirement for making all CPUs available to your system
</pre>
}}

=== x86 High Memory support ===

Due to limitations in the 32-bit address space of the x86 architecture, a kernel with default configuration can only support up to 896MB RAM. If your system has more memory, only the first 896MB will be visible, unless you enable high memory support. 

{{Note|This limitation is specific to the x86 (IA32) architecture. Other architectures naturally support large amounts of memory, with no configuration tweaks required.}}

High memory support is not enabled by default, because it introduces a small system overhead. Do not be distracted by this, the overhead is insignificant when compared to the performance increase of having more memory available! 

{{Kernel|Enabling high memory support on x86|<pre>
Processor type and features  --->
 High Memory Support  --->
  (X) 4GB
  ( ) 64GB
  Choose the 4GB option, unless your system has more than 4GB of RAM.
</pre>
}}

== Kernel configuration shorthand notation ==

=== Introduction ===

When you read about kernel configurations, you will often see that settings are described as <code>CONFIG_<something></code>. This short-hand notation is what the kernel configuration actually uses internally, and is what you will find in the kernel configuration file (be it {{Path|/usr/src/linux/.config}} or in the auto-generated {{Path|/proc/config.gz}} file). Of course, using short-hand notation wouldn't do much good if you cannot translate this to the real location in the kernel configuration. Luckily, the <code>make menuconfig</code> tool allows you to do just that.

=== Translating CONFIG_FOO to the real configuration location ===

Suppose you need to enable <code>CONFIG_TMPFS_XATTR</code>, launch the kernel configuration menu (<code>make menuconfig</code>) and type in {{Key|/}}. This will open the search box. In this search box, type <code>CONFIG_TMPFS_XATTR</code> (you can even drop the <code>CONFIG_</code>). The next code listing shows the result of this search. 

{{Kernel|Result of looking for CONFIG_TMPFS_XATTR|<pre>
Symbol: TMPFS_XATTR [=n]
Type  : boolean
Prompt: Tmpfs extended attributes
  Defined at fs/Kconfig:138
  Depends on: TMPFS [=y]
  Location:
    -> File systems
      -> Pseudo filesystems
        -> Virtual memory file system support (former shm fs) (TMPFS [=y])
  Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
</pre>
}}

This output yields lots of interesting information. 

{| class="wikitable" style="text-align: left;" 
|- 
! Entry
! Description
|- 
| Symbol: TMPFS_XATTR [=n]
| This identifies the kernel configuration entry you are looking for. It also already tells you that the setting is currently ''not enabled'' ([=n]).
|- 
| Type: boolean
| The setting you looked for is a boolean (which means you can enable or disable it). Some settings are numbers or strings.
|- 
| Prompt: Tmpfs extended attributes
| This is the text you will find in <code>make menuconfig</code> and as such, is the entry that you are looking for in a more human readable format.
|- 
| Depends on: TMPFS [=y]
| Before you can even see this entry, you need to have <code>CONFIG_TMPFS</code> enabled. In this case, this is done (hence the [=y]) but if this is not the case, you will first need to look (and enable) <code>CONFIG_TMPFS</code>.
|- 
| Location: ...
| This is the location in the <code>make menuconfig</code> structure where you can find the setting. Remember, the setting you are looking for is ''Tmpfs extended attributes''.
|- 
| Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
| If the settings described here are both enabled (in our case, the first one isn't), then <code>CONFIG_TMPFS_XATTR</code> will be automatically enabled as well and you will not be able to disable it.
|-
|}

With this information, you should be able to translate any <code>CONFIG_*</code> requirements tossed at you easily. In short, it means you 

# need to enable the settings described in the ''Depends on'' field
# navigate where ''Location:'' points you towards
# toggle the value referred to by ''Prompt:''

== Other kernel configuration documentation ==

So far, we have only discussed general concepts and specific problems related to kernel configuration, without going into any precise details (such details are for you to discover!). However, other parts of the Gentoo documentation collection provide specialised details for the topics at hand. 

You may find these documents helpful while configuring those specific areas, but if you are new to kernel configuration, don't be too adventurous. Start by getting a basic system up and running, you can always come back later to add support for your audio, printing, etc. 

* The [[ALSA]] article details the configuration options required for sound card support. Note that ALSA is one exception to the suggested scheme of not building things as modules: ALSA is actually much easier to configure when the components are modular.

* The [[Bluetooth]] article details the options you need in order to use bluetooth devices on your system.

* The [[IPv6 router guide]] describes how to configure your kernel for routing using the next generation network addressing scheme.

* If you will be using the closed-source nVidia graphics drivers for improved 3D graphics performance, the [[NVidia/nvidia-drivers|nVidia Guide]] lists the options that should and should not be selected on such a system.

* Amongst other things, the [[Power_management/HOWTO|Power Management Guide]] explains how to configure your kernel for CPU frequency scaling, and for suspend and hibernate functionality.

* If you are running a PowerPC system, the [[PPC/FAQ|PPC FAQ]] has a few sections about kernel configuration.

* The [[Printing|Printing HOWTO]] lists the kernel options needed to support printing in Linux.

* The [[USB/HOWTO|USB Guide]] details the configuration required to use common USB devices such as keyboards/mice, storage devices, and printers.

== Troubleshooting ==

=== Configuration changes do not take effect ===

It is very common for users to make a configuration change, but then make a small mistake in the process following on from that point. They reboot into a kernel image that is not the one they just reconfigured, observe that whatever problem they were trying to solve is still present, and conclude that the configuration change does not solve the problem. 

The process of compiling and installing kernels is outside the scope of this document, you should refer to the [[Kernel/Upgrade|Kernel Upgrade Guide]] for general guidance. In short, the process is: configure, compile, mount {{Path|/boot}} (if not already mounted), copy new kernel image over, reboot. If you miss out any of those final stages, your changes will not take effect! 

It is possible to verify if the kernel you are booted from matches the kernel compiled on your hard disk by examining the date and time of compilation. Assuming your architecture is x86 and your kernel sources are installed at {{Path|/usr/src/linux}}: 

{{RootCmd|uname -v|output=<pre>
#4 SMP PREEMPT Sat Jul 15 08:49:26 BST 2006
</pre>}}

The above command displays the date and time that the kernel you are currently booted from was compiled.

{{RootCmd|ls -l /usr/src/linux/arch/i386/boot/bzImage|output=<pre>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
</pre>}}

The above command displays the date and time that the kernel image on your hard disk was last compiled.

If the two times from the above commands differ by more than 2 minutes, it indicates that you have made a mistake during kernel reinstallation and you are not booted from the kernel image that you thought you were!

=== Modules do not get loaded automatically ===

As mentioned earlier in this document, the kernel configuration system hides a large behavioural change when selecting a kernel component as a module (M) rather than built-in (Y). It is worth repeating this again because so many users fall into this trap. 

When you select a component as built-in, the code is built into the kernel image (bzImage). When the kernel needs to use that component, it can initialise and load it automatically, without any user intervention. 

When you select a component as a module, the code is built into a kernel module file and installed on your filesystem. In general, when the kernel needs to use that component, it can't! With some exceptions, the kernel makes no effort to actually load these modules - this task is left up to the user. 

So, if you build support for your network card as a module, and you then find that you cannot access your network, it is probably because the module is not loaded - you must either do this manually or configure your system to autoload it at boot time. 

Unless you have reasons to do otherwise, save yourself some time by building these components directly into the kernel image, so that the kernel can automatically set these things up for you. 

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:


* Daniel Drake
* Curtis Napier
* Justin Robinson
* Åukasz Damentko
* Jonathan Smith
* nightmorph

[[Category:Server and Security]]
