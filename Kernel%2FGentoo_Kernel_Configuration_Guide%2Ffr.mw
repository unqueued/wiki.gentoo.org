<languages />


{{Metadata|abstract=Le but de ce document est d'introduire les concepts d'une configuration manuelle du noyau, et d'en détailler les pièges les plus courants.}}

Le but de ce document est d'introduire les concepts d'une configuration manuelle du noyau, et d'en détailler les pièges les plus courants.

== Introduction ==

Gentoo met à la disposition des utilisateurs deux moyens d'installation, de configuration, et de mise à jour du noyau : ''automatique'' (genkernel) et ''manuel''. Bien que la méthode automatique puisse être considérée comme plus facile pour la plupart des utilisateurs, il y a plusieurs raisons pour lesquelles un grand nombre d'utilisateurs de Gentoo choisit de configurer le noyau à la main :

# Plus grande flexibilité
# Noyau plus compact
# Temps de compilation plus court
# Expérience didactique
# Ennui sérieux
# Connaissance absolue de la configuration noyau, et/ou
# Contrôle complet

Ce guide ne parle pas de la méthode automatique (avec genkernel). Si l'utilisation de genkernel est préférée pour gérer le noyau, reportez-vous à la documentation de  [[Genkernel/fr|Genkernel]] pour plus de détails. 

Ce guide n'a pas l'ambition de documenter la configuration manuelle de A à Z — le processus de configuration s'appuie sur un large degré de bon sens, et un niveau de connaissance technique relativement élevé du système utilisé. Au lieu de cela, il vous présente les concepts de la configuration manuelle et détaille les pièges les plus courants que les utilisateurs se doivent d'éviter. 

{{Note|Ce guide est écrit avec les noyaux récents à l'esprit pour les architectures les plus courantes. Quelques détails peuvent différer pour les noyaux plus anciens et les architectures plus exotiques; cependant la majeure partie du contenu reste pertinente.}}

À ce stade, l'utilisateur est supposé avoir décompressé les sources du noyau Linux sur le disque dur (de façon générale sous {{Path|/usr/src}}), et devrait savoir comment lancer l'utilitaire de configuration {{c|menuconfig}} ansi que comment se déplacer dans le système de menus basé sur ncurse. Si l'utilisateur n'en est pas encore là, d'autres documentations sont disponibles. Lisez les articles suivant puis revenez sur ce guide :

* Le document [[Kernel/Overview/fr| Noyau/Vue d'ensemble]] contient des informations sur les différents noyaux disponibles dans l'arbre Portage.
* La page [[Kernel/Upgrade/fr|Noyau/Mise à jour]] explique comment mettre à jour un noyau ou comment commuter vers un autre noyau.
* La section [[Handbook:Main_Page/fr| Configuration du noyau]] du manuel gentoo couvre également quelques aspects de l'installation du noyau. Sélectionnez l'architecture appropriée, puis naviguez vers la section intitulée "Configurer le noyau Linux"

== Concepts de la configuration ==

=== Les bases ===

Le processus général est plutôt simple : une série d'options, sous forme de menus et sous-menus, sont présentées et le support matériel et les fonctionnalités du noyau pertinentes pour le système sont sélectionnées.

Le noyau comprend une ''configuration par défaut'', qui est présentée la première fois que <code>menuconfig</code> est exécuté sur un jeu de sources particulier. Les choix par défaut sont en général à large portée et raisonnables, ce qui veut dire qu'une majorité d'utilisateurs n'auront que peu de changements à faire à cette configuration de base. Quand le choix est fait de désactiver une option qui été activée dans la configuration par défaut du noyau, il est important de s'assurer qu'une bonne compréhension de ce que cette option fait exactement est obtenue, et des conséquence de sa déactivation. 

Lors d'une première configuration d'un noyau Linux, tentez de rester conservateur ; ne soyez pas trop aventurier, et contentez-vous de faire aussi peu de modification aux réglages par défaut que possible. En même temps, pensez bien qu'il y a une partie de la configuration qui se doit absolument d'être adaptée au système pour que ce dernier ne démarre !

=== Compilé en dur ou compilé en tant que module ===

Majoritairement, les options de configuration sont ''à trois état'' : elles peuvent être non compilées du tout <code>(N)</code>, compilées en dur dans le noyau <code>(Y)</code> ou compilées sous forme de module <code>(M)</code>. Les modules sont stockés en externe sur le système de fichiers, alors que les options compilées en dur sont incluses dans l'image du noyau elle-même. 

Il y a une différence importante entre compilé en dur et sous forme de modules : sauf quelques exceptions, le noyau n'essaye pas de charger un module externe quand le système pourrait en avoir besoin ; ceci est laissé à l'initiative de l'utilisateur. Alors que certaines autres parties du système peuvent disposer de mécanismes de ''chargement à la demande'', et qu'il y ait quelques mécanismes de chargement automatique de module, il est recommandé de compiler la prise en charge du matériel et les fonctionnalités du noyau directement dans le noyau. Le noyau est ainsi assuré de disposer des fonctionnalités et de la prise en charge du matériel quand il en a besoin. Cela se fait en configurant chaque fonctionnalité du kernel à <code>(Y)</code>. Pour que cette configuration soit cohérente, il est également nécessaire d'inclure le support des firmware directement dans le noyau. Cela se fait en configurant les options <code>FW_LOADER=y</code> et <code>CONFIG_FIRMWARE_IN_KERNEL=y</code> dans le fichier {{Path|.config}} du noyau ou par les choix suivants :

{{KernelBox|title=Inclure firmware dans le noyau|
Device Drivers  --->
   Generic Driver Options  --->
       -*- Userspace firmware loading support
       [*] Include in-kernel firmware blobs in kernel binary
}}

Pour d'autres parties de la configuration, ''compilée en dur'' est une absolue nécessité. Par exemple, si la partition root comporte un système de fichiers btrfs, le système ne démarrera pas si la prise en charge de brtfs a été compilée en tant que module. Le système devrait alors regarder dans la partition root pour trouver le module btrs (vu que les modules sont stockés dans la partition root), mais il ne peut pas lire la partition root à moins d'avoir déjà chargé le support pour btrfs! Si btrfs n'a pas été compilé en dur, le processus de démarrage n'arrivera pas à trouver la partition root.

=== Prise en charge du matériel ===

Au delà de détecter le ''type d'architecture'' du système, l'utilitaire de configuration ne cherche pas à identifier quel matériel est réellement présent sur le système. Bien qu'il existe des réglages par défaut pour la prise en charge de ''quelques'' matériels, il reviendra aux utilisateurs de trouver et sélectionner les options pertinentes pour chaque configuration matérielle. 

Sélectionner les options de configuration correctes nécessite une connaissance des composants à l'intérieur de, et connectés à, l'ordinateur. La plupart du temps, ces composants peuvent être identifiés sans avoir beoin de soulever le capot. Pour la plupart des composants, l'utilisateur doit identifier le ''jeu de circuits'' (chipset) utilisé par chacun d'entre-eux, plutôt que leur nom commercial. Beaucoup de cartes d'extension sont commercialisées avec une certaine marque, mais utilisent le chipset d'un autre fabricant.

Quelques utilitaires sont là pour aider les utilisateurs à déterminer quelles configurations du noyau utiliser. {{c|lspci}} (du paquet {{Package|sys-apps/pciutils}}) identifiera votre matériel PCI et AGP, ce qui inclut les composants construits sur la carte mère elle-même.  {{c|lsusb}} (du paquet {{Package|sys-apps/usbutils}} ) identifiera divers périphériques raccordés aux ports USB du système. 

La situation est quelque peu confuse à cause des degrés variables de normalisation dans le monde des fabricants de matériel. A moins que l'utilisateur ne s'écarte réellement des paramétrages par défaut, les disques IDE, le clavier PS/2 ou USB et la souris devraient ''simplement fonctionner''. Une prise en charge VGA de base pour l'écran est également incluse. Néanmoins, certains périphériques tels que les les adaptateurs Ethernet sont à peine normalisés ; pour ces périphériques les utilisateurs devront identifier leur chipset et sélectionner la prise en charge matérielle appropriée pour la carte spécifique pour disposer d'un accès au réseau.

De plus, alors que certains matériels fonctionnent tout simplement avec les réglages par défaut, des options plus spécialisées peuvent être sélectionnées pour tirer le meilleur du système. Par exemple, si le support pour le chipset IDE approprié n'a pas été activé, le disque sera très lent en accès.

=== Fonctionnalités du noyau ===

En plus de la prise en charge du matériel, les utilisateurs doivent penser aux fonctionnalités logicielles qui seront requises dans le noyau. Un exemple important d'une telle fonctionnalité est la prise en charge des systèmes de fichiers : les utilisateurs doivent sélectionner la prise en charge des systèmes de fichiers utilisés sur leurs disques durs, ainsi que pour chaque système de fichiers qu'ils pourraient utiliser sur des supports amovibles (par exemple VFAT pour des disques USB flash). 

Un autre exemple courant est la fonctionnalité avancé de réseau. Pour effectuer du routage ou du pare-feu, les items pertinents de la configuration doivent être inclus dans la configuration du noyau. 

=== Prêt ? ===

Maintenant que les concepts ont été présentés, il devrait être facile d'identifier la matériel du système, de naviguer dans l'interface de menuconfig, et de sélectionner les options requises du noyau pour le système. 

La suite de ce guide vise à éclaircir certaines zones de confusion fréquente, et à fournir des conseils sur la manière d'éviter les problèmes les plus couramment rencontrés par les utilisateurs. Bonne chance !

== Problèmes courants et zones de confusion ==

=== Les disques SATA sont SCSI ===

La plupart des ordinateurs de bureau modernes sont livrés avec des unités de stockage (disques durs et lecteurs de CD/DVD) sur un bus [https://fr.wikipedia.org/wiki/Serial_ATA Serial ATA], plutôt que sur l'ancien bus [https://fr.wikipedia.org/wiki/Parallel_ATA Parallel_ATA ](câble en ruban). 

La prise en charge de SATA dans Linux est mise en œuvre dans une couche connue sous le nom de ''libata'', qui siège en dessous du sous-système SCSI. Pour cette raison, les pilotes SATA sont trouvés dans la section des pilotes SCSI de la configuration.  En outre, les périphériques de stockage seront traités comme des périphériques SCSI, ce qui veut dire que la prise en charge des disques/CDROM SCSI sera également requise. Le premier disque SATA sera nommé {{Path|/dev/sda}} et le premier lecteur CD/DVD SATA sera nommé {{Path|/dev/sr0}}. 

Bien que la majorité de ces pilotes soit pour les contrôleurs SATA, ''libata'' n'a pas été conçue pour être spécifique à SATA. Tous les pilotes courants IDE seront aussi portés dans ''libata'' dans un futur proche, et après cela, les considérations évoquées plus haut, s'appliqueront aussi aux utilisateurs d'IDE. 

{{KernelBox|title=Options de configuration pour libata|1=
Device Drivers  --->
   SCSI device support  --->
      <*> SCSI device support
      <*> SCSI disk support
      <*> SCSI CDROM support
 
      [ ] SCSI low-level drivers  --->
 
   <*> Serial ATA and Parallel ATA drivers (libata)  --->
}}

{{Note|Les chipsets non standards sont listés sous <code>SCSI low-level drivers</code> dans le menu <code>Serial ATA and Parallel ATA drivers (libata)</code> de la configuration du noyau ci-dessus.}}

=== Jeux de circuits IDE et DMA ===

Malgré l'introduction de SATA, les périphériques IDE sont encore courants et beaucoup de systèmes en dépendent. IDE est une technologie parfaitement générique et, grâce à cela,  Linux prend en charge presque tous les contrôleurs IDE directement à l'installation sans qu'aucune option spécifique au contrôleur ait besoin d'être activée. 

Cependant, IDE est une technologie ancienne, et dans son implémentation originale ''entrées/sorties programmées'', elle est incapable de procurer les débits requis pars les accès rapides aux périphériques des stockage modernes. Le pilote IDE générique est limité à ces modes de transfert PIO, qui conduisent à des débits de transfert bas, et à une utilisation significative de CPU lors du transfert de données vers/du disque. 

Sauf si un utilisateur a affaire à un système pré-1995, le contrôleur IDE prend également en charge un mode de transfert alternatif, connu sous le nom de ''Direct Memory Access'' (accès direct à la mémoire - DMA). DMA est beaucoup plus rapide, et l'utilisation du CPU est à peine affectée lors des transferts de données. Si le système souffre d'une performance générale faible qlors qu'il utilise un disque IDE, il est fort probable que le mode DMA ne soit pas utilisé et doit être activé.

{{Note|Comme mentionné auparavant, libata est disponible y compris pour les disques IDE. Si libata est utilisé, alors tous les disques, y compris les disques IDE, utiliseront  DMA. Il n'y a pas lieu de procéder à des vérifications plus poussées ou à de la configuration.}}

Si libata n'est pas utilisé pour les disques IDE, il est nécessaire de vérifier que DMA est activé. La commande suivante peut être utilisée pour déterminer si DMA est utilisé :

{{RootCmd|hdparm -d /dev/hda|output=<pre>
/dev/hda:
 using_dma    =  0 (off)
</pre>
}}

Pour activer DMA pour d'anciens disques IDE (qui est une fonctionnalité dépréciée), activer les options de configuration du noyau suivantes.

{{Warning|Activer <var>CONFIG_BLK_DEV_IDE_SATA</var> créera un conflit avec le pilote SATA libata. Normalement, le support pour SATA est désactivé sur les contrôleurs IDE parce qu'il est mieux géré par le sous-sytème SCSI, activement maintenu. Activer <var>CONFIG_BLK_DEV_IDE_SATA</var> créera un conflit entre ce pilote et le support de libata pour SATA, ce qui est généralement une mauvaise idée. Ce pilote existe pour supporter d'anciens disques IDE, laissez libata gérer SATA si possible!}}

{{KernelBox|title=Options de configuration pour les contrôleurs IDE|1=
Device Drivers  --->
   <*> ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
      --- ATA/ATAPI/MFM/RLL support (DEPRECATED)
      [ ]   Support for SATA (deprecated; conflicts with libata SATA driver)
      <*>   generic ATA/ATAPI disk support
      [*]     ATA disk support
      [*]     ATAPI floppy support
      <*>   Include IDE/ATAPI CDROM support
      <*>   Include IDE/ATAPI TAPE support
  
            *** IDE chipset support/bugfixes ***
      <*>   generic/default IDE chipset support
  
            *** PCI IDE chipsets support ***
}}

{{Note|Selectionnez le bon chipset pour les choix listés sous <code>*** PCI IDE chipset support ***</code> dans le menu ''Configuration options for IDE controllers'' de la boîte de configuration du noyau ci-dessus.}}

=== Contrôleurs des hôtes USB ===

[[USB]] est un bus largement utilisé pour la connexion de périphériques externes à un ordinateur. Une des raisons du succès de USB est qu'il s'agit d'un protocole standard. Néanmoins, les périphériques de contrôle des hôtes (''host contrôleur devices ou HCD'') USB mis en œuvre sur l'ordinateur hôte varient un peu. Il y en a quatre types : 

# <code>UHCI</code>, le ''Universal Host Controller Interface'' (Interface de contrôleur d'hôte USB universel). Il prend en charge l'USB 1.1, et se trouve  ordinairement sur les cartes mères basées sur un chipset VIA ou Intel. 
# <code>OHCI</code> , l'''Open Host Controller Interface'' (l'interface de contrôleur d'hôte ouverte) . Elle prend en charge l'USB 1.1 et se trouve ordinairement sur les cartes mères  basées un chipset Nvidia ou SiS.
# <code>EHCI</code>, l'''Extended Host Controller Interface'' (interface de contrôleur d'hôte étendue). C'est le seul contrôleur d'hôte courant à prendre en charge l'USB 2.0. Il se trouve ordinairement sur tous les ordinateurs disposant de ports USB 2.0.
# <code>XHCI</code> l'''eXtensible Host Controller Interface.'' C'est le contrôleur hôte pour USB 3.0 et il est compatible avec USB 1.0, 1.1, 2.0, 3.0 et les vitesses futures. Activez cette fonctionnalité si la carte mère supporte USB 3.0.

La plupart des systèmes arrivent avec deux des types d'interface cités ci-dessus : XHCI (USB 3.0) ''et'' EHCI(USB 2.0).  Pour utiliser des périphériques USB, il n'est plus nécessaire de sélectionner les deux options étant donné que XHCI est compatible avec les versions antérieures. Les utilisateurs peuvent cependant activer EHCI pour etre ''vraiment'' surs mais cela ne pose aucun problème si les contrôleurs USB 2.0 ne sont pas disponibles.

Si les options pertinentes correspondant aux types de ports USB présents sur le sytème ne sont pas sélectionnées, des cas de ''ports USB morts'' peuvent être rencontrés. Ces cas peuvent être déterminés quand un périphérique fonctionnel est connecté, mais n'est pas alimenté ou ne répond pas. 

A neat {{c|lspci}} trick (from the {{Package|sys-apps/pciutils}} package) makes it relatively easy to detect which HCDs are present on system. Ignoring the SATA controller which was also matched, it is easy to spot that this system requires EHCI and XHCI support:

{{RootCmd|lspci -v {{!}} grep HCI|output=<pre>
00:14.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB xHCI (rev 04) (prog-if 30 [XHCI])
00:1a.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #2 (rev 04) (prog-if 20 [EHCI])
00:1d.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #1 (rev 04) (prog-if 20 [EHCI])
00:1f.2 SATA controller: Intel Corporation 8 Series/C220 Series Chipset Family 6-port SATA Controller 1 [AHCI mode] (rev 04) (prog-if 01 [AHCI 1.0])
</pre>
}}

Sélectionnez les HCDs présents sur le système. En général, sélectionnez les trois options pour un support maximal, ou si la configuration correcte est incertaine :

{{KernelBox|title=[[USB#Kernel_Configuration|Configuration des HCDs USB]]|1=
Device Drivers  --->
   USB support  --->
      <*> Support for Host-side USB
      ---   USB Host Controller Drivers
      <*>   xHCI HCD (USB 3.0) support
      <*>   EHCI HCD (USB 2.0) support
      < >   OHCI HCD  (USB 1.1) support
      < >   UHCI HCD (most Intel and VIA) support
}}

Dans le noyau Linux  3.12.13 et suivants, la ''prise en charge de OHCI pour les contrôleurs USB du bus PCI'' (<code>CONFIG_USB_OHCI_HCD_PCI</code>) doit être activée si le contrôleur USB est OHCI et  qu'une souris ou un clavier USB est utilisé.

=== Multiprocessor, Hyper-Threading and multi-core systems ===

Many computer systems are based on multiple processors, but not always in an immediately obvious way. 

* Many of Intel's CPUs support a technology which they call [https://en.wikipedia.org/wiki/Hyperthreading hyper-threading]. This technology enables a single CPU to be viewed by the system as two ''logical'' processors.
* Most Intel/AMD CPUs actually consist of multiple physical processors inside a single package, these processors are known as [https://en.wikipedia.org/wiki/Multi-core_processor multi-core] processors.
* Some high-end computer systems actually have multiple physical processors installed on specialized motherboards to provide a significant performance increase over a ''uniprocessor'' system. System users will probably know if they have such a system, since they are not cheap.

In all of these cases, the appropriate kernel options must be selected to obtain optimum performance from these setups:

{{KernelBox|title=Configuration for multi-processing support|1=
Processor type and features  --->
 [*] Symmetric multi-processing support
 [*]   SMT (Hyperthreading) scheduler support
 [*]   Multi-core scheduler support (NEW)
}}

The next option not only enables power management features, but might also be a requirement for making all CPUs available to the system:

{{KernelBox|title=Power management for multi-processor systems|1=
Power management and ACPI options  --->
 [*] ACPI (Advanced Configuration and Power Interface) Support
}}

=== Prise en charge de la mémoire x86 haute ===

Due to limitations in the 32-bit address space of the {{Keyword|x86}} architecture, a kernel with default configuration can only support up to 896MB RAM. If a system has more memory, only the first 896MB will be visible, unless high memory support has been enabled. 

{{Note|This limitation is specific to the {{Keyword|x86}} (IA32) architecture. Other architectures naturally support large amounts of memory, with no configuration tweaks required.}}

La prise en charge de la mémoire haute n'est pas activée par défaut, parce qu'elle introduit une légère surcharge. Ne vous laissez pas distraire par cela, la surcharge est insignifiante comparée au gain de performance procuré par une augmentation de la taille de la mémoire ! 

Choose the 4GB option, unless your system has more than 4GB of RAM:

{{KernelBox|title=Enabling high memory support on x86|1=
Processor type and features  --->
 High Memory Support  --->
  (X) 4GB
  ( ) 64GB
}}

=== Compressed kernel modules ===

From kernel version 3.18.x (and up) compression of kernel modules has been possible. gzip and xz compression are available. It is important to emerge {{Package|sys-apps/kmod}} with the proper USE flags ''before'' compiling a kernel with compressed modules:

{{FileBox|filename=/etc/portage/package.use|title=Enabling compression support for kmod|1=
sys-apps/kmod lzma zlib
}}

Re-emerge {{Package|sys-apps/kmod}}:

{{Emerge|params+=--oneshot --changed-use|sys-apps/kmod}}

Enable module compression and select a preferred compression method:
{{KernelBox|title=Enable module compression|1=
Enable loadable module support --->
  [*]   Compress modules on installation
  Compression algorithm ()  --->
    <X> GZIP
        XZ
}}

Usually {{c|make modules_install}} runs {{c|depmod}}. If {{Package|sys-apps/kmod}} did not have the proper USE flags set (see the {{Path|package.use}} step above) the first time it was run, then the dependency list will be empty. The system will therefore be unable to load any modules that were built compressed.

After kmod has been recompiled, re-run {{c|depmod}} as a solution to this problem:

{{RootCmd|depmod -a
|modprobe <module_name>
}}

== Configuration du noyau et notation abrégée  ==

=== Introduction ===

When reading about kernel configuration, often times settings are described as <var>CONFIG_<something></var>. This short-hand notation is what the kernel configuration actually uses internally, and is what will be found in the kernel configuration file (be it {{Path|/usr/src/linux/.config}} or in the auto-generated {{Path|/proc/config.gz}} file). Of course, using short-hand notation would not do much good if this cannot translate this to the real location in the kernel configuration. The {{c|make menuconfig}} tool makes this possible.

=== Traduire  CONFIG_FOO en un emplacement réel dans les menus de configuration ===

Suppose the <var>CONFIG_TMPFS_XATTR</var> feature needs to be enabled. Launch the kernel configuration menu ({{c|make menuconfig}}) and press the {{Key|/}} key. This will open a search box. In the search box, type <var>CONFIG_TMPFS_XATTR</var>. 

The following is an output of the result of this search:

{{KernelBox|title=Result of searching menuconfig for "CONFIG_TMPFS_XATTR"|1=
Symbol: TMPFS_XATTR [=n]
Type  : boolean
Prompt: Tmpfs extended attributes
  Defined at fs/Kconfig:138
  Depends on: TMPFS [=y]
  Location:
    -> File systems
      -> Pseudo filesystems
        -> Virtual memory file system support (former shm fs) (TMPFS [=y])
  Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
}}

Cette sortie nous fournit une multitude d'informations intéressantes.

{| class="table table-condensed table-striped" style="text-align: left;" 
|- 
! Entry
! Description
|- 
| Symbol: TMPFS_XATTR [=n]
| This identifies the kernel configuration entry being searched for. It also shows that this setting is currently ''not enabled'' ([=n]).
|- 
| Type: boolean
| The setting searched for is a boolean (which means it can be one of two options: enabled or disabled). Some settings are numbers or strings.
|- 
| Prompt: Tmpfs extended attributes
| This is the text found in the {{c|make menuconfig}} entry that controls the variable (<var>TMPFS_XATTR</var>) in the {{Path|.config}} file. It is essentially the variable name in a more human readable format.
|- 
| Depends on: TMPFS [=y]
| Before this entry can be seen <var>CONFIG_TMPFS</var> must be enabled. In this case it is already done (hence the [=y]) but if this is not the case, first look for (and enable) <var>CONFIG_TMPFS</var>.
|- 
| Location: ...
| This is the location in the {{c|make menuconfig}} structure where the setting can be found. Remember, the setting to look for is ''Tmpfs extended attributes''.
|- 
| Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
| If the settings described here are both enabled (in this case the first one is not), then <var>CONFIG_TMPFS_XATTR</var> will be automatically enabled and will not be possible to be ''disabled'' until one of these settings is de-selected.
|-
|}

With this information, it should be possible to translate any <var>CONFIG_*</var> requirements fairly easily. In short, it means a user must

# Enable the settings described in the ''Depends on'' field;
# Navigate where ''Location:'' points;
# Toggle the value referred to by ''Prompt:'';

== Autres documentations sur la configuration du noyau ==

So far only general concepts and specific problems related to kernel configuration has been discussed; precise details have been left up to the user to discover. However, other parts of the Gentoo documentation collection provide specialized details for the topics at hand.

Such documents may be helpful while configuring specific areas of the kernel. Although this warning was mentioned previously in this guide, remember: users who are new to kernel configuration should not be adventurous when attempting to configure their kernels. Start by getting a basic system up and running, support for your audio, printing, etc., can always be added at a later date.

Getting the basics of a kernel operational will help users in later configuration steps because the user will know what is breaking their system and what is not. It is always wise to save the base (working) kernel configuration in a folder other than the kernel's sources folder ''before'' attempting to add new features or hardware.  

* The [[ALSA|ALSA article]] details the configuration options required for sound card support. Note that ALSA is an exception to the suggested scheme of not building things as modules: ALSA is actually much easier to configure when the components are modular.

* The [[Bluetooth|Bluetooth article]] details the options needed in order to use Bluetooth devices.

* The [[IPv6 router guide]] describes how to configure the kernel for routing using the next generation network addressing scheme.

* If the closed-source nVidia graphics drivers will be used for improved 3D graphics performance, the [[NVidia/nvidia-drivers|nVidia Guide]] lists the options that should and should not be selected on such a system.

* Amongst other things, the [[Power_management/Guide|Power Management guide]] explains how to configure the kernel for CPU frequency scaling, and for suspend and hibernate functionality.

* If running a PowerPC system, the [[PPC/FAQ|PPC FAQ]] has a few sections about PPC kernel configuration.

* The [[Printing|Printing guide]] lists the kernel options needed to support printing in Linux.

* The [[USB/Guide|USB Guide]] details the configuration settings required to use common USB devices such as keyboards, mice, storage devices, and USB printers.

== Dépannage ==

=== Les changements apportés à la configuration restent sans effet ===

It is very common for users to make a configuration change, but then make a small mistake in the process of actually booting to their newly configured kernel. They reboot into a kernel image that is not the one they just reconfigured, observe that whatever problem they were trying to solve is still present, and conclude that the configuration change does not solve the problem. 

The process of compiling and installing kernels is outside the scope of this document; refer to the [[Kernel/Upgrade|Kernel Upgrade Guide]] for general guidance. In short, the process to get a modified kernel is the following: 1) configure, 2) compile, 3) mount {{Path|/boot}} (if not already mounted), 4) copy new kernel image to {{Path|/boot}}, 5) Make sure the bootloader will reference the new kernel, 6) reboot. If one of those final stages has been missed, then the changes will not properly take effect.

It is possible to verify if the kernel that has booted matches the newly kernel compiled on the hard disk. This is performed by examining the date and time of the kernel's compilation. Assuming the system architecture is {{Keyword|x86}} and the kernel sources are installed at {{Path|/usr/src/linux}}, the following command can be used:

{{RootCmd|uname -v|sortie=<pre>
#4 SMP PREEMPT Sat Jul 15 08:49:26 BST 2006
</pre>}}

The above command will display the date and time the currently booted kernel was compiled.

{{RootCmd|ls -l /usr/src/linux/arch/i386/boot/bzImage|sortie=<pre>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
</pre>}}

The above command displays the date and time that the kernel image on the hard disk was last compiled.

If the time stamps from the above commands differ by more than 2 minutes, it indicates a mistake was made during kernel reinstallation and the system has not booted from the newly modified kernel image.

=== Les modules ne sont pas chargés automatiquement ===

As mentioned earlier in this document, the kernel configuration system hides a large behavioral change when selecting a kernel component as a module (M) rather than built-in (Y). It is worth repeating this again because so many users fall into this trap.

When selecting a component as built-in, the code is built into the kernel image (bzImage). When the kernel needs to use that component, it can initialize and load it automatically, without any user intervention. 

When selecting a component as a module, the code is built into a kernel module file and installed on the filesystem. In general, when the kernel needs to use that component, it will not be able to find it. With some exceptions, the kernel makes no effort to actually load these modules — this task is left up to the user. 

If building support for a network card as a module, and it is discovered the network is not accessible, it is probably because the module is not loaded — either this must be done manually or the system must be configured to autoload the module at boot time.

Unless a user has a reasons to do otherwise, some time can be saved by building these components directly into the kernel image, so that the kernel can automatically configure these small settings by itself. 

== See also ==

* [[genkernel]] - A tool used to automate the build process of the kernel and initramfs.
* [[Security Handbook/Kernel security#The proc filesystem|proc filesystem (Security Handbook)]] - Dynamically change kernel parameters and variables on the fly.


[[Category:Kernel]] [[Category:Server and Security]] {{Migrated|originalauthors=Daniel Drake, Curtis Napier, Justin Robinson, Lukasz Damentko, Jonathan Smith, nightmorph}}
