<languages />

{{InfoBox stack
|{{InfoBox wikipedia|header=true}}
}}

{{Metadata|abstract=UTF-8은 가변 길이 문자 인코딩이며, 심볼당 1바이트에서 4바이트를 사용합니다. 따라서 첫번째 UTF-8 바이트는 ASCII에 대한 이전 호환성을 완전히 갖춘 문자 세트를 제공하는 ASCII 인코딩 용도로 사용합니다. UTF-8은 ASCII와 라틴 문자를 데이터의 크기를 크게 변화하지 않고도 상호 표현이 가능함을 의미하는데, 첫 번째 바이트만 활용하기 때문입니다. 상위 바이트 범위를 할당 받아 만족하지 않는 일본어권 사용자 같은 동양 문자 사용자들에게는 최대 50%의 데이터 중복을 취하게 되었습니다.}}

UTF-8은 가변 길이 문자 인코딩이며, 심볼당 1바이트에서 4바이트를 사용합니다. 따라서 첫번째 UTF-8 바이트는 ASCII에 대한 이전 호환성을 완전히 갖춘 문자 세트를 제공하는 ASCII 인코딩 용도로 사용합니다. UTF-8은 ASCII와 라틴 문자를 데이터의 크기를 크게 변화하지 않고도 상호 표현이 가능함을 의미하는데, 첫 번째 바이트만 활용하기 때문입니다. 상위 바이트 범위를 할당 받아 만족하지 않는 일본어권 사용자 같은 동방 문자 사용자들에게는 최대 50%의 데이터 중복을 취하게 되었습니다. 

== 문자 인코딩 ==

=== 문자 인코딩이란 무엇인가요? ===

컴퓨터는 인쇄한 텍스트를 자체적으로 사람이 이해하는 것처럼 이해하지 못합니다. 컴퓨터는 모든 텍스트의 문자를 숫자로 표현합니다. 옛부터 각 숫자 모음은 알파벳과 문자를 표현하는데 사용했습니다(코딩 시스템, 인코딩, 문자세트로 알려짐)만 컴퓨터 하드웨어의 제한으로, 크기의 제한을 받았습니다. 

=== 문자 인코딩 역사 ===

가장 일반적(또는 최소한 광범위하게 수용해온) 문자세트는 '''ASCII'''(정보 교환용 미 표준 코드)였습니다. 지금껏 만들어온 소프트웨어 표준에 있어 가장 성공적으로 이끌어온 ASCII야 말로 광범위하게 사용했습니다. 최신 ASCII는 1986년도에 미 국립 표준 협회에서 표준으로 제정(ANSI X3.4, RFC 20, ISO/IEC 646:1991, ECMA-6) 했습니다. 

ASCII는 7비트로 엄격하게 제한되었으며, 표현 가능한 7개의 이진수로 비트 패턴을 사용함을 의미하는데, 10진수로는 0부터 127까지의 범위를 제공합니다. 여기에는 32개의 보이지 않는 제어 문자가 있는데, 0부터 31까지의 범위에 있으며, 마지막 제어 문자는 DEL또는 delete이며, 이 제어문자는 127번에 할당되어 있습니다. 32번 부터 126번 까지는 공백 문자, 문장 부호, 라틴 문자, 숫자와 같은 눈에 보이는 문자로 구성되어 있습니다. 

ASCII의 8번째 비트는 본디 오류 검출을 위한 패리티 비트로 활용했습니다. 오류 검사를 고려하지 않으면 0으로 그대로 둡니다. ASCII에서 각 문자를 단일 바이트로 표현했음을 의미합니다. 

ASCII를 최근의 영문 의사소통을 하는데는 충분했었지만, 강세부호가 들어간 문자가 있는 다른 유럽어권의 문자에 대해서는 그렇지 않았습니다. 이런 필요성 때문에 ISO 8859 표준을 개발했습니다. ASCII와의 이전 호환성을 유지했지만 8번째 비트를 빈 채로 내버려두는 대신에 각 인코딩 주소에 다른 127개의 문자를 넣도록 했습니다. ISO 8859의 한계는 곧 다가왔고, 현재 ISO 8859 표준의 15가지 변형 표준이 있습니다. 이러한 문자 세트의 ASCII 호환 바이트 범위밖에서는 각 바이트로 표현하는 문자간의 충돌이 종종 일어났습니다. 문자 인코딩간 상호 처리를 좀 더 복잡하게 처리하기 위해 일부 마이크로소프트 윈도우 버전에서는 서유럽어권에 대해 Windows-1252 표준을 사용했습니다. 이 표준은 ISO-8859-1의 상위 집합이지만 여러모로 다른 점이 있었습니다. 이 문자세트는 ASCII 호환성을 유지했습니다. 

일본어와 한국어 같은 언어를 대상으로 사용하는 EUC(확장 유닉스 코딩)와 같은 비 라틴어 계열 문자를 대상한 완전히 다른 단일 바이트 인코딩의 개발 필요성은, 이미 다른 운영체제에서 동일한 언어에 대해 Shift-JIS, ISO-2022-JP와 같은 다른 문자셋을 이미 사용하고 있는 상황에서 더욱 혼동감을 가져왔습니다. 키릴 자모를 보려는 사용자는 러시아와 불가리아에서 사용하는 KOI8-R, 우크라이나에서 사용하는 KOI8-U, 온전치 못한 ISO 8859-5, 보통 사용하던 Windows-1251 세트 중 하나를 선택해야 했습니다. 이들 대부분의 모든 문자세트는 ASCII와의 호환성을 깨뜨렸습니다. 비록 KOI8 인코딩에서는 라틴 문자 숫서대로 키릴 문자를 배치했다는 점에 주목할 수 있지만, 이 경우 8번째 비트는 제거되었으며, 텍스트는 대소문자가 뒤집힌 음역 상태로 ASCII 터미널에서 해석 가능했습니다. 

이러한 판단 추세가 상당한 혼동을 가져왔으며, 다중 언어 의사 소통에 있어 거의 완전하게 불가능했고, 특히 다른 문자에 대해서도 불가능했습니다. 이제 유니코드로 들어가보도록 하겠습니다. 

=== 유니코드가 무엇인가요? ===

유니코드는 기존 문자세트의 단일 비트 제한을 깨버렸습니다. 최대 1,114,112 문자를 표현하기 위해, 65536 코드 포인트의 17가지 "영역"을 활용합니다. "기본 다중 언어 영역" 또는 BMP로 알려진 첫 번째 영역에서는 사용자가 필요로 하는 모든 문자를 담고 있습니다. 대부분 유니코드가 16비트 문자 세트였다는 잘못된 가정을 낳았습니다. 

유니코드는 여러가지 다른 방식으로 대응을 수행하지만, 주로 가장 많이 사용하는 방식은 '''UTF'''(유니코드 변환 형식)와 '''UCS'''(유니버설 문자 세트) 방식입니다. UTF 다음의 숫자는, 하나의 유닛에 들어가는 비트 수를 나타내며, UCS 다음에 나타나는 숫자는 총 바이트 수를 나타냅니다. 가장 널리 활용하게 된 UTF-8 은 유니코드 내용을 있는 그대로의 8비트로 표현합니다. 그러니까, UTF-8이 이 문서의 제목입니다.

=== UTF-8이 처리할 수 있는 것 ===

UTF-8은 표준 호환과 전세계적으로 통용되는 다중 언어 환경을 살려 작업할 수 있도록 하며 데이터 중복성을 비교적 최소화 합니다. UTF-8은 비 ASCII 문자를 인터넷으로, 전자 메일 또는 IRC로 전송할 때 알맞은 방법입니다. 이럼에도 불구하고, 대부분의 사용자는 온라인 소통에 대해 UTF-8 사용을 모욕적인 행위로 여기기도 합니다. ''비 ASCII'' UTF-8 을 사용하기 전에 일부 채널, 메일링 리스트, 유즈넷 그룹에서의 UTF-8에 대한 인식은 매우 긍정적입니다. 

== 젠투 리눅스에서 UTF-8 설정 ==

=== UTF-8 로캘 찾기 또는 만들기 ===

이제 유니코드의 이론을 이해했으며 UTF-8을 자체적으로 사용할 준비가 끝났습니다!

더 많은 설명에 관심있는 사용자 분들을 위해 [[Localization/Guide/ko|젠투 지역화 안내서]]에 내용을 준비했습니다. 

선택한 언어에 대해 UTF-8 로캘을 사용할 수 있는지, 로캘을 만들어야 하는 지 여부를 결정해야합니다.

{{Cmd|locale -a {{!}} grep 'en_GB'|output=<pre>
en_GB
en_GB.utf8
</pre>
}}

이 명령행의 출력과 같이, <code>.UTF-8</code>와 같은 접미부가 나타나야 합니다. <code>.UTF-8</code> 접미부와 유사한 결과가 나타나지 않는다면 UTF-8 호환 로캘을 만들어야 합니다. 

{{Note|사용할 언어에 대한 UTF-8 로캘이 없을 경우에만 다음 코드 예제를 실행하십시오.}}

"en_GB"를 원하는 로캘 설정으로 바꾸십시오:
{{RootCmd|localedef -i en_GB -f UTF-8 en_GB.UTF-8}}

다른 방법으로 UTF-8 로캘을 포함하려면 {{Path|/etc/locale.gen}} 파일에 추가하고 {{c|locale-gen}} 명령으로 필요한 로캘을 생성하십시오. 생성한 로캘은 {{Path|/usr/lib/locale/locale-archive}} 디렉터리에 기록합니다.

{{CodeBox|title=/etc/locale.gen의 줄|1=
en_GB.UTF-8 UTF-8
}}

{{RootCmd|locale-gen|output=<pre>
 * Generating 1 locales (this might take a while) with 1 jobs
 *  (1/1) Generating en_GB.UTF-8 ...                            [ ok ]
 * Generation complete
</pre>}}

=== 로캘 설정 ===

새 UTF-8 로캘을 사용하려고 설정해야 할 환경 변수가 하나 있습니다. <var>LC_CTYPE</var>(또는 시스템 언어도 바꾸려면 추가적으로 <var>LANG</var>도 변경)이 바로 그 변수입니다. 로캘을 설정하는 여러가지 방법이 있습니다. 어떤 시스템 관리자는 일부 사용자에게만 UTF-8 환경을 맞춰주는데, 이 경우 각 사용자에게 (본 쉘 사용자가 {{Path|/bin/sh}}를 사용할 경우) {{Path|~/.profile}} 파일, (본 어게인 쉘 사용자가 {{Path|/bin/bash}}를 사용할 경우) {{Path|~/.bash_profile}} 또는 {{Path|~/.bashrc}}를 사용합니다. 더 자세한 내용과 가장 적합한 실제 사용 예는 [[Localization/Guide/ko|지역화 안내서]]에서 찾아보실 수 있습니다. 

로캘을 설정하는 또 다른 선호 방식은 전체적으로 설정하는 방법입니다. {{Path|/etc/init.d/xdm}}를 사용 할 때와 같은 특정 환경의 경우 작성자에게 부분적으로 추천하는데, 초기화 스크립트가 앞서 언급한 쉘 시작 파일을 source로 등록하기 전에 디스플레이 관리자와 데스크톱을 시작합니다. 다시 말해, 환경 변수 값을 설정하기 전에 언급한 과정을 수행합니다. 

{{Path|/etc/env.d/02locale}} 파일을 사용하면 전체 로캘 설정을 할 수 있습니다. 이 파일의 내용은 다음과 같아야 합니다: 

{{CodeBox|title=/etc/env.d/02locale 예제|lang=bash|1=
## (As always, change "en_GB.utf8" to the appropriate locale value; each language has a different value!)
LANG="en_GB.utf8"
}}

{{Note/ko| <var>LANG</var> 변수를 <var>LC_CTYPE</var> 변수로 바꿀 수 있습니다. <var>LC_CTYPE</var> 사용에 영향을 주는 범위의 자세한 정보는 [http://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html#Locale-Categories 그뉴 로캘 페이지]<sup style="color:#ff0077">en</sup>를 참고하십시오.}}

다음 명령을 실행하여 환경을 업데이트해야합니다: 

{{RootCmd|env-update|output=<pre>
>>> Regenerating /etc/ld.so.cache...
</pre>}}
{{RootCmd|source /etc/profile}}

이제 어떠한 매개변수 값도 설정하지 말고 {{c|locale}}을 실행하여 환경에 올바른 값을 설정했는지 확인하십시오: 

{{RootCmd|locale|output=<pre>
LANG=en_GB.utf8
LC_CTYPE="en_GB.utf8"
LC_NUMERIC="en_GB.utf8"
LC_TIME="en_GB.utf8"
LC_COLLATE="en_GB.utf8"
LC_MONETARY="en_GB.utf8"
LC_MESSAGES="en_GB.utf8"
LC_PAPER="en_GB.utf8"
LC_NAME="en_GB.utf8"
LC_ADDRESS="en_GB.utf8"
LC_TELEPHONE="en_GB.utf8"
LC_MEASUREMENT="en_GB.utf8"
LC_IDENTIFICATION="en_GB.utf8"
LC_ALL=
</pre>
}}

=== 로캘 설정할 때 대신 eselect 활용 ===
위에서 설명한 방법이 시스템을 관리하는 좋은 방법이긴 하지만, {{c|eselect}} 유틸리티로 올바른 로캘 설정을 검증할 수 있습니다.

시스템에서 사용할 수 있는 로캘 목록을 보려면 {{c|eselect}}를 사용하십시오:

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX *
  [3] en_GB.utf8
  [ ] (free form)
</pre>
}}

{{c|eselect}} 명령을 사용하면 목록에 나타난 바와 마찬가지로 로캘 설정이 단순해집니다. 다음 처럼 명령을 실행하면 올바른 로캘을 결정합니다:

{{RootCmd|eselect locale set 3 |output=<pre>
Setting LANG to en_GB.utf8 ...
</pre>
}}

결과를 확인하십시오:

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX
  [3] en_GB.utf8 *
  [ ] (free form)
</pre>
}}

이 경우 {{Path|/etc/env.d/02locale}} 파일에 <code>.utf8</code> 대신 <code>.UTF-8</code>을 넣게 됩니다. {{c|eselect}} 명령을 적절하게 실행하십시오:

{{RootCmd|eselect locale set en_GB.UTF-8 |output=<pre>
Setting LANG to en_GB.UTF-8 ...
</pre>
}}

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX
  [3] en_GB.utf8
  [4] en_GB.UTF-8 *
  [ ] (free form)
</pre>
}}

다음 명령을 실행하면 쉘에서 변수 값을 업데이트합니다:

{{RootCmd|env-update && source /etc/profile |output=<pre>
>>> Regenerating /etc/ld.so.cache...
</pre>
}}

다 되었습니다. 이제 시스템에서는 UTF-8 로캘을 사용합니다. 다음 넘어야 할 장애물은 매일 사용하는 프로그램의 설정입니다.

== 프로그램 지원 ==

소프트웨어 세계에서 처음 유니코드를 도입할 즈음엔, 멀티바이트 문자 세트는 대부분 일반적으로 사용하는 프로그램의 기본 언어인 C와 같은 언어에 잘 맞지 않았습니다. 하지만 최근에는 일부 프로그램만 UTF-8을 적절하게 처리하지 못합니다. 다행스럽게도, 대부분의 일반적인 프로그램에서 지원합니다! 

=== 파일 이름, NTFS, FAT ===

리눅스 커널 설정 메뉴에 다양한 NLS 옵션이 있지만, 혼동하지 말아야 합니다! 대부분의 경우 UTF-8 NLS 지원을 커널에 넣어 기본 NLS 옵션을 utf8로 바꾸면 됩니다. 

{{KernelBox|title=UTF-8 NLS 커널 설정 단계|<pre>
File Systems -->
  Native Language Support -->
    (utf8) Default NLS Option
    <*> NLS UTF8
    ## (Also <*> other character sets that are in use in the system's FAT filesystems or Joilet CD-ROMs.)
</pre>
}}

NTFS 파티션을 마운트한다면 <code>nls=</code> 옵션을 지정해야합니다. FAT 파티션을 마운트한다면 <code>codepage=</code> 옵션을 지정해야합니다. 추가적으로, 커널 설정에서 FAT의 기본 코드 페이지를 지정할 수 있습니다.

{{Note|{{c|mount}} 명령에서 <code>codepage</code> 옵션을 사용하면 커널 설정을 무시하고 중복 우선 적용합니다.}}

{{KernelBox|title=커널 설정 메뉴 중 FAT 설정|<pre>
File Systems -->
  DOS/FAT/NT Filesystems  -->
    (437) Default codepage for fat
</pre>
}}

<code>Default iocharset for fat</code> 설정을 UTF-8로 지정하는건 추천하지 않으므로 피하십시오. 대신 FAT 파티션을 마운트할 때 <code>utf8=true</code> 옵션을 전달할 수 있습니다. 더 많은 정보는 {{c|man mount}}와 {{Path|/usr/src/linux/Documentation/filesystems/vfat.txt}}의 커널 문서를 살펴보십시오.

파일 이름 인코딩을 바꾸려면 {{Package|app-text/convmv}} 패키지를 사용할 수 있습니다. 

{{Emerge|app-text/convmv}}

{{c|convmv}} 명령의 형식은 다음과 같습니다:

{{RootCmd|convmv -f <current-encoding> -t utf-8 <filename>}}

iso-8859-1 대신 바꾸고자 하는 문자 세트 이름을 넣으십시오:

{{RootCmd|convmv -f iso-8859-1 -t utf-8 filename}}

파일의 ''내용''을 바꾸려면, 모든 젠투 시스템에 설치해야 하는 {{Package|sys-libs/glibc}} 꾸러미의 {{c|iconv}} 유틸리티를 사용하십시오.  iso-8859-1 대신 바꾸고자 하는 문자 세트 이름을 넣으십시오. 명령을 실행한 후에는 출력 결과가 온전히 나왔는지 확인하십시오:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 filename}}

파일을 변환하려면 다른 파일을 만들어야 합니다:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 filename > newfile}}

이 목적으로 recode({{Package|app-text/recode}}) 꾸러미도 사용할 수 있습니다.

=== 시스템 콘솔 ===

UTF-8을 콘솔에서 사용하려면, {{Path|/etc/rc.conf}}를 편집하십시오.<code>unicode="yes"</code>를 설정해야 하며 파일의 주석을 읽어보십시오. 유니코드 문자 영역 대부분의 영역을 잘 구현한 글꼴을 보유하는 게 중요합니다. 이 문제를 해결하려면 유니코드 로캘을 제대로 만들었는지 확인하십시오. 

{{Path|/etc/conf.d/keymaps}}에 설정한 <var>keymap</var> 변수에서, Unicode 키 맵을 지정해야합니다. 

{{CodeBox|title=/etc/conf.d/keymaps 일부 예제|lang=bash|1=
## (Change "uk" to the right local layout)
keymap="uk"
}}

=== ncueses 와 slang ===

{{Note/ko|slang을 설치하지 않았거나 필요로 하지 않는다면 이 장의 slang 언급 부분은 무시하십시오.}}

{{Path|[[:/etc/portage/make.conf#USE|/etc/portage/make.conf]]}}에 [https://packages.gentoo.org/useflags/unicode <code>unicode</code>]를 전역 [[Use flag|USE 플래그]]<sup style="color:#ff0077">en</sup>로 추가하는 것이 좋으며, 원할 경우 {{Package|sys-libs/ncurses}}와 {{Package|sys-libs/slang}}을 다시 이머지하는 것이 좋습니다. 포티지는 <code>--changed-use</code> 또는 <code>--newuse</code>를 지정했을 경우 자동으로 처리합니다. 꾸러미를 가져오려면 다음 명령을 내리십시오: 

{{RootCmd|emerge --update --deep --newuse world}}

이들 설정을 연결하려 꾸러미를 다시 빌드해야 하므로 이제 바꾼 USE 설정을 적용하겠습니다. 우리가 사용할 도구({{c|revdep-rebuild}})는 {{Package|app-portage/gentoolkit}} 꾸러미에 있습니다. 

{{RootCmd|revdep-rebuild --soname libncurses.so.5
|revdep-rebuild --soname libslang.so.1}}

=== KDE, 그놈, Xfce ===

모든 주요 데스크톱 환경은 완전한 유니코드 지원 기능을 제공하며, 이 안내서에서 이미 다룬 더 이상의 설정이 필요하지 않습니다. 왜냐면 근본적인 그래픽 툴-키트(Qt 또는 GTK+2)는 UTF-8을 인식하기 떄문입니다. 그 다음에는 이 툴키트 위에서 동작하는 모든 프로그램은 특별히 UTF-8을 인지해야 합니다. 

{{:Input_methods/key_sequence}}

Xlib와 GTK+1 활용시 별도의 고려사항이 있습니다. GTK+1에서는 ~/.gtkrc에 iso-10646-1 FontSpec이 필요한데, <code>-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1</code>를 예로 들 수 있습니다. 또한 Xlib나 Xaw를 활용하는 프로그램은 동일한 FontSpec이 필요한데, 이 요건을 충족하지 않으면 동작하지 않습니다. 

{{Note|그놈1 버전 제어판을 보유하고 있다면, 대신 이 버전을 사용하십시오. 해당 버전에서 어떤 iso10646-1 서체든 고르십시오.}}

{{CodeBox|title=유니코드 호환 글꼴을 정의하는 ~/.gtkrc (for GTK+1) 예제|1=
style "user-font"
{
    fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"
}
widget_class "*" style "user-font"
}}

프로그램에서 Qt와 GTK+2 GUI를 지원한다면, 보통 GTK+2 GUI가 유니코드를 더 잘 지원합니다.

=== X11과 글꼴 ===

유니코드 체계에서 명백히 모든 단일 글리프를 서체에 만들어놓진 않지만, 트루타입 서체는 유니코드를 지원하며, Xorg에 확장 문자를 지원하는 대부분의 서체가 트루타입입니다. 

또한 포티지의 다양한 글꼴 꾸러미는 유니코드 기반입니다. 추천 글꼴 및 설정 관련 내용은 [[Fontconfig/ko|Fontconfig]]를 참고하십시오.

=== 창 관리자와 터미널 에뮬레이터 ===

창 관리자는 유니코드를 상당히 잘 지원하는 GTK+나 Qt로 보통 빌드하지 않고, 보통 글꼴을 처리할 때 Xft 라이브러리를 사용합니다. 창 관리자가 글꼴을 처리할 때 Xft를 사용하지 않는다면, 이전에 언급한 FontSpec을 유니코드 글꼴에 활용할 수 있습니다. 

Xft를 사용하며 유니코드를 지원하는 터미널 에뮬레이터는 좀처럼 찾아보기 쉽지 않습니다. Konsole과 gnome-terminal 이외에 포티지에서 선택할 수 있는 최상의 선택지는,  {{Package|x11-terms/rxvt-unicode}}, {{Package|x11-terms/xfce4-terminal}}, {{Package|gnustep-apps/terminal}}, {{Package|x11-terms/mlterm}}, 또는 <code>unicode</code> USE 플래그를 사용할 때 uxterm으로 실행하는 {{Package|x11-terms/xterm}} 입니다.{{Package|app-misc/screen}}에서는 {{c|screen -U}} 또는 {{Path|~/.screenrc}}에 다음 명령을 넣었을 때 UTF-8을 지원합니다: 

{{CodeBox|title=UTF-8용 ~/.screenrc|1=
defutf8 on
}}

=== Vim, Emacs, Xemacs, Nano ===

[[Vim#Change_file_encoding|Vim]]<sup style="color:#ff0077">en</sup> 은 UTF-8을 완벽하게 지원하며, UTF-8 파일을 자체적으로 감지합니다. [[Vim#Change_file_encoding|Vim]]<sup style="color:#ff0077">en</sup>에 대한 더 많은 내용은 <code>:help mbyte.txt</code> 명령으로 살펴보십시오. 

[[GNU Emacs]]<sup style="color:#ff0077">en</sup>은 버전 23부터, [[XEmacs]]<sup style="color:#ff0077">en</sup>은 버전 21.5부터 UTF-8을 완벽하게 지원합니다. GNU  Emacs 24 에서도 양방향성 텍스트 편집을 지원합니다: 

nano는 1.3.6부터 UTF-8을 완벽하게 지원합니다.

=== 쉘 ===

현재, {{c|[[bash]]}}에서는 GNU readline 바이너리를 통해 유니코드를 완벽하게 지원합니다. Z 쉘({{c|[[zsh]]}})에서는 <code>unicode</code> USE 플래그로 유니코드를 지원합니다. 

The C 쉘 {{c|tcsh}}와 {{c|ksh}}는 UTF-8을 완전히 지원하지 않습니다.

=== Irssi ===

Irssi는 사용자가 옵션을 별도로 설정해야 하지만 UTF-8을 완벽하게 지원합니다. 

{{Cmd|set term_charset UTF-8|prompt=[irssi] }}

비 UTF-8 문자 세트로 비 ASCII 문자를 자주 주고받는 채널이라면, 문자를 변환할때 {{c|/recode}} 명령을 사용하십시오. 더 많은 내용은 {{c|/help recode}}를 입력하십시오.

=== Mutt ===

Mutt 메일 사용자 에이전트는 유니코드를 상당히 잘 지원합니다. Mutt에서 UTF-8을 사용하려면 설정 파일에 무언가를 설정할 필요가 없습니다. Mutt는 모든 설정 파일(서명 포함)을 UTF-8로 인코딩했다면 별도의 수정 없이 유니코드 환경에서 동작합니다. 

{{Note|Mutt에서 메일을 볼 때 여전히 '?'이 보일 수도 있습니다. 이 현상은 다른 사람들이 전자메일에 문자세트를 명확하게 표시하지 않는 메일 클라이언트를 사용하기 때문입니다. 그 사람들이 클라이언트를 제대로 설정하도록 이야기해주는 방법 말고 취할 수 있는 조치가 몇 있긴 합니다.}}

더 많은 내용은 [http://wiki.mutt.org/index.cgi?MuttFaq/Charset Mutt 위키]<sup style="color:#ff0077">en</sup>에 있습니다.

=== Man ===

Man pages are an integral part of any Linux machine. To ensure that any unicode in the man pages render correctly, edit {{Path|/etc/man.conf}} and replace a line as shown below. This is only needed when {{Package|sys-apps/man}} is used instead of {{Package|sys-apps/man-db}}.

{{CodeBox|title=유니코드 지원용 man.conf 변경|1=
## (This is the old line)
NROFF           /usr/bin/nroff -Tascii -c -mandoc
## (Replace the one above with this)
NROFF           /usr/bin/nroff -mandoc -c
}}

=== elinks와 links ===

일반적으로 사용하는 텍스트 기반 브라우저에서 어떻게 UTF-8 지원 기능을 사용하는지 살펴보도록 하겠습니다. {{c|elinks}}와 {{c|links}}에서는 두가지 방법이 있는데, 브라우저 안에서 설정 옵션을 사용하는 방법이 있고, 설정 파일을 편집하는 방법이 있습니다. 브라우저에서 옵션을 설정하려면 {{c|elinks}} 또는 {{c|links}}에서 사이트를 열고 {{Key|Alt}} + {{Key|S}}를 눌러 설정 메뉴로 들어간 다음 터미널 옵션을 선택하거나 {{Key|T}}를 누르십시오. 스크롤을 내린 후 마지막 옵션 <code>UTF-8 I/O</code>을 {{Key|Enter}}를 눌러 선택하십시오. 저장하고 메뉴를 빠져나오십시오. {{c|links}} 에서는 {{Key|Alt}} + {{Key|S}} 를 반복해서 누른 후 {{Key|S}}를 눌러 저장하십시오. 설정 파일 옵션은 아래에 있습니다. 

{{CodeBox|title=elinks/links의 UTF-8 활성화|1=
## (For elinks, edit /etc/elinks/elinks.conf or ~/.elinks/elinks.conf and
add the following line)
set terminal.linux.utf_8_io = 1
## (For links, edit ~/.links/links.cfg and add the following line)
terminal "xterm" 0 1 0 us-ascii utf-8
}}

=== Samba ===

삼바는 Mac, 리눅스, FreeBSD와 같은 UNIX 시스템에서 SMB(서버 메시지 블록) 프로토콜을 구현한 소프트웨어 모음입니다. 이 프로토콜은 일반 인터넷 파일 시스템(CIFS)처럼 참고하기도 합니다. 삼바에는 윈도우 네트워크 파일 공유에 사용하는 NetBIOS 시스템도 있습니다. 

다음 내용을 [global] 섹션에 추가하십시오:
{{RootCmd|nano -w /etc/samba/smb.conf|output=<pre>
dos charset = 1255
unix charset = UTF-8
display charset = UTF-8
</pre>
}}

=== 전체 시험하기 ===

UTF-8을 시험해볼 수 있는 웹사이트는 이곳저곳에 널려있으며, 인기있는 대부분의 [https://packages.gentoo.org/categories/www-client 젠투 웹 브라우저]에서 UTF-8을 완벽하게 지원합니다. 

텍스트 전용 웹 브라우저중 하나를 사용할 경우, 유니코드를 표시하는 터미널을 사용하는지 확실히 파악해두십시오.

몇가지 글자가 문자 또는 숫자 사이사이에 상자로 나타난다면, 사용하고 있는 [[fonts|글꼴]]에 해당 문자에 대한 글리프가 없다는 의미입니다. 따라서, 원래 문자 대신 UTF-8 심볼의 16진수 코드에 해당하는 박스를 표시합니다. 

* [http://unicode-table.com/en/ unicode-table.com]
* [http://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html W3C UTF-8 시험 페이지] 
* [http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm 프랑크푸르트 대학교 제공 UTF-8 시험 페이지]

== 알려진 문제 ==

=== 시스템 설정 파일 (/etc) ===

({{Path|/etc/fstab}}과 같은) 대부분의 시스템 설정 파일에서는 UTF-8을 지원하지 않습니다. 이 파일은 ASCII 문자 세트를 그대로 계속 사용하시는게 좋습니다.

== 외부 자료 ==

* [https://en.wikipedia.org/wiki/Unicode The Wikipedia entry for Unicode] 
* [https://en.wikipedia.org/wiki/UTF-8 The Wikipedia entry for UTF-8] 
* [http://www.unicode.org Unicode.org] 
* [http://www.utf-8.com UTF-8.com] 
* [https://www.ietf.org/rfc/rfc3629.txt RFC 3629] 
* [https://www.ietf.org/rfc/rfc2277.txt RFC 2277] 
* [https://www.tbray.org/ongoing/When/200x/2003/04/26/UTF Characters vs. Bytes]
* [https://www.gnu.org/software/libc/manual/html_node/Locales.html The GNU C Library: Locales and Internationalization]
* [http://unifoundry.com/unicode-tutorial Unifoundry.com - Unicode Tutorial]
* [https://packages.gentoo.org/useflags/unicode unicode USE flag description]

[[Category:Localization]] {{Migrated|originalauthors=Thomas Martin, Alexander Simonov, Shyam Mani, nightmorph}}
