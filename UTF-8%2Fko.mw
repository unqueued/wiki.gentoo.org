<languages />

{{Metadata|abstract=UTF-8은 가변 길이 문자 인코딩이며, 심볼당 1바이트에서 4바이트를 사용합니다. 따라서 첫번째 UTF-8 바이트는 ASCII에 대한 이전 호환성을 완전히 갖춘 문자 세트를 제공하는 ASCII 인코딩 용도로 사용합니다. UTF-8은 ASCII와 라틴 문자를 데이터의 크기를 크게 변화하지 않고도 상호 표현이 가능함을 의미하는데, 첫 번째 바이트만 활용하기 때문입니다. 상위 바이트 범위를 할당 받아 만족하지 않는 일본어권 사용자 같은 동방 문자 사용자들에게는 최대 50%의 데이터 중복을 취하게 되었습니다.}}

UTF-8은 가변 길이 문자 인코딩이며, 심볼당 1바이트에서 4바이트를 사용합니다. 따라서 첫번째 UTF-8 바이트는 ASCII에 대한 이전 호환성을 완전히 갖춘 문자 세트를 제공하는 ASCII 인코딩 용도로 사용합니다. UTF-8은 ASCII와 라틴 문자를 데이터의 크기를 크게 변화하지 않고도 상호 표현이 가능함을 의미하는데, 첫 번째 바이트만 활용하기 때문입니다. 상위 바이트 범위를 할당 받아 만족하지 않는 일본어권 사용자 같은 동방 문자 사용자들에게는 최대 50%의 데이터 중복을 취하게 되었습니다. 

== 문자 인코딩 ==

=== 문자 인코딩이란 무엇인가요? ===

컴퓨터는 자체적으로 텍스트를 이해하지 못합니다. 대신 모든 문자를 숫자로 표현합니다. 옛부터 각 숫자 모음은 알파벳과 문자를 표현하는데 사용했습니다(코딩 시스템, 인코딩, 문자세트로 알려져왔습니다)만 컴퓨터 하드웨어의 제한으로, 크기의 제한을 받았습니다. 

=== 문자 인코딩 역사 ===

가장 일반적(또는 최소한 광범위하게 수용해온) 문자세트는 '''ASCII'''(정보 교환용 미 표준 코드)였습니다. 지금껏 소프트웨어 표준에 있어 가장 성공적으로 이끌어온 ASCII야 말로 광범위하게 사용되었ㅅ브니다. 최신 ASCII는 1986년도에 미 국립 표준 협회에서 표준으로 제정(ANSI X3.4, RFC 20, ISO/IEC 646:1991, ECMA-6) 했습니다. 

ASCII는 7비트로 엄격하게 제한되었으며, 표현 가능한 7개의 이진수로 비트 패턴을 사용함을 의미하는데, 10진수로는 0부터 127까지의 범위를 제공합니다. 여기에는 32개의 보이지 않는 제어 문자가 있는데, 0부터 31까지의 범위에 있으며, 마지막 제어 문자는 DEL또는 delete이며, 이 제어문자는 127번에 할당되어 있습니다. 32번 부터 126번 까지는 공백 문자, 문장 부호, 라틴 문자, 숫자와 같은 눈에 보이는 문자로 구성되어 있습니다. 

ASCII의 8번째 비트는 본디 오류 검출을 위한 패리티 비트로 활용했습니다. 용도를 고려하지 않으면 0으로 그대로 내버려두었습니다. ASCII에서 각 문자를 단일 바이트로 표현했음을 의미합니다. 

ASCII를 최근의 영문 의사소통을 하는데는 충분했었지만, 강세부호가 들어간 문자가 있는 다른 유럽어권의 문자에 대해서는 그렇지 않았습니다. 이런 필요성 때문에 ISO 8859 표준을 개발했습니다. ASCII와의 이전 호환성을 유지했지만 8번째 비트를 빈 채로 내버려두는 대신에 각 인코딩 주소에 다른 127개의 문자를 넣도록 했습니다. ISO 8859의 한계는 곧 다가왔고, 현재 ISO 8859 표준의 15가지 변형 표준이 있습니다. 이러한 문자 세트의 ASCII 호환 바이트 범위밖에서는 각 바이트로 표현하는 문자간의 충돌이 종종 일어났습니다. 문자 인코딩간 상호 처리를 좀 더 복잡하게 처리하기 위해 일부 마이크로소프트 윈도우 버전에서는 서유럽어권에 대해 Windows-1252 표준을 사용했습니다. 이 표준은 ISO-8859-1의 상위 집합이지만 여러모로 다른 점이 있었습니다. 그러나 이러한 세트는 ASCII 호환성을 유지했습니다. 

일본어와 한국어 같은 언어를 대상으로 사용하는 EUC(확장 유닉스 코딩)와 같은 비 라틴어 계열 문자를 대상한 완전히 다른 단일 바이트 인코딩의 개발 필요성은, 이미 다른 운영체제에서 동일한 언어에 대해 Shift-JIS, ISO-2022-JP와 같은 다른 문자셋을 이미 사용하고 있는 상황에서 더욱 혼동감을 가져왔습니다. 키릴 자모를 보려는 사용자는 러시아와 불가리아에서 사용하는 KOI8-R, 우크라이나에서 사용하는 KOI8-U, 온전치 못한 ISO 8859-5, 보통 사용하던 Windows-1251 세트 중 하나를 선택해야 했습니다. 이들 대부분의 모든 문자세트는 ASCII와의 호환성을 깨뜨렸습니다(비록 KOI8 인코딩은 라틴 문자 숫서대로 키릴 문자를 배치했지만, 이 경우 8번째 비트는 제거되었으며, 텍스트는 대소문자가 뒤집힌 음역 상태로 ASCII 터미널에서 해석 가능했습니다). 

이러한 판단 추세가 혼동을 가져왔으며, 다중 언어 의사 소통에 있어 거의 완전하게 불가능했고, 특히 다른 문자에 대해서도 불가능했습니다. 이제 유니코드로 들어가보도록 하겠습니다. 

=== 유니코드가 무엇인가요? ===

유니코드는 기존 문자세트의 단일 비트 제한을 깨버렸습니다. 최대 1,114,112 문자를 표현하기 위해, 65536 코드 포인트의 17가지 "영역"을 활용합니다. "기본 다중 언어 영역" 또는 BMP로 알려진 첫 번째 영역에서는 지금껏 여전히 사용해온 모든 문자를 담고 있는데, 유니코드가 16비트 문자 세트였다는 잘못된 가정을 낳았습니다. 

유니코드는 여러가지 다른 방식으로 댕으을 수행하지만, 주로 가장 많이 사용하는 방식은 '''UTF'''(유니코드 변환 형식)와 '''UCS'''(유니버설 문자 세트) 방식입니다. UTF 다음의 숫자는, 하나의 유닛에 들어가는 비트 수를 나타내며, UCS 다음에 나타나는 숫자는 총 바이트 수를 나타냅니다. 가장 널리 활용하게 된 UTF-8 은 유니코드 내용을 있는 그대로의 8비트로 표현하며, 이 문서의 제목이기도 함을 의미합니다. 

=== UTF-8이 처리할 수 있는 것 ===

UTF-8은 표준 호환과 전세계적으로 통용되는 다중 언어 환경을 살려 작업할 수 있도록 하며 데이터 중복성을 비교적 최소화 합니다. UTF-8은 비 ASCII 문자를 인터넷으로, 전자 메일 또는 IRC로 전송할 때 알맞은 방법입니다. 이럼에도 불구하고, 대부분의 사용자는 온라인 소통에 대해 UTF-8 사용을 모욕적인 행위로 여기기도 합니다. ''비 ASCII'' UTF-8 을 사용하기 전에 일부 채널, 메일링 리스트, 유즈넷 그룹에서의 UTF-8에 대한 인식은 매우 긍정적입니다. 

== 젠투 리눅스에서 UTF-8 설정 ==

=== UTF-8 로캘 찾기 또는 만들기 ===

이제 유니코드의 이론을 이해했으며 시스템에 UTF-8을 활용할 준비를 마쳤습니다. 

UTF-8을 활용하는데 우선 필요한 사항은 국제 언어를 지원하는 glibc 버전을 가지고 있어야 합니다. 이를 의미하는 추천 요소는 {{Path|/etc/locale.gen}} 파일입니다. 이 파일을 활용하는 방법에 대한 설명은 이 안내서의 범위를 벗어납니다. [https://wiki.gentoo.org/wiki/Localization/HOWTO/ko 젠투 지역화 안내서]에 설명했습니다. 

다음, UTF-8 로케일이 이미 사용할 언어에 대해 준비되어 있는지 새로 언어 지원 항목을 만들어야 하는지 파악해야 합니다. 

{{Cmd|locale -a {{!}} grep 'en_GB'|output=<pre>
en_GB
en_GB.UTF-8
</pre>
}}

이 명령행의 출력에서 보시듯, <code>.UTF-8</code>와 같은 접미부가 나타나야 합니다. <code>.UTF-8</code> 접미부와 유사한 결과가 나타나지 않는다면 UTF-8 호환 로캘을 만들어야 합니다. 


{{Note/ko|사용할 언어에 대해 UTF-8 로캘이 없을 경우에만 다음 코드 예제를 실행하십시오.}}

"en_GB"를 결정한 로캘 설정으로 바꾸십시오:
{{RootCmd|localedef -i en_GB -f UTF-8 en_GB.UTF-8}}

Another way to include a UTF-8 locale is to add it to the {{Path|/etc/locale.gen}} file and generate necessary locales with <code>locale-gen</code> command. 

{{Code|Line in /etc/locale.gen|<pre>
en_GB.UTF-8 UTF-8
</pre>
}}

=== 로캘 설정 ===

There is one environment variable that needs to be set in order to use our new UTF-8 locales: <code>LC_CTYPE</code> (or optionally <code>LANG</code>, if you want to change the system language as well). There are also many different ways to set it; some people prefer to only have a UTF-8 environment for a specific user, in which case they set them in their {{Path|~/.profile}} (if you use <code>/bin/sh</code> ), {{Path|~/.bash_profile}} or {{Path|~/.bashrc}} (if you use <code>/bin/bash</code>). More details and best practices can be found in our [https://wiki.gentoo.org/wiki/Localization/HOWTO Localization Guide]. 

Others prefer to set the locale globally. One specific circumstance where the author particularly recommends doing this is when {{Path|/etc/init.d/xdm}} is in use, because this init script starts the display manager and desktop before any of the aforementioned shell startup files are sourced, and so before any of the variables are in the environment. 

Setting the locale globally should be done using {{Path|/etc/env.d/02locale}}. The file should look something like the following: 

{{Code|Demonstration /etc/env.d/02locale|<pre>
## (As always, change "en_GB.UTF-8" to your locale)
LANG="en_GB.UTF-8"
</pre>
}}

{{Note|You can also substitute <code>LC_CTYPE</code> for <code>LANG</code>. For more information on the categories affected by using <code>LC_CTYPE</code>, please read the [http://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html#Locale-Categories GNU locale page].}}

Next, the environment must be updated with the change. 

{{RootCmd|env-update|output=<pre>
>>> Regenerating /etc/ld.so.cache...
 * Caching service dependencies ...
</pre>}}
{{RootCmd|source /etc/profile}}

Now, run <code>locale</code> with no arguments to see if we have the correct variables in our environment: 

{{RootCmd|locale|output=<pre>
LANG=en_GB.UTF-8
LC_CTYPE="en_GB.UTF-8"
LC_NUMERIC="en_GB.UTF-8"
LC_TIME="en_GB.UTF-8"
LC_COLLATE="en_GB.UTF-8"
LC_MONETARY="en_GB.UTF-8"
LC_MESSAGES="en_GB.UTF-8"
LC_PAPER="en_GB.UTF-8"
LC_NAME="en_GB.UTF-8"
LC_ADDRESS="en_GB.UTF-8"
LC_TELEPHONE="en_GB.UTF-8"
LC_MEASUREMENT="en_GB.UTF-8"
LC_IDENTIFICATION="en_GB.UTF-8"
LC_ALL=
</pre>
}}

That's everything. You are now using UTF-8 locales, and the next hurdle is the configuration of the applications you use from day to day.

== 프로그램 지원 ==

When Unicode first started gaining momentum in the software world, multibyte character sets were not well suited to languages like C, in which many of the day-to-day programs people use are written. Even today, some programs are not able to handle UTF-8 properly. Fortunately, most are! 

=== 파일 이름, NTFS, FAT ===

There are several NLS options in the Linux kernel configuration menu, but it is important to not become confused! For the most part, the only thing you need to do is to build UTF-8 NLS support into your kernel, and change the default NLS option to utf8. 

{{Kernel|Kernel configuration steps for UTF-8 NLS|<pre>
File Systems -->
  Native Language Support -->
    (utf8) Default NLS Option
    <*> NLS UTF8
    ## (Also <*> other character sets that are in use in
    your FAT filesystems or Joilet CD-ROMs.)
</pre>
}}

If you plan on mounting NTFS partitions, you may need to specify an <code>nls=</code> option with mount. If you plan on mounting FAT partitions, you may need to specify a <code>codepage=</code> option with mount. Optionally, you can also set a default codepage for FAT in the kernel configuration. Note that the <code>codepage</code> option with mount will override the kernel settings. 

{{Kernel|FAT settings in kernel configuration|<pre>
File Systems -->
  DOS/FAT/NT Filesystems  -->
    (437) Default codepage for fat
</pre>
}}

You should avoid setting <code>Default iocharset for fat</code> to UTF-8, as it is not recommended. Instead, you may want to pass the option utf8=true when mounting your FAT partitions. For further information, see <code>man mount</code> and the kernel documentation at {{Path|/usr/src/linux/Documentation/filesystems/vfat.txt}} . 

For changing the encoding of filenames, {{Package|app-text/convmv}} can be used. 

{{Emerge|app-text/convmv}}

The format of the <code>convmv</code> command is as follows:

{{RootCmd|convmv -f &lt;current-encoding&gt; -t utf-8 &lt;filename&gt;}}

Substitute iso-8859-1 with the charset you are converting from:

{{RootCmd|convmv -f iso-8859-1 -t utf-8 filename}}

For changing the ''contents'' of files, use the <code>iconv</code> utility, bundled with <code>glibc</code>. Substitute iso-8859-1 with the charset you are converting from, and check that the output is sane:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 filename}}

To convert a file, you must create another file:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 filename &gt; newfile}}

이 목적으로 {{Package|app-text/recode}} 패키지도 사용할 수 있습니다.

=== 시스템 콘솔 ===

{{Important/ko|콘솔에서 유니코드를 사용하려면 {{Package|sys-apps/baselayout-1.11.9}}이상의 버전이 필요합니다.}}

To enable UTF-8 on the console, you should edit {{Path|/etc/rc.conf}} and set <code>unicode="yes"</code>, and also read the comments in that file -- it is important to have a font that has a good range of characters if you plan on making the most of Unicode. For this to work, make sure you have properly created a Unicode locale. 

The <code>keymap</code> variable, set in {{Path|/etc/conf.d/keymaps}}, should have a Unicode keymap specified. 

{{Code|Example /etc/conf.d/keymaps snippet|<pre>
## (Change "uk" to your local layout)
keymap="uk"
</pre>
}}

=== ncueses 와 slang ===

{{Note/ko|slang을 설치하지 않았거나 사용하지 않는다면 이 장의 slang 언급 부분은 무시하십시오.}}

It is wise to add <code>unicode</code> to your global USE flags in {{Path|/etc/portage/make.conf}}, and then to remerge {{Package|sys-libs/ncurses}} and {{Package|sys-libs/slang}} if appropriate. Portage will do this automatically when you update your system: 

{{RootCmd|emerge --update --deep --newuse world}}

We also need to rebuild packages that link to these, now the USE changes have been applied. The tool we use (<code>revdep-rebuild</code>) is part of the {{Package|app-portage/gentoolkit}} package. 

{{RootCmd|revdep-rebuild --soname libncurses.so.5
|revdep-rebuild --soname libslang.so.1}}

=== KDE, GNOME and Xfce ===

All of the major desktop environments have full Unicode support, and will require no further setup than what has already been covered in this guide. This is because the underlying graphical toolkits (Qt or GTK+2) are UTF-8 aware. Subsequently, all applications running on top of these toolkits should be UTF-8-aware out of the box. 

The exceptions to this rule come in Xlib and GTK+1. GTK+1 requires a iso-10646-1 FontSpec in the ~/.gtkrc, for example <code>-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1</code> . Also, applications using Xlib or Xaw will need to be given a similar FontSpec, otherwise they will not work. 

{{Note|If you have a version of the gnome1 control center around, use that instead. Pick any iso10646-1 font from there.}}

{{Code|Example ~/.gtkrc (for GTK+1) that defines a Unicode compatible font|<pre>
style "user-font"
{
    fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"
}
widget_class "*" style "user-font"
</pre>
}}

If an application has support for both a Qt and GTK+2 GUI, the GTK+2 GUI will generally give better results with Unicode. 

=== X11 and Fonts ===

TrueType fonts have support for Unicode, and most of the fonts that ship with Xorg have impressive character support, although, obviously, not every single glyph available in Unicode has been created for that font. To build fonts (including the Bitstream Vera set) with support for East Asian letters with X, make sure you have the <code>cjk</code> USE flag set. Many other applications utilise this flag, so it may be worthwhile to add it as a permanent USE flag. 

Also, several font packages in Portage are Unicode aware. 

{{Emerge|terminus-font intlfonts freefonts corefonts}}

=== Window Managers and Terminal Emulators ===

Window managers not built on GTK+ or Qt generally have very good Unicode support, as they often use the Xft library for handling fonts. If your window manager does not use Xft for fonts, you can still use the FontSpec mentioned in the previous section as a Unicode font. 

Terminal emulators that use Xft and support Unicode are harder to come by. Aside from Konsole and gnome-terminal, the best options in Portage are {{Package|x11-terms/rxvt-unicode}}, {{Package|x11-terms/xfce4-terminal}}, {{Package|gnustep-apps/terminal}}, {{Package|x11-terms/mlterm}}, or plain {{Package|x11-terms/xterm}} when built with the <code>unicode</code> USE flag and invoked as <code>uxterm</code>. {{Package|app-misc/screen}} supports UTF-8 too, when invoked as <code>screen -U</code> or the following is put into the {{Path|~/.screenrc}}: 

{{Code|~/.screenrc for UTF-8|<pre>
defutf8 on
</pre>
}}

=== Vim, Emacs, Xemacs and Nano ===

Vim provides full UTF-8 support, and also has builtin detection of UTF-8 files. For further information in Vim, use <code>:help mbyte.txt</code> . 

[[GNU Emacs]] since version 23 and [[XEmacs]] version 21.5 have full UTF-8 support. GNU Emacs 24 also supports editing bidirectional text. 

Nano has provided full UTF-8 support since version 1.3.6.

=== 쉘 ===

Currently, <code>bash</code> provides full Unicode support through the GNU readline library. Z Shell ( <code>zsh</code> ) offers Unicode support with the <code>unicode</code> USE flag. 

The C shell, <code>tcsh</code> and <code>ksh</code> do not provide UTF-8 support at all. 

=== Irssi ===

Irssi has complete UTF-8 support, although it does require a user to set an option. 

{{Cmd|set term_charset UTF-8|prompt=[irssi] }}

For channels where non-ASCII characters are often exchanged in non-UTF-8 charsets, the <code>/recode</code> command may be used to convert the characters. Type <code>/help recode</code> for more information. 

=== Mutt ===

The Mutt mail user agent has very good Unicode support. To use UTF-8 with Mutt, you don't need to put anything in your configuration files. Mutt will work under unicode enviroment without modification if all your configuration files (signature included) are UTF-8 encoded. 

{{Note|You may still see '?' in mail you read with Mutt. This is a result of people using a mail client which does not indicate the used charset. You can't do much about this than to ask them to configure their client correctly.}}

Further information is available from the [http://wiki.mutt.org/index.cgi?MuttFaq/Charset Mutt Wiki] . 

=== Man ===

Man pages are an integral part of any Linux machine. To ensure that any unicode in your man pages render correctly, edit {{Path|/etc/man.conf}} and replace a line as shown below. 

{{Code|man.conf changes for Unicode support|<pre>
## (This is the old line)
NROFF           /usr/bin/nroff -Tascii -c -mandoc
## (Replace the one above with this)
NROFF           /usr/bin/nroff -mandoc -c
</pre>
}}

=== elinks와 links ===

These are commonly used text-based browsers, and we shall see how we can enable UTF-8 support on them. On <code>elinks</code> and <code>links</code>, there are two ways to go about this, one using the Setup option from within the browser or editing the config file. To set the option through the browser, open a site with <code>elinks</code> or <code>links</code> and then {{Key|Alt}} + {{Key|S}} to enter the Setup Menu then select Terminal options, or press {{Key|T}}. Scroll down and select the last option <code>UTF-8 I/O</code> by pressing {{Key|Enter}}. Then Save and exit the menu. On <code>links</code> you may have to do a repeat {{Key|Alt}} + {{Key|S}} and then press {{Key|S}} to save. The config file option, is shown below. 

{{Code|Enabling UTF-8 for elinks/links|<pre>
## (For elinks, edit /etc/elinks/elinks.conf or ~/.elinks/elinks.conf and
add the following line)
set terminal.linux.utf_8_io = 1

## (For links, edit ~/.links/links.cfg and add the following
line)
terminal "xterm" 0 1 0 us-ascii utf-8
</pre>
}}

=== Samba ===

Samba is a software suite which implements the SMB (Server Message Block) protocol for UNIX systems such as Macs, Linux and FreeBSD. The protocol is also sometimes referred to as the Common Internet File System (CIFS). Samba also includes the NetBIOS system - used for file sharing over windows networks. 

다음 내용을 [global] 섹션에 추가하십시오:
{{RootCmd|nano -w /etc/samba/smb.conf|output=<pre>
dos charset = 1255
unix charset = UTF-8
display charset = UTF-8
</pre>
}}

=== 전체 시험하기 ===

There are numerous UTF-8 test websites around. {{Package|net-www/w3m}}, {{Package|net-www/links}}, {{Package|net-www/elinks}}, {{Package|net-www/lynx}} and all Mozilla based browsers (including Firefox) support UTF-8. Konqueror and Opera have full UTF-8 support too. 

When using one of the text-only web browsers, make absolutely sure you are using a Unicode-aware terminal. 

If you see certain characters displayed as boxes with letters or numbers inside, this means that your font does not have a character for the symbol or glyph that the UTF-8 wants. Instead, it displays a box with the hex code of the UTF-8 symbol. 

* [http://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html A W3C UTF-8 Test Page] 
* [http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm A UTF-8 test page provided by the University of Frankfurt]

=== Input Methods ===

''Dead keys'' may be used to input characters in X that are not included on your keyboard. These work by pressing your right {{Key|Alt}} key (or in some countries, {{Key|AltGr}}) and an optional key from the non-alphabetical section of the keyboard to the left of the return key at once, releasing them, and then pressing a letter. The dead key should modify it. Input can be further modified by using the {{Key|Shift}} key at the same time as pressing the {{Key|AltGr}} and modifier. 

To enable dead keys in X, you need a layout that supports it. Most European layouts already have dead keys with the default variant. However, this is not true of North American layouts. Although there is a degree of inconsistency between layouts, the easiest solution seems to be to use a layout in the form "en_US" rather than "us", for example. The layout is set in {{Path|/etc/X11/xorg.conf}} like so: 

{{Code|/etc/X11/xorg.conf snippet|<pre>
Section "InputDevice"
    Identifier "Keyboard0"
    Driver     "kbd"
    Option     "XkbLayout" "en_US" ## # Rather than just "us"
    ## (Other Xkb options here)
EndSection
</pre>
}}

{{Note|The preceding change only needs to be applied if you are using a North American layout, or another layout where dead keys do not seem to be working. European users should have working dead keys as is.}}

This change will come into effect when your X server is restarted. To apply the change now, use the <code>setxkbmap</code> tool, for example, <code>setxkbmap en_US</code> . 

It is probably easiest to describe dead keys with examples. Although the results are locale dependent, the concepts should remain the same regardless of locale. The examples contain UTF-8, so to view them you need to either tell your browser to view the page as UTF-8, or have a UTF-8 locale already configured. 

When I press {{Key|AltGr}} and {{Key|[}} at once, release them, and then press {{Key|a}}, 'ä' is produced. When I press {{Key|AltGr}} and {{Key|[}} at once, and then press {{Key|e}}, 'ë' is produced. When I press {{Key|AltGr}} and {{Key|;}} at once, and then press {{Key|a}}, 'á' is produced, and when I press {{Key|AltGr}} and {{Key|;}} at once, release them, and then press {{Key|e}}, 'é' is produced. 

By pressing {{Key|AltGr}}, {{Key|Shift}} and {{Key|[}} at once, releasing them, and then pressing {{Key|a}}, a Scandinavian 'å' is produced. Similarly, when I press {{Key|AltGr}}, {{Key|Shift}} and {{Key|[}} at once, release ''only'' the {{Key|[}}, and then press it again, '°' is produced. Although it looks like one, this (U+02DA) is not the same as a degree symbol (U+00B0).

{{Key|AltGr}} can be used with alphabetical keys alone. For example, {{Key|AltGr}} and {{Key|m}}, a Greek lower-case letter mu is produced. {{Key|AltGr}} and {{Key|s}} produce a scharfes s or esszet, etc. As many European users would expect (because it is marked on their keyboard), {{Key|AltGr}} and {{Key|4}} (or {{Key|E}} depending on the keyboard layout) produces a Euro sign, '€'.

=== Resources ===

*  [https://en.wikipedia.org/wiki/Unicode The Wikipedia entry for Unicode] 
*  [https://en.wikipedia.org/wiki/UTF-8 The Wikipedia entry for UTF-8] 
*  [http://www.unicode.org Unicode.org] 
*  [http://www.utf-8.com UTF-8.com] 
*  [http://www.ietf.org/rfc/rfc3629.txt RFC 3629] 
*  [http://www.ietf.org/rfc/rfc2277.txt RFC 2277] 
*  [http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF Characters vs. Bytes]

== Reported Issues or Problems ==

=== System Configuration Files (in /etc) ===

Most system configuration files, such as {{Path|/etc/fstab}} , do not support UTF-8. It is recommended to stick with the ASCII character set for these files. 

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* Thomas Martin
* Alexander Simonov
* Shyam Mani
* nightmorph
