<languages />

Bu sayfada kaynak kodu, güvenli ve mantıklı CFLAGS ve CXXFLAGS kulllanarak optimize etmekle ilgili bilgi verilmektedir. Ayrıca derlemeyi optimize etmenin arkasındaki genel mantığı da ele almaktadır.

== Tanıtım ==

=== CFLAGS ve CXXFLAGS nedir? ===

CFLAGS ve CXXFLAGS değerleri, GNU Compiler Collection (<code>GCC</code>) tarafından kaynak kodu derlerken ne tür değişiklikler yapılması gerektiğini belirleyen ortam değişkenleridir. CFLAGS değerleri C dili ile yazılmış kodları etkiler, CXXFLAGS ise C++. 

Derlenen programın üreteceği hata ayıklama (debug) mesajlarının yoğunluğunu düşürebilir, hata durumunda gösterilecek uyarı mesajlarını artırabilir ve elbette üretilen kodun sisteminiz için optimize edilmesini sağlayabilirler. [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC yardım sayfası]nda kullanılabilecek seçenekler ve açıklamaları bulunmaktadır. 

=== Nasıl kullanılırlar? ===

CFLAGS ve CXXFLAGS iki şekilde kullanılabilir. İlk olarak, her uygulamaya özel olarak derleme sırasında automake tarafından üretilen Makefile dosyalarında bulunabilirler. 

Ancak bu yöntem Portage içerisindeki paketleri kurarken uygulanmamalıdır. Bunun yerine {{Path|/etc/portage/make.conf}} dosyasındaki CFLAGS ve CXXFLAGS değerlerini ayarlamalısınız. Tüm paketler, burada seçtiğiniz yapılandırmaya göre derlenecektir. 

{{Code|/etc/portage/make.conf dosyasındaki CFLAGS değerleri|<pre>
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Gördüğünüz gibi, CXXFLAGS değerleri CFLAGS'a atanan değerlerin aynısını kullanmakta. Muhtemelen hatasız bir derleme için ihtiyacınız olan durum da budur. Normal şartlarda CXXFLAGS için farklı bir değer belirtmeye ihtiyaç duymamanız gerekir. 

=== Hatalı düşünceler ===

CFLAGS ve CXXFLAGS değerleri daha küçük veya daha hızlı çalışan dosyalar üretmekte yardımcı olabilir. Ancak bazı durumlarda yavaşlama, boyut büyümesi, derlenen dosyanın istendiği gibi çalışmaması ve tabi ki derleme sırasında hatalara sebep olabilir! 

CFLAGS değerleri sihirli değnek değildir; otomatik olarak sisteminizi daha ufak ve daha hızlı bir hale getiremezler. Gereğinden fazla ve gereksiz değerler eklemek sisteminizi çorbaya çevirebilir ve başladığınızdan daha kötü bir noktaya ulaştırabilir. 

İnternette bulacağınız övgüler bir yana, agresif CFLAGS ve CXXFlags değerleri uygulamalarınıza yarardan çok zarar getirme eğilimindedir. Bu değerlerin var olma sebebinin özel amaçlarda özel yerlerde kullanılması olduğunu unutmayınız. Bir CFLAGS değerinin bir parça kod veya bir uygulama üzerinde işe yarıyor olması tüm sisteminizi bu flag kullanılarak derlemenizin faydanıza olacağı anlamına gelmez. 

=== Hazır mısınız? ===

Karşılaşacağınız riskleri de bildiğinize göre artık bazı mantıklı ve güvenli değerleri incelemenin zamanı geldi. Bu değerler sisteminizi sağlıklı tutacak ve [http://bugs.gentoo.org Bugzilla]'ya raporlayacağınız hatalarda geliştiricilere yardımcı olacak değerlerdir. Geliştiriciler hata raporlarında genellikle (agresif değerlerin yazılıma zarar verebileceğini bildikleri için) problem oluşturan yazılımın basit CFLAGS değerleri ile tekrar derlenmesini ve problemin halen devam edip etmediğinin incelenmesini isterler. 

== Optimizasyon ==

=== Temel ===

CFLAGS ve CXXFLAGS kullanılmasının amacı sonuçta mümkün olduğu kadar güvenilir ve hızlı uygulamalara/sisteme sahip olmanız için kodları sisteminize uyumlu şekilde derlemektir. Bu seçeneklerden her CPU mimarisine göre en iyi çalışanlardan bahsedeceğiz. Ardından dikkat etmeniz gereken agresif seçeneklere de değineceğiz. <code>GCC</code> yardım sayfasındaki tüm seçenekleri açıklamayacağız (ki yüzlerce var), yalnızca en bilinen ve temel bayrakları ele alacağız. 

{{Note|Bir seçeneğin tam olarak ne yaptığından emin değilseniz, [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC yardım sayfası]nın ilgili bölümüne bakın. Anlamazsanız Google'ı deneyin veya <code>GCC</code> [http://gcc.gnu.org/lists.html e-posta listeleri]ni deneyin.}}

=== -march ===

İlk ve en önemli seçenek <code>-march</code>. Bu seçenek derleyiciye kodun hangi [http://en.wikipedia.org/wiki/Microarchitecture işlemci mimarisi]ne uygun kod üretileceğini belirtir. Farklı işlemcilerin farklı özellikleri, çalışma yöntemleri ve desteklediği değerler bulunmaktadır. <code>-march</code> değeri ile derleyici sahip olduğunuz işlemcinin kapasitesine ve özelliklerine uygun bir kod üretecektir. 

{{Path|/etc/portage/make.conf}} dosyasındaki  CHOST değeri mimari seçeneğinizi iletse de, <code>-march</code> halen daha uyumlu kod üretmek için kullanılabilir. x86 ve x86-64 işlemciler (ve bazı diğerleri) <code>-march</code> bayrağından faydalanabilir. 

Ne tür bir işlemciniz var? Öğrenmek için aşağıdaki kodu çalıştırabilirsiniz: 

{{Cmd|cat /proc/cpuinfo}}

Şimdi de <code>-march</code> değerini iş başında görelim. Aşağıdaki örnek eski bir Pentium III işlemci için: 

{{Code|/etc/portage/make.conf: Pentium III|<pre>
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Şimdi de 64-bit bir işlemci için bir örnek: 

{{Code|/etc/portage/make.conf: AMD64|<pre>
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Hangi tür işlemciye sahip olduğunuzdan veya işlemciniz için ne kullanacağınızdan halen emin değilseniz <code>-march=native</code> kullanın. Bu değeri kullanarak, GCC'nin işlemcinizi otomatik olarak tanıyarak en uyumlu değerleri kendi belirlemesini sağlayabilirsiniz. '''Ancak farklı bir CPU'da çalışacak bir paket derliyorsanız bu seçeneği kullanmayın!''' 

Yani bir bilgisayarda derleme yapıp derlediğiniz paketleri farklı bir bilgisayarda (mesela daha eski ve yavaş bir cihazda) çalıştırmak istiyorsanız <code>-march=native</code> kullanmamalısınız. "Native" (doğal) seçeneği derlemenin sonunda üretilen kodun yalnızca derlendiği işlemci türünde çalışabileceği anlamına gelir. AMD Athlon 64 işlemci üzerinde <code>-march=native</code> kullanarak derlediğiniz bir paket VIA C3 işlemci üzerinde çalışamayacaktır. 

Ayrıca <code>-mtune</code> ve <code>-mcpu</code> bayraklarını da kullanabilirsiniz. Bunlar normalde yalnızca uyumlu <code>-march</code> seçeneği olmadığında kullanılan seçeneklerdir. Bazı işlemci mimarileri <code>-mtune</code> hatta <code>-mcpu</code> kullanımını gerektirebilir. Malesef <code>GCC</code>'nin her bayrak için davranışı bir mimariden diğerine farklılık göstermektedir. 

x86 ve x86-64 işlemcilerde <code>-march</code> kullandığınızda sonuç olarak işlemciniz ile tam uyumlu kodlar alırsınız, yani üretilen paketler farklı veya daha eski işlemcilerde çalışmaz. Paketleri yalnızca derlediğiniz sistemde kullanacaksanız <code>-march</code> kullanın. <code>-mtune</code> ve <code>-mcpu</code> seçeneklerini yalnızca daha eski işlemcilere (i386 ve i486 gibi) uyumlu paketler derleme amacındaysanız değerlendirin. <code>-mcpu</code> seçeneği kullanıldığında birçok gerekli değeri (ABI gibi) dikkate almadığı için, bu seçeneği x86 ve x86-64 sistemlerde kullanmayın. 

Sadece x86/x86-64 olmayan işlemciler (Sparc, Alpha ve PowerPC gibi) <code>-mtune</code> veya <code>-mcpu</code> seçeneklerine ihtiyaç duyabilir. Bu mimarilerde bu seçenekler, x86/x86-64 mimarideki <code>-march</code> seçeneğinin yaptığı görevi yapmaktadır. Emin olmak için [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options GCC yardım sayfası]nı incelediğinize emin olunuz. 

{{Note|Daha fazla <code>-march</code>/ <code>-mtune</code>/ <code>-mcpu</code> tavsiyesi için lütfen [http://www.gentoo.org//doc/en/handbook/ Gentoo Kurulum Belgesi]nin 5. bölümünü inceleyin. Ayrıca <code>GCC</code>'nin [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options mimariye özel belgeleri] de yardımcı olabilir.}}

=== -O ===

Gelecek seçeneğimiz <code>-O</code>. Bu seçenek genel optimizasyon değerini kontrol etmekte. Yüksek optimizasyon kullandığınızda biraz daha yavaş ve RAM tüketen bir derleme sürecine sahip olabilirsiniz. 

5 farklı <code>-O</code> ayarı bulunmaktadır:  <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> ve <code>-Os</code>. {{Path|/etc/portage/make.conf}} dosyasında bunlardan yalnızca birini kullanmalısınız. 

With the exception of <code>-O0</code> , the <code>-O</code> settings each activate several additional flags, so be sure to read the GCC manual's chapter on [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimization options] to learn which flags are activated at each <code>-O</code> level, as well as some explanations as to what they do. 

Let's examine each optimization level: 

*  <code>-O0</code> : This level (that's the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in CFLAGS or CXXFLAGS.  This reduces compilation time and can improve debugging info, but some applications will not work properly without optimization enabled.  This option is not recommended except for debugging purposes.

*  <code>-O1</code> : This is the most basic optimization level. The compiler will try to produce faster, smaller code without taking much compilation time. It's pretty basic, but it should get the job done all the time.

*  <code>-O2</code> : A step up from <code>-O1</code> . This is the ''recommended'' level of optimization unless you have special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code> . With <code>-O2</code> , the compiler will attempt to increase code performance without compromising on size, and without taking too much compilation time.

*  <code>-O3</code> : This is the highest level of optimization possible.  It enables optimizations that are expensive in terms of compile time and memory usage.  Compiling with <code>-O3</code> is not a guaranteed way to improve performance, and in fact in many cases can slow down a system due to larger binaries and increased memory usage.  <code>-O3</code> is also known to break several packages.  Therefore, using <code>-O3</code> is not recommended.

*  <code>-Os</code> : This option will optimize your code for size. It activates all <code>-O2</code> options that don't increase the size of the generated code. It can be useful for machines that have extremely limited disk storage space and/or have CPUs with small cache sizes.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and you aren't using <code>-O2</code>, try rebuilding with that option.  As a fallback option, try setting your CFLAGS and CXXFLAGS to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).

=== -pipe ===

A common flag is <code>-pipe</code> . This flag actually has no effect on the generated code, but it makes the compilation process faster. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, GCC might get killed. In that case, do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code> ) on architectures where doing so does not interfere with debugging (such as x86-64), but you may need to activate it yourself by adding it to your flags. Though the <code>GCC</code> manual does not specify all architectures it is turned on by using <code>-O</code> , you will need to explicitly activate it on x86. However, using this flag will make debugging hard to impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. However, if you don't plan to do much software debugging and haven't added any other debugging-related CFLAGS such as <code>-ggdb</code> , then you can try using <code>-fomit-frame-pointer</code> . 

{{Important|Do ''not'' combine <code>-fomit-frame-pointer</code> with the similar flag <code>-momit-leaf-frame-pointer</code> . Using the latter flag is discouraged, as <code>-fomit-frame-pointer</code> already does the job properly. Furthermore, <code>-momit-leaf-frame-pointer</code> has been shown to negatively impact code performance.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE] , [http://en.wikipedia.org/wiki/SSE2 SSE2] , [http://en.wikipedia.org/wiki/SSSE3 SSE3] , [http://en.wikipedia.org/wiki/MMX MMX] , and [http://en.wikipedia.org/wiki/3dnow 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to check if your CPU supports these by running <code>cat /proc/cpuinfo</code> . The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

You normally don't need to add any of these flags to {{Path|/etc/portage/make.conf}} as long as you are using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code> ). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these you'll need to enable additional flags where appropriate after checking the output of <code>cat /proc/cpuinfo</code> . 

{{Note|You should check the [http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options list] of x86 and x86-64-specific flags to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then you don't need to specify it; it will be turned on by using the proper <code>-march</code> setting.}}

== Optimization FAQs ==

=== But I get better performance with -funroll-loops -fomg-optimize! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt your applications when used system-wide. Even the <code>GCC</code> [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> makes code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code> , <code>-fforce-mem</code> , <code>-fforce-addr</code> , and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

The truth of the matter is that they are dangerously aggressive flags. Take a good look around the [http://forums.gentoo.org Gentoo Forums] and [http://bugs.gentoo.org Bugzilla] to see what those flags do: nothing good! 

You don't need to use those flags globally in CFLAGS or CXXFLAGS. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat your code and get your bugs marked INVALID or WONTFIX. 

You don't need dangerous flags like these. '''Don't use them''' . Stick to the basics: <code>-march</code> , <code>-O</code> , and <code>-pipe</code> . 

=== What about -O levels higher than 3? ===

Some users boast about even better performance obtained by using <code>-O4</code> , <code>-O9</code> , and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept CFLAGS like <code>-O4</code> , but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code> , nothing more. 

Need more proof? Examine the <code>code</code> [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup source code] : 

{{Code|-O source code|<pre>
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>
}}

As you can see, any value higher than 3 is treated as just <code>-O3</code> . 

=== What about redundant flags? ===

Oftentimes CFLAGS and CXXFLAGS that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}} . Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all CFLAGS and CXXFLAGS, or it may replace <code>-O</code> with a different level. 

The [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] outlines where and how flag filtering/replacing works. 

It's possible to circumvent <code>-O</code> filtering by redundantly listing the flags for a certain level, such as <code>-O3</code> , by doing things like: 

{{Code|Specifying redundant CFLAGS|<pre>
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>
}}

However,'''this is not a smart thing to do'''. CFLAGS are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers'' . Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

You will most likely continue to run into problems when you build a package with unacceptable flags. When you report your troubles on Bugzilla, the flags you use in {{Path|/etc/portage/make.conf}} will be readily visible and you will be told to recompile without those flags. Save yourself the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume that you know better than the developers. 

=== What about LDFLAGS? ===

The Gentoo developers have already set basic, safe LDFLAGS in the base profiles, so you don't need to change them. 

=== Can I use per-package flags? ===

{{Warning|Using per-package flags complicates debugging and support. Make sure you mention in your bug reports if you make use of this feature and what the changes are you made.}}

Information on how to use per-package environment variables (including CFLAGS) is described in the [http://www.gentoo.org//doc/en/handbook/handbook-amd64.xml?part=3&chap=6#doc_chap2 Gentoo Handbook, "Per-Package Environment Variables"] . 

== Resources ==

The following resources are of some help in further understanding optimization: 

* The [http://gcc.gnu.org/onlinedocs/ GCC online documentation] 

* Chapter 5 of the [http://www.gentoo.org//doc/en/handbook/ Gentoo Installation Handbooks] 

* <code>man make.conf</code>

* [http://en.wikipedia.org Wikipedia]

* The [http://forums.gentoo.org Gentoo Forums]

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* nightmorph
