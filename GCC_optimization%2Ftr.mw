<languages />

{{Metadata|abstract=Bu sayfada kaynak kodunu, güvenli ve mantıklı CFLAGS ve CXXFLAGS kulllanarak optimize etmekle ilgili bilgi verilmektedir. Ayrıca derlemeyi optimize etmenin arkasındaki genel mantık da ele alınmaktadır.}}

Bu sayfada kaynak kodunu, güvenli ve mantıklı CFLAGS ve CXXFLAGS kulllanarak optimize etmekle ilgili bilgi verilmektedir. Ayrıca derlemeyi optimize etmenin arkasındaki genel mantık da ele alınmaktadır.

== Tanıtım ==

=== CFLAGS ve CXXFLAGS nedir? ===

<code>CFLAGS</code> ve <code>CXXFLAGS</code> değerleri, GNU Compiler Collection (<code>GCC</code>) tarafından kaynak kodu derlerken ne tür değişiklikler yapılması gerektiğini belirleyen ortam değişkenleridir. <code>CFLAGS</code> değerleri C dili ile yazılmış kodları etkiler, <code>CXXFLAGS</code> ise C++. 

Derlenen programın üreteceği hata ayıklama (debug) mesajlarının yoğunluğunu düşürebilir, hata durumunda gösterilecek uyarı mesajlarını artırabilir ve elbette üretilen kodun sisteminiz için optimize edilmesini sağlayabilirler. [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC yardım sayfası]nda kullanılabilecek seçenekler ve açıklamaları bulunmaktadır.

=== Nasıl kullanılırlar? ===

CFLAGS ve CXXFLAGS iki şekilde kullanılabilir. İlk olarak, her uygulamaya özel olarak derleme sırasında <tt>automake</tt> tarafından üretilen Makefile dosyalarında bulunabilirler. 

Ancak bu yöntem Portage içerisindeki paketleri kurarken uygulanmamalıdır. Bunun yerine {{Path|/etc/portage/make.conf}} dosyasında <code>CFLAGS</code> ve <code>CXXFLAGS</code> değerlerini ayarlamalısınız. Tüm paketler, burada seçtiğiniz yapılandırmaya göre derlenecektir.

{{CodeBox|title=/etc/portage/make.conf dosyasındaki CFLAGS değerleri|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important|While it is possible to have multiple lines in '''USE''' flags, having multiple lines in <code>CFLAGS</code> can and ''will'' result in problems with programs such as <tt>cmake</tt>. Make sure the CFLAGS declaration is on a single line, with as little whitespace as possible to avoid issues. See {{Bug|500034}} as an example.}}

Örnekte gördüğünüz gibi, <code>CXXFLAGS</code> değerleri <code>CFLAGS</code>'a atanan değerlerin aynısını kullanmakta. Çoğu sistemin hatasız bir derleme için ihtiyacı olan da bu olacaktır. Normal şartlarda <code>CXXFLAGS</code> için farklı bir değer belirtmeye ihtiyaç duymamanız gerekir.

=== Hatalı düşünceler ===

<code>CFLAGS</code> ve <code>CXXFLAGS</code> değerleri daha küçük veya daha hızlı çalışan dosyalar üretmekte yardımcı olabilir. Ancak hatalı yapılandırma durumlarında yavaşlama, boyut büyümesi, derlenen dosyanın istendiği gibi çalışmaması ve tabi ki derleme sırasında hatalara sebep olabilir! 

<code>CFLAGS</code> değerleri bir sihirli değnek değildir; otomatik olarak sisteminizi daha ufak ve daha hızlı bir hale getiremezler. Gereğinden fazla ve gereksiz değerler eklemek sisteminizi çorbaya çevirebilir ve başladığınızdan daha kötü bir noktaya ulaştırabilir. 

İnternette bulacağınız övgüler bir yana, agresif <code>CFLAGS</code> ve <code>CXXFlags</code> değerleri uygulamalarınıza yarardan çok zarar getirme eğilimindedir. Bu değerlerin var olma sebebinin "özel amaçlar" için "özel yerlerde" kullanılması olduğunu unutmayınız. Bir <code>CFLAGS</code> değerinin bir parça kod veya bir uygulama üzerinde işe yarıyor olması tüm sisteminizi bu flag kullanılarak derlemenizin faydanıza olacağı anlamına gelmez.

=== Hazır mısınız? ===

Karşılaşacağınız riskleri de bildiğinize göre artık bazı mantıklı ve güvenli değerleri incelemenin zamanı geldi. Bu değerler sisteminizi sağlıklı tutacak ve [http://bugs.gentoo.org Bugzilla]'ya raporlayacağınız hatalarda geliştiricilere yardımcı olacak değerlerdir. Geliştiriciler hata raporlarında genellikle (agresif değerlerin yazılıma zarar verebileceğini bildikleri için) problem oluşturan yazılımın basit <code>CFLAGS</code> değerleri ile tekrar derlenmesini ve problemin halen devam edip etmediğinin incelenmesini isterler. 

== Optimizasyon ==

=== Temel ===

<code>CFLAGS</code> ve <code>CXXFLAGS</code> kullanılmasının amacı sonuçta mümkün olduğu kadar güvenilir ve hızlı uygulamalara/sisteme sahip olmanız için kodları sisteminize uyumlu şekilde derlemektir. Bu seçeneklerden her CPU mimarisine göre en iyi çalışanlardan bahsedeceğiz. Ardından dikkat etmeniz gereken agresif seçeneklere de değineceğiz. <code>GCC</code> yardım sayfasındaki tüm seçenekleri açıklamayacağız (ki yüzlerce seçenek var), yalnızca en bilinen ve temel bayrakları ele alacağız. 

{{Note/tr|Bir seçeneğin tam olarak ne yaptığından emin değilseniz, [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC yardım sayfası]nın ilgili bölümüne bakın. Anlamazsanız Google'ı veya GCC   [http://gcc.gnu.org/lists.html e-posta listeleri]ni deneyin.}}

=== -march ===

İlk ve en önemli seçenek <code>-march</code>. Bu seçenek derleyiciye derleme sonucunda hangi [http://en.wikipedia.org/wiki/Microarchitecture işlemci mimarisi]ne uygun kod üretileceğini belirtir. Farklı işlemcilerin farklı özellikleri, çalışma yöntemleri ve desteklediği değerler bulunmaktadır. <code>-march</code> değerinin yardımı ile derleyici sahip olduğunuz işlemcinin kapasitesine ve özelliklerine uygun bir kod üretecektir. 

{{Path|/etc/portage/make.conf}} dosyasındaki <code>CHOST</code> değeri mimari seçeneğinizi iletse de, <code>-march</code> halen daha uyumlu kod üretmek için kullanılabilir. x86 ve x86-64 işlemciler (diğerleri gibi) <code>-march</code> bayrağından faydalanabilir. 

Ne tür bir işlemciniz var? Öğrenmek için aşağıdaki komutu çalıştırabilirsiniz: 

{{Cmd|cat /proc/cpuinfo}}

To get more details, including <code>march</code> and <code>mtune</code> values, use:

{{Cmd|<nowiki>gcc -c -Q -march=native --help=target</nowiki>}}

Şimdi de <code>-march</code> değerini iş başında görelim. Aşağıdaki örnek eski bir Pentium III işlemci için: 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium III örneği|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

Şimdi de 64-bit bir işlemci için bir örnek: 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64 örneği|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

Hangi tür işlemciye sahip olduğunuzdan veya işlemciniz için ne kullanacağınızdan halen emin değilseniz <code>-march=native</code> kullanın. Bu değeri kullanarak, GCC'nin işlemcinizi otomatik olarak tanıyarak en uyumlu değerleri kendi belirlemesini sağlayabilirsiniz. '''Ancak oluşacak paketi farklı bir CPU'da çalıştırmak üzere bir derleme yapıyorsanız bu seçeneği kullanmayın!''' 

{{Warning|Do '''not''' use <code>-march{{=}}native</code> or <code>-mtune{{=}}native</code> in the <code>CFLAGS</code> or <code>CXXFLAGS</code> variables of {{Path|make.conf}} when compiling with <tt>[[Distcc#-march.3Dnative|distcc]]</tt>.}}

Yani bir bilgisayarda derleme yapıp derlediğiniz paketleri farklı bir bilgisayarda (mesela daha eski ve yavaş bir cihazda) çalıştırmak istiyorsanız <code>-march=native</code> kullanmamalısınız. "Native" (doğal) seçeneği derlemenin sonunda üretilen kodun yalnızca derlendiği işlemci türünde çalışabileceği anlamına gelir. AMD Athlon 64 işlemci üzerinde <code>-march=native</code> kullanarak derlediğiniz bir paket VIA C3 işlemci üzerinde çalışamayacaktır. 

Ayrıca <code>-mtune</code> ve <code>-mcpu</code> bayraklarını da kullanabilirsiniz. Bunlar normalde sadece uyumlu <code>-march</code> seçeneği bulunmadığında kullanılan seçeneklerdir; bazı işlemci mimarileri <code>-mtune</code> hatta <code>-mcpu</code> kullanımını gerektirebilir. Malesef GCC'nin her bayrak için davranışı bir mimariden diğerine farklılık göstermektedir. 

x86 ve x86-64 işlemcilerde <code>-march</code> kullandığınızda sonuç olarak işlemciniz ile tam uyumlu kodlar alırsınız, yani üretilen paketler farklı veya daha eski işlemcilerde çalışmaz. Paketleri yalnızca derlediğiniz sistemde kullanacaksanız <code>-march</code> kullanın. <code>-mtune</code> ve <code>-mcpu</code> seçeneklerini yalnızca daha eski işlemcilere (i386 ve i486 gibi) uyumlu paketler derleme amacındaysanız değerlendirin. <code>-mcpu</code> seçeneği kullanıldığında birçok gerekli değeri (ABI gibi) dikkate almadığı için, bu seçeneği x86 ve x86-64 sistemlerde kullanmayın. 

Sadece x86/x86-64 olmayan işlemciler (Sparc, Alpha ve PowerPC gibi) <code>-mtune</code> veya <code>-mcpu</code> seçeneklerine ihtiyaç duyabilir. Bu mimarilerde bu seçenekler, x86/x86-64 mimarideki <code>-march</code> seçeneğinin yaptığı görevi yapmaktadır. Emin olmak için [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options GCC yardım sayfası]nı incelediğinize emin olunuz. 

{{Note/tr|Daha fazla <code>-march</code>/ <code>-mtune</code>/ <code>-mcpu</code> tavsiyesi için lütfen [[Handbook:Main_Page|Gentoo Kurulum Belgesi]]nin 5. bölümünü inceleyin. Ayrıca GCC'nin [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options mimariye özel belgeleri] de özellikle <code>-march</code>, <code>-mcpu</code> ve <code>-mtune</code> arasındaki farkları anlamada yardımcı olabilir.}}

=== -O ===

Gelecek seçeneğimiz <code>-O</code>. Bu seçenek genel optimizasyon değerini kontrol etmekte. Bu değeri değiştirmek, özellikle yüksek değerlerde derleme sürecini biraz daha yavaş hale getirip, RAM tüketimini artırabilir. 

There are seven <code>-O</code> settings: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code>, and <code>-Ofast</code>. Only use one of them in {{Path|/etc/portage/make.conf}}

<code>-O0</code> istisna olmak üzere, tüm <code>-O</code> seçenekleri bazı farklı optimizasyon bayraklarını aktifleştirmektedir. Detay için GCC'nin [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimizasyon seçenekleri] sayfasını inceleyebilirsiniz. 

Let us examine each optimization level: 

*  <code>-O0</code>: This level (that is the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in <code>CFLAGS</code> or <code>CXXFLAGS</code>. This reduces compilation time and can improve debugging info, but some applications will not work properly without optimization enabled. This option is not recommended except for debugging purposes.

*  <code>-O1</code>: the most basic optimization level. The compiler will try to produce faster, smaller code without taking much compilation time. It is basic, but it should get the job done all the time.

*  <code>-O2</code>: A step up from <code>-O1</code>. The ''recommended'' level of optimization unless the system has special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code>. With <code>-O2</code>, the compiler will attempt to increase code performance without compromising on size, and without taking too much compilation time.

*  <code>-O3</code>: the highest level of optimization possible. It enables optimizations that are expensive in terms of compile time and memory usage.  Compiling with <code>-O3</code> is not a guaranteed way to improve performance, and in fact, in many cases, can slow down a system due to larger binaries and increased memory usage. <code>-O3</code> is also known to break several packages. Using <code>-O3</code> is not recommended.

*  <code>-Os</code>: optimizes code for size. It activates all <code>-O2</code> options that do not increase the size of the generated code. It can be useful for machines that have extremely limited disk storage space and/or CPUs with small cache sizes.

*  <code>-Og</code>: GCC 4.8'de yeni bir  optimizasyon seviyesi olarak <code>-Og</code> tanıtıldı. Çalıştırma hızından çok ödün vermeden, hızlı bir derleme ile hata ayıklama modunda çalışmak için kullanılmaktadır. Geliştirme için genel olarak <code>-O0</code>'dan daha rahat bir ortam sağlamaktadır. <code>-Og</code> uygulamak otomatik olarak <code>-g</code>'yi aktif hale getirmez, yalnızca hata ayıklamayı zorlaştıran optimizasyonları etkisiz hale getirir.

*  <code>-Ofast</code>: GCC 4.7 ile gelen bir seçenektir, <code>-O3</code> üzerine <code>-ffast-math</code>, <code>-fno-protect-parens</code> ve <code>-fstack-arrays</code> ekler. Bu seçenek tavsiye edilen standartların dışında olduğu için tavsiye edilmemektedir.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and while not using <code>-O2</code>, try rebuilding with that option. As a fallback option, try setting the <code>CFLAGS</code> and <code>CXXFLAGS</code> to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).

=== -pipe ===

A common flag is <code>-pipe</code>. This flag has no effect on the generated code, but it makes the compilation process ''faster''. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, GCC might get killed. In those cases do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but it may need to activated. In that case add it to the flags. Though the GCC manual does not specify all architectures, it is turned on by using the <code>-O</code> option. Use the <code>-O</code> option to explicitly activate it on x86, with GCC up to version 4.6 or when using <code>-Os</code>. However, using this flag will make debugging hard or impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. When not doing software debugging and no other debugging-related CFLAGS such as <code>-ggdb</code> have been used, then try using <code>-fomit-frame-pointer</code>. 

{{Important/tr|<code>-fomit-frame-pointer</code> seçeneğini benzeri olan <code>-momit-leaf-frame-pointer</code> ile '''kullanmayın'''. Ayrıca <code>-momit-leaf-frame-pointer</code> seçeneğinin performans üzerinde negatif etkisi olduğu bilinmektedir.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extentions] (SSE), [http://en.wikipedia.org/wiki/SSE2 SSE2], [http://en.wikipedia.org/wiki/SSSE3 SSE3], [http://en.wikipedia.org/wiki/MMX_(instruction_set) MMX], and [http://en.wikipedia.org/wiki/3dnow 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to see if the CPU supports these instruction sets by running <kbd>cat /proc/cpuinfo</kbd>. The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

Normally none of these flags need to be added to {{Path|/etc/portage/make.conf}}, as long as the system is using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code>). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these additional flags will need to be enabled where appropriate after checking {{Path|/proc/cpuinfo}}. 

{{Note|Check the [http://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags] to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then it does not need to be separately specified; it will be turned on by using the proper <code>-march</code> setting.}}

== Optimizasyon SSS ==

=== Ama -funroll-loops -fomg-optimize seçenekleri ile daha iyi performans alıyorum! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt applications when used system-wide. Even the GCC [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> will make code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

Aslında bunlar tehlikeli derecede agresif seçenekler. Bu seçeneklerin kullanımı ile ilgili [http://forums.gentoo.org Gentoo Forumları] ve [http://bugs.gentoo.org Bugzilla]'ya göz attığınızda pek iyi bir manzara ile karşılaşmayacaksınız. 

You do not need to use those flags globally in <code>CFLAGS</code> or <code>CXXFLAGS</code>. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat the code and get your bugs marked INVALID or WONTFIX. 

Genelde böyle zararlı bayraklara ihtiyacınız olmaz. O yüzden '''kullanmayın''' . Güvenlileri deneyin: <code>-march</code> , <code>-O</code> ve <code>-pipe</code> .

=== Peki ya 3'ten büyük -O seviyeleri? ===

Bazı kullanıcılar <code>-O4</code>, <code>-O9</code> gibi yüksek optimizasyon seviyeleri ile daha iyi performans aldıklarını iddia etmekteler. Aslında <code>-O3</code>'ün üzerindeki hiçbir optimizasyon değerinin bir etkisi bulunmamakta. Derleyici yalnızca <code>-O3</code> seviyesini uygulamaktadır. 

Need more proof? Examine the [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup source code]: 

{{CodeBox|title=-O source code|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

Gördüğünüz gibi, 3'den büyük değerler <code>-O3</code> muamelesi görmekte.

=== What about compiling outside the target machine? ===

Some readers might wonder if compiling outside the target machine with a strictly inferior CPU or GCC sub-architecture will result in inferior optimization results (compared to a native compilation). The answer is simple: '''No'''.  Regardless of the actual hardware on which the compilation takes place and the CHOST for which GCC was built, as long as the same arguments are used <small>(except for <code>-march=native</code>)</small> and the same version of GCC is used <small>(although minor version might be different)</small>, the resulting optimizations are strictly the same.

To exemplify, if Gentoo is installed on a machine whose GCC's CHOST is ''i686-pc-linux-gnu'', and a [[Distcc]] server is setup on another computer whose GCC's CHOST is ''i486-linux-gnu'', then there is no need to be afraid that the results would be less optimal because of the strictly inferior sub-architecture of the remote compiler and/or hardware. The result would be as optimized as a native build, as long as the same options are passed to both compilers (and the <code>-march</code> parameter doesn't get a <code>native</code> argument).  In this particular case the target architecture needs to be specified explicitly as explained in [[Distcc#-march.3Dnative|Distcc and -march=native]].

The only difference in behavior between two GCC versions built targeting different sub-architectures is the implicit default argument for the <code>-march</code> parameter, which is derived from the GCC's CHOST when not explicitly provided in the command line.

=== Peki ihtiyaç fazlası bayraklar? ===

Çoğu zaman {{Path|/etc/portage/make.conf}} dosyasındaki CFLAGS ve CXXFLAGS değerlerinin  arasında tekrarlanan <code>-O</code> değerlerini görebilirsiniz. Bu bazen hata ile bazen de bayrak değişiminin önüne geçmek için yapılan birşeydir. 

Bayrak filtreleme/değişimi Portage içerisinde birçok uygulamada yapılmakta. Genellikle bir uygulamanın belirli bir <code>-O</code> değeri ile çalışamadığı görüldüğünde ebuild üzerinde ilgili seçeneğin kaldırılması veya değiştirilmesi ile problem aşılıyor. 

[http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo geliştirici belgelerinde] bu işlem detaylı olarak anlatılmakta. 

Gereksiz <code>-O</code> değerleri kullanarak belirli bir seviye için filtreleme işleminden kurtulmak mümkün. Örneğin <code>-O3</code> için: 

{{CodeBox|title=Specifying redundant CFLAGS|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

Ancak bu '''akıllıca bir işlem değil'''. CFLAGS değerinin ebuild üzerinde filtrelenmesinin bir amacı var. Uygulamanın bu bayrak ile derlenmesinin güvenli '''olmadığına''' emin olunduktan sonra bu tür değişiklikler yapılmakta. Bu sebeple bu tür işlemler yapmamalısınız. 

Desteklenmeyen seçenekler kullandığınızda problemler yaşamanız ve hata raporu ilettiğinizde bu seçenekleri değiştirerek tekrar derleme yapma talebiyle karşılaşmanız kaçınılmazdır. Zaman kaybetmemek için gereksiz bayrak kullanımından kaçının.

=== Peki ya LDFLAGS? ===

The Gentoo developers have already set basic, safe LDFLAGS in the base profiles, so they do not need to be changed.

=== Her paket için ayrı bayrak kullanabilir miyim? ===

{{Warning/tr|Her paket için farklı bayrak kullanımı hata ayıklama ve destek almanızı zorlaştıracaktır. Hata raporu açtığınızda bu özelliği kullanıyorsanız tüm detayları iletmeyi unutmayın.}}

Information on how to use per-package environment variables (including CFLAGS) is described in the [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]].

== Kaynaklar ==

Aşağıdaki kaynaklar optimizasyon ile ilgili daha fazla bilgi almanıza yardımcı olabilir: 

* [http://gcc.gnu.org/onlinedocs/ GCC online dökümanları] 

* Chapter 5 of the [[Handbook:Main_Page|Gentoo Installation Handbooks]]

* <kbd>man make.conf</kbd>

* [http://en.wikipedia.org Wikipedia]

* [http://forums.gentoo.org Gentoo Forumları]

{{Migrated|originalauthors=nightmorph}}
