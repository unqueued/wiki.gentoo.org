<languages />

<div class="mw-translate-fuzzy">
{{Metadata|abstract=Bu sayfada kaynak kodunu, güvenli ve mantıklı CFLAGS ve CXXFLAGS kulllanarak optimize etmekle ilgili bilgi verilmektedir. Ayrıca derlemeyi optimize etmenin arkasındaki genel mantık da ele alınmaktadır.}}
</div>

<div class="mw-translate-fuzzy">
Bu sayfada kaynak kodunu, güvenli ve mantıklı <var>CFLAGS</var> ve <var>CXXFLAGS</var> kulllanarak optimize etmekle ilgili bilgi verilmektedir. Ayrıca derlemeyi optimize etmenin arkasındaki genel mantık da ele alınmaktadır.
</div>

== Tanıtım ==

=== CFLAGS ve CXXFLAGS nedir? ===

<div class="mw-translate-fuzzy">
<var>CFLAGS</var> ve <var>CXXFLAGS</var> değerleri, GNU Compiler Collection (<var>GCC</var>) tarafından kaynak kodu derlerken ne tür değişiklikler yapılması gerektiğini belirleyen ortam değişkenleridir. <var>CFLAGS</var> değerleri C dili ile yazılmış kodları etkiler, <var>CXXFLAGS</var> ise C++.
</div>

Because such a large proportion of the packages that make up most Gentoo systems are written in C and C++, these are two variables administrators will definitely want to set correctly as they will greatly influence the way much of the system is built.

<div class="mw-translate-fuzzy">
Derlenen programın üreteceği hata ayıklama (debug) mesajlarının yoğunluğunu düşürebilir, hata durumunda gösterilecek uyarı mesajlarını artırabilir ve elbette üretilen kodun sisteminiz için optimize edilmesini sağlayabilirler. [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC yardım sayfası]nda kullanılabilecek seçenekler ve açıklamaları bulunmaktadır.
</div>

=== Nasıl kullanılırlar? ===

<div class="mw-translate-fuzzy">
<var>CFLAGS</var> ve <var>CXXFLAGS</var> iki şekilde kullanılabilir. İlk olarak, her uygulamaya özel olarak derleme sırasında <tt>automake</tt> tarafından üretilen Makefile dosyalarında bulunabilirler.
</div>

{{CodeBox|title=/etc/portage/make.conf dosyasındaki CFLAGS değerleri|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

<div class="mw-translate-fuzzy">
{{Important/tr|'''USE''' bayrakları için birden fazla satır kullanmanız mümkünken, <var>CFLAGS</var> için birden fazla satır tanımı özellikle <tt>cmake</tt> ile yapılan derlemelerde sorun çıkaracaktır. Bu sebeple CFLAGS tanımının tek satırda olduğuna emin olun. Bkz. {{Bug|500034}} }}
</div>

<div class="mw-translate-fuzzy">
Örnekte gördüğünüz gibi, <var>CXXFLAGS</var> değerleri <var>CFLAGS</var>'a atanan değerlerin aynısını kullanmakta. Çoğu sistemin hatasız bir derleme için ihtiyacı olan da bu olacaktır. Normal şartlarda <var>CXXFLAGS</var> için farklı bir değer belirtmeye ihtiyaç duymamanız gerekir.
</div>

{{Tip|[[Safe_CFLAGS|Safe CFLAGS]] article might help beginners start optimizing their systems.}}

=== Hatalı düşünceler ===

<div class="mw-translate-fuzzy">
<var>CFLAGS</var> ve <var>CXXFLAGS</var> değerleri daha küçük veya daha hızlı çalışan dosyalar üretmekte yardımcı olabilir. Ancak hatalı yapılandırma durumlarında yavaşlama, boyut büyümesi, derlenen dosyanın istendiği gibi çalışmaması ve tabi ki derleme sırasında hatalara sebep olabilir!
</div>

Remember, the global <var>CFLAGS</var> configured in {{Path|/etc/portage/make.conf}} will be applied to every package on the system so administrators typically only set general, widely-applicable options. Individual packages further modify these options either in the ebuild or the build system itself to generate the final set of flags used when invoking the compiler.

=== Hazır mısınız? ===

Karşılaşacağınız riskleri de bildiğinize göre artık bazı mantıklı ve güvenli değerleri incelemenin zamanı geldi. Bu değerler sisteminizi sağlıklı tutacak ve [http://bugs.gentoo.org Bugzilla]'ya raporlayacağınız hatalarda geliştiricilere yardımcı olacak değerlerdir. Geliştiriciler hata raporlarında genellikle (agresif değerlerin yazılıma zarar verebileceğini bildikleri için) problem oluşturan yazılımın basit <var>CFLAGS</var> değerleri ile tekrar derlenmesini ve problemin halen devam edip etmediğinin incelenmesini isterler. 

== Optimizasyon ==

=== Temel ===

<div class="mw-translate-fuzzy">
<var>CFLAGS</var> ve <var>CXXFLAGS</var> kullanılmasının amacı sonuçta mümkün olduğu kadar güvenilir ve hızlı uygulamalara/sisteme sahip olmanız için kodları sisteminize uyumlu şekilde derlemektir. Bu seçeneklerden her CPU mimarisine göre en iyi çalışanlardan bahsedeceğiz. Ardından dikkat etmeniz gereken agresif seçeneklere de değineceğiz. <code>GCC</code> yardım sayfasındaki tüm seçenekleri açıklamayacağız (ki yüzlerce seçenek var), yalnızca en bilinen ve temel bayrakları ele alacağız.
</div> 

<div class="mw-translate-fuzzy">
{{Note/tr|Bir seçeneğin tam olarak ne yaptığından emin değilseniz, [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC yardım sayfası]nın ilgili bölümüne bakın. Anlamazsanız Google'ı veya GCC   [http://gcc.gnu.org/lists.html e-posta listeleri]ni deneyin.}}
</div>

=== -march ===

<div class="mw-translate-fuzzy">
İlk ve en önemli seçenek <code>-march</code>. Bu seçenek derleyiciye derleme sonucunda hangi [http://en.wikipedia.org/wiki/Microarchitecture işlemci mimarisi]ne uygun kod üretileceğini belirtir. Farklı işlemcilerin farklı özellikleri, çalışma yöntemleri ve desteklediği değerler bulunmaktadır. <code>-march</code> değerinin yardımı ile derleyici sahip olduğunuz işlemcinin kapasitesine ve özelliklerine uygun bir kod üretecektir.
</div>

<code>-march=</code> is an ISA selection option; it tells the compiler that it may use the instructions from the [[Wikipedia:Instruction_set_architecture|ISA]]. On an Intel/AMD64 platform with <code>-march=native -O2</code> or lower OPT level, the code will likely end up with AVX instructions used but using shorter SSE XMM registers. To take full advantage of AVX YMM registers, the <code>-ftree-vectorize</code>, <code>-O3</code> or <code>-Ofast</code> options should be used as well<ref>GNU GCC Bugzilla, [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57952#c8 AVX/AVX2 no ymm registers used in a trivial reduction]. Retrieved on 2017/07/18.</ref>.

<code>-ftree-vectorize</code> is an optimization option (default at <code>-O3</code> and <code>-Ofast</code>), which attempts to vectorize loops using the selected ISA if possible.  The reason it isn't enabled at <code>-O2</code> is that it doesn't always improve code, it can make code slower as well, and usually makes the code larger; it really depends on the loop etc. 

<div class="mw-translate-fuzzy">
{{Path|/etc/portage/make.conf}} dosyasındaki <code>CHOST</code> değeri mimari seçeneğinizi iletse de, <code>-march</code> halen daha uyumlu kod üretmek için kullanılabilir. x86 ve x86-64 işlemciler (diğerleri gibi) <code>-march</code> bayrağından faydalanabilir.
</div> 

Ne tür bir işlemciniz var? Öğrenmek için aşağıdaki komutu çalıştırabilirsiniz: 

{{Cmd|cat /proc/cpuinfo}}

or even install {{Package|app-portage/cpuid2cpuflags}} and add the available CPU-specific options to the {{Path|make.conf}} file, which the tool does through e.g. the [[CPU FLAGS X86|CPU_FLAGS_X86]] variable:

{{Cmd|cpuid2cpuflags|output=<pre>
CPU_FLAGS_X86: aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3</pre>}}

{{RootCmd|echo "CPU_FLAGS_X86{{=}}'aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3'" >> /etc/portage/make.conf}}

<code>march</code> ve <code>mtune</code> dahil, seçenekler hakkında daha fazla detay için iki komut kullanılabilir:

{{Cmd|<nowiki>gcc -c -Q -march=native --help=target</nowiki>}}

{{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

Şimdi de <code>-march</code> değerini iş başında görelim. Aşağıdaki örnek eski bir Pentium III işlemci için: 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium III örneği|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

Şimdi de 64-bit bir işlemci için bir örnek: 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64 örneği|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

Hangi tür işlemciye sahip olduğunuzdan veya işlemciniz için ne kullanacağınızdan halen emin değilseniz <code>-march=native</code> kullanın. Bu değeri kullanarak, GCC'nin işlemcinizi otomatik olarak tanıyarak en uyumlu değerleri kendi belirlemesini sağlayabilirsiniz. '''Ancak oluşacak paketi farklı bir CPU'da çalıştırmak üzere bir derleme yapıyorsanız bu seçeneği kullanmayın!''' 

{{Warning|<tt>[[Distcc#-march.3Dnative|distcc]]</tt> ile derleme yaparken {{Path|make.conf}} içerisindeki <var>CFLAGS</var> veya <var>CXXFLAGS</var> değerlerinde <code>-march{{=}}native</code> veya <code>-mtune{{=}}native</code> değerlerini '''kullanmayın'''.}}

<div class="mw-translate-fuzzy">
Yani bir bilgisayarda derleme yapıp derlediğiniz paketleri farklı bir bilgisayarda (mesela daha eski ve yavaş bir cihazda) çalıştırmak istiyorsanız <code>-march=native</code> kullanmamalısınız. "Native" (doğal) seçeneği derlemenin sonunda üretilen kodun yalnızca derlendiği işlemci türünde çalışabileceği anlamına gelir. AMD Athlon 64 işlemci üzerinde <code>-march=native</code> kullanarak derlediğiniz bir paket VIA C3 işlemci üzerinde çalışamayacaktır.
</div> 

Ayrıca <code>-mtune</code> ve <code>-mcpu</code> bayraklarını da kullanabilirsiniz. Bunlar normalde sadece uyumlu <code>-march</code> seçeneği bulunmadığında kullanılan seçeneklerdir; bazı işlemci mimarileri <code>-mtune</code> hatta <code>-mcpu</code> kullanımını gerektirebilir. Malesef GCC'nin her bayrak için davranışı bir mimariden diğerine farklılık göstermektedir. 

x86 ve x86-64 işlemcilerde <code>-march</code> kullandığınızda sonuç olarak işlemciniz ile tam uyumlu kodlar alırsınız, yani üretilen paketler farklı veya daha eski işlemcilerde çalışmaz. Paketleri yalnızca derlediğiniz sistemde kullanacaksanız <code>-march</code> kullanın. <code>-mtune</code> ve <code>-mcpu</code> seçeneklerini yalnızca daha eski işlemcilere (i386 ve i486 gibi) uyumlu paketler derleme amacındaysanız değerlendirin. <code>-mcpu</code> seçeneği kullanıldığında birçok gerekli değeri (ABI gibi) dikkate almadığı için, bu seçeneği x86 ve x86-64 sistemlerde kullanmayın. 

<div class="mw-translate-fuzzy">
Sadece x86/x86-64 olmayan işlemciler (Sparc, Alpha ve PowerPC gibi) <code>-mtune</code> veya <code>-mcpu</code> seçeneklerine ihtiyaç duyabilir. Bu mimarilerde bu seçenekler, x86/x86-64 mimarideki <code>-march</code> seçeneğinin yaptığı görevi yapmaktadır. Emin olmak için [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options GCC yardım sayfası]nı incelediğinize emin olunuz.
</div> 

<div class="mw-translate-fuzzy">
{{Note/tr|Daha fazla <code>-march</code>/ <code>-mtune</code>/ <code>-mcpu</code> tavsiyesi için lütfen [[Handbook:Main_Page|Gentoo Kurulum Belgesi]]nin 5. bölümünü inceleyin. Ayrıca GCC'nin [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options mimariye özel belgeleri] de özellikle <code>-march</code>, <code>-mcpu</code> ve <code>-mtune</code> arasındaki farkları anlamada yardımcı olabilir.}}
</div>

<div class="mw-translate-fuzzy">
=== -O ===
</div>

{{Warning|Using <code>-O3</code> or <code>-Ofast</code> may cause some packages to break during the compilation.}}

{{Note|To print all packages that were built with specified <var>CFLAGS</var>/<var>CXXFLAGS</var> it's possible to use the following command: <code>grep Ofast /var/db/pkg/*/*/CFLAGS</code>}}

Gelecek seçeneğimiz <code>-O</code>. Bu seçenek genel optimizasyon değerini kontrol etmekte. Bu değeri değiştirmek, özellikle yüksek değerlerde derleme sürecini biraz daha yavaş hale getirip, RAM tüketimini artırabilir. 

<div class="mw-translate-fuzzy">
7 farklı <code>-O</code> ayarı bulunmaktadır:  <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> ,<code>-Os</code>, <code>-Og</code> ve <code>-Ofast</code>. {{Path|/etc/portage/make.conf}} dosyasında bunlardan yalnızca birini kullanmalısınız.
</div>

<div class="mw-translate-fuzzy">
<code>-O0</code> istisna olmak üzere, tüm <code>-O</code> seçenekleri bazı farklı optimizasyon bayraklarını aktifleştirmektedir. Detay için GCC'nin [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimizasyon seçenekleri] sayfasını inceleyebilirsiniz.
</div> 

Optimiasyon seviyelerinin yaptıklarına bir göz atalım: 

*  <code>-O0</code> : Bu seviye (bir "O" harfinin ardından eklenmiş sıfır) tıpkı <code>-O</code> kullanılmamış gibi tüm optimizasyon seçeneklerini kapalı konuma getirir. Bu sayede derleme zamanı azalır ve hata ayıklamak kolaylaşır ancak bazı uygulamalar optimizasyon olmadan düzgün çalışamayacaktır. Programdaki hataları yakalama amacı dışında bu seçenek önerilmemektedir.

*  <code>-O1</code> : En temel optimizasyon seviyesidir. Derleme süresini çok yükseltmeden daha hızlı ve daha ufak kodlar üretir. Basit bir seçenektir ancak genellikle her zaman güvenlidir diyebiliriz.

<div class="mw-translate-fuzzy">
*  <code>-O2</code> : <code>-O1</code> seçeneğinin bir üstü ve özel bir ihtiyacınız yok ise ''tavsiye edilen'' optimizasyon seçeneğidir. <code>-O2</code>,  <code>-O1</code>'in açtığı bayrakları da açıp, üzerine bazı bayraklar açmaktadır. Bu seçenekle yine derleyici derleme zamanını fazla uzatmadan güvenli ve hızlı kod üretmeye çalışacaktır.
</div>

<div class="mw-translate-fuzzy">
*  <code>-O3</code> : Mümkün olan en üst düzey optimizasyondur. Derleme süresini ve kullanılan RAM'i artırma pahasına daha fazla optimizasyon yapar. Sonuçta daha hızlı bir sistem garanti etmez, hatta fazla kaynak tüketiminden dolayı bazı durumlarda daha yavaş bir sonuçla karşılaşabilirsiniz. <code>-O3</code>'ün ayrıca bazı paketleri çalışmaz hale getirdiği bilinmektedir. Bu yüzden kullanımı tavsiye edilmemektedir.
</div>

*  <code>-Os</code> : Bu seçenek üretilen kodun boyutunu optimize eder. Boyutta büyümeye sebep olmayacak tüm <code>-O2</code> seçeneklerini açar. Çok az disk alanı ve/veya işlemcisinde ufak önbellekleri bulunan bilgisayarlarda kullanışlı olabilir.

*  <code>-Og</code>: GCC 4.8'de yeni bir  optimizasyon seviyesi olarak <code>-Og</code> tanıtıldı. Çalıştırma hızından çok ödün vermeden, hızlı bir derleme ile hata ayıklama modunda çalışmak için kullanılmaktadır. Geliştirme için genel olarak <code>-O0</code>'dan daha rahat bir ortam sağlamaktadır. <code>-Og</code> uygulamak otomatik olarak <code>-g</code>'yi aktif hale getirmez, yalnızca hata ayıklamayı zorlaştıran optimizasyonları etkisiz hale getirir.

*  <code>-Ofast</code>: GCC 4.7 ile gelen bir seçenektir, <code>-O3</code> üzerine <code>-ffast-math</code>, <code>-fno-protect-parens</code> ve <code>-fstack-arrays</code> ekler. Bu seçenek tavsiye edilen standartların dışında olduğu için tavsiye edilmemektedir.

Önceden de belirttiğimiz gibi <code>-O2</code> önerilen optimizasyon seviyesidir. Eğer derlemeniz hata ile sonlandıysa ve <code>-O2</code> kullanmıyorsanız, öncelikle kullanarak tekrar deneyin. Hata oluştuğu durumlarda optimizasyonu azaltmayı (<code>-O1</code>), hatta kapatmayı (<code>-O0 -g2 -ggdb</code>) deneyebilirsiniz.

=== -pipe ===

Bir başka sık kullanılan bayrak da <code>-pipe</code>'dır. Derleme sonrası üretilen kodda bir değişikliğe sebep olmaz ancak derleme işleminin daha hızlı gerçekleştirilmesini sağlar. Derleyiciye, derleme sırasında geçici dosyalar kullanmak yerine [http://en.wikipedia.org/wiki/Pipeline_(Unix) pipe] kullanmasını belirtir. Bu işlem daha fazla RAM kullanımına sebep olduğu için, eğer cihazınızda RAM sıkıntısı yaşıyorsanız ve derleme sırasında problem oluşuyor ise bu seçeneği kullanmayabilirsiniz. 

=== -fomit-frame-pointer ===

Bu da üretilen kodun azaltılmasını sağlayan yaygın bir seçenektir. Hata ayıklamayı zorlaştırmadığı platformlarda (x86-64 gibi) <code>-O</code> seçeneğinin her seviyesinde (<code>-O0</code> hariç) otomatik olarak açılır. GCC belgeleri her mimari için bu durumu netleştirmemektedir ancak x86 üzerinde kendiniz ekleyerek açmanız gerektiği bilinmektedir. Bu seçeneği kullanmak uygulamalarda oluşan hataları yakalamayı oldukça zorlaştırır. 

<div class="mw-translate-fuzzy">
Özel olarak Java ile yazılmış uygulamaların hata ayıklamasını neredeyse imkansız hale getirir. Yine de bu bayrak yalnızca Java kodlarını etkilememektedir. Yani getirisinin bir bedeli olarak problem oluşturan uygulamalarınızın hata kaydı çıktıları işe yaramaz duruma gelecektir. Hata ayıklama işlemine ihtiyacınız yok ise ve farklı hata ayıklama seçeneklerini (<code>-ggdb</code> gibi) kullanmıyorsanız <code>-fomit-frame-pointer</code> kullanmayı deneyebilirsiniz.
</div> 

{{Important/tr|<code>-fomit-frame-pointer</code> seçeneğini benzeri olan <code>-momit-leaf-frame-pointer</code> ile '''kullanmayın'''. Ayrıca <code>-momit-leaf-frame-pointer</code> seçeneğinin performans üzerinde negatif etkisi olduğu bilinmektedir.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

<div class="mw-translate-fuzzy">
Bu bayraklar x86 ve x86-64 mimarilerinde bulunan [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE], [http://en.wikipedia.org/wiki/SSE2 SSE2] , [http://en.wikipedia.org/wiki/SSSE3 SSE3] , [http://en.wikipedia.org/wiki/MMX MMX] ve [http://en.wikipedia.org/wiki/3dnow 3DNow!] seçeneklerini aktifleştirmek için bulunmaktadır. Bu seçenekler çokluortam, oyun ve diğer birçok matematiksel işlem içeren uygulamada performansı yükseltmektedir ve güncel işlemcilerin çoğunda bulunmaktadır.
</div> 

<div class="mw-translate-fuzzy">
{{Important/tr|<code>cat /proc/cpuinfo</code> komutunu çalıştırarak işlemcinizin bu bayrakları desteklediğine emin olun. Aldığınız çıktı işlemcinizin hangilerini desteklediğini gösterecektir. '''pni''' seçeneğinin SSE3 ile aynı anlama geldiğini hatırlatmak isteriz.}}
</div>

Doğru <code>-march</code> değerini kullandığınız sürece normal şartlarda bu seçenekleri {{Path|/etc/portage/make.conf}} dosyasına eklemenize gerek bulunmamakta. Örneğin <code>-march=nocona</code> seçeneği zaten içerisinde <code>-msse3</code> barındırmakta. Bazı yeni VIA ve Amd64 işlemcilerde <code>-march</code>'ın kapsamadığı seçenekler (sse3 gibi) bulunabilmekte. Bu tür durumlarda <code>cat /proc/cpuinfo</code> kodunun çıktısına bakarak gerekli eklemeyi yapmanız gerekecektir. 

<div class="mw-translate-fuzzy">
{{Note/tr|Aktifleştirilen işlemci bayrakları ile ilgili GCC [http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options notlarını] inceleyebilirsiniz. Eğer bir seçenek listelenmişse, özel olarak eklemenize gerek bulunmayacak ve doğru <code>-march</code> ayarı ile gelecektir.}}
</div>

== Optimizasyon SSS ==

=== Ama -funroll-loops -fomg-optimize seçenekleri ile daha iyi performans alıyorum! ===

<div class="mw-translate-fuzzy">
Hayır. Sadece birisi sizi daha fazla seçenek eklemenin daha iyi olduğu konusuna inandırdığı için '''öyle düşünüyorsunuz'''. Agresif bayraklar sistem genelinde kullanıldığında yalnızca uygulamalarınıza zarar verecektir.  <code>GCC</code> dahi [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options belgelerinde] <code>-funroll-loops</code> ve <code>-funroll-all-loops</code> seçeneklerinin boyutu büyüttüğüne ve yavaşlamaya sebep olduğuna dikkat çekiyor. Ancak bu iki seçenek halen <code>-ffast-math</code> , <code>-fforce-mem</code> , <code>-fforce-addr</code> ve benzeri seçeneklerle birlikte övgü kaynağı olmaya devam ediyor.
</div> 

Aslında bunlar tehlikeli derecede agresif seçenekler. Bu seçeneklerin kullanımı ile ilgili [http://forums.gentoo.org Gentoo Forumları] ve [http://bugs.gentoo.org Bugzilla]'ya göz attığınızda pek iyi bir manzara ile karşılaşmayacaksınız. 

<div class="mw-translate-fuzzy">
Bu seçenekleri <var>CFLAGS</var> veya <var>CXXFLAGS</var> içerisinde sistem genelinde kullanmak sisteminize zarar vermenin yanı sıra raporladığınız hataların INVALID (geçersiz) veya WONTFIX (çözülmeyecek) olarak işaretlenmesine sebep olacaktır.
</div> 

<div class="mw-translate-fuzzy">
Genelde böyle zararlı bayraklara ihtiyacınız olmaz. O yüzden '''kullanmayın''' . Güvenlileri deneyin: <code>-march</code> , <code>-O</code> ve <code>-pipe</code> .
</div>

=== Peki ya 3'ten büyük -O seviyeleri? ===

Bazı kullanıcılar <code>-O4</code>, <code>-O9</code> gibi yüksek optimizasyon seviyeleri ile daha iyi performans aldıklarını iddia etmekteler. Aslında <code>-O3</code>'ün üzerindeki hiçbir optimizasyon değerinin bir etkisi bulunmamakta. Derleyici yalnızca <code>-O3</code> seviyesini uygulamaktadır. 

<div class="mw-translate-fuzzy">
Kanıt mı istiyorsunuz? [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup Kaynak kodunu] inceleyin:
</div> 

<div class="mw-translate-fuzzy">
{{CodeBox|title=-O kaynak kodu|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}
</div>

    case OPT_LEVELS_3_PLUS_AND_SIZE:
      enabled = (level >= 3 {{!}}{{!}} size);
      break;
}}

<div class="mw-translate-fuzzy">
Gördüğünüz gibi, 3'den büyük değerler <code>-O3</code> muamelesi görmekte.
</div>

=== Ya hedef bilgisayar haricinde derleme yapıyorsak? ===

Some readers might wonder if compiling outside the target machine with a strictly inferior CPU or GCC sub-architecture will result in inferior optimization results (compared to a native compilation). The answer is simple: '''No'''.  Regardless of the actual hardware on which the compilation takes place and the CHOST for which GCC was built, as long as the same arguments are used <small>(except for <code>-march=native</code>)</small> and the same version of GCC is used <small>(although minor version might be different)</small>, the resulting optimizations are strictly the same.

To exemplify, if Gentoo is installed on a machine whose GCC's CHOST is ''i686-pc-linux-gnu'', and a [[Distcc]] server is setup on another computer whose GCC's CHOST is ''i486-linux-gnu'', then there is no need to be afraid that the results would be less optimal because of the strictly inferior sub-architecture of the remote compiler and/or hardware. The result would be as optimized as a native build, as long as the same options are passed to both compilers (and the <code>-march</code> parameter doesn't get a <code>native</code> argument).  In this particular case the target architecture needs to be specified explicitly as explained in [[Distcc#-march.3Dnative|Distcc and -march=native]].

The only difference in behavior between two GCC versions built targeting different sub-architectures is the implicit default argument for the <code>-march</code> parameter, which is derived from the GCC's CHOST when not explicitly provided in the command line.

=== Peki ihtiyaç fazlası bayraklar? ===

Çoğu zaman {{Path|/etc/portage/make.conf}} dosyasındaki CFLAGS ve CXXFLAGS değerlerinin  arasında tekrarlanan <code>-O</code> değerlerini görebilirsiniz. Bu bazen hata ile bazen de bayrak değişiminin önüne geçmek için yapılan birşeydir. 

Bayrak filtreleme/değişimi Portage içerisinde birçok uygulamada yapılmakta. Genellikle bir uygulamanın belirli bir <code>-O</code> değeri ile çalışamadığı görüldüğünde ebuild üzerinde ilgili seçeneğin kaldırılması veya değiştirilmesi ile problem aşılıyor. 

<div class="mw-translate-fuzzy">
[http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo geliştirici belgelerinde] bu işlem detaylı olarak anlatılmakta.
</div> 

Gereksiz <code>-O</code> değerleri kullanarak belirli bir seviye için filtreleme işleminden kurtulmak mümkün. Örneğin <code>-O3</code> için: 

{{CodeBox|title=Gereksiz CFLAGS belirtme|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

<div class="mw-translate-fuzzy">
Ancak bu '''akıllıca bir işlem değil'''. CFLAGS değerinin ebuild üzerinde filtrelenmesinin bir amacı var. Uygulamanın bu bayrak ile derlenmesinin güvenli '''olmadığına''' emin olunduktan sonra bu tür değişiklikler yapılmakta. Bu sebeple bu tür işlemler yapmamalısınız.
</div> 

<div class="mw-translate-fuzzy">
Desteklenmeyen seçenekler kullandığınızda problemler yaşamanız ve hata raporu ilettiğinizde bu seçenekleri değiştirerek tekrar derleme yapma talebiyle karşılaşmanız kaçınılmazdır. Zaman kaybetmemek için gereksiz bayrak kullanımından kaçının.
</div>

=== Peki ya LDFLAGS? ===

Gentoo geliştiricileri zaten gerekli ve güvenli LDFLAGS değerlerini profillerin içine yerleştirdikleri için herhangi bir değişiklik yapmanıza gerek bulunmamaktadır.

=== Her paket için ayrı bayrak kullanabilir miyim? ===

<div class="mw-translate-fuzzy">
{{Warning/tr|Her paket için farklı bayrak kullanımı hata ayıklama ve destek almanızı zorlaştıracaktır. Hata raporu açtığınızda bu özelliği kullanıyorsanız tüm detayları iletmeyi unutmayın.}}
</div>

Her paket için ayrı ortam değişkenini (CFLAGS dahil) nasıl kullanabileceğiniz ile ilgili bilgi [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables| Gentoo El Kitabı, "Per-Package Environment Variables"]] bölümünde bulunmaktadır.

== See also ==

* [[Handbook:AMD64/Installation/Stage#Configuring_compile_options|Configuring compile options]] (AMD64 Handbook)

<div class="mw-translate-fuzzy">
== Kaynaklar ==
</div>

Aşağıdaki kaynaklar optimizasyon ile ilgili daha fazla bilgi almanıza yardımcı olabilir: 

<div class="mw-translate-fuzzy">
* [http://gcc.gnu.org/onlinedocs/ GCC online dökümanları]
</div> 

<div class="mw-translate-fuzzy">
* <kbd>man make.conf</kbd> komutu
</div>

* [http://en.wikipedia.org Wikipedia]

* [http://forums.gentoo.org Gentoo Forumları]

== References ==

{{reflist}}

{{Migrated|originalauthors={{Dev|nightmorph}}}}


[[Category:Compilation]]
