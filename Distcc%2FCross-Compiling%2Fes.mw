<languages />

Esta guía le muestras cómo configurar distcc para realizar compilación cruzada entre diferentes arquitecturas de procesador.

== Compilación cruzada con distcc ==

== Introducción ==

<code>distcc</code> es una herramienta que permite compartir la carga de compilación de software entre varios computadores en una red. Mientras todos los computadores usen las mismas herramientas de sistema
(toolchain) construidas para la misma arquitectura de procesador no hace falta ninguna configuración especial para <code>distcc</code>. Pero, ¿Qué hacer si se necesita compilar para una arquitectura diferente utilizando computadores diferentes? Esta guía le muestra cómo configurar <code>distcc</code> para compilar para diferentes arquitecturas. 

=== Hacer emerge de la utilidades necesarias ===

En primer lugar necesitará hacer emerge de <code>crossdev</code> en cada uno de los
equipos involucrados en el proceso de compilación. La herramienta <code>crossdev</code> hace más fácil la construcción de herramientas de sistema para arquitecturas de forma cruzada. Originalmente lo escribió Joshua Kinard y luego Mike
Frysinger lo reescribió desde cero. Su uso es sencillo: <code>crossdev -t sparc</code>
construirá un conjunto de herramientas de sistema cruzado para la arquitectura sparc. Esto incluye binutils, gcc, glibc y linux-headers. Si necesita más ayuda, lance <c>crossdev --help</c>. Obviamente, solo es necesario hacer emerge del conjunto de
herramientas del sistema cruzado adecuado en los equipos que asisten a la compilación. 

A continuación, necesitará hacer emerge de <code>distcc</code> en todos los equipos
involucrados en el proceso. Esto incluye el equipo que ejecutará emerge y los máquinas con los compiladores cruzados. Por favor, eche un vistazo a [http://www.gentoo.org//doc/es/distcc.xml La documentación de Distcc en Gentoo] para obtener más información acerca de cómo configurar y utilizar <code>distcc</code>.

=== Notas específicas de las arquitecturas ===

==== Subarquitecturas Intel x86 ====

Si está haciendo una compilación cruzada entre distintas subarquitecturas Intel x86 (por ejemplo, i586 e i686), debe construir el conjunto de herramientas de sistema cruzado para el CHOST requerido, en caso contrario la compilación fallará. Esto es debido a que i586 e i686 son CHOSTs diferentes a pesar que ambos son considerados "x86". Por favor, tenga esto en cuenta cuando construya sus herramientas de sistema cruzado. Por ejemplo, si el sistema objetivo es i586, tiene que construir las herramientas de sistema cruzado para i586 en los equipos i686 que participan en la construcción. 

==== SPARC ====

El uso de <code>crossdev -t sparc</code> podría fallar arrojando los siguientes errores:

{{Code|Errors displayed when running crossdev -t sparc|<pre>
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
</pre>}}

If this happens, try using the following command instead:

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== Configuring distcc to cross-compile correctly ===

In the default distcc setup, cross-compiling will ''not'' work properly. The problem is that many builds just call <code>gcc</code> instead of the full compiler name (e.g. <code>sparc-unknown-linux-gnu-gcc</code> ). When this compile gets distributed to a distcc helper box, the native compiler gets called instead of your shiny new cross-compiler. 

Fortunately, there is a workaround for this little problem. All it takes is a wrapper script and a few symlinks on the box that will be running <code>emerge</code> . I'll use my Sparc box as an example. Wherever you see <code>sparc-unknown-linux-gnu</code> below, you will want to insert your own CHOST ( <code>x86_64-pc-linux-gnu</code> for an AMD64 box, for example). When you first emerge distcc, the {{Path|/usr/lib/distcc/bin}} directory looks like this: 

{{Note|The following instructions are to be performed only on the box running the emerge. Do not perform these steps on the helper boxes.}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

Here is what you want to do: 

{{RootCmd|rm c++ g++ gcc cc}}

Next, we'll create the new script on this box. Fire up your favorite editor and create a file with the following text in it, then save it as {{Path|sparc-unknown-linux-gnu-wrapper}} . Remember to change the CHOST (in this case, <code>sparc-unknown-linux-gnu</code> ) to the actual CHOST of the box that will be running the emerge. 

{{Code|The new wrapper script|<pre>
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
</pre>
}}

Next, we'll make the script executable and create the proper symlinks: 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

When you're done, {{Path|/usr/lib/distcc/bin}} will look like this: 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

Congratulations; you now have a (hopefully) working cross-distcc setup. 

=== How this works ===

When <code>distcc</code> is called, it checks to see what it was called as (e.g. <code>i686-pc-linux-gnu-gcc</code> , <code>sparc-unknown-linux-gnu-g++</code> , etc.) When distcc then distributes the compile to a helper box, it passes along the name it was called as. The distcc daemon on the other helper box then looks for a binary with that same name. If it sees just <code>gcc</code> , it will look for <code>gcc</code> , which is likely to be the native compiler on the helper box, if it is not the same architecture as the box running <code>emerge</code> . When the ''full'' name of the compiler is sent (e.g. <code>sparc-unknown-linux-gnu-gcc</code> ), there is no confusion. 

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* Andrew Gaffney
* Joshua Saddler
