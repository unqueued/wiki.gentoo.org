<languages />


{{Metadata|abstract=Esta guía muestra como configurar distcc para compilación cruzada entre diferentes arquitecturas de procesador.}}

Esta guía le muestras cómo configurar distcc para realizar compilación cruzada entre diferentes arquitecturas de procesador.

== Compilación cruzada con distcc ==

== Introducción ==

<code>distcc</code> es una herramienta que permite compartir la carga de compilación de software entre varios computadores en una red. Mientras todos los computadores usen las mismas herramientas de sistema (toolchain) construidas para la misma arquitectura de procesador no hace falta ninguna configuración especial para <code>distcc</code>. 

'''Esta guía muestra cómo configurar <code>distcc</code> para compilar en distintas arquitecturas.''' 

=== Hacer emerge de la utilidades necesarias ===

En primer lugar necesitará hacer emerge de <code>crossdev</code> en cada uno de los equipos involucrados en el proceso de compilación. La herramienta <code>crossdev</code> hace más fácil la construcción de herramientas de sistema para arquitecturas de forma cruzada. Su uso es sencillo: <code>crossdev -t sparc</code>
construirá un conjunto de herramientas de sistema cruzado para la arquitectura sparc. Esto incluye binutils, gcc, glibc y linux-headers. 

Necesitará hacer emerge de la cadena de herramientas para compilación cruzada adecuada en todos los equipos que vayan a participar. Si necesita más ayuda, lance <code>crossdev --help</code>.

Si desea realizar un ajuste fino de la cadena de herramientas de compilación cruzada, a continuación se muestra un guión que producirá una línea de comandos con las versiones exactas de los paquetes de desarrollo cruzado que deben ser construidos en los equipos que participan en la compilación (El guión se debe lanzar en el equipo destino).

{{CodeBox|title=Guión para realizar un ajuste fino de las herramientas de desarrollo|lang=bash|1=
#! /bin/bash
A="sys-devel/binutils" ; B=`equery l $A` ; BINUTILS_VER=`echo $B {{!}} cut -d- -f3-`
A=`/usr/bin/gcc-config -c` ; B=`echo $A {{!}} cut -d- -f5` ; GCC_VER=`equery l sys-devel/gcc {{!}} grep $B {{!}} cut -d- -f3-`
KERNEL_VER=`uname -r {{!}} sed s/-gentoo//`
A="sys-libs/glibc" ; B=`equery l $A` ; LIBC_VER=`echo $B {{!}} cut -d- -f3-`
echo "crossdev --b =$BINUTILS_VER --g =$GCC_VER --k =$KERNEL_VER --l =$LIBC_VER -t `uname -m`"
}}

A continuación necesitará hacer emerge de <code>distcc</code> en todas las máquinas involucradas en el proceso. Esto incluye la máquina en la que lanzará emerge y las máquinas con los compiladores cruzados. Por favor, lea la [[Distcc/es|Documentación sobre Distcc de Gentoo]] para obtener más información acerca de cómo configurar y usar <code>distcc</code>.

{{Note|Current versions of <tt>crossdev</tt> have a <code>-S (--stable)</code> flag for installing only stable versions of compiler tools.  (ie. <tt>crossdev -t i686-pc-linux-gnu --stable --ex-gcc --ex-gdb --portage --pretend</tt>). Without this option, <tt>crossdev</tt> installs the latest experimental compiler tools packages! 
When using this option, the above script is no longer needed, unless specific versions of package tools and/or headers have been unmasked.}}

=== Notas específicas de las arquitecturas ===

{{Note|Se puede obtener la arquitectura echando un vistazo a la variable <code>CHOST</code> del destino de la compilación en {{Path|/etc/make.conf}}. Cuando se ensambla el nombre de arquitectura para la opción <tt>crossdev -t</tt>, <tt>crossdev</tt> intentará de buen grado instalar las herramientas utilizando el nombre de la arquitectura que se ha ensamblado para los nombres de los directorios dentro de {{Path|/usr}} (esto es, {{Path|/usr/i686-pc-linux-gnu/}}, {{Path|/usr/i686-linux-gnu/}}, ...). Para arreglar esto se debe indicar cada nombre de arquitectura ensamblado o nombre de directorio a <tt>crossdev --clean</tt> para desinstalaro o eliminar manualmente los directorios dentro del sistema.}}

==== Subarquitecturas Intel x86 ====

Si está realizando una compilación cruzada entre distintas subarquitecturas de intel X86 (por ejemplo i586 e i686), deberá construir una cadena de herramientas completa para el CHOST deseado o de lo contrario la construcción fallará. Esto es debido a que i586 e i686 son realmente CHOSTs diferentes a pesar del hecho de que ambos se consideran "x86". Por favor, recuerde esto cuando construya cadenas de herramientas de compilación cruzada. Por ejemplo, si la máquina destino es una i586 esto significa que debe construir cadenas de herramientas de compilación cruzada para i586 en sus máquinas participantes i686. 

==== SPARC ====

El uso de <code>crossdev -t sparc</code> podría fallar arrojando los siguientes errores:

{{CodeBox|title=Errores mostrados cuando se lanza crossdev -t sparc|1=
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
}}

Si esto sucede, intente utilizar la siguiente orden:

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== Configurar distcc para realizar compilaciones cruzadas correctas ===

En la configuración por defecto de distcc, la compilación cruzada "no" funcionará correctamente. El problema es que muchos paquetes llaman a <code>gcc</code> en lugar de usar el nombre completo (por ejemplo,
<code>sparc-unknown-linux-gnu-gcc</code>). Cuando esta tarea de compilación se distribuye a un equipo participante, se invoca al compilador nativo en lugar del compilador cruzado. 

Por suerte, existe una solución a este pequeño problema. Lo único que se requiere es un guión o envoltorio y algunos enlaces simbólicos en el equipo que lanza la orden <code>emerge</code>. Usaremos un equipo Sparc como ejemplo. Donde quiera que vea <code>sparc-unknown-linux-gnu</code> más abajo, sustitúyalo por su propio CHOST (por ejemplo, <code>x86_64-pc-linux-gnu</code> para un equipo AMD64). Al hacer emerge de distcc, el directorio {{Path|/usr/lib/distcc/bin}} tendrá el siguiente aspecto: 

{{Note|Las siguientes órdenes se deben lanzar únicamente en la máquina que invoca a emerge. No realice estos pasos en el resto de máquinas participantes.}}

{{RootCmd|cd /usr/lib/distcc/bin |ls -l|output=<pre>
total 0
lrwxrwxrwx 1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc 
</pre>
}}

Esto es lo que debe hacer: 

{{RootCmd|rm c++ g++ gcc cc}}

A continuación crearemos un guión nuevo para esta máquina. Use su editor de texto preferido y cree un archivo con el siguiente texto, luego guárdelo como {{Path|sparc-unknown-linux-gnu-wrapper}}. Recuerde
cambiar el CHOST (en este caso <code>sparc-unknown-linux-gnu</code>) a la definición de CHOST del equipo que correrá emerge. 

{{CodeBox|title=El nuevo guión envoltorio|lang=bash|1=
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
}}

A continuación haremos que el guión sea ejecutable y crearemos los enlaces simbólicos adecuados: 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++
}}

Cuando haya terminado, {{Path|/usr/lib/distcc/bin}} tendrá el siguiente aspecto: 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx 1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx 1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx 1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx 1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper lrwxrwxrwx 1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x 1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

A continuación queremos asegurarnos de que estos envoltorios están disponibles después de actualizar el paquete distcc ya que se sobrescribirán los enlaces simbólicos. Podemos hacer esto a través del fichero {{Path|/etc/portage/bashrc}} que tiene el siguiente aspecto:

{{FileBox|filename=/etc/portage/bashrc|lang=bash|1=
case ${CATEGORY}/${PN} in
    sys-devel/distcc&41;
        # ¡Eh hombre! ¿Cómo fue que ese CONFIG PROTECT no funciona?
        if [ "${EBUILD_PHASE}" == "postinst" ] {{!}}{{!}} [ "${EBUILD_PHASE}" == "postrm" ];
        then cd /usr/lib/distcc/bin
            rm cc c++ gcc g++
            ln -s sparc-unknown-linux-gnu-wrapper cc
            ln -s sparc-unknown-linux-gnu-wrapper c++
            ln -s sparc-unknown-linux-gnu-wrapper gcc
            ln -s sparc-unknown-linux-gnu-wrapper g++
        fi
    ;;
esac
}}

¡Enhorabuena!. Probablemente tenga ahora una configuración de compilación cruzada con distcc en funcionamiento.

=== Como funciona esto ===

Cuando llamamos a <code>distcc</code>, comprueba que se ha invocado (por ejemplo, como <code>i686-pc-linux-gnu-gcc</code>,
<code>sparc-unknown-linux-gnu-g++</code>, etc.). Entonces, cuando distcc
distribuya la tarea de compilación a un equipo participante, pasa también el mismo nombre con el que se llamó. El demonio distcc en el equipo participante busca un binario con el mismo nombre. Si solo
ve <code>gcc</code>, buscará <code>gcc</code>, que probablemente será el
compilador nativo en el equipo participante si la arquitectura no es la misma que el equipo que corre <code>emerge</code>. Cuando pasamos el nombre "completo" del compilador (por ejemplo <code>sparc-unknown-linux-gnu-gcc</code>), entonces no habrá confusión.


=== Resolución de problemas ===

Esta sección cubre algunos problemas comunes cuando se utiliza <tt>distcc</tt> para realizar una compilación cruzada.

==== Remote host distccd COMPILE ERRORS ====

Cuando se lee el mensaje <code>COMPILE ERRORS</code> dentro del fichero {{Path|/var/log/distccd.log}} de un equipo remoto, lea las notas de arriba que se refieren a la especificación correcta del nombre de arquitectura (esto es, <tt>crossdev -t $DESTINO</tt>).

Otra solución es desinstalar y volver a instalar las herramientas de compilación <tt>crossdev</tt> usando la opción <tt>crossdev --clean</tt> o asegurándose de que ya no existe {{Path|/usr/$TARGET}} e instalar completamente el compilador cruzado a continuación.

Se recomienda editar el fichero {{Path|/usr/$DESTINO/etc/portage/make.conf}}, del equipo remoto y asegurarse de que los valores de la variable <code>CFLAGS</code> son los mismos en todos los equipos que participan en las operaciones de compilación.

==== Failed to exec $DESTINO-uknown-linux-gnu-gcc: No such file or directory ====

Los guiones envoltorio pueden fallar en su ejecución incluso con los permisos correctos:

{{CodeBox|title=Mensaje de error del guión envoltorio|1=
distcc[6195] (dcc_execvp) ERROR: failed to exec i686-unknown-linux-gnu-gcc: No such file or directory
}}

Para arreglar esto, asegúrese de haber creado el guión envoltorio con el nombre completo de la arquitectura destino:

{{Cmd|ls -alh /usr/lib/distcc/bin/c++|output=<pre>
/usr/lib/distcc/bin/c++ ->./i686-pc-linux-gnu-wrapper
</pre>}}


{{Migrated|originalauthors=Andrew Gaffney, Joshua Saddler}}
