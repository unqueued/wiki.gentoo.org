<languages />


{{Metadata|abstract=Esta guía muestra como configurar distcc para compilación cruzada entre diferentes arquitecturas de procesador.}}

Esta guía le muestras cómo configurar distcc para realizar compilación cruzada entre diferentes arquitecturas de procesador.

== Compilación cruzada con distcc ==

== Introducción ==

{{c|distcc}} es una herramienta que permite compartir la carga de compilación de software entre varios computadores en una red. Mientras todos los computadores usen las mismas herramientas de sistema (toolchain) construidas para la misma arquitectura de procesador no hace falta ninguna configuración especial para {{c|distcc}}. 

'''Esta guía ofrece instrucciones sobre cómo configurar distcc para compilar en distintas arquitecturas.''' 

=== Hacer emerge de la utilidades necesarias ===

First, you will need to emerge {{c|crossdev}} on all the machines that will be involved in the compiling process. {{c|crossdev}} is a tool that makes building cross-architecture toolchains easy. Its usage is straightforward: {{c|crossdev -t sparc}} will build a full cross-toolchain targeting the Sparc architecture. This includes binutils, gcc, glibc, and linux-headers. 

Necesitará hacer emerge de la cadena de herramientas para compilación cruzada adecuada en todos los equipos que vayan a participar. Si necesita más ayuda, lance {{c|crossdev --help}}.

Si desea realizar un ajuste fino de la cadena de herramientas de compilación cruzada, a continuación se muestra un guión que producirá una línea de comandos con las versiones exactas de los paquetes de desarrollo cruzado que deben ser construidos en los equipos que participan en la compilación (El guión se debe lanzar en el equipo destino).

{{CodeBox|title=Guión para realizar un ajuste fino de las herramientas de desarrollo|lang=bash|1=
#! /bin/bash
A="sys-devel/binutils" ; B=`equery l $A` ; BINUTILS_VER=`echo $B {{!}} cut -d- -f3-`
A=`/usr/bin/gcc-config -c` ; B=`echo $A {{!}} cut -d- -f5` ; GCC_VER=`equery l sys-devel/gcc {{!}} grep $B {{!}} cut -d- -f3-`
KERNEL_VER=`uname -r {{!}} sed s/-gentoo//`
A="sys-libs/glibc" ; B=`equery l $A` ; LIBC_VER=`echo $B {{!}} cut -d- -f3-`
echo "crossdev --b =$BINUTILS_VER --g =$GCC_VER --k =$KERNEL_VER --l =$LIBC_VER -t `uname -m`"
}}

A continuación necesitará hacer emerge de {{c|distcc}} en todas las máquinas involucradas en el proceso. Esto incluye la máquina en la que lanzará emerge y las máquinas con los compiladores cruzados. Por favor, lea la [[Distcc/es|Documentación sobre Distcc de Gentoo]] para obtener más información acerca de cómo configurar y usar {{c|distcc}}.

{{Note|Las versiones actuales de {{c|crossdev}} tienen un ajuste <code>-S</code> (<code>--stable)</code> para instalar únicamente las versiones estables de las herramientas de compilación (esto es, {{c|crossdev -t i686-pc-linux-gnu --stable --ex-gcc --ex-gdb --portage --pretend}}). Sin esta opción, {{c|crossdev}} instala los últimos paquetes experimentales de la herramientas de compilación!. Cuando se utiliza esta opción ya no es necesario el guión de arriba a menos que se hayan desenmascarado versiones específicas de los paquetes de herramientas o ficheros de cabecera.}} 

<!-- Translated in previous entry -->

=== Notas específicas de las arquitecturas ===

{{Note|Obtain the architecture name by looking at the compile target's <var>CHOST</var> variable within {{Path|/etc/make.conf}}. When mangling the architecture name for the {{c|crossdev -t}} option, {{c|crossdev}} will merrily guess and install tools using the mangled architecture name for folder names within {{Path|/usr}} (ie. {{Path|/usr/i686-pc-linux-gnu/}}, {{Path|/usr/i686-linux-gnu/}}, ...). To resolve this, specify each mangled architecture/folder name to {{c|crossdev --clean}} for uninstalling, or manually remove the folders from the system.}}

==== Subarquitecturas Intel x86 ====

If you are cross-compiling between different subarchitectures for Intel {{Keyword|x86}} (e.g. i586 and i686), you must still build a full cross-toolchain for the desired <var>CHOST</var>, or else the compilation will fail. This is because i586 and i686 are actually different CHOSTs, despite the fact that they are both considered "x86." Please keep this in mind when you build your cross-toolchains. For example, if the target box is i586, this means that you must build i586 cross-toolchains on your i686 helper boxes. 

==== SPARC ====

Using {{c|crossdev -t sparc}} might fail with one of the following errors:

{{CodeBox|title=Errores mostrados cuando se lanza crossdev -t sparc|1=
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
}}

Si esto sucede, intente utilizar la siguiente orden:

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== Configurar distcc para realizar compilaciones cruzadas correctas ===

In the default distcc setup, cross-compiling will ''not'' work properly. The problem is that many builds just call {{c|gcc}} instead of the full compiler name (e.g. {{c|sparc-unknown-linux-gnu-gcc}}). When this compile gets distributed to a distcc helper box, the native compiler gets called instead of your shiny new cross-compiler. 

Fortunately, there is a workaround for this little problem. All it takes is a wrapper script and a few symlinks on the box that will be running {{c|emerge}}. We'll use a Sparc box as an example. Wherever you see <code>sparc-unknown-linux-gnu</code> below, you will want to insert your own <var>CHOST</var> value (<code>x86_64-pc-linux-gnu</code> for an AMD64 box, for example). When you first emerge distcc, the {{Path|/usr/lib/distcc/bin}} directory looks like this: 

{{Note|Las siguientes órdenes se deben lanzar únicamente en la máquina que invoca a emerge. No realice estos pasos en el resto de máquinas participantes.}}

{{RootCmd|cd /usr/lib/distcc/bin |ls -l|output=<pre>
total 0
lrwxrwxrwx 1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc 
</pre>
}}

Esto es lo que debe hacer: 

{{RootCmd|rm c++ g++ gcc cc}}

Next, we'll create the new script on this box. Fire up your favorite editor and create a file with the following text in it, then save it as {{Path|sparc-unknown-linux-gnu-wrapper}}. Remember to change the <var>CHOST</var> value (in this case, <code>sparc-unknown-linux-gnu</code>) to the actual <var>CHOST</var> of the box that will be running the emerge. 

{{CodeBox|title=El nuevo guión envoltorio|lang=bash|1=
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
}}

A continuación haremos que el guión sea ejecutable y crearemos los enlaces simbólicos adecuados: 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++
}}

Cuando haya terminado, {{Path|/usr/lib/distcc/bin}} tendrá el siguiente aspecto: 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx 1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx 1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx 1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx 1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper lrwxrwxrwx 1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx 1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x 1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

A continuación queremos asegurarnos de que estos envoltorios están disponibles después de actualizar el paquete distcc ya que se sobrescribirán los enlaces simbólicos. Podemos hacer esto a través del fichero {{Path|/etc/portage/bashrc}} que tiene el siguiente aspecto:

{{FileBox|filename=/etc/portage/bashrc|lang=bash|1=
case ${CATEGORY}/${PN} in
<pre>                 sys-devel/distcc | sys-devel/gcc)</pre>
			if [ "${EBUILD_PHASE}" == "postinst" ]; then
				/usr/local/sbin/distcc-fix &
			fi
		;;
esac
}}

Then create this file:

{{FileBox|filename=/usr/local/sbin/distcc-fix|lang=bash|1=
#!/bin/bash	                
 
sleep 20
# change TUPLE to match your machine
TUPLE="sparc-unknown-linux-gnu"
cd /usr/lib/distcc/bin
rm cc c++ gcc g++ ${TUPLE}-wrapper
echo '#!/bin/bash' > ${TUPLE}-wrapper
echo "exec ${TUPLE}-g\${0:\$[-2]}" "\"\$@\"" >> ${TUPLE}-wrapper
chmod 755 ${TUPLE}-wrapper
ln -s ${TUPLE}-wrapper cc
ln -s ${TUPLE}-wrapper c++
ln -s ${TUPLE}-wrapper gcc
ln -s ${TUPLE}-wrapper g++
}}

Give it the proper permissions:

{{RootCmd|chmod 755 /usr/local/sbin/distcc-fix}}

¡Enhorabuena!. Probablemente tenga ahora una configuración de compilación cruzada con distcc en funcionamiento.

=== Como funciona esto ===

When {{c|distcc}} is called, it checks to see what it was called as (e.g. <code>i686-pc-linux-gnu-gcc</code>, <code>sparc-unknown-linux-gnu-g++</code>, etc.) When distcc then distributes the compile to a helper box, it passes along the name it was called as. The distcc daemon on the other helper box then looks for a binary with that same name. If it sees just {{c|gcc}}, it will look for {{c|gcc}}, which is likely to be the native compiler on the helper box, if it is not the same architecture as the box running {{c|emerge}}. When the ''full'' name of the compiler is sent (e.g. <code>sparc-unknown-linux-gnu-gcc</code>), there is no confusion.

=== Resolución de problemas ===

This section covers a number of common problems when using {{c|distcc}} for cross-compiling.

==== Remote host distccd COMPILE ERRORS ====

When receiving the message <code>COMPILE ERRORS</code> within a remote host's {{Path|/var/log/distccd.log}} file, see the above notes concerning specifying the correct architecture name (ie. {{c|crossdev -t $TARGET}}).

Another solution is to uninstall and re-install {{c|crossdev}} compiler tools, using the {{c|crossdev --clean}} option, or ensuring {{Path|/usr/$TARGET}} no longer exists, and then completely reinstall the cross compiler.

It might also be wise to edit the remote host's {{Path|/usr/$TARGET/etc/portage/make.conf}}, and ensure the contents of the <var>CFLAGS</var> variable are similar on all computers or hosts performing compiler operations.

==== Failed to exec $DESTINO-uknown-linux-gnu-gcc: No such file or directory ====

Los guiones envoltorio pueden fallar en su ejecución incluso con los permisos correctos:

{{CodeBox|title=Mensaje de error del guión envoltorio|1=
distcc[6195] (dcc_execvp) ERROR: failed to exec i686-unknown-linux-gnu-gcc: No such file or directory
}}

Para arreglar esto, asegúrese de haber creado el guión envoltorio con el nombre completo de la arquitectura destino:

{{Cmd|ls -alh /usr/lib/distcc/bin/c++|output=<pre>
/usr/lib/distcc/bin/c++ ->./i686-pc-linux-gnu-wrapper
</pre>}}


{{Migrated|originalauthors=Andrew Gaffney, Joshua Saddler}}
