{{InfoBox stack
|{{InfoBox homepage|http://clang.llvm.org/|header=true}}
|{{InfoBox wikipedia}}
}}

{{Package|sys-devel/clang}} is a "LLVM native" C/C++/Objective-C compiler using LLVM as a backend and optimizer. It aims to be GCC compatible yet stricter, offers fast compile times with low memory usage, and has useful error and warning messages for easier compile troubleshooting.

== Installation ==

=== Prerequisites ===

One of the goals of the Clang project is to be compatible with GCC. Occasionally some packages will fail to build correctly with it and some may build successfully but segfault when executed. Some packages also have GCC specific code and will also fail during compiling. In these events, GCC will need to be used as a fallback.

=== USE flags ===

Some packages are aware of the [https://packages.gentoo.org/useflags/clang <code>clang</code>] USE flag.

{{FileBox|filename=/etc/portage/make.conf|lang=bash|1=
USE="clang"
}}

=== Emerge ===

{{Emerge|params+=--update --deep --changed-use|sys-devel/clang}}

== Configuration ==

=== GCC fallback environments ===

Create a configuration file with a set of environment variables using Portage's built in {{Path|[[:/etc/portage/env|/etc/portage/env]]}} directory. This will override any defaults for any packages that fail to compile with clang. The name used below is just an example, so feel free to choose whatever name is desired for the fallback environment. Be sure to substitute chosen name with the examples used in this article.

{{FileBox|filename=/etc/portage/env/compiler-gcc|title=Environment named ''compiler-gcc''|lang=bash|
CC{{=}}"gcc"
CXX{{=}}"g++"
}}

The above is the most basic environmental variable needed. You can change it to suit your needs, such as enabling/disabling link-time optimizations, alternative AR, NM, RANLIB, and so on. Here are two examples below:

{{FileBox|filename=/etc/portage/env/compiler-gcc-flto|title=Environment variable named ''compiler-gcc-flto''|lang=bash|
CC{{=}}"gcc"
CXX{{=}}"g++"
CFLAGS{{=}}"-flto -march{{=}}native -O2 -pipe"
CXXFLAGS{{=}}"${CFLAGS}"
AR{{=}}"gcc-ar"
NM{{=}}"gcc-nm"
RANLIB{{=}}"gcc-ranlib"
}}

{{FileBox|filename=/etc/portage/env/compiler-gcc-fno-lto|title=Environment variable named ''compiler-gcc-fno-lto''|lang=bash|
CC{{=}}"gcc"
CXX{{=}}"g++"
CFLAGS{{=}}"-fno-lto -march{{=}}native -O2 -pipe"
CXXFLAGS{{=}}"${CFLAGS}"
AR{{=}}"ar"
NM{{=}}"nm"
RANLIB{{=}}"ranlib"
}}

Basically, copy over your current working GCC config from your make.conf in the event we need to use it as a fallback. If you choose to use LLVM's implementation of AR, NM, and RANLIB as detailed later in the article, be sure to set them back to the GNU versions for your GCC fallback environments as shown in the above example. If you choose not to, you can ignore the AR, NM, and RANLIB variables. If you want to use link-time optimization it's a good idea to have two separate environments like the above examples.

In the event you have to use the GCC fallback environment(s) set the appropriate flags in the {{Path|/etc/portage/package.env}} file.

{{FileBox|filename=/etc/portage/package.env|title=Falling back to ''GCC'' for ''app-foo/bar'' and ''app-bar/baz''|
app-foo/bar compiler-gcc-flto        #compiled using GCC with link-time optimization since package bar compiles using flto
app-bar/baz compiler-gcc-fno-lto     #compiled using GCC with no link-time optimization since package baz fails using flto
}}

Alternatively, if you have {{Package|app-portage/flaggie}} installed, the {{Path|/etc/portage/package.env}} file could be modified using:

{{RootCmd|flaggie app-foo/bar app-bar/baz +compiler-gcc}}

=== Testing against GCC ===

Those wishing to rebuild the system's @world set with clang should first enable tests via <code>FEATURES=test</code> in {{Path|[[make.conf]]}}. Note that many developers do not actually care about their own tests, and as a result there may be many false positives. Because of this, it is wise to compare the package test results against GCC build tests. Some packages that fail with {{c|clang}} will also fail with {{c|gcc}}.

=== Clang environments ===

Now that we've set up a safe fallback we can proceed to enable the usage of Clang in Gentoo. There are two ways to do this: System wide using {{Path|/etc/portage/make.conf}} or via environmental variables like the one(s) we created for the GCC fallback.

We'll use the same process as we did earlier in the article for setting up GCC fallbacks.

{{FileBox|filename=/etc/portage/env/compiler-clang|title=Environment variable named ''compiler-clang''|lang=bash|
CC{{=}}"clang"
CXX{{=}}"clang++"
}}

You can now use Clang on a per package basis by invoking the compiler-clang environmental variable you created.

{{FileBox|filename=/etc/portage/package.env|title=Using the ''Clang'' compiler for ''app-foo/bar'' and ''app-bar/baz''|
app-foo/bar compiler-clang
app-bar/baz compiler-clang
}}

Of course, that's about as basic as it gets. You can create more complex environments if you wish. It's a good idea to have a variable for link-time optimized Clang and one without if you want to take advantage of LTO as detailed later in the article. Simply create two environments, one with the flag <code>-flto</code> and one with <code>-fno-lto</code> and apply each to packages as needed.

{{FileBox|filename=/etc/portage/env/compiler-clang-flto|title=Environment variable named ''compiler-clang-flto''|lang=bash|
CC{{=}}"clang"                            
CXX{{=}}"clang++"                         
CFLAGS{{=}}"${CFLAGS} -flto"              
CXXFLAGS{{=}}"${CXXFLAGS} -flto"          
LDFLAGS{{=}}"-Wl,-O2 -Wl,--as-needed"     #please use whichever optimization level you're comfortable with
}}

{{FileBox|filename=/etc/portage/env/compiler-clang-fno-lto|title=Environment variable named ''compiler-clang-fno-lto''|lang=bash|
CC{{=}}"clang"                            
CXX{{=}}"clang++"                         
CFLAGS{{=}}"${CFLAGS} -fno-lto"              
CXXFLAGS{{=}}"${CXXFLAGS} -fno-lto"          
}}

You can now use Clang with or without link-time optimization on a per package basis by invoking the proper environmental you created. Please see "Using link-time optimizations with Clang" for a detailed guide.

{{FileBox|filename=/etc/portage/package.env|title=Using the ''Clang'' compiler for ''app-foo/bar'' and ''app-bar/baz''|
app-foo/bar compiler-clang-flto      #compiled using Clang with link-time optimization since package bar compiles using flto
app-bar/baz compiler-clang-fno-lto   #compiled using Clang with no link-time optimization since package baz fails using flto
}}

=== Global configuration via make.conf ===

When attempting to use Clang system wide '''the system absolutely must have a GCC fallback!''' This cannot be stressed enough as the system will not be able to compile everything using Clang at the moment, such as the GCC compiler. Configuring Gentoo to use Clang system wide is simple. Change the <var>CC</var> and <var>CXX</var> variables in {{Path|/etc/portage/make.conf}} to reference the Clang equivalents. No further configuration is necessary.

{{FileBox|filename=/etc/portage/make.conf|title=Setting the system compiler to ''Clang''|lang=bash|
CC{{=}}"clang"
CXX{{=}}"clang++"
}}

Packages that must use GCC for compiling can be handled with one of the fallback environments created earlier.

== Usage ==

=== Link-time optimizations with Clang ===

The link-time optimization feature defers optimizing the resulting executables to linking phase. This can result in better optimization of packages but isn't standard behavior in Gentoo yet. In order to use LTO we must first install LLVM with the Gold linker plugin so Clang can pass the <code>-plugin</code> flag to the linker. 

==== The Gold linker ====

Set the gold flag in the LLVM package so Portage knows to include the Gold plugin.

{{FileBox|filename=/etc/portage/package.use|1=
sys-devel/llvm gold
}}

Now emerge LLVM and check the USE flags to make sure the changes went into effect.

{{RootCmd|emerge -1vN sys-devel/llvm|output=<pre>

These are the packages that would be merged:

Calculating dependencies... done!
[ebuild     U  ] sys-devel/llvm-3.8.0-r3:0/3.8.0::gentoo [3.8.0-r2:0/3.8.0::gentoo] USE="clang gold libffi python static-analyzer xml -debug -doc -libedit -lldb -multitarget -ncurses -ocaml {-test}" ABI_X86="32 (64) (-x32)" PYTHON_TARGETS="python2_7" VIDEO_CARDS="-radeon" 0 KiB      

Total: 1 package (1 upgrade), Size of downloads: 0 KiB

Would you like to merge these packages? [Yes/No]
</pre>
}}

Gold must be set as the default linker since it allows clang to pass the <code>-plugin</code> flag. By default, Gentoo uses the bfd linker. As of July 2016, the bfd linker bundled with binutils does ''not'' support passing the <code>-plugin</code> as seen below.

{{RootCmd|/usr/bin/ld -plugin|output=<pre>
/usr/bin/ld: unrecognized option '-plugin'
/usr/bin/ld: use the --help option for usage information
</pre>
}}

===== Default linker using binutils-config =====

Using the sys-devel/binutils-config program, set {{c|ld}} to default to ld.gold instead of ld.bfd.

{{RootCmd|binutils-config --linker ld.gold|output=<pre>
* Setting default linker to ld.gold for x86_64-pc-linux-gnu-2.25.1 ...
</pre>
}}

Once {{c|ld}} is set to Gold, check the <code>-plugin</code> flag to see if it works.

{{RootCmd|/usr/bin/ld -plugin|output=<pre>
/usr/bin/ld: -plugin: missing argument
/usr/bin/ld: use the --help option for usage information
</pre>
}}

Great! It works. If you want to switch back to the default linker change the command from ld.gold to ld.bfd.

{{RootCmd|binutils-config --linker ld.bfd|output=<pre>
* Setting default linker to ld.bfd for x86_64-pc-linux-gnu-2.25.1 ...
</pre>
}}

=== LTO ===

==== Environment ====

Now that we're done setting up the Gold linker, we can create a new environment for LTO enabled clang. We covered this a little bit earlier but we'll go more into depth here. We enable LTO by passing the <code>-flto</code> flag to clang via the <var>CFLAGS</var> variable which in turn passes the <code>-plugin</code> flag to the linker.<ref>http://llvm.org/docs/GoldPlugin.html</ref> You need to set optimization flags via the <var>LDFLAGS</var> variable which Clang and Gold use when linking because that's when code optimization occurs. Linker flags should have <code>-Wl</code>, preceding them since they're being invoked by the compiler and not run manually<ref>http://linux.die.net/man/1/ld</ref>.

{{FileBox|filename=/etc/portage/env/compiler-clang-flto|title=Environment named ''compiler-clang-flto''|lang=bash|
CC{{=}}"clang"                            
CXX{{=}}"clang++"                         
CFLAGS{{=}}"${CFLAGS} -flto"              
CXXFLAGS{{=}}"${CXXFLAGS} -flto"          
LDFLAGS{{=}}"-Wl,-O2 -Wl,--as-needed"     #please use whichever optimization level you're comfortable with
}}

As an alternative, LLVM provides their own ar, nm, and ranlib. You're free to use them and may or may not get more mileage over using the standard ar, nm, and ranlib since they're intended to handle LLVM bitcode which Clang produces when using the <code>-flto</code> flag.

{{FileBox|filename=/etc/portage/env/compiler-clang-flto|title=Environment named ''compiler-clang-flto''|lang=bash|
CC{{=}}"clang"                            
CXX{{=}}"clang++"                         
CFLAGS{{=}}"${CFLAGS} -flto"              
CXXFLAGS{{=}}"${CXXFLAGS} -flto"          
LDFLAGS{{=}}"-Wl,-O2 -Wl,--as-needed"    #please use whichever optimization level you're comfortable with
AR{{=}}"llvm-ar"
NM{{=}}"llvm-nm"
RANLIB{{=}}"llvm-ranlib"
}}

Now you can set {{Path|/etc/portage/package.env}} overrides using Clang with LTO enabled.

{{FileBox|filename=/etc/portage/package.env|title=Enabling ''LTO'' for ''app-foo/bar'' and ''app-bar/baz''|
app-foo/bar compiler-clang-flto
app-bar/baz compiler-clang-flto
}}

==== Global configuration ====

Similar to what we covered earlier in the article, we can do a system wide Clang with LTO enabled setup by changing our {{Path|/etc/portage/make.conf}} file.

{{FileBox|filename=/etc/portage/make.conf|title=Setting the system compiler to ''Clang''|lang=bash|
CC{{=}}"clang"                            
CXX{{=}}"clang++"                         
CFLAGS{{=}}"${CFLAGS} -flto"              
CXXFLAGS{{=}}"${CXXFLAGS} -flto"          
LDFLAGS{{=}}"-Wl,-O2 -Wl,--as-needed"    #please use whichever optimization level you're comfortable with
AR{{=}}"llvm-ar"
NM{{=}}"llvm-nm"
RANLIB{{=}}"llvm-ranlib"
}}

Again, it's up to you if you want to set the AR, NM, and RANLIB to the LLVM implementations. Since earlier in the article we set up compiler environments using Clang without LTO, GCC without LTO, and GCC with LTO, we can pick and choose which is best on a per package basis. Since the goal is to compile packages system wide with Clang using LTO and not every package will successfully compile using it, we'll have to fall back to Clang with LTO disabled or GCC. Your {{Path|/etc/portage/package.env}} may look like this:

{{FileBox|filename=/etc/portage/package.env|title=Example ''package.env'' setup|
app-foo/bar compiler-clang-fno-lto   #compiled using Clang with no link-time optimization since package bar fails using flto
app-bar/baz compiler-gcc-fno-lto     #compiled using GCC with no link-time optimization since package bar fails using flto
app-baz/foo compiler-gcc-flto        #compiled using GCC with link-time optimization since package foo compiles using flto
}}

=== ThinLTO starting with Clang 3.9 ===

As of Clang 3.9, a new feature called ThinLTO has been introduced. In a nutshell, ThinLTO gives you the performance of full LTO, but with the compile times of no LTO.<ref>http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html</ref> To invoke the command, simply change -flto (which defaults to full when invoked) to -flto=thin in your configuration files.

The Gold linker is still required for this so make sure you've followed the steps above to set it as the default linker.

{{FileBox|filename=/etc/portage/make.conf|title=Enabling Clang's ThinLTO feature|lang=bash|
CC{{=}}"clang"                            
CXX{{=}}"clang++"                         
CFLAGS{{=}}"${CFLAGS} -flto{{=}}thin"              
CXXFLAGS{{=}}"${CXXFLAGS} -flto{{=}}thin"          
LDFLAGS{{=}}"-Wl,-O2 -Wl,--as-needed"    #please use whichever optimization level you're comfortable with
}}

=== distcc ===

In order to use clang on a distcc client, additional symlinks have to be created in ''/usr/lib*/distcc/bin'':

{{RootCmd|ln -s /usr/bin/distcc /usr/lib/distcc/bin/clang|ln -s /usr/bin/distcc /usr/lib/distcc/bin/clang++}}

=== ccache ===

Automatic with `>=ccache-3.9-r3` when Clang is emerged.

== Troubleshooting ==

The main place for looking up known failures with clang is {{Bug|408963}}. If you hit one not reported on our Bugzilla already, please open a new bug report and make it block 408963.

=== Compile errors when using Clang with -flto ===

If the packages you're installing are failing, check your logs. Often times packages with errors like the following will need to disable LTO by invoking the compiler-clang-fno-lto environment.

{{FileBox|filename=/var/log/portage/sys-apps:less-483-r1:20160712-034715.log|
<nowiki>
/usr/bin/x86_64-pc-linux-gnu-ld: error: version.o:1:3: invalid character
/usr/bin/x86_64-pc-linux-gnu-ld: error: version.o:1:3: syntax error, unexpected $end
/usr/bin/x86_64-pc-linux-gnu-ld: error: version.o: not an object or archive
</nowiki>
}}

You will also most likely see this error in every LTO failure case.

{{FileBox|filename=/var/log/portage/sys-apps:less-483-r1:20160712-034715.log|
<nowiki>
x86_64-pc-linux-gnu-clang-3.8: error: linker command failed with exit code 1 (use -v to see invocation)
</nowiki>
}}

Simply add the failing package to your {{Path|/etc/portage/package.env}}. In this case it's {{Package|sys-apps/less}}, so we'll apply the proper override.

{{FileBox|filename=/etc/portage/package.env|title=Example ''package.env'' setup|
sys-apps/less compiler-clang-fno-lto   #compiled using Clang with no link-time optimization since package less fails using flto
}}

Sometimes a package will fail to compile even when disabling LTO because it requires another package which was compiled using -flto and works incorrectly. You may see an error like this:

{{FileBox|filename=/var/log/portage/dev-libs:boehm-gc-7.4.2:20160713-085706.log|
/usr/lib64/libatomic_ops.a: error adding symbols: Archive has no index; run ranlib to add one
}}

In this case libatomic_ops is causing boehm-gc to fail compiling. Recompile the program causing the failure using your -fno-lto environment and then recompile the new program. In this case, boehm-gc fails when using LTO, so we'll add both of them to our {{Path|/etc/portage/package.env}} file and assign the environments using the -fno-lto flags.

{{FileBox|filename=/etc/portage/package.env|title=Example ''package.env'' setup|
dev-libs/boehm-gc		compiler-clang-fno-lto
dev-libs/libatomic_ops		compiler-clang-fno-lto
}}

=== Use of GNU extensions without proper -std= ===

Some packages tend to use GNU extensions in their code without specifying <code>-std=</code> appropriately. GCC allows that usage, yet Clang disables some of more specific GNU extensions by default.

If a particular package relies on such extensions being available, you will need to append the correct ''-std='' flag to it:

* <code>-std=gnu89</code> for C89/C90 with GNU extensions,
* <code>-std=gnu99</code> for C99 with GNU extensions,
* <code>-std=gnu++98</code> for C++:1998 with GNU extensions.

A common symptom of this problem are multiple definitions of inline functions like this:

{{FileBox|filename=/var/log/portage/Example package error in example log|
<nowiki>
/usr/bin/x86_64-pc-linux-gnu-ld: error: ../mpi/.libs/libmpi.a(mpi-bit.o): multiple definition of '_gcry_mpih_add'
/usr/bin/x86_64-pc-linux-gnu-ld: ../mpi/.libs/libmpi.a(mpi-add.o): previous definition here
/usr/bin/x86_64-pc-linux-gnu-ld: error: ../mpi/.libs/libmpi.a(mpi-bit.o): multiple definition of '_gcry_mpih_add_1'
/usr/bin/x86_64-pc-linux-gnu-ld: ../mpi/.libs/libmpi.a(mpi-add.o): previous definition here
</nowiki>
}}

This is because Clang uses C99 inline rules by default which do not work with gnu89 code. To work around it, you most likely have to pass <code>-std=gnu89</code> or set one of your environmental overrides to use GCC to compile the failing package if passing the right <code>-std=</code> flag doesn't work.

[[Category:Core system]] [[Category:Compilation]]
