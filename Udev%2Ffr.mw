<languages />


{{Metadata|abstract=udev est le gestionnaire de périphériques pour le noyau Linux. Il administre les nœuds de périphérique dans /dev et prend en charge toutes les actions de l'espace utilisateur lors de l'ajout ou de la suppression de périphériques. }}

{{Lowercase title}}
{{InfoBox stack
|{{InfoBox wikipedia|header=true}}
}}

'''udev''' est le gestionnaire de périphérique pour le noyau de Linux. En premier lieu, il gère les nœuds de périphérique dans {{Path|/dev}} et prend en charge toutes les actions dans l'espace utilisateur lors de l'ajout ou de la suppression de périphériques. Consultez aussi [[Project:Eudev|eudev]], une dérivation  de udev.

== Qu'est-ce que udev? ==

=== Le répertoire  /dev  ===

Lorsque les utilisateurs de Linux parlent du matériel sur leur système à des gens qui pensent que Linux est une sorte de virus ou de marque de café, l'utilisation de "slash dev slash foo"  provoquera à coup sûr une sorte d'étonnement. Mais, pour l'utilisateur heureux (comme vous) utiliser  {{Path|/dev/sda1}} est une façon rapide d'expliquer que nous parlons de la première partition du premier disque maître SATA ? 

Nous savons tous ce qu'est un fichier de périphérique. Certains savent même pourquoi les fichiers de périphériques possèdent des numéros spéciaux quand ils les regardent de près après avoir exécuté une commande <code>ls -l</code> dans le dossier {{Path|/dev}}. Mais ce que nous tenons toujours comme garanti, c'est que le premier disque SATA est référencé comme {{Path|/dev/sda}}. Vous pouvez le voir autrement mais cela est un défaut de conception. 

Pensez à des périphériques connectables à chaud, comme les périphériques USB et IEE1394, ou les périphériques PCI commutables à chaud, ... Quel est le premier périphérique ? Et pour combien de temps ? Comment les autres périphériques seront-ils nommés quand le premier disparaitra ? Cela sera-t-il amusant si votre tâche d'impression est tout à coup déplacée de votre toute nouvelle imprimante laser vers votre quasi-moribonde imprimante à matrice parce que votre gamin aura tiré sur le cordon d'alimentation de l'imprimante laser qui justement était la première imprimante ? 

C'est alors qu'''udev'' fait son entrée. Le but du projet udev est à la fois intéressant et nécessaire :

* Fonctionne dans l'espace utilisateur
* Crée/enlève des fichiers de périphérique de manière dynamique
* Assure un nommage cohérent
* Fournit une API dans l'espace utilisateur

À chaque fois qu'une modification de la structure des périphériques se produit, le noyau génère un événement  ''uevent'' qui est intercepté par udev. udev suit alors les règles déclarées dans les répertoires  {{Path|/etc/udev/rules.d}}, {{Path|/run/udev/rules.d}} et {{Path|/lib/udev/rules.d}}. En se basant sur l'information contenue dans l'événement, il trouve la règle ou les règles dont il a besoin pour déclencher et accomplir les actions requises. Ces actions peuvent être de créer ou de supprimer des fichiers de périphérique, mais elles peuvent aussi déclencher le chargement de micro-logiciels particuliers dans la mémoire du noyau.

== Installation ==

{{Note| Si vous êtes en train de faire une mise à jour, consultez la [[/upgrade|sous-page upgrade]].}}

=== Noyau ===

Vous devez activer les options suivantes du noyau :

<!-- See http://git.kernel.org/?p=linux/hotplug/udev.git;a=blob_plain;f=README -->
{{Kernel||<pre>
General setup  --->
    [*] Configure standard kernel features (expert users)  --->
        [ ] Enable deprecated sysfs features to support old userspace tools
        [*] Enable signalfd() system call
Enable the block layer  --->
    [*] Block layer SG support v4
Networking support  --->
    Networking options  --->
        <*> Unix domain sockets
Device Drivers  --->
    Generic Driver Options  --->
        ()  path to uevent helper
        [*] Maintain a devtmpfs filesystem to mount at /dev
    < > ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
File systems  --->
    [*] Inotify support for userspace
    Pseudo filesystems --->
        [*] /proc file system support
        [*] sysfs file system support
</pre>}}

=== Logiciel ===

Portage connaît l'option globale ''udev'' de la variable USE pour activer la prise en charge de udev dans les autres paquets. Activer cette option de la variable USE (par défaut dans tous les [[profile|profils]] ''linux'') provoquera l'installation du paquet  {{Package|sys-fs/udev}} automatiquement.

{{File|/etc/portage/make.conf||<pre>
USE="... udev ..."
</pre>}}

Les options de la variable  USE d'udev sont :

{{USEflag|package=sys-fs/udev
|acl+yes
|doc
|firmware-loader+yes
|gudev+yes
|introspection+yes
|kmod+yes
|openrc+yes
|selinux++no
|static-libs++no
}}

Après les avoir définies vous devez mettre votre système à jour pour que les changements prennent effet :

{{Emerge|params+=--changed-use --deep|@world}}

== Configuration ==

=== Service ===

Pour démarrer udev au démarrage de la machine, ajoutez le au sysinit de  votre niveau d'exécution : {{RootCmd|rc-update add udev sysinit}}

== Configuration avancée ==

=== Rules ===

udev provides a set of rules that match against exported values of uevents (events sent by the kernel) and properties of the discovered device. A matching rule will possibly name and create a device node and run configured programs to set-up and configure the device.

The rule definitions are stored in {{Path|/lib/udev/rules.d}} (installed by packages) and {{Path|/etc/udev/rules.d}} (for end-user specified rules). In these directories, multiple rule files (with suffix {{Path|.rules}}) are traversed in alphanumerical order. Inside the rules files, udev will find expressions that might match a uevent together with the state to match (is the uevent because a device is added or removed) and the command to execute.

The event matching is based on information such as:
* the ''SUBSYSTEM'' of the uevent (for which type of device is the uevent fired)
* the ''ACTION'' that is taken (add, change or remove)
* one or more attributes (through ''ATTR'' or ''ATTRS''), such as the device class, vendor or other device information
* the kernel-provided name (through ''KERNEL''), such as sd* (for SCSI/SATA disks) or input* (for input devices such as mice and keyboards)
* one or more environment settings (through ''ENV''), used to send information between multiple rules

Based on this information, the rule can then state if 
* some information needs to be shared with later events (through environment variables)
* links need to be created in {{Path|/dev}}
* commands need to be executed

Udev does this for every rule that matches (so it does not stop after the first match) to allow a flexible device management approach.

=== Persistent device names ===

The kernel detects devices asynchronous, udev mirrors the kernel's [[sysfs]] filesystem and so the device are named and numbered in order of detection. So by default udev provides no persistent device names. However there are mechanismen for some device classes to provide these:

* udev creates for storage devices additional symlinks based on the device's id, label, uuid and path. See the {{Path|/dev/disk/by-*}} directory. So instead of using e.g. the device file {{Path|/dev/sda}} use the file {{Path|/dev/disk/by-label/SOME_LABEL}}.

* The same for input devices in the {{Path|/dev/input}} directory.

* Using custom rules you can create your own device files.

== Usage ==

Some useful commands are:

* Show all messages about a given device file:
: {{RootCmd|udevadm info --query{{=}}all --name{{=}}/dev/DEVICE_FILE}}

* Monitor udev activities:
: {{RootCmd|udevadm monitor}}

See the ''udevadm'' [[man page]] for more information.

== Troubleshooting ==

* {{Bug|udev|search=package}}

=== Log monitor messages ===

Log all message you see, when you run '''udevadm monitor''':

{{File|/etc/conf.d/udev||<pre>
udev_monitor="YES"
</pre>}}

It will create the new log file {{Path|/run/udev/udevmonitor.log}}.

=== Debug mode ===

Enable debug mode to get more log messages:

{{File|/etc/conf.d/udev||<pre>
udev_debug="YES"
</pre>}}

It will create the new log file {{Path|/run/udev/udevdebug.log}}.

=== Missing device files {{Path|/dev/null}} and {{Path|/dev/console}} ===

Some udev versions need these files and can't create them on their own. So you have to create them:

{{RootCmd
|mkdir test
|mount --bind / test
|cd test/dev
|mknod -m 660 console c 5 1
|mknod -m 660 null c 1 3
|cd ../..
|umount test
|rmdir test
}}

=== NIC assigned eth0, but is moved to eth1 ===

Those having dual network cards on their motherboards may run into a situation where ifconfig may show no eth0 or eth1.  Dmesg may show their NIC detected as eth0, and later moved to eth1. Performing a "ifconfig -a" will also show the NIC as eth1. This is caused by using the kernel assigned names in the first place. You should write your own rules like {{Path|/etc/udev/rules.d/70-my-network.rules}} to
use free names like lan0 or wireless0 or use the predictable interface names which are enabled by the default since version 197.

Remember to also remove old files from old versions of udev:

{{RootCmd|rm /etc/udev/rules.d/70-persistent-net.rules}}


[[Category:Core system]]
[[Category:Daemons]]
