<languages />

Este CÓMO le ayudará a crear configuraciones de nodos sin disco en Gentoo Linux.

== Introducción ==

=== Acerca de este CÓMO ===

Este CÓMO le ayudará a configurar estaciones de trabajo "sin disco" basadas en la distribución Gentoo Linux. Hemos intentado hacerla fácil de usar y atractiva para el principiante, porque todos nosotros en algún momento hemos sido uno :&#41;. Si bien un usuario experimentado puede unir varios CÓMOS sobre nodos sin disco y juntarlos con otros sobre trabajo en red, esperamos que esta guía facilite la instalación a todos los usuarios interesados, geeks" o no. 

=== ¿Qué es una máquina sin disco? ===

Una máquina sin disco es un PC sin ninguno de los dispositivos de arranque tradicionales, como discos duros, disquetes o CD-ROMs. Un nodo sin disco arranca desde la red y por lo tanto necesita un servidor que le ofrezca un espacio de almacenamiento que pueda utilizar como disco local. De ahora en adelante llamaremos al servidor "maestro" y a la máquina sin disco "esclavo" (menudo nombre :). El nodo esclavo necesita un adaptador de red con soporte para el arranque PXE o Etherboot; eche un vistazo a [http://www.etherboot.org Etherboot.org] para obtener una lista de dispositivos soportados. La mayoría de tarjetas actuales soportan PXE y muchos de los adaptadores incorporados en las placas base también funcionarán. 

=== Antes de empezar ===

Debe tener Gentoo instalado en su nodo maestro y tener espacio suficiente en él para almacenar los sistemas de ficheros de los nodos esclavos a los que vaya a servir. Además, asegúrese de tener una interfase conectada a Internet distinta de la que se utiliza para la conexión a la red local. 

== Configurar el maestro y los esclavos ==

=== Acerca de los núcleos ===

El núcleo es el software situado entre el hardware y el resto de software instalado en su máquina, es esencialmente el corazón  de un sistema operativo basado en núcleo. Cuando inicia su computadora, el BIOS ejecuta las instrucciones que están en el 
espacio reservado para el arranque en su disco duro. Estas instrucciones son típicamente un cargador de arranque que carga  su núcleo. Después de que se ha cargado el núcleo, éste se ocupa de todos los demás procesos. 

Para obtener más información acerca del núcleo o de su configuración, puede que quiera leer el [http://www.tldp.org/HOWTO/Kernel-HOWTO.html CÓMO del núcleo]. 

=== Configurar el núcleo maestro ===

El núcleo maestro puede ser tan grande y personalizado como se desee, sin embargo, existen algunas opciones requeridas que se necesitan seleccionar. Teclee la siguiente orden para ir al menú de configuración del núcleo: 

{{RootCmd|cd /usr/src/linux |make menuconfig}}

Debe aparecer una pantalla azul y gris que ofrece una alternativa segura para editar manualmente el fichero {{Path|/usr/src/linux/.config}}. Si el núcleo actual funciona correctamente, es recomendable que guarde el fichero de configuración, para ello puede salir de la interfaz gráfica y teclear: 

{{RootCmd|cp .config .config_working}}

Entre en los siguientes submenús y asegúrese de que las opciones listadas se construyen como integradas en el núcleo (built-in) (y "NO" como módulos). Las opciones mostradas abajo se han tomado de la versión 2.6.10 del núcleo. Si utiliza una versión distinta, el texto o la secuencia podrían diferir. Simplemente asegúrese de que selecciona al menos las opciones mostradas a continuación. 

{{Kernel|Opciones para el núcleo maestro|<pre>
Code maturity level options --->
 [*] Prompt for development and/or incomplete code/drivers

Device Drivers --->
 Networking options --->
  <*> Packet socket
  <*> Unix domain sockets
  [*] TCP/IP networking
  [*] IP: multicasting
  [ ] Network packet filtering (replaces ipchains)

File systems --->
 Network File Systems --->
  <*> NFS server support
  [*] Provide NFSv3 server support
</pre>
}}

Si quiere acceder a Internet a través de su nodo maestro o tener un cortafuegos seguro, añade el soporte para iptables.

{{Kernel|Habilitar el soporte para iptables|<pre>
 [*] Network packet filtering (replaces ipchains)
 IP: Netfilter Configuration --->
  <*> Connection tracking (required for masq/NAT)
  <*> IP tables support (required for filtering/masq/NAT)
</pre>
}}

Si quiere activar el filtrado de paquetes, puede añadir el resto como módulos más tarde. Asegúrese de leer el [http://www.gentoo.org/doc/es/security/security-handbook.xml?part=1&chap=12 Manual de seguridad Gentoo Capítulo 12 acerca de los Cortafuegos] para saber cómo configurarlo de manera adecuada. 

{{Note|Se deben añadir estas opciones de configuración del núcleo a las opciones de configuración específicas para su sistema, no están
diseñadas para reemplazar completamente la configuración de su núcleo.}}

Después de haber reconfigurado el núcleo maestro, debe reconstruirlo: 

{{RootCmd|make && make modules_install |cp arch/i386/boot/bzImage /boot/bzImage-master}}

A continuación añada una opción para el nuevo núcleo nuevo en {{Path|lilo.conf}} o {{Path|grub.conf}} dependiendo del cargador de arranque que utilice, y asegúrese de que el nuevo núcleo es la opción predeterminada. Ahora que la nueva bzImage se ha copiado al directorio de arranque, todo lo que necesita hacer para cargar estas nuevas opciones es reiniciar el sistema. 

=== Acerca del núcleo esclavo ===

Recomendamos que compile su núcleo esclavo sin módulos, ya que cargar y configurarlos en un arranque por red es un proceso dificultoso e
innecesario. Además, el núcleo esclavo debe ser tan simple y compacto como sea posible, para hacer el arranque a través de la red eficiente. Vamos a compilar el núcleo esclavo en el mismo lugar donde
configuramos el núcleo maestro. 

Para evitar cualquier confusión y desperdicio de tiempo es una buena idea hacer una copia de seguridad del fichero de configuración del
núcleo maestro tecleando: 

{{RootCmd|cp /usr/src/linux/.config /usr/src/linux/.config_master}}

Ahora configuraremos el núcleo esclavo de la misma forma que lo hicimos con el núcleo maestro. Si va empezar con un fichero de configuración nuevo, recuerde que puede recuperar el archivo por defecto
{{Path|/usr/src/linux/.config}}f tecleando: 

{{RootCmd|cd /usr/src/linux |cp .config_master .config}}

Ahora entremos a la interfaz visual de configuración tecleando: 

{{RootCmd|cd /usr/src/linux |make menuconfig}}

Debe asegurarse de seleccionar las siguientes opciones como integradas (built-in) y "NO" como módulos del núcleo: 

{{Kernel|slave's kernel options|<pre>
Code maturity level options --->
 [*] Prompt for development and/or incomplete code/drivers

Device Drivers --->
 [*] Networking support
 Networking options --->
   <*> Packet socket
   <*> Unix domain sockets
   [*] TCP/IP networking
   [*] IP: multicasting
   [*] IP: kernel level autoconfiguration
   [*] IP: DHCP support (NEW)

File systems --->
 Network File Systems --->
 <*> file system support
 [*] Provide NFSv3 client support
 [*] Root file system on NFS
</pre>
}}

{{Note|Una alternativa al servidor dhcp es configurar un servidor BOOTP.}}

{{Important|Es importante que añada su adaptador de red dentro del núcleo (y no como módulo) en los nodos. Sin embargo, utilizarlo como módulo generalmente no es un problema para nodos sin disco.}}

Ahora necesitará compilar el núcleo esclavo. Tiene que ser cuidadoso en este paso ya que seguro que no quiere estropear los módulos (si es que hay alguno) que compiló para su  núcleo maestro: 

{{RootCmd|cd /usr/src/linux |make}}

Ahora cree el directorio en el maestro que se utilizará para almacenar los ficheros del esclavo además de sus ficheros de sistema. Nosotros
utilizamos un directorio {{Path|/diskless}} pero puede elegir la ubicación que prefiera. Ahora, copie la bzImage de su esclavo dentro de {{Path|/diskless}}: 


{{Note|Si está utilizando distintas arquitecturas tal vez prefiera guardar cada configuración dentro de {{Path|.config_arch}}. Haga lo mismo con las imágenes: guárdelas dentro de {{Path|/diskless}}
como {{Path|bzImage_arch}}.}}


{{RootCmd|mkdir /diskless |cp /usr/src/linux/arch/i386/boot/bzImage /diskless}}

=== Configurar un sistema de ficheros esclavo preliminar ===

Se pueden ajustar los sistemas de ficheros maestro y esclavo y cambiar bastante, pero por ahora solo nos interesa tener sistemas de ficheros preliminares con los ficheros de configuración apropiados y los puntos de montaje necesarios. Primero, necesitamos crear un directorio dentro de {{Path|/diskless}} para el primer esclavo. Cada esclavo necesita su propio sistema de ficheros raíz porque compartir ciertos ficheros del sistema causará problemas con
los permisos y caídas del sistema. Les puede poner a estos directorios los nombres que desee pero le sugerimos que utilice las direcciones IP de los esclavos, ya que estas son únicas y no confunden. La dirección IP estática de su primer esclavo sería, por
ejemplo, <code>192.168.1.21</code>: 

{{RootCmd|mkdir /diskless/192.168.1.21}}

Various configuration files in {{Path|/etc}} need to be altered to work on the slave. Copy the master's {{Path|/etc}} directory onto your new slave root by typing: 

{{RootCmd|cp -r /etc /diskless/192.168.1.21/etc}}

Still this filesystem isn't ready because it needs various mount points and directories. To create them, type: 

{{RootCmd|mkdir /diskless/192.168.1.21/home
|mkdir /diskless/192.168.1.21/dev
|mkdir /diskless/192.168.1.21/proc
|mkdir /diskless/192.168.1.21/tmp
|mkdir /diskless/192.168.1.21/mnt
|chmod a+w /diskless/192.168.1.21/tmp
|mkdir /diskless/192.168.1.21/mnt/.initd
|mkdir /diskless/192.168.1.21/root}}

{{RootCmd|mkdir /diskless/192.168.1.21/sys
|mkdir /diskless/192.168.1.21/var
|mkdir /diskless/192.168.1.21/var/empty
|mkdir /diskless/192.168.1.21/var/lock
|mkdir /diskless/192.168.1.21/var/log
|mkdir /diskless/192.168.1.21/var/run
|mkdir /diskless/192.168.1.21/var/spool
|mkdir /diskless/192.168.1.21/usr
|mkdir /diskless/192.168.1.21/opt
}}

Most of these "stubs" should be recognizable to you; stubs like {{Path|/dev}} , {{Path|/proc}} or {{Path|/sys}} will be populated when the slave starts, the others will be mounted later. You should also change the {{Path|/diskless/192.168.1.21/etc/conf.d/hostname}} file to reflect the hostname of the slave. Binaries, libraries and other files will be populated later in this HOWTO right before you attempt to boot the slave. 

Even though {{Path|/dev}} is populated by <code>udev</code> later on, you need to create the {{Path|console}} entry. If not, you will receive the error "unable to open initial console". 

{{RootCmd|mknod /diskless/192.168.1.21/dev/console c 5 1}}

== Configuring the DHCP server ==

=== About the DHCP server ===

DHCP stands for Dynamic Host Configuration Protocol. The DHCP server is the first computer the slaves will communicate with when they PXE boot. The primary purpose of the DHCP server is to assign IP addresses. The DHCP server can assign IP addresses based on hosts ethernet MAC addresses. Once the slave has an IP address, the DHCP server will tell the slave where to get its initial file system and kernel. 

=== Before you get started ===

There are several things you will want to make sure are working before you begin. First check your network connectivity: 

{{RootCmd|ifconfig eth0 multicast
|ifconfig -a}}

You will want to make sure you have have an ''eth0'' device running. It should look something like this: 

{{Code|A properly working eth0 device|<pre>
eth0      Link encap:Ethernet  HWaddr 00:E0:83:16:2F:D6
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:26460491 errors:0 dropped:0 overruns:2 frame:0
          TX packets:32903198 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:100
          RX bytes:2483502568 (2368.4 Mb)  TX bytes:1411984950 (1346.5 Mb)
          Interrupt:18 Base address:0x1800
</pre>
}}

It's important that it says ''MULTICAST'' , if it doesn't then you will have to recompile your kernel to include multicast support. 

=== Installing the DHCP server ===

If your network does not already have a DHCP server installed you will need to install one: 

{{Emerge|dhcp}}

If your network already has a DHCP server installed you will have to edit the configuration file to get the PXE boot to function correctly. 

=== Configuring the DHCP server ===

There is only one configuration file you will have to edit before starting the DHCP server: {{Path|/etc/dhcp/dhcpd.conf}} . Copy and edit the provided sample file: 

{{RootCmd|cp /etc/dhcp/dhcpd.conf.sample /etc/dhcp/dhcpd.conf
|nano -w /etc/dhcp/dhcpd.conf}}

The general layout of the file is set up in an indented fashion and looks like this: 

{{Code|Sample dhcpd.conf layout|<pre>
# global options here
ddns-update-style none;
shared-network LOCAL-NET {
  # shared network options here
  subnet 192.168.1.0 netmask 255.255.255.0 {
    # subnet network options here
    host slave{
        # host specific options here
    }
    group {
        # group specific options here
    }
  }
}
</pre>
}}

The <code>shared-network</code> block is optional and should be used for IPs you want to assign that belong to the same network topology. At least one <code>subnet</code> must be declared and the optional <code>group</code> block allows you to group options between items. A good example of {{Path|dhcpd.conf}} looks like this: 

{{Code|Sample dhcpd.conf|<pre>
#
# Sample dhcpd.conf for diskless clients
#
  
# Disable dynamic DNS
ddns-update-style none;
  
# Assume one default gateway for IP traffic will do
option routers 192.168.1.1;
  
# Provide DNS info to clients
option domain-name-servers 192.168.1.1;
option domain-name "mydomain.com";
  
# Specify the TFTP server to be used
next-server 192.168.1.1;
  
# Declare a vendor-specific option buffer for PXE clients:
# Code 1: Multicast IP address of boot file server
# Code 2: UDP port that client should monitor for MTFTP responses
# Code 3: UDP port that MTFTP servers are using to listen for MTFTP requests
# Code 4: Number of seconds a client must listen for activity before trying
#         to start a new MTFTP transfer
# Code 5: Number of seconds a client must listen before trying to restart
#         a MTFTP transfer
  
option space PXE;
option PXE.mtftp-ip               code 1 = ip-address;
option PXE.mtftp-cport            code 2 = unsigned integer 16;
option PXE.mtftp-sport            code 3 = unsigned integer 16;
option PXE.mtftp-tmout            code 4 = unsigned integer 8;
option PXE.mtftp-delay            code 5 = unsigned integer 8;
option PXE.discovery-control      code 6 = unsigned integer 8;
option PXE.discovery-mcast-addr   code 7 = ip-address;
  
# Declare the subnet where our diskless nodes will live
subnet 192.168.1.0 netmask 255.255.255.0 {
  
  # Provide PXE clients with appropriate information
  class "pxeclient" {
    match if substring(option vendor-class-identifier, 0, 9) = "PXEClient";
    vendor-option-space PXE;
  
    # At least one of the vendor-specific PXE options must be set in
    # order for the client boot ROMs to realize that we are a PXE-compliant
    # server.  We set the MCAST IP address to 0.0.0.0 to tell the boot ROM
    # that we can't provide multicast TFTP.
  
    option PXE.mtftp-ip 0.0.0.0;
  
    # This is the name of the file the boot ROMs should download.
    filename "pxelinux.0";
  }
  
  # Provide Etherboot clients with appropriate information
  class "etherboot" {
    match if substring(option vendor-class-identifier, 0, 9) = "Etherboot";
    filename "vmlinuz_arch";
  }
  
  # Add one host declaration for each diskless host
  host slave21 {
    hardware ethernet 00:02:A5:04:3B:66;
    fixed-address 192.168.1.21;
  }
}
</pre>
}}

{{Note|There is nothing prohibiting the use of both PXE boot and Etherboot together. The above Code Listing is merely an example; if you have issues, please consult the DHCPd documentation.}}

The IP address after <code>next-server</code> will be asked for the specified <code>filename</code> . This IP address should be the IP of the tftp server, usually the same as the master's IP address. The <code>filename</code> is relative to the {{Path|/diskless}} directory (this is due to the tftp server specific options which will be covered later). Inside the <code>host</code> block, the <code>hardware ethernet</code> option specifies a MAC address, and <code>fixed-address</code> assigns a fixed IP address to that particular MAC address. There is a pretty good man page on {{Path|dhcpd.conf}} with options that are beyond the scope of this HOWTO. You can read it by typing: 

{{Cmd|man dhcpd.conf}}

=== Starting the DHCP server ===

Before you start the dhcp initialization script edit the {{Path|/etc/conf.d/dhcp}} file so that it looks something like this: 

{{Code|Sample /etc/conf.d/dhcp|<pre>
IFACE="eth0"
# Insert any customizations needed
</pre>
}}

The <code>IFACE</code> variable is the device you wish to run your DHCP server on, in our case <code>eth0</code> . Adding more arguments to the <code>IFACE</code> variable can be useful for a complex network topology with multiple Ethernet cards. To start the dhcp server type: 

{{RootCmd|/etc/init.d/dhcp start}}

To add the dhcp server to your start-up scripts type: 

{{RootCmd|rc-update add dhcp default}}

=== Troubleshooting the DHCP server ===

To see if a node boots you can take a look at {{Path|/var/log/messages}} . If the node successfully boots, the {{Path|messages}} file should have some lines at the bottom looking like this: 

{{Code|Sample log file entries created by dhcp|<pre>
DHCPDISCOVER from 00:00:00:00:00:00 via eth0
DHCPOFFER on 192.168.1.21 to 00:00:00:00:00:00 via eth0
DHCPREQUEST for 192.168.1.21 from 00:00:00:00:00:00 via eth0
DHCPACK on 192.168.1.21 to 00:00:00:00:00:00 via eth0
</pre>
}}

{{Note|This log file can also help you discover the slaves' MAC addresses.}}

If you get the following message it probably means there is something wrong in the configuration file but that the DHCP server is broadcasting correctly. 

{{Code|Sample dhpc server error|<pre>
no free leases on subnet LOCAL-NET
</pre>
}}

Every time you change the configuration file you must restart the DHCP server. To restart the server type: 

{{RootCmd|/etc/init.d/dhcpd restart}}

== Configuring the TFTP server and PXE Linux Bootloader and/or Etherboot ==

=== About the TFTP server ===

TFTP stands for Trivial File Transfer Protocol. The TFTP server is going to supply the slaves with a kernel and an initial filesystem. All of the slave kernels and filesystems will be stored on the TFTP server, so it's probably a good idea to make the master the TFTP server. 

=== Installing the TFTP server ===

A highly recommended tftp server is available as the tftp-hpa package. This tftp server happens to be written by the author of SYSLINUX and it works very well with pxelinux. To install simply type: 

{{Emerge|tftp-hpa}}

=== Configuring the TFTP server ===

Edit {{Path|/etc/conf.d/in.tftpd}} . You need to specify the tftproot directory with <code>INTFTPD_PATH</code> and any command line options with <code>INTFTPD_OPTS</code> . It should look something like this: 

{{Code|Sample /etc/conf.d/in.tftpd|<pre>
INTFTPD_PATH="/diskless"
INTFTPD_OPTS="-l -v -s ${INTFTPD_PATH}"
</pre>
}}

The <code>-l</code> option indicates that this server listens in stand alone mode so you don't have to run inetd. The <code>-v</code> indicates that log/error messages should be verbose. The <code>-s /diskless</code> specifies the root of your tftp server. 

=== Starting the  TFTP Server ===

To start the tftp server type: 

{{RootCmd|/etc/init.d/in.tftpd start}}

This should start the tftp server with the options you specified in the {{Path|/etc/conf.d/in.tftpd}} . If you want this server to be automatically started at boot type: 

{{RootCmd|rc-update add in.tftpd default}}

=== About PXELINUX ===

This section is not required if you are only using Etherboot. PXELINUX is the network bootloader equivalent to LILO or GRUB and will be served via TFTP. It is essentially a tiny set of instructions that tells the client where to locate its kernel and initial filesystem and allows for various kernel options. 

=== Before you get started ===

You will need to get the pxelinux.0 file which comes in the SYSLINUX package by H. Peter Anvin. You can install this package by typing: 

{{Emerge|syslinux}}

=== Setting up PXELINUX ===

{{Note|This isn't needed for Etherboot}}

Before you start your tftp server you need to setup pxelinux. First copy the pxelinux binary into your {{Path|/diskless}} directory: 

{{RootCmd|cp /usr/share/syslinux/pxelinux.0 /diskless
|mkdir /diskless/pxelinux.cfg
|touch /diskless/pxelinux.cfg/default}}

This will create a default bootloader configuration file. The binary {{Path|pxelinux.0}} will look in the {{Path|pxelinux.cfg}} directory for a file whose name is the client's IP address in hexadecimal. If it does not find that file it will remove the rightmost digit from the file name and try again until it runs out of digits. Versions 2.05 and later of syslinux first perform a search for a file named after the MAC address. If no file is found, it starts the previously mentioned discovery routine. If none is found, the {{Path|default}} file is used. 

{{Code|Files that PXE looks for in pxelinux.cfg/ in sequence|<pre>
## (Leading 01 means Ethernet, next bytes match our slave's MAC address)
01-00-40-63-c2-ca-c9
  
## (Assigned IP in hexadecimal)
C0A80115
C0A8011
C0A801
C0A80
C0A8
C0A
C0
C
  
default
</pre>
}}

{{Note|These are all in lowercase.}}

Let's start with the {{Path|default}} file: 

{{Code|Sample pxelinux.cfg/default|<pre>
DEFAULT /bzImage
APPEND ip=dhcp root=/dev/nfs nfsroot=192.168.1.1:/diskless/192.168.1.21
</pre>
}}

The <code>DEFAULT</code> tag directs pxelinux to the kernel bzImage that we compiled earlier. The <code>APPEND</code> tag appends kernel initialisation options. Since we compiled the slave kernel with <code>NFS_ROOT_SUPPORT</code> , we will specify the nfsroot here. The first IP is the master's IP and the second IP is the directory that was created in {{Path|/diskless}} to store the slave's initial filesystem. 

=== About Etherboot ===

{{Note|This isn't required if you are using PXE boot.}}

Etherboot boots network boot images from a TFTP server. As the PXE this is equivalent to LILO or GRUB. The <code>mknbi</code> utility enables you to create different images using different options. 

=== Before you get started ===

You will need to get the <code>mknbi</code> (utility for making tagged kernel images useful for netbooting) package to create your Etherboot images. This tool will create a preconfigured kernel image from your original kernel. This contains the boot options as shown further down. 

{{Emerge|mknbi}}

=== Setting up Etherboot ===

In this section we will create a simple etherboot image. As the dhcp server gives out the clients root-path in the "option root-path" dhcp.conf, we do not have to include this here. More details can be found in the mknbi manual. 

{{Cmd|man mknbi}}

Making the boot images. This will create a ELF bootable image capable of passing dhcp and the rootpath to the kernel. Also forcing the kernel to browse the network for a dhcp server. 

{{RootCmd|mkelf-linux -ip{{=}}dhcp /diskless/bzImage > /diskless/vmlinuz }}

{{Note|For the arch specific images you have to type <code>bzImage_arch</code> and <code>vmlinuz_arch</code> .}}

=== Troubleshooting the network boot process ===

There are a few things you can do to debug the network boot process. Primarily you can use a tool called <code>tcpdump</code> . To install <code>tcpdump</code> type: 

{{Emerge|tcpdump}}

Now you can listen to various network traffic and make sure your client/server interactions are functioning. If something isn't working there are a few things you might want to check. First make sure that the client/server is physically connected properly and that the networking cables are not damaged. If your client/server is not receiving requests on a particular port make sure that there is no firewall interference. To listen to interaction between two computers type: 

{{RootCmd|tcpdump host client_ip and server_ip}}

You can also use <code>tcpdump</code> to listen on particular port such as the tftp port by typing: 

{{RootCmd|tcpdump port 69}}

A common error you might receive is: "PXE-E32: TFTP open time-out". This is probably due to firewall issues. If you are using <code>TCPwrappers</code> , you might want to check {{Path|/etc/hosts.allow}} and {{Path|etc/hosts.deny}} and make sure that they are configured properly. The client should be allowed to connect to the server. 

== Configuring the NFS server ==

=== About the NFS server ===

NFS stands for Network File System. The NFS server will be used to serve directories to the slave. This part can be somewhat personalized later, but right now all we want is a preliminary slave node to boot diskless. 

=== About Portmapper ===

Various client/server services do not listen on a particular port, but instead rely on RPCs (Remote Procedure Calls). When the service is initialised it listens on a random port and then registers this port with the Portmapper utility. NFS relies on RPCs and thus requires Portmapper to be running before it is started. 

=== Before you start ===

The NFS Server needs kernel level support so if you don't have this you should recompile your master's kernel. To double check your master's kernel configuration type: 

{{RootCmd|grep NFS /usr/src/linux/.config_master}}

You should see output that looks something like this if your kernel has been properly configured: 

{{Kernel|Proper NFS specific options in the master's kernel configuration|<pre>
CONFIG_PACKET=y
# CONFIG_PACKET_MMAP is not set
# CONFIG_NETFILTER is not set
CONFIG_NFS_FS=y
CONFIG_NFS_V3=y
# CONFIG_NFS_V4 is not set
# CONFIG_NFS_DIRECTIO is not set
CONFIG_NFSD=y
CONFIG_NFSD_V3=y
# CONFIG_NFSD_V4 is not set
# CONFIG_NFSD_TCP is not set
</pre>
}}

=== Installing the NFS server ===

The NFS package that can be acquired through portage by typing: 

{{Emerge|nfs-utils}}

This package will emerge a portmapping utility, nfs server, and nfs client utilities and will automatically handle initialisation dependencies. 

=== Configuring the NFS server ===

There are three major configuration files you will have to edit: 

{{Code|Nfs configuration files|<pre>
/etc/exports
/diskless/192.168.1.21/etc/fstab
/etc/conf.d/nfs
</pre>
}}

The {{Path|/etc/exports}} file specifies how, to who and what to export through NFS. The slave's fstab will be altered so that it can mount the NFS filesystems that the master is exporting. 

A typical {{Path|/etc/exports}} for the master should look something like this: 

{{Code|Sample master /etc/exports|<pre>
# one line like this for each slave
/diskless/192.168.1.21   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
# common to all slaves
/opt   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/usr   192.168.1.0/24(sync,ro,no_root_squash,no_all_squash)
/home  192.168.1.0/24(sync,rw,no_root_squash,no_all_squash)
# if you want to have a shared log
/var/log   192.168.1.21(sync,rw,no_root_squash,no_all_squash)
</pre>
}}

The first field indicates the directory to be exported and the next field indicates to who and how. This field can be divided in two parts: who should be allowed to mount that particular directory, and what the mounting client can do to the filesystem: <code>ro</code> for read only, <code>rw</code> for read/write; <code>no_root_squash</code> and <code>no_all_squash</code> are important for diskless clients that are writing to the disk, so that they don't get "squashed" when making I/O requests. The slave's fstab file, {{Path|/diskless/192.168.1.21/etc/fstab}} , should look like this: 

{{Code|Sample slave fstab|<pre>
# these entries are essential
master:/diskless/192.168.1.21   /         nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
master:/opt                     /opt      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/usr                     /usr      nfs     sync,hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/home                    /home     nfs     sync,hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
none                            /proc     proc    defaults                                     0 0
# useful but superfluous
master:/var/log                 /var/log  nfs     hard,intr,rw                                 0 0
</pre>
}}

In this example, ''master'' is just the hostname of the master but it could easily be the IP of the master. The first field indicates the directory to be mounted and the second field indicates where. The third field describes the filesystem and should be NFS for any NFS mounted directory. The fourth field indicates various options that will be used in the mounting process (see mount(1) for info on mount options). Some people have had difficulties with soft mount points so we made them all hard, but you should look into various {{Path|/etc/fstab}} options to make your cluster more efficient. 

The last file you should edit is {{Path|/etc/conf.d/nfs}} which describes a few options for nfs when it is initialised and looks like this: 

{{Code|Sample master /etc/conf.d/nfs|<pre>
# Config file for /etc/init.d/nfs
  
# Number of servers to be started up by default
RPCNFSDCOUNT=8
  
# Options to pass to rpc.mountd
RPCMOUNTDOPTS=""
</pre>
}}

You should change <code>RPCNFSDCOUNT</code> to the number of diskless nodes on the network. 

=== Starting the NFS server ===

You should start the nfs server with its init script located in {{Path|/etc/init.d}} by typing: 

{{RootCmd|/etc/init.d/nfs start}}

If you want to this script to start when the system boots simply type: 

{{RootCmd|rc-update add nfs default}}

== Completing the slave filesystem ==

=== Copy the missing files ===

We will now make the slave's file system in sync with the master's and provide the necessary binaries while still preserving slave specific files. 

{{RootCmd|rsync -avz /bin /diskless/192.168.1.21
|rsync -avz /sbin /diskless/192.168.1.21
|rsync -avz /lib /diskless/192.168.1.21
}}

{{Note|The reason for rsync -avz instead of cp is to maintain symlinks and permissions.}}

=== Configure diskless networking ===

In order to prevent the networking initscript from killing the connection to your NFS server, you will need to add an option to {{Path|/etc/conf.d/net}} on your diskless client's filesystem. 

{{Code|Editing /etc/conf.d/net|<pre>
config_eth0=( "noop" )
</pre>
}}

{{Note|For more information, please read {{Path|/usr/share/doc/openrc-*/net.example.bz2}} .}}

=== Initialisation scripts ===

You need as many init scripts under {{Path|/diskless/192.168.1.21/etc/runlevels}} as you need services on your diskless nodes. It all depends on what you want your slaves to do. 

{{Warning|Do not use the <code>rc-update</code> program to add or remove scripts from the slave runlevels when logged on your master. This would change your master runlevels. You need to create the links manually or log into your slave nodes using ssh or connect a screen and keyboard to your slave.}}

{{Code|Typical slave runlevels|<pre>
/diskless/192.168.1.21/etc/runlevels/:
total 16
drwxr-xr-x    2 root     root         4096 2003-11-09 15:27 boot
drwxr-xr-x    2 root     root         4096 2003-10-01 21:10 default
drwxr-xr-x    2 root     root         4096 2003-03-13 19:05 nonetwork
drwxr-xr-x    2 root     root         4096 2003-02-23 12:26 single
  
/diskless/192.168.1.21/etc/runlevels/boot:
total 0
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 bootmisc -> /etc/init.d/bootmisc
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 checkfs -> /etc/init.d/checkfs
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 domainname -> /etc/init.d/domainname
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 hostname -> /etc/init.d/hostname
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 localmount -> /etc/init.d/localmount
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 modules -> /etc/init.d/modules
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 net.lo -> /etc/init.d/net.lo
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 netmount -> /etc/init.d/netmount
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 rmnologin -> /etc/init.d/rmnologin
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 urandom -> /etc/init.d/urandom
  
/diskless/192.168.1.21/etc/runlevels/default:
total 0
lrwxrwxrwx    1 root     root           23 2003-10-18 17:28 consolefont -> /etc/init.d/consolefont
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 distccd -> /etc/init.d/distccd
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 keymaps -> /etc/init.d/keymaps
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 sshd -> /etc/init.d/sshd
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 syslog-ng -> /etc/init.d/syslog-ng
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 vixie-cron -> /etc/init.d/vixie-cron
  
/diskless/192.168.1.21/etc/runlevels/nonetwork:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
  
/diskless/192.168.1.21/etc/runlevels/single:
total 0
</pre>
}}

Now is a good time to boot your slave and cross your fingers. It works? Congratulations, you are now the proud owner of (a) diskless node(s) :) 

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:


* Michael Andrews
* Kristian Jerpetjoen
* Sven Vermeulen
* Xavier Neys
