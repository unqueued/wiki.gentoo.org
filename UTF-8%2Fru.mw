<languages />

{{InfoBox stack
|{{InfoBox wikipedia|header=true}}
}}

{{Metadata|abstract=UTF-8 is a variable-length character encoding, which in this instance means that it uses 1 to 4 bytes per symbol. So, the first UTF-8 byte is used for encoding ASCII, giving the character set full backwards compatibility with ASCII. UTF-8 means that ASCII and Latin characters are interchangeable with little increase in the size of the data, because only the first byte is used. Users of Eastern alphabets such as Japanese, who have been assigned a higher byte range are unhappy, as this results in as much as a 50% redundancy in their data.}}

UTF-8 — это кодировка символов переменной длины, что, в данном случае, означает длину от 1 до 4 байт на символ. Первый байт UTF-8 используется для кодирования ASCII, что означает, что данный набор символов полностью обратно совместим с ASCII. UTF-8 означает, что символы ASCII и Latin полностью взаимозаменяемы с небольшим увеличением размера данных, так как используется только первый байт. Пользователи восточных алфавитов, например, японского, которым назначили диапазон с большим числом байт несчастливы, так как это приводит к 50%-й избыточности в их данных. 

== Кодировки символов ==

=== Что такое кодировка символов? ===

Computers themselves do not understand printed text as a human would. For computers, every character of text is represented by a number. Traditionally, each set of numbers used to represent alphabets and characters (known as a coding system, encoding, or character set) was limited in size due to limitations in computer hardware. 

=== The history of character encodings ===

The most common (or at least the most widely accepted) character set is '''ASCII''' (American Standard Code for Information Interchange). It is widely held that ASCII is the most successful software standard ever created. Modern ASCII was standardized in 1986 (ANSI X3.4, RFC 20, ISO/IEC 646:1991, ECMA-6) by the American National Standards Institute. 

ASCII является строго семибитной кодировкой, из чего следует, что она использует семь двоичных цифр, то есть интервал от 0 до 127. ASCII начинается с 32 невидимых управляющих символов (с кодами от 0 до 31) и заканчивается управляющим символом DEL (или delete) с кодом 127. Символы в диапазоне от 32 до 126 видимы &mdash; это пробел, знаки препинания, латинские буквы и цифры. 

The eighth bit in ASCII was originally used as a parity bit for error checking. If error checking is not desired, it is left as 0. This means that, with ASCII, each character is represented by a single byte. 

Although ASCII was enough for communication in modern English, in other European languages that include accented characters, things were not so easy. The ISO 8859 standards were developed to meet these needs. They were backwards compatible with ASCII, but instead of leaving the eighth bit blank, they used it to allow another 127 characters in each encoding. ISO 8859's limitations soon came to light, and there are currently 15 variants of the ISO 8859 standard (8859-1 through to 8859-15). Outside of the ASCII-compatible byte range of these character sets, there is often conflict between the letters represented by each byte. To complicate interoperability between character encodings further, Windows-1252 is used in some versions of Microsoft Windows instead for Western European languages. This is a super-set of ISO 8859-1, however it is different in several ways; these sets do all retain ASCII compatibility. 

The necessary development of completely different single-byte encodings for non-Latin alphabets, such as EUC (Extended Unix Coding) which is used for Japanese and Korean (and to a lesser extent Chinese) created more confusion. Other operating systems still used different character sets for the same languages, for example, Shift-JIS and ISO-2022-JP. Users wishing to view cyrillic glyphs had to choose between KOI8-R for Russian and Bulgarian or KOI8-U for Ukrainian, as well as all the other cyrillic encodings such as the unsuccessful ISO 8859-5, and the common Windows-1251 set. All of these character sets broke most compatibility with ASCII. Although it should be mentioned KOI8 encodings place cyrillic characters in Latin order, so in case the eighth bit is stripped, text is still decipherable on an ASCII terminal through case-reversed transliteration. 

All of this has led to mass confusion, and to an almost total inability for multilingual communication; especially across different alphabets. Enter Unicode. 

=== Что такое Юникод? ===

Unicode throws away the traditional single-byte limit of character sets. It uses 17 "planes" of 65,536 code points to describe a maximum of 1,114,112 characters. As the first plane, aka. "Basic Multilingual Plane" or BMP, contains almost everything character a user will ever need. Many have made the wrong assumption that Unicode was a 16-bit character set. 

Unicode has been mapped in many different ways, but the two most common are '''UTF''' (Unicode Transformation Format) and '''UCS''' (Universal Character Set). A number after UTF indicates the number of bits in one unit, while the number after UCS indicates the number of bytes. UTF-8 has become the most widespread means for the interchange of Unicode text as a result of its eight-bit clean nature; it is therefore the subject of this document. 

=== What UTF-8 can do ===

UTF-8 allows users to work in a standards-compliant and internationally accepted multilingual environment, with a comparatively low data redundancy. It is the preferred way for transmitting non-ASCII characters over the Internet, through Email, IRC, or almost any other medium. Despite this, many people regard UTF-8 in online communication as abusive. It is always best to be aware of the attitude towards UTF-8 in a specific channel, mailing list, or Usenet group before using ''non-ASCII'' UTF-8. 

== Включение UTF-8 в Gentoo Linux ==

=== Finding or creating UTF-8 locales ===

Now that the principles behind Unicode have been laid out, get ready to start using UTF-8 locally!

The preliminary requirement for UTF-8 is to have a version of glibc installed that has national language support. The recommend means to do this is the {{Path|/etc/locale.gen}} file. It is beyond the scope of this document to explain the usage of this file. For users interested in more knowledge further explanation can be found in the [[Localization/HOWTO|Gentoo Localization Guide]]. 

Next, the user needs to decide whether a UTF-8 locale is available for the language of choice, or whether one needs to be generated.

{{Cmd|locale -a {{!}} grep 'ru_RU'|output=<pre>
ru_RU
ru_RU.UTF-8
</pre>
}}

From the output of the above command, look for a result with a suffix similar to <code>.UTF-8</code>. If there is no result with a similar suffix a UTF-8 compatible locale must be created. 

{{Note|Only execute the following code if the system does not have a UTF-8 locale available for the language of choice.}}

Replace "en_GB" with the desired locale setting:
{{RootCmd|localedef -i en_GB -f UTF-8 en_GB.UTF-8}}

Another way to include a UTF-8 locale is to add it to the {{Path|/etc/locale.gen}} file and generate necessary locales using the <tt>locale-gen</tt> command. 

{{CodeBox|title=Line in /etc/locale.gen|1=
en_GB.UTF-8 UTF-8
}}

=== Setting the locale ===

There is one environment variable that needs to be set in order to use the new UTF-8 locales: <code>LC_CTYPE</code> (optionally modify the <code>LANG</code> variable to change the system language as well). There are also many different ways to set it; some system administrators prefer to only have a UTF-8 environment for a specific user, in which case they set them in their {{Path|~/.profile}} (<tt>/bin/sh</tt> for Bourne shell users), {{Path|~/.bash_profile}} or {{Path|~/.bashrc}} (<tt>/bin/bash</tt> for Bourne again shell users). More details and best practices can be found in the [[Localization/HOWTO|Localization Guide]]. 

Still others prefer to set the locale globally. One specific circumstance where the author particularly recommends doing this is when {{Path|/etc/init.d/xdm}} is in use, because this init script starts the display manager and desktop before any of the aforementioned shell startup files are sourced. In other words, this is performed before any of the variables are loaded in the environment. 

Setting the locale globally should be done using {{Path|/etc/env.d/02locale}} file. This file should look something like the following: 

{{CodeBox|title=Demonstration /etc/env.d/02locale|lang=bash|1=
## (As always, change "en_GB.UTF-8" to your locale)
LANG="en_GB.UTF-8"
}}

{{Note|It is possible to substitute <code>LC_CTYPE</code> for <code>LANG</code>. For more information on the categories affected by using <code>LC_CTYPE</code> read the [http://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html#Locale-Categories GNU locale page].}}

Далее следует обновить среду. 

{{RootCmd|env-update|output=<pre>
>>> Regenerating /etc/ld.so.cache...
 * Caching service dependencies ...
</pre>}}
{{RootCmd|source /etc/profile}}

Now, run <tt>locale</tt> with no arguments to see if the correct variables have been loaded in the environment: 

{{RootCmd|locale|output=<pre>
LANG=ru_RU.UTF-8
LC_CTYPE="ru_RU.UTF-8"
LC_NUMERIC="ru_RU.UTF-8"
LC_TIME="ru_RU.UTF-8"
LC_COLLATE="ru_RU.UTF-8"
LC_MONETARY="ru_RU.UTF-8"
LC_MESSAGES="ru_RU.UTF-8"
LC_PAPER="ru_RU.UTF-8"
LC_NAME="ru_RU.UTF-8"
LC_ADDRESS="ru_RU.UTF-8"
LC_TELEPHONE="ru_RU.UTF-8"
LC_MEASUREMENT="ru_RU.UTF-8"
LC_IDENTIFICATION="ru_RU.UTF-8"
LC_ALL=
</pre>
}}

===Alternatively, using eselect to set locales ===
Although it is good to maintain the system as described above, it is possible to verify the correct locale configured using the <tt>eselect</tt> utility.

Use <tt>eselect</tt> to list the available locales on the system:

{{RootCmd|eselect locale list {{!}} grep en_GB |output=<pre>
[213] en_GB
[214] en_GB.iso88591
[215] en_GB.utf8 *
</pre>
}}

Using <tt>eselect</tt> setting the locale is as simple as listing them. Once the correct locale has been determined invoke:

{{RootCmd|eselect locale set en_GB.utf8 |output=<pre>
Setting LANG to en_GB.utf8 ...
</pre>
}}

Running the following command will update the variables in the shell:

{{RootCmd|env-update && source /etc/profile |output=<pre>
>>> Regenerating /etc/ld.so.cache...
</pre>
}}

That is everything. The system is now using UTF-8 locales. The next hurdle is the configuration of the applications used from day to day.

== Application support ==

When Unicode first started gaining momentum in the software world, multibyte character sets were not well suited to languages like C, which is the base language of most commonly used programs. Even today, some programs are not able to handle UTF-8 properly. Fortunately the majority of programs, especially the common ones, are supported. 

=== Имена файлов, NTFS и FAT ===

There are several NLS options in the Linux kernel configuration menu, but it is important to not become confused. For the most part, the only thing you need to do is to build UTF-8 NLS support into the kernel, and change the default NLS option to utf8. 

{{KernelBox|title=Kernel configuration steps for UTF-8 NLS|<pre>
File Systems -->
  Native Language Support -->
    (utf8) Default NLS Option
    <*> NLS UTF8
    ## (Also <*> other character sets that are in use in
    your FAT filesystems or Joilet CD-ROMs.)
</pre>
}}

When planning to mount NTFS partitions, users may need to specify a <code>nls=</code> option with mount. When planning on mounting FAT partitions, users may need to specify a <code>codepage=</code> option with mount. Optionally, users can also set a default codepage for FAT in the kernel configuration.

{{Note|Using the <code>codepage</code> option via the <tt>mount</tt> will override the settings used in the kernel.}}

{{KernelBox|title=FAT settings in kernel configuration|<pre>
File Systems -->
  DOS/FAT/NT Filesystems  -->
    (437) Default codepage for fat
</pre>
}}

Avoid setting <code>Default iocharset for fat</code> to UTF-8; it is not recommended. Instead, pass the <code>utf8=true</code> option when mounting FAT partitions. For further information <tt>man mount</tt> or see the appropriate kernel documentation at {{Path|/usr/src/linux/Documentation/filesystems/vfat.txt}}

Чтобы сменить кодировку имен файлов, используйте {{Package|app-text/convmv}}. 

{{Emerge|app-text/convmv}}

The format of the <tt>convmv</tt> command is as follows:

{{RootCmd|convmv -f <current-encoding> -t utf-8 <filename>}}

Substitute iso-8859-1 with the charset being converted from:

{{RootCmd|convmv -f koi8-r -t utf-8 имя_файла}}

For changing the ''contents'' of files, use the <tt>iconv</tt> utility, it comes bundled with {{Package|sys-libs/glibc}} and should be installed on all Gentoo systems. Substitute iso-8859-1 with the charset being converted from. After running the command be sure to check for sane output:

{{RootCmd|iconv -f koi8-r -t utf-8 имя_файла}}

To convert a file, another file must be created:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 filename > newfile}}

The recode ({{Package|app-text/recode}}) package can also be used for this purpose.

=== The system console ===

{{Important|The {{Package|sys-apps/baselayout}}-1.11.9 (or higher) package is needed for Unicode on the console.}}

To enable UTF-8 on the console edit {{Path|/etc/rc.conf}} Set <code>unicode="yes"</code> and read the comments -- it is important to have a font that has a good range of characters to make the most of Unicode. For this to work make sure the Unicode locale has been properly created. 

В файле {{Path|/etc/conf.d/keymaps}} переменной <code>KEYMAP</code> должна соответствовать раскладка Unicode. 

{{CodeBox|title=Example /etc/conf.d/keymaps snippet|lang=bash|1=
## (Change "uk" to your local layout)
keymap="uk"
}}

=== Ncurses и Slang ===

{{Note|Ignore any mention of Slang in this section if it is not installed or unneeded.}}

It is wise to add <code>unicode</code> to the global USE flags in {{Path|/etc/portage/make.conf}}, and then to re-emerge {{Package|sys-libs/ncurses}} and {{Package|sys-libs/slang}}. Portage will do this automatically if the <code>--changed-use</code> or <code>--newuse</code> options are used. Run the following command to pull in the packages: 

{{RootCmd|emerge --update --deep --newuse world}}

Также понадобится пересобрать пакеты, зависящие от них, раз изменения USE	вступили в силу. Используемая утилита (<code>revdep-rebuild</code>) входит в пакет {{Package|gentoolkit}}. 

{{RootCmd|revdep-rebuild --soname libncurses.so.5
|revdep-rebuild --soname libslang.so.1}}

=== KDE, GNOME и Xfce ===

Все основные графические оболочки полностью совместимы с Юникодом и не требуют дополнительной настройки, кроме той, что описана в этом документе. Все это	благодаря тому, графические библиотеки (Qt и GTK+2) совместимы с UTF-8. Следовательно, все приложения, работающие на основе этих библиотек, также должны поддерживать UTF-8 без дополнительных настроек. 

Исключением в этом правиле является Xlib и GTK+1. GTK+1 требует iso-10646-1 FontSpec в ~/.gtkrc, например <code>-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1</code>. Также приложения, использующие Xlib или Xaw, нуждаются в подобной FontSpec, иначе они не буду работать. 

{{Note/ru|Если у вас установлен центр управления gnome1, используйте его. Воспользуйтесь любым из шрифтов семейства iso10646-1.}}

{{CodeBox|title=Example ~/.gtkrc (for GTK+1) that defines a Unicode compatible font|1=
style "user-font"
{
    fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"
}
widget_class "*" style "user-font"
}}

Если приложение одинаково поддерживает Qt и GTK+2, то обычно GTK+2 GUI выдает лучшие результаты при работе с Юникодом. 

=== X11 and fonts ===

TrueType fonts have support for Unicode, and most of the fonts that ship with Xorg have impressive character support, although, obviously, not every single glyph available in Unicode has been created for that font. To build fonts (including the Bitstream Vera set) with support for East Asian letters with X, make sure you have the <code>cjk</code> USE flag set. Many other applications utilize this flag, so it may be worthwhile to add it as a permanent USE flag. 

Также несколько пакетов шрифтов в Portage совместимы с Юникодом. 

{{Emerge|terminus-font intlfonts freefonts corefonts}}

=== Window managers and terminal emulators ===

Диспетчеры окон, не использующие GTK или Qt, обычно очень хорошо поддерживают Юникод, так как чаще всего для отображения шрифтов используют библиотеку Xft. Если ваш диспетчер окон не использует Xft, то вы все еще можете использовать FontSpec, указанный в предыдущем разделе в качестве шрифта Юникода. 

Эмуляторы терминала, использующие Xft и поддерживающие Юникод найти сложнее. Кроме Konsole и gnome-terminal, лучшим выбором в Portage будет {{Package|x11-terms/rxvt-unicode}}, {{Package|x11-terms/xfce4-terminal}}, {{Package|gnustep-apps/terminal}}, {{Package|x11-terms/mlterm}} или просто {{Package|x11-terms/xterm}}, собранный с USE-флагом <code>unicode</code> и запускаемый как <code>uxterm</code>. {{Package|app-misc/screen}} тоже поддерживает UTF-8, если запускается с параметром <code>screen -U</code>, или в файле {{Path|~/.screenrc}} есть следующая строчка: 

{{CodeBox|title=~/.screenrc for UTF-8|1=
defutf8 on
}}

=== Vim, emacs, xemacs and nano ===

Vim полностью поддерживает UTF-8 и к тому же автоматически определяет файлы с UTF-8. Для более детальной информации используйте в Vim <code>:help mbyte.txt</code>. 

[[GNU Emacs]] с версии 23 и [[XEmacs]] версии 21.5 имеют полную поддержку UTF-8. GNU Emacs 24 также поддерживает редактирование текста в обоих направлениях. 

Nano полностью поддерживает UTF-8 начиная с версии 1.3.6.

=== Командные оболочки ===

Currently, <code>bash</code> provides full Unicode support through the GNU readline library. Z Shell (<tt>zsh</tt>) offers Unicode support with the <code>unicode</code> USE flag. 

The C shell, <tt>tcsh</tt> and <code>ksh</tt> do not provide UTF-8 support at all. 

=== Irssi ===

Irssi полностью поддерживает UTF-8, хотя для этого требуется дополнительная настройка пользователем. 

{{Cmd|set term_charset UTF-8|prompt=[irssi] }}

Для каналов, где не-ASCII символы чаще всего передаются в не-UTF-8 кодировках, может пригодиться команда <code>/recode</code> для перекодировки символов. Наберите <code>/help recode</code> для большего количества информации. 

=== Mutt ===

The Mutt mail user agent has very good Unicode support. To use UTF-8 with Mutt, you don't need to put anything in your configuration files. Mutt will work under Unicode environment without modification if all your configuration files (signature included) are UTF-8 encoded. 

{{Note/ru|Вы всё ещё можете видеть знаки вопроса при чтении почты с помощью Mutt. Это случается из-за того, что некоторые люди используют почтовые клиенты, не устанавливающие используемую кодировку письма. Вы ничего больше не можете сделать, кроме как попросить их правильно настроить свои клиенты.}}

Для более детальной информации смотри [http://wiki.mutt.org/index.cgi?MuttFaq/Charset Mutt Wiki]. 

=== Man ===

Man-страницы являются неотъемлемой частью любой системы Linux. Чтобы удостовериться, что все страницы отображаются верно, отредактируйте {{Path|/etc/man.conf}} и замените следующую строку. 

{{CodeBox|title=man.conf changes for Unicode support|1=
## (This is the old line)
NROFF           /usr/bin/nroff -Tascii -c -mandoc
## (Replace the one above with this)
NROFF           /usr/bin/nroff -mandoc -c
}}

=== links and elinks ===

These are commonly used text-based browsers, and we shall see how we can enable UTF-8 support on them. On <tt>elinks</tt> and <tt>links</tt>, there are two ways to go about this, one using the Setup option from within the browser or editing the config file. To set the option through the browser, open a site with <tt>elinks</tt> or <tt>links</tt> and then {{Key|Alt}}+{{Key|S}} to enter the Setup Menu then select Terminal options, or press {{Key|T}}. Scroll down and select the last option <code>UTF-8 I/O</code> by pressing {{Key|Enter}}. Then Save and exit the menu. On <tt>links</tt> you may have to do a repeat {{Key|Alt}}+{{Key|S}} and then press {{Key|S}} to save. The config file option, is shown below. 

{{CodeBox|title=Enabling UTF-8 for elinks/links|1=
## (For elinks, edit /etc/elinks/elinks.conf or ~/.elinks/elinks.conf and
add the following line)
set terminal.linux.utf_8_io = 1

## (For links, edit ~/.links/links.cfg and add the following
line)
terminal "xterm" 0 1 0 us-ascii utf-8
}}

=== Samba ===

Samba это набор программ, реализующих протокол SMB (Server Message Block) для UNIX-систем (Mac, Linux и FreeBSD). Этот протокол также иногда упоминается как Common Internet File System (CIFS). Samba содержит также систему NetBIOS, используемую для предоставления доступа к файлам в Windows-сетях. 

Добавьте следующее в раздел [global]:
{{RootCmd|nano -w /etc/samba/smb.conf|output=<pre>
dos charset = 1255
unix charset = UTF-8
display charset = UTF-8
</pre>
}}

=== Проверка работоспособности ===

Есть множество сайтов, использующих UTF-8. {{Package|net-www/w3m}}, {{Package|net-www/links}}, {{Package|net-www/elinks}}, {{Package|net-www/lynx}} и все браузеры, основанные на движке Mozilla (включая Firefox), поддерживают UTF-8. Konqueror и Opera тоже полностью поддерживают UTF-8. 

При использовании текстовых браузеров, удостоверьтесь, что используете совместимый с Юникодом терминал. 

Если вы видите символы, отображаемые как квадратики с буквами или цифрами	внутри, то это значит, что в ваших шрифтах нет соответствующего глифа для	символа. Вместо этого, они отображают квадрат с шестнадцатиричным кодом символа UTF-8. 

*  [http://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html Тестовая страница UTF-8 W3C]
*  [http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm Тестовая страничка UTF-8 от Университета Франкфурта]

=== Input methods ===

''Dead keys'' могут быть использованы для ввода символов, не отображенных на клавиатуре, в X-сервере. Для этого нужно, удерживая правый {{Key|Alt}} (в некоторых странах он называется {{Key|AltGr}}), нажать на дополнительную неалфавитную клавишу с символом, не являющимся буквой или цифрой (модификатор), а затем нажать на необходимую букву. Dead key изменит ее. Ввод может быть изменен также с помощью {{Key|Shift}} при нажатых {{Key|AltGr}} и модификаторе. 

Чтобы включить dead keys в X, нужно иметь раскладку, поддерживающую их. Большинство европейских раскладок уже имеют dead keys по умолчанию. Тем не менее, это не так в североамериканских раскладках. Хотя	существуют незначительные отличия между различными раскладками, простейшим решением будет использование раскладки в форме "en_US" вместо просто "us". Раскладка указывается в {{Path|/etc/X11/xorg.conf}}: 

{{CodeBox|title=/etc/X11/xorg.conf snippet|lang=xorg_conf|1=
Section "InputDevice"
    Identifier "Keyboard0"
    Driver     "kbd"
    Option     "XkbLayout" "en_US" ## # Rather than just "us"
    ## (Other Xkb options here)
EndSection
}}

{{Note/ru|Эти изменения нужны только в том случае, если вы используете североамериканскую раскладку либо любую другую, в которой dead keys не работают. Европейским пользователям нет нужны что-либо менять.}}

This change will come into effect when your X server is restarted. To apply the change now, use the <tt>setxkbmap</tt> tool, for example, <tt>setxkbmap en_US</tt> . 

Рассмотрим действия dead keys на примерах. Хотя результат зависит от текущей локали, сам принцип действия должен работать в нее зависимости от нее. Примеры содержат символы Юникода, так что убедитесь, что ваш браузер корректно отображает их. 

Если одновременно нажать {{Key|AltGr}} и {{Key|[}}, отпустить, а затем нажать {{Key|a}}, получим символ 'ä'. Если одновременно нажать {{Key|AltGr}} и {{Key|[}}, а затем {{Key|e}}, получим 'ë'. Если одновременно нажать {{Key|AltGr}} и {{Key|;}}, затем {{Key|a}}, получим 'á'. Если одновременно нажать {{Key|AltGr}} и {{Key|;}}, затем {{Key|e}}, получим 'é'. <!-- for translating tool checker: ]] --> 

Если одновременно нажать {{Key|AltGr}}, {{Key|Shift}} и {{Key|[}}, отпустить их и нажать {{Key|a}}, получим скандинавскую 'å'. Аналогично, при одновременном нажатии {{Key|AltGr}}, {{Key|Shift}} и {{Key|[}}, отпускании ''только'' {{Key|[}} и повторном ее нажатии, мы получим '°'. Хотя этот символ (U+02DA) и похож на символ градуса (U+00B0), на самом деле он им не является. <!-- for translating tool checker: ]]] -->

Клавиша {{Key|AltGr}} может быть использована вместе с одной из алфавитных клавиш. Например, комбинация {{Key|AltGr}} и {{Key|m}} выводит греческую строчную букву мю. {{Key|AltGr}} и {{Key|s}} выводит немецкий символ эсцет и т. д. Множество европейцев захотят установить сочетание {{Key|AltGr}} и {{Key|4}} (или {{Key|E}} в зависимости от наклеек или гравировок на клавишах), выводящее символ Евро, '€' (так как на их клавиатурах он нанесен).

=== Ссылки ===

*  [https://en.wikipedia.org/wiki/Unicode Статья в Википедии про Юникод] ([https://ru.wikipedia.org/wiki/Юникод ru])
*  [https://en.wikipedia.org/wiki/UTF-8 Статья в Википедии про UTF-8] ([https://ru.wikipedia.org/wiki/UTF-8 ru])
*  [http://www.unicode.org Unicode.org] 
*  [http://www.utf-8.com UTF-8.com] 
*  [http://www.ietf.org/rfc/rfc3629.txt RFC 3629] 
*  [http://www.ietf.org/rfc/rfc2277.txt RFC 2277] 
*  [http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF Символы и байты]

== Reported issues and problems ==

=== System configuration files (in /etc) ===

Most system configuration files (such as {{Path|/etc/fstab}}) do not support UTF-8. It is recommended to stick with the ASCII character set for these files. 

{{Migrated|originalauthors=Thomas Martin, Alexander Simonov, Shyam Mani, nightmorph}}
