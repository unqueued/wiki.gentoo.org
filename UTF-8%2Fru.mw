<languages />

{{InfoBox stack
|{{InfoBox wikipedia|header=true}}
}}

{{Metadata|abstract=UTF-8 — это кодировка символов переменной длины, что, в данном случае, означает длину от 1 до 4 байт на символ. Первый байт UTF-8 используется для кодирования ASCII, что означает, что данный набор символов полностью обратно совместим с ASCII. UTF-8 означает, что символы ASCII и Latin полностью взаимозаменяемы с небольшим увеличением размера данных, так как используется только первый байт. Пользователи восточных алфавитов, например, японского, которым назначили диапазон с большим числом байт несчастливы, так как это приводит к 50%-избыточности в их данных.}}

UTF-8 — это кодировка символов переменной длины, что, в данном случае, означает длину от 1 до 4 байт на символ. Первый байт UTF-8 используется для кодирования ASCII, что означает, что данный набор символов полностью обратно совместим с ASCII. UTF-8 означает, что символы ASCII и Latin полностью взаимозаменяемы с небольшим увеличением размера данных, так как используется только первый байт. Пользователи восточных алфавитов, например, японского, которым назначили диапазон с большим числом байт несчастливы, так как это приводит к 50%-й избыточности в их данных. 

== Кодировки символов ==

=== Что такое кодировка символов? ===

Компьютеры неспособны воспринимать текст как человек. Вместо этого они каждый символ представляют как число. Традиционно каждый набор чисел, используемый для представления алфавитов и символов (известный как кодировка или набор символов), ограничен по размеру в силу ограничений оборудования. 

=== История кодировок символов ===

Самой распространенной (или, по крайней мере, наиболее принятой повсеместно) кодировкой является '''ASCII''' (Американский стандартный код для обмена информацией, American Standard Code for Information Interchange). Часто считается, что ASCII &mdash; наиболее успешный программный стандарт из когда-либо созданных. Современный ASCII стандартизован в 1986 году (ANSI X3.4, RFC 20, ISO/IEC 646:1991, ECMA-6) Американским национальным институтом по стандартизации (American National Standards Institute, ANSI). 

ASCII является строго семибитной кодировкой, из чего следует, что она использует семь двоичных цифр, то есть интервал от 0 до 127. ASCII начинается с 32 невидимых управляющих символов (с кодами от 0 до 31) и заканчивается управляющим символом DEL (или delete) с кодом 127. Символы в диапазоне от 32 до 126 видимы &mdash; это пробел, знаки препинания, латинские буквы и цифры. 

Восьмой бит в ASCII изначально использовался как бит контроля четности для проверки ошибок при передаче информации. Если проверка на ошибки не важна, то он остается равным 0. Это означает, что в ASCII каждый символ занимал один байт. 

Хотя ASCII было достаточно для передачи информации на английском, для других европейских языков, содержащих символы с ударениями, это было не так просто. Для них был разработаны стандарты семейства ISO 8859. Они были обратно совместимы с ASCII, но использовали восьмой бит для дополнения таблицы дополнительными 127 символами для каждой кодировки. Скоро стали видны и ограничения ISO 8859. На данный момент существует 15 вариантов стандарта ISO 8859 (от 8859-1 до 8859-15). Однако для каждого символа вне ASCII-совместимого диапазона между этими стандартами возникал конфликт. Чтобы еще больше усилить конфликт между различными кодировками, для восточноевропейских языков корпорацией Microsoft был введен набор Windows-1252, использованный в ранних версиях Windows. Этот набор является надстройкой ISO 8859-1, обладающий собственными изменениями. Однако все же эти наборы были совместимы с ASCII. 

Необходимость разработки совершенно отличных от ASCII однобайтовых кодировок для нелатинских алфавитов, как например EUC (Extended Unix Coding), используемый в японском и корейском (и в меньшей степени китайском) алфавитах, породила еще большую неразбериху с кодировками. Ряд операционных систем все еще использует различные наборы символов для одного и того же языка, например японские Shift-JIS и ISO-2022-JP. А пользователи, желающие видеть кириллицу, вынуждены были выбирать между KOI8-R (для русского и болгарского языков) и KOI8-U (для украинского языка), неудачной ISO 8859-5 и популярной Windows-1251. Все три семейства кодировок не полностью совместимы с ASCII. Хотя надо отметить, в KOI8 фонетически созвучные кириллические символы расположены так же, как и латинские, благодаря чему даже при отбрасывании восьмого бита текст оставался читабельным в ASCII-терминалах в виде транслита. 

Все это привело к путанице и почти полной невозможности многоязычного общения; в особенности с использованием различных алфавитов. Переходим к Юникоду. 

=== Что такое Юникод? ===

Юникод отбрасывает лимит традиционных однобайтовых кодировок. Он использует 17 "плоскостей", содержащих по 65,536 кодов символов. Таким образом, максимальное возможное число символов равно 1,114,112. Поскольку в первой плоскости ("Basic Multilingual Plane" или BMP) содержится почти всё, что может понадобиться, многие ошибочно посчитали, что Юникод это 16-битный набор символов. 

Юникод реализован несколькими способами, но распространены только два '''UTF''' (Unicode Transformation Format) и '''UCS''' (Universal Character Set). Число после UTF обозначает число бит на каждый символ, когда как число после UCS обозначает число байт. UTF-8 стала наиболее распространенной при обмене текста Юникод из-за своей явной ориентированности на размер в 8 бит; поэтому является основной темой данного документа.

=== Что UTF-8 может сделать ===

UTF-8 позволяет пользователям работать в совместимой со всеобщими стандартами и принятой по всему миру многоязычной среде, правда с небольшим увеличением размера данных. Это наилучший способ для передачи не-ASCII символов через интернет, будь то электронная почта, IRC-сети или что-нибудь еще. Несмотря на это, множество людей расценивают использование UTF-8 при передаче данных неприличным и неуважительным. Всегда следует выяснять, поддерживает ли определенный канал, группа Usenet или список рассылки UTF-8 перед тем, как использовать символы из ''не-ASCII'' диапазона UTF-8. 

== Включение UTF-8 в Gentoo Linux ==

=== Поиск или создание локалей UTF-8 ===

Теперь, когда принципы лежащие в основе Unicode были изложены, начнем использовать UTF-8 на локальной системе!

Пользователям, которым нужна более детальная информация, могут найти ее в статье [[Localization/Guide/ru|Руководство по локализации Gentoo]]. 

Далее, нужно определить, доступна ли локаль UTF-8 для нашего языка или придется создать её.

{{Cmd|locale -a {{!}} grep 'en_GB'|output=<pre>
en_GB
en_GB.UTF-8
</pre>
}}

На выходе этой команды мы должны получить хотя бы одну строку, содержащую суффикс <code>.utf8</code>. Если таковых нет, то нам придётся создать локаль, совместимую с UTF-8. 

{{Note|Запускайте следующую команду, если в система не имеет UTF-8 локали для выбранного языка.}}

Замените "en_GB", если нужна какая-то другая локаль:
{{RootCmd|localedef -i en_GB -f UTF-8 en_GB.UTF-8}}

Другим способом включить локаль UTF-8 является добавление её в файл {{Path|/etc/locale.gen}} и генерация нужных локалей, используя команду {{c|locale-gen}}. Локали будут записаны в архив локалей {{Path|/usr/lib/locale/locale-archive}}.

{{CodeBox|title=Строка в /etc/locale.gen|1=
en_GB.UTF-8 UTF-8
}}

{{RootCmd|locale-gen|output=<pre>
 * Generating 1 locales (this might take a while) with 1 jobs
 *  (1/1) Generating en_GB.UTF-8 ...                            [ ok ]
 * Generation complete
</pre>}}

=== Настройка локали ===

Есть одна переменная среда, которую необходимо настроить, чтобы использовать UTF-8 локали: <var>LC_CTYPE</var> (также, можно изменить переменную <var>LANG</var>, чтобы изменить системный язык). Есть множество способов сделать это. Некоторые системные администраторы предпочитают использовать UTF-8 только для определенного пользователя, поэтому они устанавливают эту переменную в своём {{Path|~/.profile}} ({{Path|/bin/sh}}> для пользователей Bourne shell), {{Path|~/.bash_profile}} или {{Path|~/.bashrc}} ({{Path|/bin/bash}} для пользователей Bourne again shell). Больше информации, а также наилучшие способы локализации можно найти в [[Localization/Guide/ru|Руководстве по локализации]]. 

Другие же предпочитают установить локаль глобально. Есть по крайней один весомый аргумент в пользу этого подхода - при использовании {{Path|/etc/init.d/xdm}}, так как сценарии инициализации запускают диспетчер окон до того, как будут загружены конфигурационные файлы командной оболочки. Другими словами, это выполняется до того момента, как какие-либо переменные попадут в окружение пользователя. 

Настройка локали глобально делается с помощью файла {{Path|/etc/env.d/02locale}}. Он должен выглядеть следующим образом: 

{{CodeBox|title=Демонстрация /etc/env.d/02locale|lang=bash|1=
## (Как обычно, замените "en_GB.utf8" соответствующее значение локали; каждый язык имеет своё значение!)
LANG="en_GB.utf8"
}}

{{Note|Можно использовать <var>LC_CTYPE</var> вместо переменной <var>LANG</var>. За дополнительными сведениями о категориях, на которые влияет использование <var>LC_CTYPE</var>, обращайтесь к 
[http://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html#Locale-Categories странице локалей GNU].}}

Далее, следует обновить среду переменных, запустив следующую команду: 

{{RootCmd|env-update|output=<pre>
>>> Regenerating /etc/ld.so.cache...
</pre>}}
{{RootCmd|source /etc/profile}}

Теперь запустите {{c|locale}} без аргументов, чтобы увидеть, что верные переменные были загружены в окружающую среду переменных: 

{{RootCmd|locale|output=<pre>
LANG=en_GB.utf8
LC_CTYPE="en_GB.utf8"
LC_NUMERIC="en_GB.utf8"
LC_TIME="en_GB.utf8"
LC_COLLATE="en_GB.utf8"
LC_MONETARY="en_GB.utf8"
LC_MESSAGES="en_GB.utf8"
LC_PAPER="en_GB.utf8"
LC_NAME="en_GB.utf8"
LC_ADDRESS="en_GB.utf8"
LC_TELEPHONE="en_GB.utf8"
LC_MEASUREMENT="en_GB.utf8"
LC_IDENTIFICATION="en_GB.utf8"
LC_ALL=
</pre>
}}

===Альтернативный метод: использование eselect для настройки локали===
То, что было написано выше, достаточно, чтобы хорошо настроить систему, можно также проверить правильность настройки локали с помощью утилиты {{c|eselect}}.

Используйте команду {{c|eselect}}, чтобы получить список доступных локалей в системе:

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX *
  [3] en_GB.utf8
  [ ] (free form)
</pre>
}}

Утилита {{c|eselect}} выводит список локалей. После того, как нужная локаль была определена, активируйте ее:

{{RootCmd|eselect locale set 3 |output=<pre>
Setting LANG to en_GB.utf8 ...
</pre>
}}

Проверим результат:

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX
  [3] en_GB.utf8 *
  [ ] (free form)
</pre>
}}

In case it is preferred to have {{Path|/etc/env.d/02locale}} with <code>.UTF-8</code> instead of <code>.utf8</code>, run the appropriate {{c|eselect}} command:

{{RootCmd|eselect locale set en_GB.UTF-8 |output=<pre>
Setting LANG to en_GB.UTF-8 ...
</pre>
}}

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX
  [3] en_GB.utf8
  [4] en_GB.UTF-8 *
  [ ] (free form)
</pre>
}}

Запуск следующей команды обновит переменное окружение для shell:

{{RootCmd|env-update && source /etc/profile |output=<pre>
>>> Regenerating /etc/ld.so.cache...
</pre>
}}

Вот и всё. Теперь система использует локаль UTF-8. Следующим этапом будет настройка повседневно используемых приложений.

== Поддержка приложениями ==

Когда Юникод делал первые шаги в мире программного обеспечения, многобайтовые кодировки были плохо совместимы с таким языком программирования как C, на котором написаны многие из часто используемых программ. Даже сейчас некоторые программы не способны работать с UTF-8 как надо. К счастью, большинство распространенных программ поддерживают Юникод. 

=== Имена файлов, NTFS и FAT ===

В конфигурационном меню ядра Linux есть множество параметров NLS, но главное не паниковать. В большинстве случаев всё, что нужно это включить поддержку UTF-8 NLS в ядре и изменить переменную NLS со значения по умолчанию на utf8. 

{{KernelBox|title=Шаги настройки UTF-8 NLS для ядра|<pre>
File Systems -->
  Native Language Support -->
    (utf8) Default NLS Option
    <*> NLS UTF8
    ## (Также пометьте <*> другие наборы символов, которые используются
    в файловой системе FAT или Joilet для CD-ROM.)
</pre>
}}

Если требуется подключить разделы NTFS, то пользователю при подключении понадобиться указать специальный параметр <code>nls=</code>. Если требуется подключить разделы FAT, нужно указать при монтировании параметр <code>codepage=</code>. Также можно установить для FAT кодовую страницу по умолчанию при конфигурации ядра.

{{Note|Помните, что параметр <code>codepage</code>, указанный вместе с командой {{c|mount}}, будет иметь приоритет над настройками ядра.}}

{{KernelBox|title=Настройки FAT в конфигурации ядра|<pre>
File Systems -->
  DOS/FAT/NT Filesystems  -->
    (437) Default codepage for fat
</pre>
}}

Не устанавливайте <code>Default iocharset for fat</code> в UTF-8, так как это не рекомендуется. Вместо этого укажите параметр <code>utf8=true</code> при монтировании раздела FAT. Для более детальной информации, смотрите {{c|man mount}} или смотрите соответствующую документацию ядра расположенную в {{Path|/usr/src/linux/Documentation/filesystems/vfat.txt}}.

Чтобы сменить кодировку имен файлов, используйте {{Package|app-text/convmv}}. 

{{Emerge|app-text/convmv}}

Команда {{c|convmv}} имеет следующий формат:

{{RootCmd|convmv -f <текущая кодировка> -t utf-8 <имя файла>}}

Замените iso-8859-1 кодировкой, с которой хотите конвертировать:

{{RootCmd|convmv -f iso-8859-1 -t utf-8 имя_файла}}

Для изменения ''содержимого'' файлов, используйте утилиту {{c|iconv}}, поставляемую вместе с {{Package|sys-libs/glibc}} и уже должна быть установлена в системе Gentoo. Замените iso-8859-1 кодировкой, с которой хотите конвертировать. После запуска команды убедитесь в нормальном выходе:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 имя_файла}}

Чтобы конвертировать файл, нужно создать другой файл:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 имя_файла > новый_файл}}

Также для перекодировки может быть использован пакет ({{Package|app-text/recode}}).

=== Системная консоль ===

Для поддержки консолью локали UTF-8 нужно отредактировать {{Path|/etc/rc.conf}}. Установите переменную <code>UNICODE="yes"</code> и прочтите комментарии в этом файле -- важно, чтобы в системе были шрифты с нужным диапазоном символов, если хотите выжать из Юникода всё. Чтобы это сработало, удостоверьтесь, что локаль Unicode была правильно создана. 

В файле {{Path|/etc/conf.d/keymaps}} переменная <var>KEYMAP</var> должна соответствовать раскладке Unicode. 

{{CodeBox|title=Выдержка из /etc/conf.d/keymaps|lang=bash|1=
## (Замените uk на любимую раскладку)
keymap="uk"
}}

=== Ncurses и Slang ===

{{Note|Игнорируйте любые упоминания о Slang в этом разделе, если он не установлен или не нужен.}}

Будет хорошим решением добавить [https://packages.gentoo.org/useflags/unicode <code>unicode</code>] к глобальным [[USE_flag|USE-флагам]] в файле {{Path|[[:/etc/portage/make.conf#USE|/etc/portage/make.conf]]}}, а затем при необходимости пересобрать {{Package|sys-libs/ncurses}} и {{Package|sys-libs/slang}}. Portage это сделает автоматически при обновлении системы, если он был запущен с опциями <code>--changed-use</code> или <code>--newuse</code>. Запустите следующую команду чтобы обновить пакеты: 

{{RootCmd|emerge --update --deep --newuse world}}

Также понадобится пересобрать пакеты, зависящие от них, чтобы изменения USE вступили в силу. Используемая утилита ({{c|revdep-rebuild}}) входит в пакет {{Package|app-portage/gentoolkit}}. 

{{RootCmd|revdep-rebuild --soname libncurses.so.5
|revdep-rebuild --soname libslang.so.1}}

=== KDE, GNOME, and Xfce ===

Все основные графические оболочки полностью совместимы с Юникодом и не требуют дополнительной настройки, кроме той, что описана в этом документе. Все это	благодаря тому, графические библиотеки (Qt и GTK+2) совместимы с UTF-8. Следовательно, все приложения, работающие на основе этих библиотек, также должны поддерживать UTF-8 без дополнительных настроек. 

{{:Input_methods/key_sequence}}

Исключением в этом правиле является Xlib и GTK+1. GTK+1 требует iso-10646-1 FontSpec в ~/.gtkrc, например <code>-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1</code>. Также приложения, использующие Xlib или Xaw, нуждаются в подобной FontSpec, иначе они не буду работать. 

{{Note|Если старая версия центра управления gnome1 доступна, используйте ее. Воспользуйтесь любым из шрифтов семейства iso10646-1.}}

{{CodeBox|title=Пример ~/.gtkrc (для GTK+1), определяющий Юникод-совместимый шрифт|1=
style "user-font"
{
    fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"
}
widget_class "*" style "user-font"
}}

Если приложение одинаково поддерживает Qt и GTK+2, то обычно GTK+2 GUI выдает лучшие результаты при работе с Юникодом.

=== X11 и шрифты ===

Шрифты TrueType обычно совместимы с Юникодом, и большинство шрифтов, поставляемых с Xorg, имеют поддержку большинства кодировок, хотя не все глифы Юникода могут быть отображены для конкретного шрифта. 

Также множество пакетов шрифтов в Portage совместимы с Юникодом. Смотрите страницу [[Fontconfig/ru|Fontconfig]] для более подробной информации о рекомендуемых шрифтах и настройках.

=== Диспетчеры окон и эмуляторы терминалов ===

Диспетчеры окон, не использующие GTK+ или Qt, обычно очень хорошо поддерживают Юникод, так как чаще всего для отображения шрифтов используют библиотеку Xft. Если диспетчер окон не использует Xft, то еще возможно использовать FontSpec, указанный в предыдущем разделе в качестве шрифта Юникода. 

Terminal emulators that use Xft and support Unicode are harder to come by. Aside from Konsole and gnome-terminal, the best options in Portage are {{Package|x11-terms/rxvt-unicode}}, {{Package|x11-terms/xfce4-terminal}}, {{Package|gnustep-apps/terminal}}, {{Package|x11-terms/mlterm}}, or plain {{Package|x11-terms/xterm}} when built with the <code>unicode</code> USE flag and invoked as <code>uxterm</code>. {{Package|app-misc/screen}} supports UTF-8 too, when invoked as {{c|screen -U}} or the following is put into the {{Path|~/.screenrc}}: 

{{CodeBox|title=~/.screenrc для UTF-8|1=
defutf8 on
}}

=== Vim, emacs, xemacs, and nano ===

[[Vim#Change_file_encoding|Vim]] provides full UTF-8 support, and also has builtin detection of UTF-8 files. For further information in [[Vim#Change_file_encoding|Vim]], use <code>:help mbyte.txt</code>. 

[[GNU Emacs]] с версии 23 и [[XEmacs]] версии 21.5 имеют полную поддержку UTF-8. GNU Emacs 24 также поддерживает редактирование текста в обоих направлениях. 

Nano полностью поддерживает UTF-8 начиная с версии 1.3.6.

=== Командные оболочки ===

Currently, {{c|bash}} provides full Unicode support through the GNU readline library. Z Shell ({{c|zsh}}) offers Unicode support with the <code>unicode</code> USE flag. 

The C shell, {{c|tcsh}} and {{c|ksh}} do not provide UTF-8 support at all.

=== Irssi ===

Irssi полностью поддерживает UTF-8, хотя для этого требуется дополнительная настройка пользователем. 

{{Cmd|set term_charset UTF-8|prompt=[irssi] }}

For channels where non-ASCII characters are often exchanged in non-UTF-8 charsets, the {{c|/recode}} command may be used to convert the characters. Type {{c|/help recode}} for more information.

=== Mutt ===

Почтовый агент Mutt очень хорошо справляется с Юникодом. Чтобы использовать UTF-8 в Mutt, не надо что-либо добавлять в конфигурационные файлы. Mutt будет работать с Юникодом без модификаций, при условии, что все конфигурационные файлы (включая подпись) сохранены в UTF-8. 

{{Note|Если всё ещё видите '?' в письмах при чтении с помощью Mutt? Это случается из-за того, что некоторые люди используют почтовые клиенты, которые не указывают используемую кодировку письма. Мало что можно сделать в этом случае, кроме как попросить их правильно настроить свои клиенты.}}

Для более детальной информации смотри [http://wiki.mutt.org/index.cgi?MuttFaq/Charset Mutt Wiki]. 

=== Man ===

Man страницы являются неотъемлемой частью любой системы Linux. Чтобы удостовериться, что man страницы отображаются верно, отредактируйте {{Path|/etc/man.conf}} и замените следующую строку. 

{{CodeBox|title=Изменения man.conf для поддержки Юникода|1=
## (Это старая строка)
NROFF           /usr/bin/nroff -Tascii -c -mandoc
## (Замените ее этой)
NROFF           /usr/bin/nroff -mandoc -c
}}

=== links и elinks ===

These are commonly used text-based browsers, and we shall see how we can enable UTF-8 support on them. On {{c|elinks}} and {{c|links}}, there are two ways to go about this, one using the Setup option from within the browser or editing the config file. To set the option through the browser, open a site with {{c|elinks}} or {{c|links}} and then {{Key|Alt}}+{{Key|S}} to enter the Setup Menu then select Terminal options, or press {{Key|T}}. Scroll down and select the last option <code>UTF-8 I/O</code> by pressing {{Key|Enter}}. Then Save and exit the menu. On {{c|links}} one may have to do a repeat {{Key|Alt}}+{{Key|S}} and then press {{Key|S}} to save. The config file option, is shown below. 

{{CodeBox|title=Enabling UTF-8 for elinks/links|1=
## (For elinks, edit /etc/elinks/elinks.conf or ~/.elinks/elinks.conf and add the following line)
set terminal.linux.utf_8_io = 1
## (For links, edit ~/.links/links.cfg and add the following line)
terminal "xterm" 0 1 0 us-ascii utf-8
}}

=== Samba ===

Samba это набор программ, реализующих протокол SMB (Server Message Block) для UNIX-систем (Mac, Linux и FreeBSD). Этот протокол также иногда упоминается как Common Internet File System (CIFS). Samba содержит также систему NetBIOS, используемую для предоставления доступа к файлам в Windows-сетях. 

Добавьте следующее в раздел [global]:
{{RootCmd|nano -w /etc/samba/smb.conf|output=<pre>
dos charset = 1255
unix charset = UTF-8
display charset = UTF-8
</pre>
}}

=== Проверка работоспособности ===

Есть множество сайтов, использующих UTF-8. {{Package|net-www/w3m}}, {{Package|net-www/links}}, {{Package|net-www/elinks}}, {{Package|net-www/lynx}} и все браузеры, основанные на движке Mozilla (включая Firefox), поддерживают UTF-8. Konqueror и Opera тоже полностью поддерживают UTF-8. 

При использовании текстовых браузеров, удостоверьтесь, что используется совместимый с Юникодом терминал.

Если некоторые символы отображаемые как квадратики с буквами или цифрами внутри, то это значит, что в текущем шрифте нет соответствующего символа или глифа, который нужен UTF-8. Вместо этого, он отображают квадрат с шестнадцатиричным кодом символа UTF-8. 

* [http://unicode-table.com/en/blocks/dingbats/ unicode-table.com]
* [http://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html Тестовая страница UTF-8 W3C]
* [http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm Тестовая страничка UTF-8 от Университета Франкфурта]

=== Ссылки ===

*  [https://en.wikipedia.org/wiki/Unicode Статья в Википедии про Юникод] ([https://ru.wikipedia.org/wiki/Юникод ru])
*  [https://en.wikipedia.org/wiki/UTF-8 Статья в Википедии про UTF-8] ([https://ru.wikipedia.org/wiki/UTF-8 ru])
*  [http://www.unicode.org Unicode.org] 
*  [http://www.utf-8.com UTF-8.com] 
*  [http://www.ietf.org/rfc/rfc3629.txt RFC 3629] 
*  [http://www.ietf.org/rfc/rfc2277.txt RFC 2277] 
*  [http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF Символы и байты]
* [http://www.gnu.org/software/libc/manual/html_node/Locales.html Локали и Интернационализация]

== Известные проблемы ==

=== Системные конфигурационные файлы (в /etc) ===

Большинство системных конфигурационных файлов (например, {{Path|/etc/fstab}}) не поддерживают UTF-8. Рекомендуется придерживаться набора символов ASCII при работе с этими файлами.

[[Category:Localization]] {{Migrated|originalauthors=Thomas Martin, Alexander Simonov, Shyam Mani, nightmorph}}
