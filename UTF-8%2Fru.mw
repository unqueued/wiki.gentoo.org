<languages />

UTF-8 это кодировка символов переменной длины, что, в данном случае, означает длину от 1 до 4 байт на символ. Первый байт UTF-8 используется для кодирования ASCII, что означает, что данный набор символов полностью обратно совместим с ASCII. UTF-8 означает, что символы ASCII и Latin полностью взаимозаменяемы с небольшим увеличением размера данных, так как используется только первый бит. Пользователи Восточных алфавитов, например, Японского, которым назначили диапазон с большим числом байт несчастливы, так как это приводит к 50%-избыточности в их данных. 

== Кодировки символов ==

=== Что такое Кодировка Символов? ===

Компьютеры неспособны воспринимать текст. Вместо этого они каждый символ представляют как число. Традиционно каждый набор чисел, соответствующий алфавиту и символам (известный как кодировка или набор символов), ограничен в размере в силу ограничений оборудования. 

=== История кодировок символов ===

Самой распространенной (или, по крайней мере, наиболее принятой повсеместно) кодировкой является '''ASCII''' (Американский стандартный код для обмена информацией, American Standard Code for Information Interchange). Часто считается, что ASCII &mdash; наиболее успешный программный стандарт современности. Нынешний ASCII стандартизован в 1986 году (ANSI X3.4, RFC 20, ISO/IEC 646:1991, ECMA-6) Американским национальным институтом по стандартизации (American National Standards Institute, ANSI). 

ASCII является строго семибитной кодировкой, из чего следует, что она использует семь двоичных цифр, то есть интервал от 0 до 127. ASCII начинается с 32 невидимых управляющих символов (с кодами от 0 до 31) и заканчивается управляющим символом DEL (или delete) с кодом 127. Символы в диапазоне от 32 до 126 видимы &mdash; это пробел, знаки препинания, латинские буквы и цифры. 

Восьмой бит в ASCII изначально использовался как бит целостности для проверки ошибок при передаче информации. Если целостность была не важна, он всегда равнялся 0. Это означает, что в ASCII каждый символ занимал один байт. 

Хотя ASCII было достаточно для передачи информации на английском, для других европейских языков, содержащих символы с ударениями, это было не так просто. Для них был разработаны стандарты семейства ISO 8859. Они были обратно совместимы с ASCII, но использовали восьмой бит для дополнения таблицы дополнительными 127 символами для каждой кодировки. Скоро стали видны и ограничения ISO 8859. На данный момент существует 15 вариантов стандарта ISO 8859 (от 8859-1 до 8859-15). Однако для каждого символа вне ASCII-совместимого диапазона между этими стандартами возникал конфликт. Чтобы еще больше усилить конфликт между различными кодировками, для восточноевропейских языков корпорацией Microsoft был введен набор Windows-1252, использованный в ранних версиях Windows. Этот набор является надстройкой ISO 8859-1, обладающий собственными изменениями. Однако все же эти наборы были совместимы с ASCII. 

Необходимость разработки совершенно отличных от ASCII однобайтовых кодировок для нелатинских алфавитов, как например EUC (Extended Unix Coding), используемый в японском и корейском (и в меньшей степени китайском) алфавитах, породила еще большую неразбериху с кодировками, из-за чего ряд операционных систем все еще использует различные наборы символов для одного и того же языка, например японские Shift-JIS и ISO-2022-JP. А пользователи, желающие видеть кириллицу, вынуждены были выбирать между KOI8-R (для русского и болгарского языков) и KOI8-U (для украинского языка), неудачной ISO 8859-5 и популярной Windows-1251. Все три семейства кодировок не полностью совместимы с ASCII (хотя в KOI8 фонетически созвучные кириллические символы расположены так же, как и латинские, благодаря чему даже при отбрасывании восьмого бита текст оставался читабельным в ASCII-терминалах в виде транслита). 

Все это привело к путанице и полной невозможности многоязычного общения, в особенности с использованием различных алфавитов. Переходим к Юникоду. 

=== Что такое Юникод? ===

Юникод отбрасывает лимит традиционных однобайтовых кодировок. Он использует 17 "плоскостей", содержащих по 65,536 кодов символов. Таким образом, максимальное возможное число символов равно 1,114,112. Поскольку в первой плоскости ("Basic Multilingual Plane" или BMP) содержится почти всё, что вам может понадобиться, многие ошибочно посчитали, что Юникод это 16-битный набор символов. 

Юникод реализован несколькими способами, но распространены только два '''UTF''' (Unicode Transformation Format) и '''UCS''' (Universal Character Set). Число после UTF обозначает число бит на каждый символ, когда как число после UCS обозначает число байт. UTF-8 стала наиболее распространенной при обмене текста Юникод из-за своей явной ориентированности на размер в 8 бит, поэтому она и является основной темой данного документа. 

=== Что UTF-8 может сделать для вас ===

UTF-8 позволяет вам работать в совместимой со всеобщими стандартами и принятой по всему миру многоязычной среде, правда с небольшим увеличением размера данных. UTF-8 это наилучший способ для передачи не-ASCII символов через интернет, будь то электронная почта, IRC-сети или что-нибудь еще. Несмотря на это, множество людей расценивают использование UTF-8 при передаче данных неприличным и неуважительным. Всегда следует выяснять, поддерживает ли определенный канал, группа Usenet или список рассылки UTF-8 перед тем, как использовать символы из ''не-ASCII'' диапазона UTF-8. 

== Включение UTF-8 в Gentoo Linux ==

=== Поиск или создание локалей UTF-8 ===

Теперь, когда вы поняли основы Юникода, вы готовы начать использование UTF-8 в вашей системе. 

Главным требованием для UTF-8 является наличие установленной библиотеки glibc с поддержкой национального языка. При этом рекомендуется использовать файл {{Path|/etc/locale.gen}}. Описание использования этого файла, однако, выходит за рамки данного документа. Его использование описано в [[Localization/HOWTO|Руководстве по локализации Gentoo]] 

Далее, нужно определить, доступна ли локаль UTF-8 для нашего языка или придётся её создать. 

{{Cmd|locale -a {{!}} grep 'ru_RU'|output=<pre>
ru_RU
ru_RU.UTF-8
</pre>
}}

На выходе этой команды мы должны получить хотя бы одну строку, содержащую суффикс <c>.UTF-8</c>. Если таковых нет, то нам придётся создать локаль, совместимую с UTF-8. 


{{Note/ru|Запускайте следующую команду, если у вас нет UTF-8 локали для вашего языка}}

Замените "ru_RU", если вам нужна какая-то другая локаль:
{{RootCmd|localedef -i ru_RU -f UTF-8 ru_RU.UTF-8}}

Другим способом включить локаль UTF-8 является добавление её в файл {{Path|/etc/locale.gen}} и генерация нужных локалей командой <code>locale-gen</code>. 

{{Code/ru|Строка в /etc/locale.gen|<pre>
ru_RU.UTF-8 UTF-8
</pre>
}}

=== Настройка локали ===

Есть одна переменная среды, которую необходимо установить, чтобы использовать UTF-8 локали: <code>LC_CTYPE</code> (или, опционально, переменную <code>LANG</code>, если вы хотите заодно изменить и системный язык). Есть множество способов сделать это. Некоторые люди предпочитают использовать UTF-8 только для определенного пользователя, поэтому они устанавливают эту переменную в своём {{Path|~/.profile}} (если используется <code>/bin/sh</code>), {{Path|~/.bash_profile}} или {{Path|~/.bashrc}} (если используется <code>/bin/bash</code>). Большее количество информации, а также наилучшие способы локализации можно найти в нашем [[Localization/HOWTO|Гайде по Локализации]]. 

Другие предпочитают установить локаль глобально. Есть по крайней один весомый аргумент в пользу этого подхода - при использовании {{Path|/etc/init.d/xdm}}, так как сценарии инициализации запускают диспетчер окон до того, как будут загружены конфигурационные файлы командной оболочки, и, поэтому, до того момента, как какие-либо переменные попадут в окружение пользователя. 

При установке глобальной локали должен быть использован файл {{Path|/etc/env.d/02locale}}. Он должен выглядеть следующим образом: 

{{Code/ru|Демонстрация /etc/env.d/02locale|<pre>
## (Как обычно, замените "ru_RU.UTF-8" на нужную локаль)
LANG="ru_RU.UTF-8"
</pre>
}}

{{Note/ru|Вы можете также указывать <code>LC_CTYPE</code> вместо <code>LANG</code>. За дополнительными сведениями о категориях, затронутых использованием <code>LC_CTYPE</code>, пожалуйста, обращайтесь к 
[http://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html#Locale-Categories странице локалей GNU].}}

Далее следует обновить среду. 

{{RootCmd|env-update|output=<pre>
>>> Regenerating /etc/ld.so.cache...
 * Caching service dependencies ...
</pre>}}
{{RootCmd|source /etc/profile}}

Теперь запустите <code>locale</code> без аргументов, чтобы увидеть, что у вас верные переменные среды: 

{{RootCmd|locale|output=<pre>
LANG=ru_RU.UTF-8
LC_CTYPE="ru_RU.UTF-8"
LC_NUMERIC="ru_RU.UTF-8"
LC_TIME="ru_RU.UTF-8"
LC_COLLATE="ru_RU.UTF-8"
LC_MONETARY="ru_RU.UTF-8"
LC_MESSAGES="ru_RU.UTF-8"
LC_PAPER="ru_RU.UTF-8"
LC_NAME="ru_RU.UTF-8"
LC_ADDRESS="ru_RU.UTF-8"
LC_TELEPHONE="ru_RU.UTF-8"
LC_MEASUREMENT="ru_RU.UTF-8"
LC_IDENTIFICATION="ru_RU.UTF-8"
LC_ALL=
</pre>
}}

Вот и всё. Теперь вы используете локаль UTF-8, и следующим этапом является настройка повседневно используемых вами приложений. 

== Поддержка приложениями ==

Когда Юникод делал первые шаги в мире программного обеспечения, и многобайтовые кодировки еще не были включены в языки программирования, наподобие C, на котором написаны многие из повседневно используемых программ. Даже сейчас некоторые программы не способны работать с UTF-8 как надо. К счастью, таких не так много! 

=== Имена файлов, NTFS и FAT ===

В в конфигурационном меню ядра Linux есть множество параметров NLS, но главное не паниковать! В большинстве случаев всё, что вам нужно - включить поддержку UTF-8 NLS в ваше ядро и изменить NLS по умолчанию на utf8. 

{{Kernel|Шаги настройки UTF-8 NLS для ядра|<pre>
File Systems -->
  Native Language Support -->
    (utf8) Default NLS Option
    <*> NLS UTF8
    ## (Также пометьте <*> другие наборы символов, которые вы используете
    в вашей файловой системе FAT или Joilet для CD-ROM.)
</pre>
}}

Если вы планируете монтировать разделы NTFS, то вам понадобиться указать параметр при монтировании <code>nls=</code>. Если вы будете монтировать разделы FAT, вам понадобится указать при монтировании параметр <code>codepage=</code>. Также вы можете установить для FAT кодовую страницу по умолчанию при конфигурации ядра. Помните, что параметр <code>codepage</code>, указываемый при монтировании, будет иметь приоритет над настройками ядра. 

{{Kernel/ru|Настройки FAT в конфигурации ядра|<pre>
File Systems -->
  DOS/FAT/NT Filesystems  -->
    (437) Default codepage for fat
</pre>
}}

Не устанавливайте <code>Default iocharset for fat</code> в UTF-8, так как это не рекомендуется. Вместо этого укажите параметр utf8=true при монтировании раздела FAT. Для более детальной информации, смотрите <code>man mount</code> и документацию по ядру {{Path|/usr/src/linux/Documentation/filesystems/vfat.txt}}. 

Чтобы сменить кодировку имен файлов, используйте <code>app-text/convmv</code>. 

{{Emerge|app-text/convmv}}

Команда <code>convmv</code> имеет следующий формат:

{{RootCmd|convmv -f &lt;текущая кодировка&gt; -t utf-8 &lt;имя файла&gt;}}

Замените koi8-r кодировкой, с которой хотите конвертировать:

{{RootCmd|convmv -f koi8-r -t utf-8 имя_файла}}

Для изменения ''содержимого'' файлов, используйте утилиту <code>iconv</code>, поставляемую вместе с <code>glibc</code>. Замените koi8-r кодировкой, с которой хотите конвертировать, и проверьте вывод программы:

{{RootCmd|iconv -f koi8-r -t utf-8 имя_файла}}

Чтобы преобразовать файл, вы должны создать другой файл:

{{RootCmd|iconv -f koi8-r -t utf-8 имя_файла &gt; новый_файл}}

Также для этой цели может быть использована утилита <code>app-text/recode</code>. 

=== Системная консоль ===

{{Important/ru|Вам необходим sys-apps/baselayout версии 1.11.9 или более высокой для поддержки Юникода в консоли.}}

Для включения UTF-8 в консоли вы должны отредактировать {{Path|/etc/rc.conf}} и установить переменную <code>UNICODE="yes"</code>. Также прочтите комментарии в этом файле - важно, чтобы в системе были шрифты с нужным диапазоном символов, если вы хотите выжать из Юникода всё. Чтобы это сработало, удостоверьтесь, что вы правильно создали локаль Unicode. 

В файле {{Path|/etc/conf.d/keymaps}} переменной <code>KEYMAP</code> должна соответствовать раскладка Unicode. 

{{Code/ru|Выдержка из /etc/conf.d/keymaps|<pre>
## (Замените ru4 на вашу любимую раскладку)
keymap="ru4"
</pre>
}}

=== Ncurses и Slang ===

{{Note/ru|Если вы не устанавливали или не используете slang, не принимайте во внимание упоминания о нём в этом разделе.}}

It is wise to add <code>unicode</code> to your global USE flags in {{Path|/etc/portage/make.conf}} , and then to remerge <code>sys-libs/ncurses</code> and <code>sys-libs/slang</code> if appropriate. Portage will do this automatically when you update your system: 

{{RootCmd|emerge --update --deep --newuse world}}

We also need to rebuild packages that link to these, now the USE changes have been applied. The tool we use ( <code>revdep-rebuild</code> ) is part of the <code>gentoolkit</code> package. 

{{RootCmd|revdep-rebuild --soname libncurses.so.5
|revdep-rebuild --soname libslang.so.1}}

=== KDE, GNOME and Xfce ===

All of the major desktop environments have full Unicode support, and will require no further setup than what has already been covered in this guide. This is because the underlying graphical toolkits (Qt or GTK+2) are UTF-8 aware. Subsequently, all applications running on top of these toolkits should be UTF-8-aware out of the box. 

The exceptions to this rule come in Xlib and GTK+1. GTK+1 requires a iso-10646-1 FontSpec in the ~/.gtkrc, for example <code>-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1</code> . Also, applications using Xlib or Xaw will need to be given a similar FontSpec, otherwise they will not work. 

{{Note|If you have a version of the gnome1 control center around, use that instead. Pick any iso10646-1 font from there.}}

{{Code|Example ~/.gtkrc (for GTK+1) that defines a Unicode compatible font|<pre>
style "user-font"
{
    fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"
}
widget_class "*" style "user-font"
</pre>
}}

If an application has support for both a Qt and GTK+2 GUI, the GTK+2 GUI will generally give better results with Unicode. 

=== X11 and Fonts ===

TrueType fonts have support for Unicode, and most of the fonts that ship with Xorg have impressive character support, although, obviously, not every single glyph available in Unicode has been created for that font. To build fonts (including the Bitstream Vera set) with support for East Asian letters with X, make sure you have the <code>cjk</code> USE flag set. Many other applications utilise this flag, so it may be worthwhile to add it as a permanent USE flag. 

Also, several font packages in Portage are Unicode aware. 

{{Emerge|terminus-font intlfonts freefonts corefonts}}

=== Window Managers and Terminal Emulators ===

Window managers not built on GTK or Qt generally have very good Unicode support, as they often use the Xft library for handling fonts. If your window manager does not use Xft for fonts, you can still use the FontSpec mentioned in the previous section as a Unicode font. 

Terminal emulators that use Xft and support Unicode are harder to come by. Aside from Konsole and gnome-terminal, the best options in Portage are <code>x11-terms/rxvt-unicode</code> , <code>x11-terms/xfce4-terminal</code> , <code>gnustep-apps/terminal</code> , <code>x11-terms/mlterm</code> , or plain <code>x11-terms/xterm</code> when built with the <code>unicode</code> USE flag and invoked as <code>uxterm</code> . <code>app-misc/screen</code> supports UTF-8 too, when invoked as <code>screen -U</code> or the following is put into the {{Path|~/.screenrc}} : 

{{Code|~/.screenrc for UTF-8|<pre>
defutf8 on
</pre>
}}

=== Vim, Emacs, Xemacs and Nano ===

Vim provides full UTF-8 support, and also has builtin detection of UTF-8 files. For further information in Vim, use <code>:help mbyte.txt</code> . 

Emacs version 23 and Xemacs version 21.5 have full UTF-8 support. Emacs 24 will also support editing bidirectional text. 

Nano has provided full UTF-8 support since version 1.3.6. 

=== Shells ===

Currently, <code>bash</code> provides full Unicode support through the GNU readline library. Z Shell ( <code>zsh</code> ) offers Unicode support with the <code>unicode</code> USE flag. 

The C shell, <code>tcsh</code> and <code>ksh</code> do not provide UTF-8 support at all. 

=== Irssi ===

Irssi has complete UTF-8 support, although it does require a user to set an option. 

{{Cmd|set term_charset UTF-8|prompt=[irssi] }}

For channels where non-ASCII characters are often exchanged in non-UTF-8 charsets, the <code>/recode</code> command may be used to convert the characters. Type <code>/help recode</code> for more information. 

=== Mutt ===

The Mutt mail user agent has very good Unicode support. To use UTF-8 with Mutt, you don't need to put anything in your configuration files. Mutt will work under unicode enviroment without modification if all your configuration files (signature included) are UTF-8 encoded. 

{{Note|You may still see '?' in mail you read with Mutt. This is a result of people using a mail client which does not indicate the used charset. You can't do much about this than to ask them to configure their client correctly.}}

Further information is available from the [http://wiki.mutt.org/index.cgi?MuttFaq/Charset Mutt Wiki] . 

=== Man ===

Man pages are an integral part of any Linux machine. To ensure that any unicode in your man pages render correctly, edit {{Path|/etc/man.conf}} and replace a line as shown below. 

{{Code|man.conf changes for Unicode support|<pre>
## (This is the old line)
NROFF           /usr/bin/nroff -Tascii -c -mandoc
## (Replace the one above with this)
NROFF           /usr/bin/nroff -mandoc -c
</pre>
}}

=== elinks and links ===

These are commonly used text-based browsers, and we shall see how we can enable UTF-8 support on them. On <code>elinks</code> and <code>links</code> , there are two ways to go about this, one using the Setup option from within the browser or editing the config file. To set the option through the browser, open a site with <code>elinks</code> or <code>links</code> and then <code>Alt+S</code> to enter the Setup Menu then select Terminal options, or press <code>T</code> . Scroll down and select the last option <code>UTF-8 I/O</code> by pressing Enter. Then Save and exit the menu. On <code>links</code> you may have to do a repeat <code>Alt+S</code> and then press <code>S</code> to save. The config file option, is shown below. 

{{Code|Enabling UTF-8 for elinks/links|<pre>
## (For elinks, edit /etc/elinks/elinks.conf or ~/.elinks/elinks.conf and
add the following line)
set terminal.linux.utf_8_io = 1

## (For links, edit ~/.links/links.cfg and add the following
line)
terminal "xterm" 0 1 0 us-ascii utf-8
</pre>
}}

=== Samba ===

Samba is a software suite which implements the SMB (Server Message Block) protocol for UNIX systems such as Macs, Linux and FreeBSD. The protocol is also sometimes referred to as the Common Internet File System (CIFS). Samba also includes the NetBIOS system - used for file sharing over windows networks. 

add the following under the [global] section:
{{RootCmd|nano -w /etc/samba/smb.conf|output=<pre>
dos charset = 1255
unix charset = UTF-8
display charset = UTF-8
</pre>
}}

=== Testing it all out ===

There are numerous UTF-8 test websites around. <code>net-www/w3m</code> , <code>net-www/links</code> , <code>net-www/elinks</code> , <code>net-www/lynx</code> and all Mozilla based browsers (including Firefox) support UTF-8. Konqueror and Opera have full UTF-8 support too. 

When using one of the text-only web browsers, make absolutely sure you are using a Unicode-aware terminal. 

If you see certain characters displayed as boxes with letters or numbers inside, this means that your font does not have a character for the symbol or glyph that the UTF-8 wants. Instead, it displays a box with the hex code of the UTF-8 symbol. 

*  [http://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html A W3C UTF-8 Test Page] 
*  [http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm A UTF-8 test page provided by the University of Frankfurt] 

=== Input Methods ===

''Dead keys'' may be used to input characters in X that are not included on your keyboard. These work by pressing your right Alt key (or in some countries, AltGr) and an optional key from the non-alphabetical section of the keyboard to the left of the return key at once, releasing them, and then pressing a letter. The dead key should modify it. Input can be further modified by using the Shift key at the same time as pressing the AltGr and modifier. 

To enable dead keys in X, you need a layout that supports it. Most European layouts already have dead keys with the default variant. However, this is not true of North American layouts. Although there is a degree of inconsistency between layouts, the easiest solution seems to be to use a layout in the form "en_US" rather than "us", for example. The layout is set in {{Path|/etc/X11/xorg.conf}} like so: 

{{Code|/etc/X11/xorg.conf snippet|<pre>
Section "InputDevice"
    Identifier "Keyboard0"
    Driver     "kbd"
    Option     "XkbLayout" "en_US" ## # Rather than just "us"
    ## (Other Xkb options here)
EndSection
</pre>
}}

{{Note|The preceding change only needs to be applied if you are using a North American layout, or another layout where dead keys do not seem to be working. European users should have working dead keys as is.}}

This change will come into effect when your X server is restarted. To apply the change now, use the <code>setxkbmap</code> tool, for example, <code>setxkbmap en_US</code> . 

It is probably easiest to describe dead keys with examples. Although the results are locale dependent, the concepts should remain the same regardless of locale. The examples contain UTF-8, so to view them you need to either tell your browser to view the page as UTF-8, or have a UTF-8 locale already configured. 

When I press AltGr and [ at once, release them, and then press a, 'ä' is produced. When I press AltGr and [ at once, and then press e, 'ë' is produced. When I press AltGr and ; at once, 'á' is produced, and when I press AltGr and ; at once, release them, and then press e, 'é' is produced. 

By pressing AltGr, Shift and [ at once, releasing them, and then pressing a, a Scandinavian 'å' is produced. Similarly, when I press AltGr, Shift and [ at once, release ''only'' the [, and then press it again, '°' is produced. Although it looks like one, this (U+02DA) is not the same as a degree symbol (U+00B0).

AltGr can be used with alphabetical keys alone. For example, AltGr and m, a Greek lower-case letter mu is produced. AltGr and s produce a scharfes s or esszet, etc. As many European users would expect (because it is marked on their keyboard), AltGr and 4 (or E depending on the keyboard layout) produces a Euro sign, '€'. 

=== Resources ===

*  [http://en.wikipedia.org/wiki/Unicode The Wikipedia entry for Unicode] 
*  [http://en.wikipedia.org/wiki/UTF-8 The Wikipedia entry for UTF-8] 
*  [http://www.unicode.org Unicode.org] 
*  [http://www.utf-8.com UTF-8.com] 
*  [http://www.ietf.org/rfc/rfc3629.txt RFC 3629] 
*  [http://www.ietf.org/rfc/rfc2277.txt RFC 2277] 
*  [http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF Characters vs. Bytes] 

== Reported Issues or Problems ==

=== System Configuration Files (in /etc) ===

Most system configuration files, such as {{Path|/etc/fstab}} , do not support UTF-8. It is recommended to stick with the ASCII character set for these files. 

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* Thomas Martin
* Alexander Simonov
* Shyam Mani
* nightmorph
