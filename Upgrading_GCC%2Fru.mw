<languages />

{{Metadata|abstract=Данный документ показывает пользователям процесс обновления GCC.}}

Данный документ [[Article description::показывает пользователям процесс обновления GCC.]]

Обратите внимание, что понижение версии GCC может иметь нежелаемые побочные эффекты. Обратитесь к [[#Устранение проблем|секции решения проблем]] для информации по часто встречаемым проблемам.

== Вкратце ==

Следующий раздел быстро введет вас в процесс обновления GCC (и того, как просто его сделать). Больше деталей предоставлено в следующем разделе [[#Объяснение обновления GCC|Объяснение обновления GCC]].

Большинство обновлений GCC так же просты, как смена версии компилятора (тут с 5.4.0 на 6.4.0) и пересборка {{c|libtool}}:

{{Emerge|sys-devel/gcc|params+=--oneshot}}

{{RootCmd|gcc-config --list-profiles|output=<pre>
[1] x86_64-pc-linux-gnu-5.4.0 *
[2] x86_64-pc-linux-gnu-6.4.0
</pre>}}

{{RootCmd
|gcc-config 2
|source /etc/profile
}}

{{Emerge|sys-devel/libtool|params+=--oneshot --usepkg=n}}

{{Note|Если вы обновляетесь с GCC 4.x на GCC 5.x или позднее, есть дополнительные инструкции; смотрите отдельную страницу [[Upgrading from gcc-4.x to gcc-5.x|Обновление с gcc-4.x на gcc-5.x]].}}

Проверьте текущую версию и удалите старую версию:

{{RootCmd|gcc --version}}

{{Emerge|{{=}}sys-devel/gcc-5.4.0|params+=--depclean}}

После этого, убедитесь в целостности системы, запустив revdep-rebuild:
{{RootCmd|revdep-rebuild}}

Наслаждайтесь новым компилятором!

== Объяснение обновления GCC ==

Обновление GCC всегда считалось какой-то мистикой, с предположениями от "пользователям ничего не нужно делать" до "пользователям нужно дважды пересобрать всю свою систему". Большинство страха, неуверенности и сомнений проистекает из проблем, связанных с несовместимостью ABI. Такое редко происходит в наши дни (и когда происходит, это анонсируется). Но, сначала кратко о {{c|libtool}}.

=== libtool ===

Причина, по которой нужно пересобирать libtool после обновления версий {{c|gcc}} это потому, что главной функцией ''libtool'' является объединение кода, зависящего от платформы в общем интерфейсе, что позволяет приложениям использовать разделяемые библиотеки без нужды иметь дело с вещами, зависящими от платформы для разделяемых библиотек. Чтобы реализовать эту функцию, скрипт {{c|libtool}} использует различные пути до библиотек, в которых есть жестко заданная информация о версии {{c|gcc}}.

=== Изменения ABI ===

ABI, или ''[[wikipedia:Application_binary_interface|Двоичный интерфейс приложений]]'', это набор соглашений, используемых всеми инструментами, работающими с бинарным видом программ, например, компиляторы, ассемблеры, линкеры и поддержка рантайма для языков (источник: [https://gcc.gnu.org/onlinedocs/gcc/Compatibility.html Бинарная совместимость GCC]). Когда ABI, используемый для бинарных приложений и библиотек меняется, появляется риск получить ошибку компоновщика, либо неработающие программы, если только вы не пересоберёте все программы, использующие код C++. 

Да, C++, поскольку в большинстве случаев несоответствия обнаруживаются на уровне двоичного интерфейса приложений C++. Если вы обновляетесь до GCC 4.1, или GCC 5.1, вы, вероятно, столкнетесь с проблемами в двоичном интерфейсе. Чтобы избежать этого должна быть запущена команда {{c|revdep-rebuild}} для {{Path|libstdc++.so.5}} (от GCC 3 до GCC 4.1), или {{Path|libstdc++.so.6}} (от GCC 4 до GCC 5.1).

{{RootCmd|revdep-rebuild --library 'libstdc++.so.6' -- --exclude gcc}}

Так почему же это нужно только до GCC 3.4.0/4.1/5? Это потому что с этой версии GCC использует обратно-совместимое ABI, и пересборка приложений и библиотек больше не требуется. Конечно, мы не можем дать вам гарантию, что так будет вечно, но если снова возникнет несоответствие, мы явно опишем этот случай здесь. В этом случае, скорее всего, будет увеличена версия библиотеки {{Path|libstdc++.so}}.

==== Особый случай C++11 (и C++14) ====

В то время как GCC (или точнее libstdc++) идет большими шагами вперед, гарантируя стабильность ABI, эта гарантия не распространяется на все части C++ в libstdc++. Формально, начиная с версии 3.4, GCC/libstdc++ только гарантируется стабильность C++98/C++03 ABI и не более. Это очень важно для пакетов, которые зависят от C++11. GCC даёт гарантию на стабильность C++11 ABI, начиная только с версии 5.1. Это означает, что переключение (даже незначительные) версии GCC (скажем, от 4.7.3 -> 4.7.4) может привести к поломке ABI для бинарных файлов, собранных из C++11 кода.

Более подробную информацию и некоторые примеры можно найти здесь:

* {{Bug|513386}}
* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61758
* https://blogs.gentoo.org/blueness/2015/03/10/the-c11-abi-incompatibility-problem-in-gentoo/
* https://stackoverflow.com/questions/16190269/g-always-backward-compatible-with-older-static-libraries/16196475#16196475

=== Какие пакеты определенно нужно пересобрать? ===

В следующей таблице приведены пакеты, которые нужно пересобрать, ''если они установлены'', и причины этой необходимости. 

{| class="table" style="text-align: left;" 
|- 
! Пакет
! Нужно пересобрать, потому что ...
|- 
| {{Package|sys-devel/libtool}}
| приложение libtool имеет внутри себя вшитые пути к встроенным библиотекам GCC
|- 
| {{Package|sys-devel/llvm}}
| зависит от конкретной версии GCC, могут возникнуть ошибки линкования с другими ебилдами, использующими LLVM (к примеру, {{Package|media-libs/mesa}}), если их не пересобрать.
|-
| {{Package|sys-devel/clang}}
| зависит от конкретной версии GCC, может зависеть от {{Package|sys-devel/llvm}}.
|}

{{Emerge|sys-devel/libtool sys-devel/llvm sys-devel/clang|params+=--oneshot --usepkg=n --verbose}}

Также известны случаи, когда пакеты должны быть собраны одним и тем же компилятором (к примеру, различные {{Path|qt-*}} пакеты). Эти пакеты чаще всего обновляются сопровождающими пакета одновременно (поэтому они всегда будут собираться одной и той же версией GCC). Выборочная переустановка таких пакетов часто сопровождается проблемами.

=== Пересборка всего ===
Некоторые люди клянутся, что нужно пересобрать все пакеты на их системе при выходе новой версии GCC. Конечно, в этом нет смысла, так как многие приложения не используют GCC для процесса сборки и установки, и на них вообще не распространяется это изменение. 

Это, однако, не означает, что они полностью неправы: новые версии GCC часто предлагают более хорошую поддержку набора инструкций процессора, а это может повлиять на производительность приложений в лучшую сторону.

Кроме таких "небольших" плюсов, пересборка всего с нуля может быть обязательна в некоторых случаях, чтобы исправить проблемы без очевидных причин.

Некоторые проблемы с программами исконно трудны в диагностике, но их можно решить простой пересборкой одного или больше соответствующих пакетов. Если подобная проблема возникла после обновления GCC и сохранилась после применения revdep-rebuild как показано выше (и после пересборки прочих очевидно связанных пакетов), полная пересборка системы может решить этот вопрос.

Самый "безопасный" (но также затратный по времени) способ этого достичь - использование опции <code>--emptytree</code> (<code>-e</code>) для emerge, чтобы пересобрать [[System set (Portage)|системные пакеты]] и [[World set (Portage)|мир]]:

{{Emerge|@system|params+=--emptytree --usepkg=n}}
{{Emerge|@world|params+=--emptytree --usepkg=n}}

Пользователям рекомендуется попробовать этот подход, прежде чем писать о багах, которые могли произойти из-за обновления GCC.

(Заметьте, что команды выше пересоберут пакеты в системном наборе дважды, что необходимо, дабы быть "абсолютно уверенными", что каждый пакет был собран в одинаковой [предположительно] "безпроблемной" среде. Любые проблемы, что сохраняются после этого - действительно баги, о которых нужно сообщить, или серьёзные проблемы с конфигурацией системы.)

== Устранение проблем ==

=== пересборка boost ===

Если {{Package|dev-libs/boost}} нужно пересобрать, вы получите следующее сообщение об ошибке:

{{RootCmd|emerge ... |output=<pre> 
checking for the Boost _____ library... no
configure: error: cannot find the flags to link with Boost _____
</pre>}} 

Пересобрать можно с помощью:

{{Emerge|dev-libs/boost|params+=--oneshot --usepkg=n --verbose}}

=== libstdc++.so.6: version `GLIBCXX_3.4.15' not found ===

В процессе обновлений вы можете встретить ошибку, похожую на следующую: 

{{CodeBox|title=GLIBCXX_x.y.z not found|1=
cmake_bootstrap_28021_test: /usr/lib/gcc/i486-pc-linux-gnu/4.1.2/libstdc++.so.6:
version `GLIBCXX_3.4.11' not found
}}

Это означает, что вы пытаетесь собрать пакет ''более старой'' версией GCC, чем собирались библиотеки, от которых зависит пакет. Помните, мы говорили, что C++ ABI обратно совместим? Это так, но означает только, что для сборки приложений и линковки библиотек могут использоваться ''более новые'' (или те же самые) версии GCC (по сравнению с версией GCC, использованной для сборки этих библиотек).

Для пересоборки всех зависящих от libstdc++ смотрите пример команды {{c|revdep-rebuild}} в [[#Вкратце|предыдущем разделе]].

== Смотрите также ==

* [[Upgrade GCC up to 4.1|Обновление GCC до версии 4.1]], предыдущая версия данного документа
* [[Upgrading from gcc-4.x to gcc-5.x|Обновление с gcc-4.x до gcc-5.x]]
* [https://fedoraproject.org/wiki/Changes/GCC6 Fedora's 'Changes/GCC6' Wiki Page]

== Ссылки ==

{{reflist}}


[[Category:Core system]]
