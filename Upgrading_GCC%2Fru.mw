<languages />

{{Metadata|abstract=Данный документ показывает пользователям процесс обновления GCC.}}

Данный документ [[Article description::показывает пользователям процесс обновления GCC.]]

Обратите внимание, что понижение версии GCC может иметь нежелаемые побочные эффекты. Обратитесь к [[#Troubleshooting|секции решения проблем]] для информации по часто встречаемым проблемам.

== Вкратце ==

Следующий раздел быстро введет вас в процесс обновления GCC (и того, как просто его сделать). Если вы хотите прочитать длинное объяснение причин, стоящих за обновлением GCC, продолжайте читать [[#GCC upgrading explained|Объяснение обновления GCC]].

Если вы обновляете GCC, то вам вообще не нужно ничего делать, кроме смены версии компилятора (тут с 5.4.0 на 6.4.0) и пересборки {{c | libtool}}:

{{Emerge|sys-devel/gcc|params+=--oneshot}}

{{RootCmd|gcc-config --list-profiles|output=<pre>
[1] x86_64-pc-linux-gnu-5.4.0 *
[2] x86_64-pc-linux-gnu-6.4.0
</pre>}}

{{RootCmd
|gcc-config 2
|source /etc/profile
}}

{{Emerge|sys-devel/libtool|params+=--oneshot --usepkg=n}}

{{Note|Если вы обновляетесь с GCC 4.x на GCC 5.x или позднее, есть дополнительные инструкции; смотрите отдельную страницу [[Upgrading from gcc-4.x to gcc-5.x|Обновление с gcc-4.x на gcc-5.x]].}}

Проверьте текущую версию и удалите старую версию:

{{RootCmd|gcc --version}}

{{Emerge|{{=}}sys-devel/gcc-5.4.0|params+=--depclean}}

После этого, убедитесь в целостности системы, запустив revdep-rebuild:
{{RootCmd|revdep-rebuild}}

Наслаждайтесь новым компилятором!

== Объяснение обновления GCC ==

Обновление GCC всегда считалось какой-то мистикой, с предположениями от "Вам ничего не нужно знать" до "Вам нужно дважды пересобрать всю свою систему". Большинство страха, неуверенности и сомнений проистекает из проблем, связанных с несовместимостью ABI. Но, сначала кратко о {{c|libtool}}.

=== libtool ===

Причина, по которой нужно пересобирать libtool после обновления версий {{c|gcc}} это потому, что главной функцией ''libtool'' является объединение кода, зависящего от платформы в общем интерфейсе, что позволяет приложениям использовать разделяемые библиотеки без нужды иметь дело с вещами, зависящими от платформы для разделяемых библиотек. Чтобы реализовать эту функцию, скрипт {{c|libtool}} использует различные пути до библиотек, в которых есть жестко заданная информация о версии {{c|gcc}}.

=== Изменения ABI ===

ABI, или [https://en.wikipedia.org/wiki/Application_binary_interface ''Двоичный интерфейс приложений''], это набор соглашений, используемых всеми инструментами, работающими с бинарным видом программ, например, компиляторы, ассемблеры, линкеры и поддержка рантайма для языков (источник: [https://gcc.gnu.org/onlinedocs/gcc/Compatibility.html Бинарная совместимость GCC]). Когда ABI, используемый для бинарных приложений и библиотек меняется, появляется риск получить ошибку компоновщика, либо неработающие программы, если только вы не пересоберёте все программы, использующие код C++. 

Да, C++, поскольку в большинстве случаев несоответствия обнаруживаются на уровне двоичного интерфейса приложений C++. Если вы обновляетесь до GCC 4.1, или GCC 5.1, вы, вероятно, столкнетесь с проблемами в двоичном интерфейсе. Это так же объясняет почему мы снова использовали команду {{c|revdep-rebuild}} для {{Path|libstdc++.so.5}} (от GCC 3 до GCC 4.1), или {{Path|libstdc++.so.6}} (от GCC 4 до GCC 5.1).

{{RootCmd|revdep-rebuild --library 'libstdc++.so.6' -- --exclude gcc}}

Так почему же это нужно только до GCC 3.4.0/4.1/5? Это потому что с этой версии GCC использует обратно-совместимое ABI, и пересборка приложений и библиотек больше не требуется. Конечно, мы не можем дать вам гарантию, что так будет вечно, но если снова возникнет несоответствие, мы явно опишем этот случай здесь. В этом случае, скорее всего, будет увеличена версия библиотеки {{Path|libstdc++.so}}.

==== Особый случай C++11 (и C++14) ====

В то время как GCC (или точнее libstdc++) идет большими шагами вперед, гарантируя стабильность ABI, эта гарантия не распространяется на все части C++ в libstdc++. Формально, начиная с версии 3.4, GCC/libstdc++ только гарантируется стабильность C++98/C++03 ABI и не более. Это очень важно для пакетов, которые зависят от C++11. GCC даёт гарантию на стабильность C++11 ABI, начиная только с версии 5.1. Это означает, что переключение (даже незначительные) версии GCC (скажем, от 4.7.3 -> 4.7.4) может привести к поломке ABI для бинарных файлов, собранных из C++11 кода.

Более подробную информацию и некоторые примеры можно найти здесь:

* {{Bug|513386}}
* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61758
* https://blogs.gentoo.org/blueness/2015/03/10/the-c11-abi-incompatibility-problem-in-gentoo/
* https://stackoverflow.com/questions/16190269/g-always-backward-compatible-with-older-static-libraries/16196475#16196475

=== Какие пакеты определенно нужно пересобрать? ===

В следующей таблице приведены пакеты, которые нужно пересобрать, ''если они установлены'', и причины этой необходимости. 

{| class="table" style="text-align: left;" 
|- 
! Пакет
! Нужно пересобрать, потому что ...
|- 
| {{Package|sys-devel/libtool}}
| приложение libtool имеет внутри себя вшитые пути к встроенным библиотекам GCC
|- 
| {{Package|sys-devel/llvm}}
| зависит от конкретной версии GCC, могут возникнуть ошибки линкования с другими ебилдами, использующими LLVM (к примеру, {{Package|media-libs/mesa}}), если их не пересобрать.
|-
| {{Package|sys-devel/clang}}
| зависит от конкретной версии GCC, может зависеть от {{Package|sys-devel/llvm}}.
|}

{{Emerge|sys-devel/libtool sys-devel/llvm sys-devel/clang|params+=--oneshot --usepkg=n --verbose}}

Также известны случаи, когда пакеты должны быть собраны одной и той же версией компилятора (к примеру, всяческие {{Path|qt-*}} пакеты). Эти пакеты чаще всего обновляются сопровождающими пакета одновременно (поэтому они всегда будут собираться одной и той же версией GCC). Выборочная переустановка таких пакетов часто сопровождается проблемами.

<div class="mw-translate-fuzzy">
Некоторые люди клянутся, что нужно пересобрать все пакеты на их системе при выходе новой версии GCC. Конечно, в этом нет смысла, так как многие приложения не используют GCC для процесса сборки и установки, и на них вообще не распространяется это изменение.
</div> 

<div class="mw-translate-fuzzy">
Это, однако, не означает, что они полностью неправы: новые версии GCC часто предлагают более хорошую поддержку набора инструкций процессора, а это может повлиять на производительность приложений в лучшую сторону. Хотя, чаще всего, данное улучшение очень незначительное, в некоторых случаях (особенно для приложений, сильно использующих процессор) это может привести к существенному улучшению.
</div>

Apart from such "benign" benefits, rebuilding everything from scratch may be necessary in some cases to fix problems that don't seem to have any obvious cause.

Some software problems are inherently difficult to diagnose and yet could be solved by simply rebuilding one or more appropriate packages. If such a problem has arisen following a GCC upgrade and persists after using the revdep-rebuild approach described above (and after rebuilding any other obviously relevant packages), a complete system rebuild may be the answer.

The "safest" (but also most time-consuming) way to accomplish this is to use the <code>--emptytree</code> (<code>-e</code>) option of emerge to rebuild the [[System set (Portage)|system set]] and then the [[World set (Portage)|world set]]:

{{Emerge|@system|params+=--emptytree --usepkg=n}}
{{Emerge|@world|params+=--emptytree --usepkg=n}}

Users are urged to try this approach before reporting any bugs that might have been caused by a GCC upgrade.

(Note that the commands above will cause the packages in the "system" set to be rebuilt twice, which is necessary to be ''absolutely certain'' that every package gets built in the same [presumably] "problem-free" environment. Any problems that remain after doing this are due to either "genuine bugs" that should be reported or poor system configuration.)

== Устранение проблем ==

=== rebuild of boost ===

If {{Package|dev-libs/boost}} needs to be rebuilt, one will get the following error message:

{{RootCmd|emerge ... |output=<pre> 
checking for the Boost _____ library... no
configure: error: cannot find the flags to link with Boost _____
</pre>}} 

One can rebuild with:

{{Emerge|dev-libs/boost|params+=--oneshot --usepkg=n --verbose}}

=== libstdc++.so.6: version `GLIBCXX_3.4.15' not found ===

В процессе обновлений вы можете встретить ошибку, похожую на следующую: 

{{CodeBox|title=GLIBCXX_x.y.z not found|1=
cmake_bootstrap_28021_test: /usr/lib/gcc/i486-pc-linux-gnu/4.1.2/libstdc++.so.6:
version `GLIBCXX_3.4.11' not found
}}

<div class="mw-translate-fuzzy">
Это означает, что вы пытаетесь собрать пакет ''более старой'' версией GCC, чем собирались библиотеки, от которых зависит пакет. Помните, мы говорили, что C++ ABI обратно совместим? Это так, но означает только, что для сборки приложений и линковки библиотек могут использоваться ''более новые'' (или те же самые) версии GCC (по сравнению с версией GCC, использованной для сборки этих библиотек).
</div>

<div class="mw-translate-fuzzy">
Для пересоборки всех зависящих от libstdc++ смотрите пример команды revdep-rebuild в предыдущем разделе.
</div>

== Смотрите также ==

<div class="mw-translate-fuzzy">
*  [[Upgrade GCC up to 4.1|Обновление GCC до версии 4.1]], предыдущая версия данного документа
* [[Upgrading from gcc-4.x to gcc-5.x|Обновление с gcc-4.x до gcc-5.x]]
</div>

== Ссылки ==

{{reflist}}


[[Category:Core system]]
