<languages />


{{Metadata|abstract=本文档将指导用户完成GCC的升级。}}

本文档将指导用户完成GCC的升级。

== 快速开始 ==

=== 介绍 ===

这篇文章讲述 ''升级'' GCC。GCC降级可能会有不愿看到的副作用。对于一些报告中常见的问题请查阅[[#故障排除|故障排除]]一节。 

下一节将给出GCC升级的快速指南（这件事太容易了）。如果你想要阅读升级GCC背后冗长的材料，请继续阅读[[#GCC升级详解|GCC升级详解]]。

=== 简明版 ===

如果你正在升级GCC，那么你需要做的事情只有改变编译器版本和重新构建libtool。 

{{RootCmd|emerge -u sys-devel/gcc
|gcc-config -l|output=<pre>
[1] i686-pc-linux-gnu-4.4.5 *
[2] i686-pc-linux-gnu-4.5.3
</pre>}}

{{RootCmd
|gcc-config 2
|env-update && source /etc/profile}}

{{Emerge|sys-devel/libtool|params+=--oneshot}}

如果你从GCC 3.4.0（3.x系列）或4.1之前的版本升级，你还需要运行 {{c|revdep-rebuild}}： 

{{RootCmd|revdep-rebuild --library 'libstdc++\.so\.5'}}

检查当前版本并卸载旧版本：

{{RootCmd|gcc --version}}

{{Emerge|{{=}}sys-devel/gcc-4.4.5|params+=--depclean}}

这样就完成了！

== GCC 升级详解 ==

=== 介绍 ===

GCC升级向来一直都被神秘化了，从“建议你不需要再做任何事情”到“你需要重新编译你的整个系统”。这些恐惧、疑惑、怀疑大多数都源自用户对ABI不兼容性的不够了解。首先先关注下 {{c|libtool}}。

=== libtool 和 fix_libtool_files.sh ===

早前在 Gentoo 上安装 GCC 需要你运行一个叫 {{c|fix_libtool_files.sh}} 的特定命令。一段时间之后，安装包（通过 toolchain eclass）集成了自动执行这个命令，因此用户不需要再手动执行。 

在升级  {{c|gcc}} 版本之后我们需要重新编译 libtool 的原因在于它的主要目的：“libtool” 是一个工具集，通过一个通用的接口聚合了特定平台的代码，允许应用程序使用共享库进行构建，无需应对平台相关的共享库。为能正确实现这一功能，{{c|libtool}} 脚本使用的各种库的定位都包含了 {{c|gcc}} 版本硬编码信息。

=== ABI 变化 ===

An ABI, or [https://en.wikipedia.org/wiki/Application_binary_interface ''Application Binary Interface''], is a set of conventions used by all tools that deal with binary representation of programs, including compilers, assemblers, linkers, and language runtime support (source: [https://gcc.gnu.org/onlinedocs/gcc/Compatibility.html GCC Binary Compatibility]). When the ABI used for binary applications and libraries is changed, you will risk getting linker errors or malfunctioning programs unless you rebuild all libraries that use C++ code. 

Yes, C++, since most incompatibilities occur within the C++ ABI. If you are upgrading to GCC 4.1, or GCC 5.1, you would probably encounter ABI issues. This is also why we use the {{c|revdep-rebuild}} command against the {{Path|libstdc++.so.5}} (from GCC 3 to GCC 4.1), or {{Path|libstdc++.so.6}} (from GCC 4 to GCC 5.1).

{{RootCmd|revdep-rebuild --library 'libstdc\+\+.so.6' -- --exclude gcc}}

那么为什么只有升级到GCC 3.4.0/4.1/5.1版本才需要这么做？这是因为在这之前的版本，GCC采用向下兼容的ABI，这使得你不需要重新编译软件和系统库。当然，我们不能永远保证这种兼容性。如果发生不兼容的情况，{{Path|libstdc++.so}} 库将很可能也会升级到更高的版本。

==== The special case C++11 (and C++14) ====

While GCC (or more specifically, libstdc++) goes to great lengths to guarantee stability of the ABI, this guarantee does not extend to all parts of C++ within libstdc++. Formally, with versions starting from 3.4, GCC/libstdc++ only guarantees C++98/C++03 ABI stability and not more. This is crucial for packages that depend on C++11. GCC only makes C++11 ABI stability guarantees beginning with version 5.1. This means that switching (even minor) versions of gcc (say from 4.7.3 -> 4.7.4) might cause ABI breakage for binaries built from C++11 code.

For more information and some examples, see:

* {{Bug|513386}}
* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61758
* https://blogs.gentoo.org/blueness/2015/03/10/the-c11-abi-incompatibility-problem-in-gentoo/
* https://stackoverflow.com/questions/16190269/g-always-backward-compatible-with-older-static-libraries/16196475#16196475

=== Rebuilding everything ===

一些人认为当新版本的GCC安装好之后,他们需要重新编译他们系统上的已经安装过的应用,当然,这被认为是没有意义的,因为这里有很多应用在编译和构建的时候并没有用到GCC,所以更新不会影响到它们. 

That however doesn't mean they are completely incorrect: newer GCC versions often include better support for the processors' instruction set, which might influence the performance of some applications in a positive way. Although it is expected that this improvement is generally only marginal, in some cases (especially CPU intensive applications) this might yield notable improvements. 

There are also known cases where packages need to be built with the same compiler. Although these packages are usually bumped by package maintainers simultaneously (so that they are always built with the same GCC version) cherry-picking re-installs on these packages might prove to be troublesome. The various {{Path|qt-*}} packages are a nice example on this matter.

== 故障排除 ==

=== libstdc++.so.6: version `GLIBCXX_3.4.15' not found ===

在升级过程中,你或许会遇到以下面这些错误: 

{{CodeBox|title=GLIBCXX_x.y.z not found|1=
cmake_bootstrap_28021_test: /usr/lib/gcc/i486-pc-linux-gnu/4.1.2/libstdc++.so.6:
version `GLIBCXX_3.4.11' not found 
}}

这意味着你正在用一个"较老版本"(新版本指的是那些已经构建好这些依赖库的版本)的GCC来构建这些包.请记住所谓的C++ABI 向前兼容指的是:假设你可以用某个版本的GCC成功构建程序和连接库文件,那么你可以用比这个版本更高版本GCC去构建这些程序,而不是用更低版本GCC来构建这些程序.

To rebuild all the packages depending on libstdc++, see the previous revdep-rebuild section.

===那些包是已知的要重新构建的?===

The following table gives the packages that, ''if installed'', need to be rebuilt and why. 

{| class="table" style="text-align: left;" 
|- 
! Package
! Rebuild needed because ...
|- 
| {{Package|sys-devel/libtool}}
| libtool application has hardcoded paths towards GCC internal libraries
|- 
| {{Package|sys-devel/llvm}}
| depends on exact gcc version, may encounter linking errors with other ebuilds making use of LLVM (e.g. {{Package|media-libs/mesa}}) if not rebuilt
|}

== 另请参阅 ==

* [[Upgrade GCC up to 4.1]], the previous version of this document
* [[Upgrading from gcc-4.x to gcc-5.x]]
* [https://fedoraproject.org/wiki/Changes/GCC6 Fedora's 'Changes/GCC6' Wiki Page]


[[Category:Core system]]
