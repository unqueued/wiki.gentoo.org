<languages />


{{Metadata|abstract=本文档将指导用户完成GCC的升级。}}

本文档将指导用户完成GCC的升级。

== 快速开始 ==

=== 介绍 ===

这篇文章讲述 ''升级'' GCC。GCC降级可能会有不愿看到的副作用。对于一些报告中常见的问题请查阅[[#故障排除|故障排除]]一节。 

下一节将给出GCC升级的快速指南（这件事太容易了）。如果你想要阅读升级GCC背后冗长的材料，请继续阅读[[#GCC升级详解|GCC升级详解]]。

=== Short version ===

如果你正在升级GCC，那么你需要做的事情只有改变编译器版本和重新构建libtool。 

{{RootCmd|emerge -u sys-devel/gcc
|gcc-config -l|output=<pre>
[1] i686-pc-linux-gnu-4.4.5 *
[2] i686-pc-linux-gnu-4.5.3
</pre>}}

{{RootCmd|gcc-config 2
|env-update && source /etc/profile
|emerge --oneshot libtool}}

If you upgrade GCC from a version earlier than 3.4.0 (for the 3.x series) or 4.1, you will need to run {{c|revdep-rebuild}} as well: 

{{RootCmd|revdep-rebuild --library 'libstdc++\.so\.5'}}

检查当前版本并卸载旧版本
{{RootCmd|gcc --version
|emerge -C &#61;sys-devel/gcc-4.4.5}}

这样就完成了！ 

== GCC upgrading explained ==

=== 介绍 ===

GCC upgrading has always been mystified, with suggestions ranging from "You do not need to do anything" up to "You will need to rebuild your entire system twice". Most of this FUD comes from the confusion surrounding ABI incompatibility. But first a quick pointer towards {{c|libtool}}.

=== libtool 和 fix_libtool_files.sh ===

早前在 Gentoo 上安装 GCC 需要你运行一个叫 <code>fix_libtool_files.sh</code> 的特定命令。一段时间之后，安装包（通过 toolchain eclass）集成了自动执行这个命令，因此用户不需要再手动执行。 

The reason we need to rebuild libtool after the upgrade of {{c|gcc}} versions is because of its main purpose: ''libtool'' is a toolset that aggregates platform-specific code in a generic interface, allowing applications to build against shared libraries without needing to deal with the platform specific aspects of shared libraries. To fulfill its function properly, the {{c|libtool}} script uses various library locations that have hard-coded {{c|gcc}} version information in them.

=== ABI changes ===

ABI[https://en.wikipedia.org/wiki/Application_binary_interface ''应用程序二进制接口'']是一个所有处理二进制的程序（包括编译器、汇编器、链接器和语言运行库支持）都会使用的接口（来源：[http://gcc.gnu.org/onlinedocs/gcc/Compatibility.html GCC 二进制兼容性]）。当二进制程序和库使用的 ABI 改变了之后，你将面临 链接错误或者程序错误的风险，除非你重新编译了所有的使用 C++ 代码的库。 

Yes, C++, since most incompatibilities occur within the C++ ABI. If you are upgrading to GCC 4.1, or GCC 5.1, you would probably encounter ABI issues. This is also why we use the {{c|revdep-rebuild}} command against the {{Path|libstdc++.so.5}} (from GCC 3 to GCC 4.1), or {{Path|libstdc++.so.6}} (from GCC 4 to GCC 5.1).

{{RootCmd|revdep-rebuild --library 'libstdc\+\+.so.6' -- --exclude gcc}}

那么为什么只有升级到GCC 3.4.0/4.1/5.1版本才需要这么做？这是因为在这之前的版本，GCC采用向下兼容的ABI，这使得你不需要重新编译软件和系统库。当然，我们不能永远保证这种兼容性。如果发生不兼容的情况，{{Path|libstdc++.so}} 库将很可能也会升级到更高的版本。

==== The special case C++11 (and C++14) ====

While GCC (or more specifically, libstdc++) goes to great lengths to guarantee stability of the ABI, this guarantee does not extend to all parts of C++ within libstdc++. Formally, with versions starting from 3.4, GCC/libstdc++ only guarantees C++98/C++03 ABI stability and not more. This is crucial for packages that depend on C++11. GCC only makes C++11 ABI stability guarantees beginning with version 5.1. This means that switching (even minor) versions of gcc (say from 4.7.3 -> 4.7.4) might cause ABI breakage for binaries built from C++11 code.

For more information and some examples, see:

* https://bugs.gentoo.org/show_bug.cgi?id=513386
* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61758
* https://blogs.gentoo.org/blueness/2015/03/10/the-c11-abi-incompatibility-problem-in-gentoo/
* http://stackoverflow.com/a/16196475

=== Rebuilding everything ===

一些人认为当新版本的GCC安装好之后,他们需要重新编译他们系统上的已经安装过的应用,当然,这被认为是没有意义的,因为这里有很多应用在编译和构建的时候并没有用到GCC,所以更新不会影响到它们. 

That however doesn't mean they are completely incorrect: newer GCC versions often include better support for the processors' instruction set, which might influence the performance of some applications in a positive way. Although it is expected that this improvement is generally only marginal, in some cases (especially CPU intensive applications) this might yield notable improvements. 

There are also known cases where packages need to be built with the same compiler. Although these packages are usually bumped by Gentoo simultaneously (so that they are always built with the same GCC version) cherry-picking re-installs on these packages might prove to be troublesome. The various {{Path|qt-*}} packages are a nice example on this matter.

== 故障排除 ==

=== libstdc++.so.6: version `GLIBCXX_3.4.15' not found ===

在升级过程中,你或许会遇到以下面这些错误: 

{{CodeBox|title=GLIBCXX_x.y.z not found|1=
cmake_bootstrap_28021_test: /usr/lib/gcc/i486-pc-linux-gnu/4.1.2/libstdc++.so.6:
version `GLIBCXX_3.4.11' not found 
}}

这意味着你正在用一个"较老版本"(新版本指的是那些已经构建好这些依赖库的版本)的GCC来构建这些包.请记住所谓的C++ABI 向前兼容指的是:假设你可以用某个版本的GCC成功构建程序和连接库文件,那么你可以用比这个版本更高版本GCC去构建这些程序,而不是用更低版本GCC来构建这些程序.

To rebuild all the packages depending on libstdc++, see the previous revdep-rebuild section.

===那些包是已知的要重新构建的?===

The following table gives the packages that, ''if installed'', need to be rebuilt and why. 

{| class="table" style="text-align: left;" 
|- 
! Package
! Rebuild needed because ...
|- 
| {{Package|sys-devel/libtool}}
| libtool application has hardcoded paths towards GCC internal libraries
|}

== 另请参阅 ==

*  [https://wiki.gentoo.org/wiki/Upgrade_GCC_up_to_4.1 GCC Upgrading up to 4.1], the previous version of this document
* [[Upgrading from gcc-4.x to gcc-5.x]]


[[Category:Core system]]
