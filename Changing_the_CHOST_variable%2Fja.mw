<languages />

{{Metadata|abstract=この文書は、既存のシステムのCHOST変数を変更する方法について説明します。}}

この文書は、既存のシステムの<var>[[CHOST]]</var>変数を変更する方法について説明します。

== はじめに ==

<var>CHOST</var>の変更は、システムをひどくめちゃくちゃにしてしまう可能性もある重大な事項です - それでは、なぜそのような大破壊をもたらす可能性のあることについてガイドがあるのでしょうか? 

<var>CHOST</var>の変更が避けられない状況はいくつかあります。たとえば[[wikipedia:Native_POSIX_Thread_Library|NTPL]]のみをサポートするglibc 2.4へアップグレードするときに現在の<var>CHOST</var>がNTPLを使用できないi386であることに気づいた場合などです。このケースではとりうる選択肢はあまり多くはなく、そして<var>CHOST</var>の変更はその1つです。 

これらの手順に従った場合でさえ問題は起こり得ますから、手順はきわめて慎重に読み、また実行してください。この例では<var>CHOST</var>変数はi386から i686へと変更されます。コマンドは個別の状況に合わせて変えてください。

== CHOST変数の変更 ==

=== make.confの更新 ===

<var>CHOST</var>変数の変更を始めるには、まず{{Path|/etc/portage/make.conf}}ファイルを編集して<var>CHOST</var>の値を要件を満たすように追加/変更します。

{{FileBox|filename=/etc/portage/make.conf|1=
CHOST="i686-pc-linux-gnu"
}}

プロファイルのデフォルトとは異なる値を使用したい場合には、''CHOST_${ABI}''の値も同様に更新しなければならないかもしれないことに注意してください。これらの変数の現在の値は''portageq''ツールを使って調べることができます:

{{Cmd|1=portageq envvar ABI|output=x86}}
{{Cmd|1=portageq envvar CHOST_x86|output=i686-pc-linux-gnu}}

この値がCHOSTと一致していれば大丈夫です。そうでない場合にはそれも同様に書き換えてください:

{{FileBox|filename=/etc/portage/make.conf|1=
CHOST_x86="i686-pc-linux-gnu"
}}

=== パッケージの構築 ===

{{Important|一般的に、パッケージをCHOSTの切り替え前と'''同じバージョンになるように'''再構築するのは良い考えです。すなわち、CHOSTの切り替えとアップグレードを組み合わせて行わないようにするということです。複数のスロットがインストールされている場合は無関係なスロットをアンインストールするか、またはすべてのスロットを再構築してください。これができない場合には、まず(古いCHOSTで)パッケージをアップグレードしてください。CHOSTの切り替えとアップグレードを組み合わせることは不可能ではないかもしれませんが、どのような潜在的問題点が発生するか予測することは困難であり、それをこのガイドに文書化することはほぼ不可能です。}}

{{Tip|<var>CHOST</var>がi386の値に設定されているシステムでは、gccのアップグレードの間はi386で使用できないglibc 2.4(以降)をマスクしてください。アンマスクは変更を完全に実行してから行ってください。}}

以下のパッケージを、この順番で再構築します:

{{Emerge|sys-devel/binutils|params+=--oneshot}}

{{Note|gccをコンパイルする前に、{{c|binutils-config}}を実行する必要があるかもしれません。}}

{{Emerge|sys-devel/gcc|params+=--oneshot}}
{{Emerge|sys-libs/glibc|params+=--oneshot}}

=== うまくいっているか確認する ===

{{c|gcc-config}}と{{c|binutils-config}}の設定が正常か、また{{Path|/etc/env.d/}}に残ってしまったものがないか、確認します。 

{{c|gcc-config}}と{{c|binutils-config}}の出力は以下のようになっている必要があります:

{{Note|出力は、ことによると、あるいはおそらく、gccのバージョンや<var>CHOST</var>の設定によって異なります。上の例ではi686でgcc 4.1.1を使用しています。}} 

{{RootCmd|gcc-config -l|output=<pre>
 [1] i686-pc-linux-gnu-4.1.1 *</pre>}}

{{RootCmd|gcc-config -c|output=<pre>
i686-pc-linux-gnu-4.1.1</pre>}}

{{RootCmd|binutils-config -l|output=<pre>
 [1] i686-pc-linux-gnu-2.16.1 *
# binutils-config -c
i686-pc-linux-gnu-2.16.1
</pre>
}}

次に、{{Path|/etc/env.d/}}に古い<var>CHOST</var>への参照がないか確認します: 

{{RootCmd|cd /etc/env.d/
|grep 386 *|output=<pre>
05gcc-i386-pc-linux-gnu:PATH="/usr/i386-pc-linux-gnu/gcc-bin/4.1.1"
05gcc-i386-pc-linux-gnu:ROOTPATH="/usr/i386-pc-linux-gnu/gcc-bin/4.1.1"
</pre>
}}

{{Note|すべてのケースでこれが起こるわけではありませんが、このケースでは{{Path|05gcc-i386-pc-linux-gnu}}は古い<var>CHOST</var>の値への参照を含んでいます。<var>CHOST</var>をどの値からどの値へ変更するのかによって、システムごとに状況は異なります。ある場合には参照がまったく残らないこともあります。名前は{{Path|05gcc-''new_CHOST''-pc-linux-gnu}}のようになっているかもしれません。}}

それらのファイルを削除する前に、更新された<var>CHOST</var>の値を含むファイルを確認しておきましょう: 

{{RootCmd|grep 686 *|output=<pre>
05binutils:MANPATH=/usr/share/binutils-data/i686-pc-linux-gnu/2.16.1/man
05binutils:INFOPATH=/usr/share/binutils-data/i686-pc-linux-gnu/2.16.1/info
05binutils:LDPATH=/usr/i686-pc-linux-gnu/lib
05gcc:PATH="/usr/i686-pc-linux-gnu/gcc-bin/4.1.1"
05gcc:ROOTPATH="/usr/i686-pc-linux-gnu/gcc-bin/4.1.1"
05gcc:MANPATH="/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/man"
05gcc:INFOPATH="/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/info"
05gcc:LDPATH="/usr/lib/gcc/i686-pc-linux-gnu/4.1.1"
</pre>
}}

こちらが正しいファイルのようであり、{{Path|/etc/env.d/}}内には<code>gcc</code>向けのファイル(この例では{{Path|05gcc}})は常に1つだけ存在しているべきなので、誤った参照を含むものは削除しておきます: 

{{RootCmd|rm 05gcc-i386-pc-linux-gnu}}

{{Path|binutils}}についても同様です - もし余分なものがあったら、どちらが古くなったものか見て削除します。続いて{{Path|/etc/env.d/binutils/}}の内容を確認します:

{{RootCmd|cd /etc/env.d/binutils/
|ls -la|output=<pre>
total 8
-rw-r--r-- 1 root root  15 Sep  3 13:48 config-i686-pc-linux-gnu
-rw-r--r-- 1 root root 126 Sep  3 13:48 i686-pc-linux-gnu-2.16.1
</pre>}}

{{RootCmd|cat config-i686-pc-linux-gnu|output=<pre>
CURRENT=2.16.1</pre>}}

{{RootCmd|cat i686-pc-linux-gnu-2.16.1|output=<pre>
TARGET="i686-pc-linux-gnu"
VER="2.16.1"
LIBPATH="/usr/lib/binutils/i686-pc-linux-gnu/2.16.1"
FAKE_TARGETS="i686-pc-linux-gnu"
</pre>
}}

これら2つのファイルはここに存在しているはずであり、こちらは大丈夫そうです。{{Path|gcc/}}ディレクトリへと移動しましょう。 

{{RootCmd|cd /etc/env.d/gcc|output=<pre>
# ls -la
total 12
-rw-r--r-- 1 root root  32 Sep  3 16:43 config
-rw-r--r-- 1 root root  32 Aug  3 14:25 config-i386-pc-linux-gnu
-rw-r--r-- 1 root root 292 Sep  3 16:43 i686-pc-linux-gnu-4.1.1
</pre>}}

{{RootCmd|cat config|output=<pre>
CURRENT=i686-pc-linux-gnu-4.1.1</pre>}}

{{RootCmd|cat config-i386-pc-linux-gnu|output=<pre>
CURRENT=i386-pc-linux-gnu-4.1.1</pre>}}

{{RootCmd|cat i686-pc-linux-gnu-4.1.1|output=<pre>
PATH="/usr/i686-pc-linux-gnu/gcc-bin/4.1.1"
ROOTPATH="/usr/i686-pc-linux-gnu/gcc-bin/4.1.1"
LDPATH="/usr/lib/gcc/i686-pc-linux-gnu/4.1.1"
GCCBITS="32"
MANPATH="/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/man"
INFOPATH="/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/info"
STDCXX_INCDIR="g++-v4"
</pre>
}}

{{Path|config}}と{{Path|i686-pc-linux-gnu-4.1.1}}は良さそうですが、もう1つの{{Path|config-i386-pc-linux-gnu}}は残り物ですから削除する必要があります。 

{{Note|繰り返しますが、古いgccバージョンへの参照を含んだファイルの名前は、たとえばシステムが(この例では)i686へ変更されているにもかかわらず{{Path|config-i686-pc-linux-gnu}}といった異なる名前を持っているかもしれません。ファイルを名前だけでなく内容からも識別することが重要です。}}

{{RootCmd|rm config-i386-pc-linux-gnu}}

それでは、環境を更新するために以下のコマンドを実行します: 

{{RootCmd|env-update && source /etc/profile}}

次に、すべてが修正されたかどうか検証します: 

{{RootCmd|grep -r 386 /etc/env.d/}}

まだファイルが見つかる場合、続行する前にそれらを探し出すようにします。

=== 変更の仕上げ ===

ここで{{Package|sys-devel/libtool}}を再度emergeし、{{Path|/usr/share/gcc-data/''$CHOST''/''<gcc-version>''/}}にある{{c|fix_libtool_files.sh}}を実行する必要があります。正しいバージョン(現在のもの、ここでは4.1.1)のgccを使用していること、古いアーキテクチャ(ここではi386)を引数として渡していることを確認してください。<code>$CHOST</code>は新しい<var>CHOST</var>の値に、また<code><gcc-version></code>はgccのバージョンに置き換えてください。この例では<var>CHOST</var>にはi686が当てはまります。 

{{Emerge|libtool|params+=--oneshot}}

{{RootCmd|/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/fix_libtool_files.sh 4.1.1 --oldarch i386-pc-linux-gnu}}

これで、すべてのパッケージを再構築することができます: 

{{Emerge|params+=--emptytree|@world}}

理論上はこれを行う必要はないはずですが、実際にそうだと100%保証することはできません。代わりに、問題があると知られているすべてのパッケージを手動で再構築することもできます:
* CHOSTプレフィックスやヘッダーラッピングを使用しているmultilibパッケージ
* 設定済みコンパイラーのパスを記憶しているPerl、Pythonおよびその他のツール

{{Emerge|params+=--oneshot|/usr/bin/i386-pc-linux-gnu-* /usr/include/i386-pc-linux-gnu /usr/lib/llvm/*/bin/i386-pc-linux-gnu-* dev-lang/perl dev-lang/python}}

あなたのシステムにあてはまらないパスについては上のコマンドから取り除く必要があるかもしれないことに注意してください。

その他に再構築が必要なパッケージに遭遇したら、このガイドの[[Talk:Changing_the_CHOST_variable|discussion page]]を通じて私達にお知らせください。

=== よくある問題 ===

<var>CHOST</var>変数の変更と同時にgcc 3.3から4.1にアップグレードする際(とにかくそれはしないでください)、数人のユーザーは{{Package|sys-apps/groff}}や{{Package|mail-mta/courier}}といった、再構築が必要な壊れたパッケージを報告しています: 

{{CodeBox|title=エラーメッセージ|1=
error while loading shared libraries: libstdc++.so.5: cannot open shared object file: No such file or directory
}}

これは、アップグレードの間に<var>CHOST</var>変数が<var>CTARGET</var>変数と厳密に一致せず、コンパイラーがシステムはクロスコンパイルを利用中であると推定するために発生します。結果として<var>LDPATH</var>が{{Path|ld.so.conf}}に挿入されずにこのエラーが発生します。 

GCCのアップグレード後に再構築が必要なものについては[[Upgrading GCC|GCC upgrade guide]]を参照してください。 

まれに、pythonの古いバージョンも破壊されることがあります。これは、{{Path|/etc/ld.so.conf}}に{{Path|/usr/lib/gcc-lib/i386-pc-linux-gnu/3.3.6}}(<var>CHOST</var>とgccのバージョンに応じて変更してください)を追加し、{{c|ldconfig}}、そして{{c|emerge libstdc++-v3}}を実行することによって修復されることがあります。しかしながら、ここに見られるように、こうした状況は避けるべきです - <var>CHOST</var>とgccは同時に変更しないでください。

=== フィードバックしてください ===

もちろん、フィードバック(動いた、失敗した、あるいはその他の問題に遭遇した、のいずれも)は歓迎します。[[Talk:Changing_the_CHOST_variable|discussion page]]を利用するか、[https://forums.gentoo.org/viewtopic-t-494147.html このフォーラムスレッド]に投稿してください。このガイドの多くはvapierによるものです、協力に感謝します!

{{Migrated|originalauthors=Wernfried Haas, {{Dev|vapier}}, Chris White}}
