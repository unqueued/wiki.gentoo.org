<languages />


{{Metadata|abstract=この文書では、手動のカーネル設定の概念を紹介することを目的と最も一般的な設定の落とし穴のいくつかを詳しく説明します。}}

この文書は手動でのカーネル設定の概念を紹介することを目的とし、また最も一般的な設定の落とし穴のいくつかを詳しく説明します。

== はじめに ==

Gentoo はカーネルの設定、インストール、アップグレードを処理する2つの方法をユーザーに提供します: ''自動''(genkernel)と''手動''です。自動的な方法がほとんどのユーザーにとってより容易であると考えられるにもかかわらず、Gentooユーザーの多くがカーネルの手動設定を選ぶのにはたくさんの理由があります:

# よりよい柔軟性
# より小さな(カーネルの)サイズ
# より短いコンパイル時間
# 学習経験
# ひどい退屈
# カーネル設定の絶対的な知識
# 完全なコントロール

このガイドでは自動的な方法(genkernel)は扱いません。genkernel を使った方法でカーネル関係のことを処理したい場合は、[[Genkernel|Genkernel の記事]]に進んで詳細を確認してください。 

このガイドは手動設定の過程を始まりから終わりまですべて文書化することは意図していません - 設定の過程は常識や使っているシステムについての相対的に高度な技術的知識に大いに依存しているからです。その代わりに、このガイドでは手動設定の概念を紹介し、またユーザーが直面するもっとも一般的な落とし穴について詳細を説明します。 

{{Note|このガイドは、最近のカーネルについて一般的なコンピューターアーキテクチャを念頭において執筆されています。より古いカーネルやより珍しいアーキテクチャではいくつかの詳細は異なっているかもしれません; しかしながら、内容の多くはその場合でもあてはまります。}}

この時点で、ユーザーは解凍済みの Linux kernel のソースをハードディスク(通常は {{Path|/usr/src}} の下のどこか)に持っているものと推定します。また、{{c|menuconfig}} 設定ユーティリティに入る方法や ncurses ベースのメニューシステム内を移動する方法を知っていることが期待されます。ユーザーがまだこの段階に達していないなら、他の文書がお役に立てるでしょう。以下の記事を読んでからこのガイドに戻って来てください:

* [[Kernel/Overview|カーネルソースの概要の記事]]には Portage ツリーで利用可能なさまざまなカーネルソースパッケージの情報が含まれています。
* [[Kernel/Upgrade|カーネルのアップグレードの記事]]では、カーネルをアップグレードしたりあるカーネルから別のカーネルに切り替える方法を説明しています。
* Gentoo ハンドブックの[[Handbook:Main_Page|カーネル設定の節]]はカーネルのインストールの一側面を扱っています。適切なアーキテクチャを選択して"カーネルの設定"という節に移動してください。

== 設定の概念 ==

=== 基本 ===

一般的な過程は実際のところかなり単純です: 各メニューとサブメニューに分類された一連のオプションが提示され、希望するハードウェアサポートやそのシステムに関係のあるカーネルの機能を選択します。

カーネルはあるソースのセットについて menuconfig を初めて実行した時に提示される''デフォルト設定''を含んでいます。デフォルトは一般的に広汎で賢明ですので、ユーザーの多くは基本設定にわずかな変更を加えるだけで足ります。カーネルのデフォルト設定で有効化されているオプションを無効化しようとする場合には、そのオプションが正確に何をするのか、またそれを無効化した結果についてよく理解するようにしてください。 

初めての Linux カーネルの設定の間は、保守的であるように心がけ、冒険的になりすぎないようにし、またできるだけデフォルト設定へ加える変更を少なくするようにしましょう。同時に、システムの設定の中にはシステムが実際にブートできるようにするためカスタマイズしなければならない部分があることを覚えておいてください。

=== ビルトインかモジュールか ===

多くの設定オプションは''3つの状態''をとります: それらはまったくビルドしない <code>(N)</code> か、カーネル内に直接ビルドするか <code>(Y)</code>、またはモジュールとしてビルドするか <code>(M)</code> になります。ビルトインの項目はカーネルイメージ自体の中に直接ビルドされるのに対し、モジュールは外部のファイルシステムに保管されます。 

[[Kernel Modules|ビルトインとモジュール]]との間には重要な違いがあります: いくつかの例外はありますが、カーネルはシステムがモジュールを必要とするときでも一切のモジュールについてロードを全く試みません; いつモジュールをロードするか、あるいはいつロードしないかの決定はユーザーに委ねられています。システムの他のある部分には必要に応じてロードする機能があるかもしれませんし、自動的にモジュールをロードするユーティリティもいくつかありますが、ハードウェアサポートやカーネル機能はカーネル内に直接ビルドすることをおすすめします。そうすれば、カーネルは機能やハードウェアサポートを必要な時に利用可能にしておけます。これは、各カーネル機能を <code>(Y)</code> にセットすることで実現できます。こうした構成を一貫させるためには、カーネル内ファームウェアのサポートも含める必要があります。このためにはカーネルの {{Path|.config}} で <code>FW_LOADER=y</code> と <code>CONFIG_FIRMWARE_IN_KERNEL=y</code> をセットするか、または以下のようにします:

{{KernelBox|title=カーネル内ファームウェアを有功にする|
Device Drivers  --->
   Generic Driver Options  --->
       -*- Userspace firmware loading support
       [*] Include in-kernel firmware blobs in kernel binary
}}

設定の他の部分では、ビルトインが絶対的な要件になっています。たとえば root パーティションが btrfs ファイルシステムの場合、btrfs がモジュールとしてビルドされているとシステムはブートできません。(モジュールは root パーティションに保管されているため)システムは btrfs モジュールを探すために root パーティションを見なければなりませんが、btrfs サポートが既にロードされていない限り root パーティションは見られないのです！ btrfs がビルトインされていなければ init プロセスは root デバイスの探索に失敗するでしょう。

=== ハードウェアサポート ===

システムの''アーキテクチャタイプ''の検知よりほかには、設定ユーティリティは実際にシステムでどのようなハードウェアが提供されているか識別しません。''いくつか''のハードウェアサポートにはデフォルト設定がありますが、ほぼ間違いなくユーザーは各システムのハードウェア構成に関連する設定オプションを探し、選択する必要があります。 

適切な設定オプションを選択するにはコンピューター内部にある、あるいは接続されたコンポーネントの知識が必要になります。たいていの場合、これらのコンポーネントはシステムの蓋を開けることなく識別可能です。ほとんどの内部コンポーネントについては、ユーザーは販売時の製品名ではなく各デバイスで使われている''チップセット''を識別する必要があります。多くの拡張カードは一定のブランド名で売られていますが、他の製造業者のチップセットを使用しています。

ユーザーがどのカーネル設定オプションを使うか決める助けになるユーティリティーがいくつかあります。{{c|lspci}} ({{Package|sys-apps/pciutils}} パッケージの一部)はPCIおよびAGPベースのハードウェアを識別します。これにはマザーボード自体に内蔵されたコンポーネントも含まれます。{{c|lsusb}} ({{Package|sys-apps/usbutils}} パッケージにあります)はシステムのUSBポートに接続されたさまざまなデバイスを識別します。 

状況はハードウェアの世界における標準化の度合いによっていくらかわかりにくくなっています。ユーザーがデフォルト設定から極端に逸脱しようとしたのでなければ、IDE ハードディスクは　PS/2 や USB のキーボードとマウスと同様、''とにかく使える''はずです。基本的な VGA ディスプレイサポートも含まれています。しかしながら、イーサネットアダプターのようないくつかのデバイスはほとんど全く標準化されていません; これらのデバイスについては、ネットワークアクセスを得るためにはユーザーがイーサネットチップセットを識別し、特定のカードについて適切なハードウェアサポートを選択する必要があります。

加えて、いくつかのものはデフォルト設定で大体動作するものの、システムの潜在能力を引き出すためにはより特化したオプションを選択する必要があるでしょう。たとえば、適切な IDE チップセットのサポートが有効化されていないと IDE ハードディスクは''とても''低速に動作するでしょう。

=== カーネル機能 ===

ハードウェアサポートに加えて、ユーザーはカーネル内で必要なソフトウェア機能を決める必要があります。そのような機能の重要な一例はファイルシステムのサポートです: ユーザーは自身のハードディスクで使用しているファイルシステムのサポートを選択しなければいけません。外部ストレージデバイスで使用するファイルシステム(例: USB ドライブ上の VFAT)についても同様です。 

もう一つの一般的なソフトウェア機能の例は応用的なネットワーク機能です。ある種のルーティングやファイヤーウォールを行うには関連する設定項目をカーネル設定に含める必要があります。 

=== 準備はできましたか？ ===

これで概念は説明し終わりました。システムのハードウェアの識別、menuconfig インターフェースのブラウジング、そしてシステムに必要なカーネルオプションの選択を簡単に始められるはずです。 

このガイドの残りの部分では、一般的な混乱を解消し、どのようにしてユーザーがしばしば直面する一般的な問題を避けるかについての助言を提供します。皆さんの成功をお祈りしています！

== 一般的な問題と混乱 ==

=== SATA ディスクは SCSI です ===

最も現代的なデスクトップシステムは旧式な [https://en.wikipedia.org/wiki/Parallel_ATA IDE] (リボンケーブル) バスではなく[https://en.wikipedia.org/wiki/Serial_ATA Serial ATA] バスのストレージデバイス(ハードディスクや CD/DVD ドライブ)を備えています。 

Linux の SATA サポートは SCSI サブシステムの下に位置する ''libata'' と呼ばれるレイヤーで実装されています。このため、SATA ドライバーは設定の SCSI driver の項にあります。さらにシステムのストレージデバイスは SCSI デバイスとして扱われるため、SCSI ディスク/CDROM サポートも必要になります。最初の SATA ハードディスクは {{Path|/dev/sda}} と命名され、また最初の SATA CD/DVD ドライブは {{Path|/dev/sr0}} と命名されます。 

これらのドライバーの多くは SATA コントローラー向けですが、libata は SATA に特有のものとして設計されたわけではありません。すべての一般的な IDE ドライバーも近い将来に libata に移行するでしょう。その時点で上で述べた注意事項は IDE ユーザーにも適用されるようになります。 

{{KernelBox|title=libata用の設定オプション|1=
Device Drivers  --->
   SCSI device support  --->
      <*> SCSI device support
      <*> SCSI disk support
      <*> SCSI CDROM support
 
      [ ] SCSI low-level drivers  --->
 
   <*> Serial ATA and Parallel ATA drivers (libata)  --->
}}

{{Note|標準的でないチップセットは上の <code>Serial ATA and Parallel ATA drivers (libata)</code> カーネルボックスの中の <code>SCSI low-level drivers</code> の下にリストされています。}}

=== IDE チップセットと DMA ===

SATAの導入にもかかわらずIDE デバイスはいまだ非常に一般的であり、多くのシステムがこれを信頼しています。IDE はかなり汎用的な技術なので、Linux はほぼすべての IDE コントローラーをコントローラー特有のオプションが何も選択されていなくてもそのまま動作するようにサポートしています。 

しかしながら、IDE は古い技術であり初期の''Programmed Input/Output''を実現したものなので、現代のストレージデバイスへの高速なアクセスに必要な転送レートを提供できません。汎用 IDE ドライバーはこれらの PIO 通信モードに限定されているので、低速なデータ転送レートとディスクとの通信時の顕著に高い CPU 使用率をもたらします。 

ユーザーが1995年以前のシステムを取り扱っているのでない限り、IDE コントローラーは''Direct Memory Access (DMA)''として知られている代替の転送モードもサポートしているでしょう。DMA はとてもとても高速で、またデータ転送中であっても CPU の使用にほとんど影響しません。システムがIDEディスクを使用している際に全体的に本当に貧弱なパフォーマンスで悩まされている場合、おそらくDMAが使用されていないため有効化する必要があります。

{{Note|前に触れたように、libata は IDE ドライバーからも利用可能です。libata を使っている場合、IDE ドライブを含むすべてのドライブは DMA を使用しています。それ以上の確認や設定をする必要はありません。}}

IDE ディスクで libata を使用していない場合、DMA が使用されているか確認して有効化してください。以下のコマンドを使用して DMA が使用されているか判断できます:

{{RootCmd|hdparm -d /dev/hda|output=<pre>
/dev/hda:
 using_dma    =  0 (off)
</pre>
}}

DMA を古い IDE デバイス(非推奨になっている設定)で有効化するには、以下のカーネル機能を有効化します。

{{Warning|<var>CONFIG_BLK_DEV_IDE_SATA</var> を有効化すると libata SATA ドライバーと衝突します。活発にメンテナンスされている SCSI サブシステムの方がより適切に対応できるため、IDE コントローラーの SATA サポートは通常無効化されています。<var>CONFIG_BLK_DEV_IDE_SATA</var> を有効化することでこのドライバーが libata の SATA サポートと衝突しますから、これは通常まずい考えです。このドライバーは古い IDE ドライブを処理するために存在するものです、可能であれば SATA の処理は libata に任せておきましょう！}}

{{KernelBox|title=非推奨の IDE コントローラー用の設定オプション|1=
Device Drivers  --->
   <*> ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
      --- ATA/ATAPI/MFM/RLL support (DEPRECATED)
      [ ]   Support for SATA (deprecated; conflicts with libata SATA driver)
      <*>   generic ATA/ATAPI disk support
      [*]     ATA disk support
      [*]     ATAPI floppy support
      <*>   Include IDE/ATAPI CDROM support
      <*>   Include IDE/ATAPI TAPE support
  
            *** IDE chipset support/bugfixes ***
      <*>   generic/default IDE chipset support
  
            *** PCI IDE chipsets support ***
}}

{{Note|上の ''Configuration options for IDE controllers'' カーネルボックス内の <code>*** PCI IDE chipset support ***</code> の下にリストされている選択肢の中から正しいチップセットを選択してください。}}

=== USB ホストコントローラー ===

[[USB]] はコンピューターに外部周辺機器を接続するために広く採用されているバスです。USB の成功の背後にある理由の一つはそれが標準化されたプロトコルであることですが、ホストコンピューターで実装されている USB ''host controller devices (HCDs)'' には少し違いがあります。
主に4つの種類があります: 

# <code>UHCI</code> は Universal Host Controller Interface です。USB 1.1 をサポートしており、通常は VIA や Intel のチップセットベースのマザーボードで見つけることができます。
# <code>OHCI</code> は Open Host Controller Interface です。USB 1.1 をサポートしており、通常は Nvidia や SiS のチップセットベースのマザーボードで見つけることができます。
# <code>EHCI</code> は Extended Host Controller Interface です。USB 2.0 をサポートするために広く使われている唯一のホストコントローラーであり、概して USB 2.0 をサポートするあらゆるコンピューターで見つけることができます。
# <code>XHCI</code> は eXtensible Host Controller Interface です。USB 3.0 用のホストコントローラーであり、USB 1.0、1.1、2.0、3.0 および次世代のスピードと互換性があります。ボードがUSB 3.0 をサポートしている場合これを選択してください。

多くのシステムは上記のインターフェースのうち2つを持っています: XHCI (USB 3.0) ''および'' EHCI (USB 2.0) です。XHCI はより低速な USB コントローラーと互換性があるので、USB デバイスを使うために両方のオプションを選択する必要はもはやありません。ユーザーは更なる安全のために EHCI も有効化することができます; USB 2.0 コントローラーがなくてもこれによる害はありません。

システムで提供されている USB HCD に対応する関連オプションが選択されていない場合、'死んだ' USB ポートを体験することになるでしょう。動作している USB デバイスを挿しても電源が入らなかったりどうしても反応しないなら、このケースだと判断できます。 

{{c|lspci}}({{Package|sys-apps/pciutils}}に含まれます) を使ったうまいやり方で、どの HCD がシステムで提供されているか比較的簡単に調べることができます。同様にマッチした SATA コントローラーを無視すれば、このシステムが EHCI や XHCI のサポートを必要としているか見分けるのは簡単です:

{{RootCmd|lspci -v {{!}} grep HCI|output=<pre>
00:14.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB xHCI (rev 04) (prog-if 30 [XHCI])
00:1a.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #2 (rev 04) (prog-if 20 [EHCI])
00:1d.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #1 (rev 04) (prog-if 20 [EHCI])
00:1f.2 SATA controller: Intel Corporation 8 Series/C220 Series Chipset Family 6-port SATA Controller 1 [AHCI mode] (rev 04) (prog-if 01 [AHCI 1.0])
</pre>
}}

システムで提供されている HCD を選択します。一般的に、最大のサポートを得るためには、あるいは正しいオプションが不確かな場合には、3つのオプションすべてを選択してください:

{{KernelBox|title=[[USB#Kernel_Configuration|USB HCD の設定]]|1=
Device Drivers  --->
   USB support  --->
      <*> Support for Host-side USB
      ---   USB Host Controller Drivers
      <*>   xHCI HCD (USB 3.0) support
      <*>   EHCI HCD (USB 2.0) support
      < >   OHCI HCD  (USB 1.1) support
      < >   UHCI HCD (most Intel and VIA) support
}}

Linux カーネル 3.12.13 以降では、USB コントローラーが OHCI でかつ USB キーボードやマウスを使用するなら <code>OHCI support for PCI-bus USB controllers</code> (<code>USB_OHCI_HCD_PCI</code>)を有効にする必要があります。

=== マルチプロセッサー、ハイパースレッディングおよびマルチコアシステム ===

多くのコンピューターシステムは複数のプロセッサーをベースにしていますが、必ずしもすぐにそれとわかるというわけではありません。 

* Intel の CPU の多くは彼らが[https://en.wikipedia.org/wiki/Hyper-threading ハイパースレッディング]と呼ぶ技術をサポートしています。この技術は1つの CPU をシステムからは2つの''論理''プロセッサーに見せることができます。
* ほとんどの Intel/AMD の CPU は実際には1つのパッケージの中にある複数の物理プロセッサーから構成されており、こうしたプロセッサーは[https://en.wikipedia.org/wiki/Multi-core_processor マルチコア]プロセッサーとして知られています。
* いくつかのハイエンドなコンピューターシステムでは、''ユニプロセッサー''システムに比べ顕著なパフォーマンスの改善を提供するために実際に複数の物理プロセッサーが特殊なマザーボード上にインストールされています。安価なものではないので、システムユーザーはこのようなシステムを持っていればおそらくそのことをわかっているでしょう。

これらすべてのケースで、構成から最適なパフォーマンスを得るためには適切なカーネルオプションを選択する必要があります:

{{KernelBox|title=マルチプロセッシングサポート用の設定|1=
Processor type and features  --->
 [*] Symmetric multi-processing support
 [*]   SMT (Hyperthreading) scheduler support
 [*]   Multi-core scheduler support (NEW)
}}

次のオプションは電源管理機能を有効化するだけでなく、すべての CPU をシステムで利用可能にするための必要条件でもあります:

{{KernelBox|title=マルチプロセッサーシステム用の電源管理|1=
Power management and ACPI options  --->
 [*] ACPI (Advanced Configuration and Power Interface) Support
}}

=== x86 大容量メモリーのサポート ===

{{Keyword|x86}} アーキテクチャの32ビットアドレス空間の制約のため、デフォルト設定のカーネルは最大896MBの RAM しかサポートできません。大容量メモリーサポートが有効化されていない限り、システムがもっと大容量のメモリーを搭載していても見えるのは最初の896MBのみです。 

{{Note|この制約は {{Keyword|x86}} (IA32)アーキテクチャに特有のものです。他のアーキテクチャは設定の微調整の必要なしに大量のメモリを本来サポートしています。}}

大容量メモリーのサポートはシステムにわずかなオーバーヘッドをもたらすため、デフォルトでは有効になっていません。これに惑わされないでください、このオーバーヘッドはより多くのメモリーが使用可能になることによるパフォーマンスの改善に比べれば些細なことです！ 

システムに4GBを超えるメモリーがあるのでなければ、4GBのオプションを選択しましょう:

{{KernelBox|title=x86 での大容量メモリーのサポートを有効にする|1=
Processor type and features  --->
 High Memory Support  --->
  (X) 4GB
  ( ) 64GB
}}

=== 圧縮されたカーネルモジュール ===

カーネルのバージョン 3.18.x (以上)では、カーネルモジュールの圧縮が可能になっています。gzip と xz 圧縮が利用できます。カーネルを圧縮されたモジュールありでコンパイルする''前に''、適切な USE フラグと共に {{Package|sys-apps/kmod}} を emerge することが重要です:

{{FileBox|filename=/etc/portage/package.use|title=kmod の圧縮サポートを有功にする|1=
sys-apps/kmod lzma zlib
}}

{{Package|sys-apps/kmod}}を再度 emerge します:

{{Emerge|params+=--oneshot --changed-use|sys-apps/kmod}}

モジュールの圧縮を有効化し、希望する圧縮方法を選択します:
{{KernelBox|title=モジュールの圧縮を有功にする|1=
Enable loadable module support --->
  [*]   Compress modules on installation
  Compression algorithm ()  --->
    <X> GZIP
        XZ
}}

通常、{{c|make modules_install}} は {{c|depmod}} を実行します。初めて実行したときに {{Package|sys-apps/kmod}} で適切な USE フラグがセットされていない(上の {{Path|package.use}} の手順を参照)場合、依存関係リストは空になります。したがって、システムは圧縮ビルドされたすべてのモジュールをロードできなくなるでしょう。

この問題への解決策として、kmod を再コンパイルした後 {{c|depmod}} を再実行してください:

{{RootCmd|depmod -a
|modprobe <module_name>
}}

== カーネル設定の略記法 ==

=== はじめに ===

カーネル設定についての文章を読んでみると、しばしば設定が <var>CONFIG_<something></var> のように表記されています。この略記法はカーネル設定の内部で実際に使用されているもので、カーネルの設定ファイル({{Path|/usr/src/linux/.config}} か、または自動生成された {{Path|/proc/config.gz}} の中にあります)でも見られるものです。もちろん、略記法の使用はそれをカーネル設定の中の実際の場所に変換できなければあまり役には立ちません。{{c|make menuconfig}} ツールではそれが可能です。

=== CONFIG_FOO を現実の設定の位置に変換する ===

<var>CONFIG_TMPFS_XATTR</var> という機能を有効化する必要があると仮定しましょう。カーネル設定メニューを起動し({{c|make menuconfig}})、{{Key|/}} キーを押します。これで検索ボックスが開くはずです。検索ボックスに <var>CONFIG_TMPFS_XATTR</var> と打ち込んでください。 

以下はその検索結果の出力です:

{{KernelBox|title="CONFIG_TMPFS_XATTR"をmenuconfigで検索した結果|1=
Symbol: TMPFS_XATTR [=n]
Type  : boolean
Prompt: Tmpfs extended attributes
  Defined at fs/Kconfig:138
  Depends on: TMPFS [=y]
  Location:
    -> File systems
      -> Pseudo filesystems
(1)     -> Virtual memory file system support (former shm fs) (TMPFS [=y])
  Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
}}

この出力は多くの興味深い情報をもたらしてくれます。

{| class="table table-condensed table-striped" style="text-align: left;" 
|- 
! 記載
! 詳細
|- 
| Symbol: TMPFS_XATTR [=n]
| 検索されたカーネルの設定項目を識別します。この設定が現在''有効になっていない'' ([=n])ことも表示されています。
|- 
| Type: boolean
| 検索された設定は boolean (つまり、この設定は2つのオプションのいずれかになります: 有効か、無効か)です。いくつかの設定は数値や文字列です。
|- 
| Prompt: Tmpfs extended attributes
| {{Path|.config}} ファイルの変数(<var>TMPFS_XATTR</var>)を制御する {{c|make menuconfig}} の項目に表示されるテキストです。これは本質的に、より人間にとって読みやすい形式の変数名です。
|- 
| Depends on: TMPFS [=y]
| この項目が見られるようにするには <var>CONFIG_TMPFS</var> を有功にする必要があります。今回は([=y]となっているので)既にそうなっていますが、そうでない場合はまず <var>CONFIG_TMPFS</var> を探す(そして有功にする)必要があります。
|- 
| Location: ...
| {{c|make menuconfig}} の構造の中でこの設定が見つかる位置です。探している設定は ''Tmpfs extended attributes'' であることを覚えておいてください。
|- 
| Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
| ここに記されている設定がいずれも有効になっている場合(今回は1つ目がそうなっていません)、<var>CONFIG_TMPFS_XATTR</var> は自動的に有効になり、これらの設定の1つが無効化されない限り''無効''にすることはできなくなります。
|-
|}

この情報を使って、すべての必要な <var>CONFIG_*</var> をかなり簡単に変換できるはずです。要するに、ユーザーは以下の事をしなければなりません:

# ''Depends on'' フィールドに記されている設定を有効化する
# ''Location:'' が指す場所に移動する
# ''Prompt:'' で参照されている値を切り替える

{{Tip|括弧の中にある数字を見てください; ユーザーは検索中にその番号を押すことでそのオプションまたは有効化されたメニューのなるべく近くにジャンプできます。上の例では、キーボードの {{Key|1}} を押すとそのオプションの近くにジャンプします。}}

== 他のカーネル設定についての文書 ==

ここまで、一般的な概念とカーネル設定に関連した特定の問題までしか説明していません: より正確な詳細はユーザーの探索に委ねられています。しかしながら、Gentoo のドキュメントコレクションの他の文書は手近な話題に特化した詳細を提供しています。

こうした文書はカーネルの特定分野を設定する際に役に立つかもしれません。このガイドで既に触れた警告ではありますが、もう一度思い出してください: カーネル設定に慣れていないユーザーは設定を試みるにあたって冒険的にならないようにしましょう。まずは基本的なシステムを立ち上げ走らせることから始めてください、オーディオや印刷その他のサポートは後でいつでも追加できます。

カーネルの基礎部分を使用できるようにすることで、ユーザーは何をするとシステムが壊れるか、また何ならそうならないかがわかるようになるので、後ほどの設定過程で助けになるでしょう。新しい機能やハードウェアを追加する''前に''基本の(動作する)カーネル設定をカーネルのソールフォルダー以外のフォルダーに保存しておくのは、常に賢明なことです。  

* [[ALSA|ALSA の記事]]はサウンドカードのサポートに必要な設定オプションを詳しく説明しています。ALSA は、モジュールとしてビルドしないというスキームの例外であることに注意してください: ALSA は実際のところモジュールになっている方が設定がはるかに簡単になります。

* [[Bluetooth|Bluetooth の記事]]では Bluetooth デバイスを使用するために必要なオプションが詳細に解説されています。

* [[IPv6 router guide]] では、カーネルを次世代のネットワークアドレススキームを使ったルーティング用に設定する方法を説明しています。

* 3Dグラフィックの性能を改善するために nVidia のクローズドソースのグラフィックドライバーを使うなら、[[NVidia/nvidia-drivers|nVidia Guide]] がそうしたシステムで選択すべき、あるいはすべきでないオプションをリストしています。

* Amongst other things, the [[Power_management/Guide|Power Management guide]] explains how to configure the kernel for CPU frequency scaling, and for suspend and hibernate functionality.

* If running a PowerPC system, the [[PPC/FAQ|PPC FAQ]] has a few sections about PPC kernel configuration.

* The [[Printing|Printing guide]] lists the kernel options needed to support printing in Linux.

* The [[USB/Guide|USB Guide]] details the configuration settings required to use common USB devices such as keyboards, mice, storage devices, and USB printers.

== トラブルシューティング ==

=== Configuration changes do not take effect ===

It is very common for users to make a configuration change, but then make a small mistake in the process of actually booting to their newly configured kernel. They reboot into a kernel image that is not the one they just reconfigured, observe that whatever problem they were trying to solve is still present, and conclude that the configuration change does not solve the problem. 

The process of compiling and installing kernels is outside the scope of this document; refer to the [[Kernel/Upgrade|Kernel Upgrade Guide]] for general guidance. In short, the process to get a modified kernel is the following: 1) configure, 2) compile, 3) mount {{Path|/boot}} (if not already mounted), 4) copy new kernel image to {{Path|/boot}}, 5) Make sure the bootloader will reference the new kernel, 6) reboot. If one of those final stages has been missed, then the changes will not properly take effect.

It is possible to verify if the kernel that has booted matches the newly kernel compiled on the hard disk. This is performed by examining the date and time of the kernel's compilation. Assuming the system architecture is {{Keyword|x86}} and the kernel sources are installed at {{Path|/usr/src/linux}}, the following command can be used:

{{RootCmd|uname -v|output=<pre>
#4 SMP PREEMPT Sat Jul 15 08:49:26 BST 2006
</pre>}}

The above command will display the date and time the currently booted kernel was compiled.

{{RootCmd|ls -l /usr/src/linux/arch/i386/boot/bzImage|output=<pre>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
</pre>}}

The above command displays the date and time that the kernel image on the hard disk was last compiled.

If the time stamps from the above commands differ by more than 2 minutes, it indicates a mistake was made during kernel reinstallation and the system has not booted from the newly modified kernel image.

=== Modules do not get loaded automatically ===

As mentioned earlier in this document, the kernel configuration system hides a large behavioral change when selecting a kernel component as a module <code>(M)</code> rather than built-in <code>(Y)</code>. It is worth repeating this again because so many users fall into this trap.

When selecting a component as built-in, the code is built into the kernel image (bzImage). When the kernel needs to use that component, it can initialize and load it automatically, without any user intervention. 

When selecting a component as a module, the code is built into a kernel module file and installed on the filesystem. In general, when the kernel needs to use that component, it will not be able to find it. With some exceptions, the kernel makes no effort to actually load these modules — this task is left up to the user. 

If building support for a network card as a module, and it is discovered the network is not accessible, it is probably because the module is not loaded — either this must be done manually or the system must be configured to autoload the module at boot time.

Unless a user has reason to do otherwise, some time can be saved by building these components directly into the kernel image, so that the kernel can automatically configure these small settings by itself.

== 参考 ==

* [[genkernel]] - A tool used to automate the build process of the kernel and initramfs.
* [[Security_Handbook/Network_security#The proc filesystem|proc filesystem (Security Handbook)]] - Dynamically change kernel parameters and variables on the fly.


[[Category:Kernel]] [[Category:Server and Security]] {{Migrated|originalauthors=Daniel Drake, Curtis Napier, Justin Robinson, Lukasz Damentko, Jonathan Smith, nightmorph}}
