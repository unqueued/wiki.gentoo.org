<languages />


{{Metadata|abstract=この文書では、手動のカーネル設定の概念を紹介することを目的と最も一般的な設定の落とし穴のいくつかを詳しく説明します。}}

この文書は手動でのカーネル設定の概念を紹介することを目的とし、また最も一般的な設定の落とし穴のいくつかを詳しく説明します。

== はじめに ==

Gentoo はカーネルの設定、インストール、アップグレードを処理する2つの方法をユーザーに提供します: ''自動''(genkernel)と''手動''です。自動的な方法がほとんどのユーザーにとってより容易であると考えられるにもかかわらず、Gentooユーザーの多くがカーネルの手動設定を選ぶのにはたくさんの理由があります:

# よりよい柔軟性
# より小さな(カーネルの)サイズ
# より短いコンパイル時間
# 学習経験
# ひどい退屈
# カーネル設定の絶対的な知識
# 完全なコントロール

このガイドでは自動的な方法(genkernel)は扱いません。genkernel を使った方法でカーネル関係のことを処理したい場合は、[[Genkernel|Genkernel の記事]]に進んで詳細を確認してください。 

このガイドは手動設定の過程を始まりから終わりまですべて文書化することは意図していません - 設定の過程は常識や使っているシステムについての相対的に高度な技術的知識に大いに依存しているからです。その代わりに、このガイドでは手動設定の概念を紹介し、またユーザーが直面するもっとも一般的な落とし穴について詳細を説明します。 

{{Note|このガイドは、最近のカーネルについて一般的なコンピューターアーキテクチャを念頭において執筆されています。より古いカーネルやより珍しいアーキテクチャではいくつかの詳細は異なっているかもしれません; しかしながら、内容の多くはその場合でもあてはまります。}}

この時点で、ユーザーは解凍済みの Linux kernel のソースをハードディスク(通常は {{Path|/usr/src}} の下のどこか)に持っているものと推定します。また、{{c|menuconfig}} 設定ユーティリティに入る方法や ncurses ベースのメニューシステム内を移動する方法を知っていることが期待されます。ユーザーがまだこの段階に達していないなら、他の文書がお役に立てるでしょう。以下の記事を読んでからこのガイドに戻って来てください:

* [[Kernel/Overview|カーネルソースの概要の記事]]には Portage ツリーで利用可能なさまざまなカーネルソースパッケージの情報が含まれています。
* [[Kernel/Upgrade|カーネルのアップグレードの記事]]では、カーネルをアップグレードしたりあるカーネルから別のカーネルに切り替える方法を説明しています。
* Gentoo ハンドブックの[[Handbook:Main_Page|カーネル設定の節]]はカーネルのインストールの一側面を扱っています。適切なアーキテクチャを選択して"カーネルの設定"という節に移動してください。

== 設定の概念 ==

=== 基本 ===

一般的な過程は実際のところかなり単純です: 各メニューとサブメニューに分類された一連のオプションが提示され、希望するハードウェアサポートやそのシステムに関係のあるカーネルの機能を選択します。

カーネルはあるソースのセットについて menuconfig を初めて実行した時に提示される''デフォルト設定''を含んでいます。デフォルトは一般的に広汎で賢明ですので、ユーザーの多くは基本設定にわずかな変更を加えるだけで足ります。カーネルのデフォルト設定で有効化されているオプションを無効化しようとする場合には、そのオプションが正確に何をするのか、またそれを無効化した結果についてよく理解するようにしてください。 

初めての Linux カーネルの設定の間は、保守的であるように心がけ、冒険的になりすぎないようにし、またできるだけデフォルト設定へ加える変更を少なくするようにしましょう。同時に、システムの設定の中にはシステムが実際にブートできるようにするためカスタマイズしなければならない部分があることを覚えておいてください。

=== ビルトインかモジュールか ===

多くの設定オプションは''3つの状態''をとります: それらはまったくビルドしない <code>(N)</code> か、カーネル内に直接ビルドするか <code>(Y)</code>、またはモジュールとしてビルドするか <code>(M)</code> になります。ビルトインの項目はカーネルイメージ自体の中に直接ビルドされるのに対し、モジュールは外部のファイルシステムに保管されます。 

[[Kernel Modules|ビルトインとモジュール]]との間には重要な違いがあります: いくつかの例外はありますが、カーネルはシステムがモジュールを必要とするときでも一切のモジュールについてロードを全く試みません; いつモジュールをロードするか、あるいはいつロードしないかの決定はユーザーに委ねられています。システムの他のある部分には必要に応じてロードする機能があるかもしれませんし、自動的にモジュールをロードするユーティリティもいくつかありますが、ハードウェアサポートやカーネル機能はカーネル内に直接ビルドすることをおすすめします。そうすれば、カーネルは機能やハードウェアサポートを必要な時に利用可能にしておけます。これは、各カーネル機能を <code>(Y)</code> にセットすることで実現できます。こうした構成を一貫させるためには、カーネル内ファームウェアのサポートも含める必要があります。このためにはカーネルの {{Path|.config}} で <code>FW_LOADER=y</code> と <code>CONFIG_FIRMWARE_IN_KERNEL=y</code> をセットするか、または以下のようにします:

{{KernelBox|title=カーネル内ファームウェアを有功にする|
Device Drivers  --->
   Generic Driver Options  --->
       -*- Userspace firmware loading support
       [*] Include in-kernel firmware blobs in kernel binary
}}

設定の他の部分では、ビルトインが絶対的な要件になっています。たとえば root パーティションが btrfs ファイルシステムの場合、btrfs がモジュールとしてビルドされているとシステムはブートできません。(モジュールは root パーティションに保管されているため)システムは btrfs モジュールを探すために root パーティションを見なければなりませんが、btrfs サポートが既にロードされていない限り root パーティションは見られないのです！ btrfs がビルトインされていなければ init プロセスは root デバイスの探索に失敗するでしょう。

=== ハードウェアサポート ===

システムの''アーキテクチャタイプ''の検知よりほかには、設定ユーティリティは実際にシステムでどのようなハードウェアが提供されているか識別しません。''いくつか''のハードウェアサポートにはデフォルト設定がありますが、ほぼ間違いなくユーザーは各システムのハードウェア構成に関連する設定オプションを探し、選択する必要があります。 

適切な設定オプションを選択するにはコンピューター内部にある、あるいは接続されたコンポーネントの知識が必要になります。たいていの場合、これらのコンポーネントはシステムの蓋を開けることなく識別可能です。ほとんどの内部コンポーネントについては、ユーザーは販売時の製品名ではなく各デバイスで使われている''チップセット''を識別する必要があります。多くの拡張カードは一定のブランド名で売られていますが、他の製造業者のチップセットを使用しています。

ユーザーがどのカーネル設定オプションを使うか決める助けになるユーティリティーがいくつかあります。{{c|lspci}} ({{Package|sys-apps/pciutils}} パッケージの一部)はPCIおよびAGPベースのハードウェアを識別します。これにはマザーボード自体に内蔵されたコンポーネントも含まれます。{{c|lsusb}} ({{Package|sys-apps/usbutils}} パッケージにあります)はシステムのUSBポートに接続されたさまざまなデバイスを識別します。 

状況はハードウェアの世界における標準化の度合いによっていくらかわかりにくくなっています。ユーザーがデフォルト設定から極端に逸脱しようとしたのでなければ、IDE ハードディスクは　PS/2 や USB のキーボードとマウスと同様、''とにかく使える''はずです。基本的な VGA ディスプレイサポートも含まれています。しかしながら、イーサネットアダプターのようないくつかのデバイスはほとんど全く標準化されていません; これらのデバイスについては、ネットワークアクセスを得るためにはユーザーがイーサネットチップセットを識別し、特定のカードについて適切なハードウェアサポートを選択する必要があります。

加えて、いくつかのものはデフォルト設定で大体動作するものの、システムの潜在能力を引き出すためにはより特化したオプションを選択する必要があるでしょう。たとえば、適切な IDE チップセットのサポートが有効化されていないと IDE ハードディスクは''とても''低速に動作するでしょう。

=== カーネル機能 ===

ハードウェアサポートに加えて、ユーザーはカーネル内で必要なソフトウェア機能を決める必要があります。そのような機能の重要な一例はファイルシステムのサポートです: ユーザーは自身のハードディスクで使用しているファイルシステムのサポートを選択しなければいけません。外部ストレージデバイスで使用するファイルシステム(例: USB ドライブ上の VFAT)についても同様です。 

もう一つの一般的なソフトウェア機能の例は応用的なネットワーク機能です。ある種のルーティングやファイヤーウォールを行うには関連する設定項目をカーネル設定に含める必要があります。 

=== 準備はできましたか？ ===

これで概念は説明し終わりました。システムのハードウェアの識別、menuconfig インターフェースのブラウジング、そしてシステムに必要なカーネルオプションの選択を簡単に始められるはずです。 

このガイドの残りの部分では、一般的な混乱を解消し、どのようにしてユーザーがしばしば直面する一般的な問題を避けるかについての助言を提供します。皆さんの成功をお祈りしています！

== 一般的な問題と混乱 ==

=== SATA ディスクは SCSI です ===

最も現代的なデスクトップシステムは旧式な [https://en.wikipedia.org/wiki/Parallel_ATA IDE] (リボンケーブル) バスではなく[https://en.wikipedia.org/wiki/Serial_ATA Serial ATA] バスのストレージデバイス(ハードディスクや CD/DVD ドライブ)を備えています。 

Linux の SATA サポートは SCSI サブシステムの下に位置する ''libata'' と呼ばれるレイヤーで実装されています。このため、SATA ドライバーは設定の SCSI driver の項にあります。さらにシステムのストレージデバイスは SCSI デバイスとして扱われるため、SCSI ディスク/CDROM サポートも必要になります。最初の SATA ハードディスクは {{Path|/dev/sda}} と命名され、また最初の SATA CD/DVD ドライブは {{Path|/dev/sr0}} と命名されます。 

これらのドライバーの多くは SATA コントローラー向けですが、libata は SATA に特有のものとして設計されたわけではありません。すべての一般的な IDE ドライバーも近い将来に libata に移行するでしょう。その時点で上で述べた注意事項は IDE ユーザーにも適用されるようになります。 

{{KernelBox|title=libata用の設定オプション|1=
Device Drivers  --->
   SCSI device support  --->
      <*> SCSI device support
      <*> SCSI disk support
      <*> SCSI CDROM support
 
      [ ] SCSI low-level drivers  --->
 
   <*> Serial ATA and Parallel ATA drivers (libata)  --->
}}

{{Note|標準的でないチップセットは上の <code>Serial ATA and Parallel ATA drivers (libata)</code> カーネルボックスの中の <code>SCSI low-level drivers</code> の下にリストされています。}}

=== IDE チップセットと DMA ===

SATAの導入にもかかわらずIDE デバイスはいまだ非常に一般的であり、多くのシステムがこれを信頼しています。IDE はかなり汎用的な技術なので、Linux はほぼすべての IDE コントローラーをコントローラー特有のオプションが何も選択されていなくてもそのまま動作するようにサポートしています。 

しかしながら、IDE は古い技術であり初期の''Programmed Input/Output''を実現したものなので、現代のストレージデバイスへの高速なアクセスに必要な転送レートを提供できません。汎用 IDE ドライバーはこれらの PIO 通信モードに限定されているので、低速なデータ転送レートとディスクとの通信時の顕著に高い CPU 使用率をもたらします。 

ユーザーが1995年以前のシステムを取り扱っているのでない限り、IDE コントローラーは''Direct Memory Access (DMA)''として知られている代替の転送モードもサポートしているでしょう。DMA はとてもとても高速で、またデータ転送中であっても CPU の使用にほとんど影響しません。システムがIDEディスクを使用している際に全体的に本当に貧弱なパフォーマンスで悩まされている場合、おそらくDMAが使用されていないため有効化する必要があります。

{{Note|前に触れたように、libata は IDE ドライバーからも利用可能です。libata を使っている場合、IDE ドライブを含むすべてのドライブは DMA を使用しています。それ以上の確認や設定をする必要はありません。}}

IDE ディスクで libata を使用していない場合、DMA が使用されているか確認して有効化してください。以下のコマンドを使用して DMA が使用されているか判断できます:

{{RootCmd|hdparm -d /dev/hda|output=<pre>
/dev/hda:
 using_dma    =  0 (off)
</pre>
}}

DMA を古い IDE デバイス(非推奨になっている設定)で有効化するには、以下のカーネル機能を有効化します。

{{Warning|<var>CONFIG_BLK_DEV_IDE_SATA</var> を有効化すると libata SATA ドライバーと衝突します。活発にメンテナンスされている SCSI サブシステムの方がより適切に対応できるため、IDE コントローラーの SATA サポートは通常無効化されています。<var>CONFIG_BLK_DEV_IDE_SATA</var> を有効化することでこのドライバーが libata の SATA サポートと衝突しますから、これは通常まずい考えです。このドライバーは古い IDE ドライブを処理するために存在するものです、可能であれば SATA の処理は libata に任せておきましょう！}}

{{KernelBox|title=非推奨の IDE コントローラー用の設定オプション|1=
Device Drivers  --->
   <*> ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
      --- ATA/ATAPI/MFM/RLL support (DEPRECATED)
      [ ]   Support for SATA (deprecated; conflicts with libata SATA driver)
      <*>   generic ATA/ATAPI disk support
      [*]     ATA disk support
      [*]     ATAPI floppy support
      <*>   Include IDE/ATAPI CDROM support
      <*>   Include IDE/ATAPI TAPE support
  
            *** IDE chipset support/bugfixes ***
      <*>   generic/default IDE chipset support
  
            *** PCI IDE chipsets support ***
}}

{{Note|上の ''Configuration options for IDE controllers'' カーネルボックス内の <code>*** PCI IDE chipset support ***</code> の下にリストされている選択肢の中から正しいチップセットを選択してください。}}

=== USB ホストコントローラー ===

[[USB]] はコンピューターに外部周辺機器を接続するために広く採用されているバスです。USB の成功の背後にある理由の一つはそれが標準化されたプロトコルであることですが、ホストコンピューターで実装されている USB ''host controller devices (HCDs)'' には少し違いがあります。
主に4つの種類があります: 

# <code>UHCI</code> は Universal Host Controller Interface です。USB 1.1 をサポートしており、通常は VIA や Intel のチップセットベースのマザーボードで見つけることができます。
# <code>OHCI</code> は Open Host Controller Interface です。USB 1.1 をサポートしており、通常は Nvidia や SiS のチップセットベースのマザーボードで見つけることができます。
# <code>EHCI</code> は Extended Host Controller Interface です。USB 2.0 をサポートするために広く使われている唯一のホストコントローラーであり、概して USB 2.0 をサポートするあらゆるコンピューターで見つけることができます。
# <code>XHCI</code> は eXtensible Host Controller Interface です。USB 3.0 用のホストコントローラーであり、USB 1.0、1.1、2.0、3.0 および次世代のスピードと互換性があります。ボードがUSB 3.0 をサポートしている場合これを選択してください。

多くのシステムは上記のインターフェースのうち2つを持っています: XHCI (USB 3.0) ''および'' EHCI (USB 2.0) です。XHCI はより低速な USB コントローラーと互換性があるので、USB デバイスを使うために両方のオプションを選択する必要はもはやありません。ユーザーは更なる安全のために EHCI も有効化することができます; USB 2.0 コントローラーがなくてもこれによる害はありません。

システムで提供されている USB HCD に対応する関連オプションが選択されていない場合、'死んだ' USB ポートを体験することになるでしょう。動作している USB デバイスを挿しても電源が入らなかったりどうしても反応しないなら、このケースだと判断できます。 

{{c|lspci}}({{Package|sys-apps/pciutils}}に含まれます) を使ったうまいやり方で、どの HCD がシステムで提供されているか比較的簡単に調べることができます。同様にマッチした SATA コントローラーを無視すれば、このシステムが EHCI や XHCI のサポートを必要としているか見分けるのは簡単です:

{{RootCmd|lspci -v {{!}} grep HCI|output=<pre>
00:14.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB xHCI (rev 04) (prog-if 30 [XHCI])
00:1a.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #2 (rev 04) (prog-if 20 [EHCI])
00:1d.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #1 (rev 04) (prog-if 20 [EHCI])
00:1f.2 SATA controller: Intel Corporation 8 Series/C220 Series Chipset Family 6-port SATA Controller 1 [AHCI mode] (rev 04) (prog-if 01 [AHCI 1.0])
</pre>
}}

システムで提供されている HCD を選択します。一般的に、最大のサポートを得るためには、あるいは正しいオプションが不確かな場合には、3つのオプションすべてを選択してください:

{{KernelBox|title=[[USB#Kernel_Configuration|USB HCD の設定]]|1=
Device Drivers  --->
   USB support  --->
      <*> Support for Host-side USB
      ---   USB Host Controller Drivers
      <*>   xHCI HCD (USB 3.0) support
      <*>   EHCI HCD (USB 2.0) support
      < >   OHCI HCD  (USB 1.1) support
      < >   UHCI HCD (most Intel and VIA) support
}}

Linux カーネル 3.12.13 以降では、USB コントローラーが OHCI でかつ USB キーボードやマウスを使用するなら <code>OHCI support for PCI-bus USB controllers</code> (<code>USB_OHCI_HCD_PCI</code>)を有効にする必要があります。

=== マルチプロセッサー、ハイパースレッディングおよびマルチコアシステム ===

多くのコンピューターシステムは複数のプロセッサーをベースにしていますが、必ずしもすぐにそれとわかるというわけではありません。 

* Many of Intel's CPUs support a technology which they call [https://en.wikipedia.org/wiki/Hyper-threading hyper-threading]. This technology enables a single CPU to be viewed by the system as two ''logical'' processors.
* Most Intel/AMD CPUs actually consist of multiple physical processors inside a single package, these processors are known as [https://en.wikipedia.org/wiki/Multi-core_processor multi-core] processors.
* Some high-end computer systems actually have multiple physical processors installed on specialized motherboards to provide a significant performance increase over a ''uniprocessor'' system. System users will probably know if they have such a system, since they are not cheap.

In all of these cases, the appropriate kernel options must be selected to obtain optimum performance from these setups:

{{KernelBox|title=Configuration for multi-processing support|1=
Processor type and features  --->
 [*] Symmetric multi-processing support
 [*]   SMT (Hyperthreading) scheduler support
 [*]   Multi-core scheduler support (NEW)
}}

The next option not only enables power management features, but might also be a requirement for making all CPUs available to the system:

{{KernelBox|title=Power management for multi-processor systems|1=
Power management and ACPI options  --->
 [*] ACPI (Advanced Configuration and Power Interface) Support
}}

=== x86 High Memory support ===

Due to limitations in the 32-bit address space of the {{Keyword|x86}} architecture, a kernel with default configuration can only support up to 896 MB RAM. If a system has more memory, only the first 896 MB will be visible, unless high memory support has been enabled. 

{{Note|This limitation is specific to the {{Keyword|x86}} (IA32) architecture. Other architectures naturally support large amounts of memory, with no configuration tweaks required.}}

High memory support is not enabled by default, because it introduces a small system overhead. Do not be distracted by this, the overhead is insignificant when compared to the performance increase of having more memory available! 

Choose the 4 GB option, unless the system has more than 4 GB of RAM:

{{KernelBox|title=Enabling high memory support on x86|1=
Processor type and features  --->
 High Memory Support  --->
  (X) 4GB
  ( ) 64GB
}}

=== Compressed kernel modules ===

From kernel version 3.18.x (and up) compression of kernel modules has been possible. gzip and xz compression are available. It is important to emerge {{Package|sys-apps/kmod}} with the proper USE flags ''before'' compiling a kernel with compressed modules:

{{FileBox|filename=/etc/portage/package.use|title=Enabling compression support for kmod|1=
sys-apps/kmod lzma zlib
}}

Re-emerge {{Package|sys-apps/kmod}}:

{{Emerge|params+=--oneshot --changed-use|sys-apps/kmod}}

Enable module compression and select a preferred compression method:
{{KernelBox|title=Enable module compression|1=
Enable loadable module support --->
  [*]   Compress modules on installation
  Compression algorithm ()  --->
    <X> GZIP
        XZ
}}

Usually {{c|make modules_install}} runs {{c|depmod}}. If {{Package|sys-apps/kmod}} did not have the proper USE flags set (see the {{Path|package.use}} step above) the first time it was run, then the dependency list will be empty. The system will therefore be unable to load any modules that were built compressed.

After kmod has been recompiled, re-run {{c|depmod}} as a solution to this problem:

{{RootCmd|depmod -a
|modprobe <module_name>
}}

== Kernel configuration shorthand notation ==

=== はじめに ===

When reading about kernel configuration, often times settings are described as <var>CONFIG_<something></var>. This short-hand notation is what the kernel configuration actually uses internally, and is what will be found in the kernel configuration file (be it {{Path|/usr/src/linux/.config}} or in the auto-generated {{Path|/proc/config.gz}} file). Of course, using short-hand notation would not do much good if this cannot translate this to the real location in the kernel configuration. The {{c|make menuconfig}} tool makes this possible.

=== Translating CONFIG_FOO to the real configuration location ===

Suppose the <var>CONFIG_TMPFS_XATTR</var> feature needs to be enabled. Launch the kernel configuration menu ({{c|make menuconfig}}) and press the {{Key|/}} key. This will open a search box. In the search box, type <var>CONFIG_TMPFS_XATTR</var>. 

The following is an output of the result of this search:

{{KernelBox|title=Result of searching menuconfig for "CONFIG_TMPFS_XATTR"|1=
Symbol: TMPFS_XATTR [=n]
Type  : boolean
Prompt: Tmpfs extended attributes
  Defined at fs/Kconfig:138
  Depends on: TMPFS [=y]
  Location:
    -> File systems
      -> Pseudo filesystems
(1)     -> Virtual memory file system support (former shm fs) (TMPFS [=y])
  Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
}}

This output yields lots of interesting information.

{| class="table table-condensed table-striped" style="text-align: left;" 
|- 
! Entry
! Description
|- 
| Symbol: TMPFS_XATTR [=n]
| This identifies the kernel configuration entry being searched for. It also shows that this setting is currently ''not enabled'' ([=n]).
|- 
| Type: boolean
| The setting searched for is a boolean (which means it can be one of two options: enabled or disabled). Some settings are numbers or strings.
|- 
| Prompt: Tmpfs extended attributes
| This is the text found in the {{c|make menuconfig}} entry that controls the variable (<var>TMPFS_XATTR</var>) in the {{Path|.config}} file. It is essentially the variable name in a more human readable format.
|- 
| Depends on: TMPFS [=y]
| Before this entry can be seen <var>CONFIG_TMPFS</var> must be enabled. In this case it is already done (hence the [=y]) but if this is not the case, first look for (and enable) <var>CONFIG_TMPFS</var>.
|- 
| Location: ...
| This is the location in the {{c|make menuconfig}} structure where the setting can be found. Remember, the setting to look for is ''Tmpfs extended attributes''.
|- 
| Selected by: TMPFS_POSIX_ACL [=n] && TMPFS [=y]
| If the settings described here are both enabled (in this case the first one is not), then <var>CONFIG_TMPFS_XATTR</var> will be automatically enabled and will not be possible to be ''disabled'' until one of these settings is de-selected.
|-
|}

With this information, it should be possible to translate any <var>CONFIG_*</var> requirements fairly easily. In short, it means a user must:

# Enable the settings described in the ''Depends on'' field
# Navigate where ''Location:'' points
# Toggle the value referred to by ''Prompt:''

{{Tip|Notice the number in parenthesis; users can jump to that option, or as close as possible for enabled menus, by pressing the number while in the search. In the above example, pressing {{Key|1}} on the keyboard will jump to or near that option. }}

== Other kernel configuration documentation ==

So far only general concepts and specific problems related to kernel configuration has been discussed; precise details have been left up to the user to discover. However, other parts of the Gentoo documentation collection provide specialized details for the topics at hand.

Such documents may be helpful while configuring specific areas of the kernel. Although this warning was mentioned previously in this guide, remember: users who are new to kernel configuration should not be adventurous when attempting to configure their kernels. Start by getting a basic system up and running, support for audio, printing, etc., can always be added at a later date.

Getting the basics of a kernel operational will help users in later configuration steps because the user will know what is breaking their system and what is not. It is always wise to save the base (working) kernel configuration in a folder other than the kernel's sources folder ''before'' attempting to add new features or hardware.  

* The [[ALSA|ALSA article]] details the configuration options required for sound card support. Note that ALSA is an exception to the suggested scheme of not building things as modules: ALSA is actually much easier to configure when the components are modular.

* The [[Bluetooth|Bluetooth article]] details the options needed in order to use Bluetooth devices.

* The [[IPv6 router guide]] describes how to configure the kernel for routing using the next generation network addressing scheme.

* If the closed-source nVidia graphics drivers will be used for improved 3D graphics performance, the [[NVidia/nvidia-drivers|nVidia Guide]] lists the options that should and should not be selected on such a system.

* Amongst other things, the [[Power_management/Guide|Power Management guide]] explains how to configure the kernel for CPU frequency scaling, and for suspend and hibernate functionality.

* If running a PowerPC system, the [[PPC/FAQ|PPC FAQ]] has a few sections about PPC kernel configuration.

* The [[Printing|Printing guide]] lists the kernel options needed to support printing in Linux.

* The [[USB/Guide|USB Guide]] details the configuration settings required to use common USB devices such as keyboards, mice, storage devices, and USB printers.

== トラブルシューティング ==

=== Configuration changes do not take effect ===

It is very common for users to make a configuration change, but then make a small mistake in the process of actually booting to their newly configured kernel. They reboot into a kernel image that is not the one they just reconfigured, observe that whatever problem they were trying to solve is still present, and conclude that the configuration change does not solve the problem. 

The process of compiling and installing kernels is outside the scope of this document; refer to the [[Kernel/Upgrade|Kernel Upgrade Guide]] for general guidance. In short, the process to get a modified kernel is the following: 1) configure, 2) compile, 3) mount {{Path|/boot}} (if not already mounted), 4) copy new kernel image to {{Path|/boot}}, 5) Make sure the bootloader will reference the new kernel, 6) reboot. If one of those final stages has been missed, then the changes will not properly take effect.

It is possible to verify if the kernel that has booted matches the newly kernel compiled on the hard disk. This is performed by examining the date and time of the kernel's compilation. Assuming the system architecture is {{Keyword|x86}} and the kernel sources are installed at {{Path|/usr/src/linux}}, the following command can be used:

{{RootCmd|uname -v|output=<pre>
#4 SMP PREEMPT Sat Jul 15 08:49:26 BST 2006
</pre>}}

The above command will display the date and time the currently booted kernel was compiled.

{{RootCmd|ls -l /usr/src/linux/arch/i386/boot/bzImage|output=<pre>
-rw-r--r-- 1 dsd users 1504118 Jul 15 08:49 /usr/src/linux/arch/i386/boot/bzImage
</pre>}}

The above command displays the date and time that the kernel image on the hard disk was last compiled.

If the time stamps from the above commands differ by more than 2 minutes, it indicates a mistake was made during kernel reinstallation and the system has not booted from the newly modified kernel image.

=== Modules do not get loaded automatically ===

As mentioned earlier in this document, the kernel configuration system hides a large behavioral change when selecting a kernel component as a module <code>(M)</code> rather than built-in <code>(Y)</code>. It is worth repeating this again because so many users fall into this trap.

When selecting a component as built-in, the code is built into the kernel image (bzImage). When the kernel needs to use that component, it can initialize and load it automatically, without any user intervention. 

When selecting a component as a module, the code is built into a kernel module file and installed on the filesystem. In general, when the kernel needs to use that component, it will not be able to find it. With some exceptions, the kernel makes no effort to actually load these modules — this task is left up to the user. 

If building support for a network card as a module, and it is discovered the network is not accessible, it is probably because the module is not loaded — either this must be done manually or the system must be configured to autoload the module at boot time.

Unless a user has reason to do otherwise, some time can be saved by building these components directly into the kernel image, so that the kernel can automatically configure these small settings by itself.

== 参考 ==

* [[genkernel]] - A tool used to automate the build process of the kernel and initramfs.
* [[Security_Handbook/Network_security#The proc filesystem|proc filesystem (Security Handbook)]] - Dynamically change kernel parameters and variables on the fly.


[[Category:Kernel]] [[Category:Server and Security]] {{Migrated|originalauthors=Daniel Drake, Curtis Napier, Justin Robinson, Lukasz Damentko, Jonathan Smith, nightmorph}}
