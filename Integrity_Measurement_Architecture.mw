The Linux IMA subsystem [[Article description::is responsible for calculating the hashes of files and programs before they are loaded]], and supports reporting on the hashes and validate if they adhere to a predefined list. In this guide, we introduce this technology and how it can be enabled in Gentoo Linux.

== Purpose of IMA ==

=== Introduction ===

{{Warning|Using IMA on your system is currently only recommended for development purposes.}}

The Linux IMA subsystem introduces hooks within the Linux kernel to support creating and collecting hashes of files when opened, before their contents are accessed for read or execute. The IMA subsystem has 2 subsystems within in it - '''measure''' and '''appraise'''. '''Measurement''' collects the hashes of files, while '''appraisal'''  compares a collected hash to a stored hash and denies access in the event of a mismatch.

To support proven integrity of the files, the IMA measurement subsystem can interact with the TPM chip within the system to protect the collected hashes from tampering by a rogue administrator or application.

The IMA measurement subsystem was added in linux-2.6.30. Appraisal came later, in linux-3.7.

Protection of the extended attribute itself is handled by [[Extended Verification Module|EVM]].

=== Trusted Computing Base ===

{{Warning|The default policies are unsuitable for general-use systems. The {{c|tcb}} policy opens up a local DoS where a malicious user can fill the measurement log and make the kernel run out of memory. The {{c|tcb_appraise}} policy prevents Portage from working.}}

The Trusted Computing Base defines a set of rules that a properly, integrity-protected system should adhere to. Linux defines 2 policies for this: The {{c|tcb}} policy, which performs measurement, and {{c|tcb_appraise}} which performs appraisal.

== Setting up IMA ==

=== Kernel configuration ===

First of all, enable the IMA subsystem in the Linux kernel configuration.

{{KernelBox|title=Linux kernel configuration for IMA|1=
CONFIG_INTEGRITY=y
CONFIG_IMA=y
CONFIG_IMA_MEASURE_PCR_IDX=10
CONFIG_IMA_LSM_RULES=y
CONFIG_INTEGRITY_SIGNATURE=y
CONFIG_IMA_APPRAISE=y

# Since 4.13
IMA_APPRAISE_BOOTPARAM=y
}}

=== Kernel command line options ===

There are 2 important IMA command line options: {{c|ima_appraise{{=}}}} and {{c|ima_policy{{=}}}}

{{c|ima_appraise{{=}}}} can take 1 of 4 values:
* '''enforce''' causes IMA to appraise files according to policy. Access is denied to the appraised file if the store hash is missing or does not match the collected value. IMA generates new stored hashes for new files and changed files with valid hashes.
* '''log''' is similar to '''enforce''' except access is not denied but only logged.
* '''off''' disables all appraisal. The stored hashes aren't checked and new stored hashes are not generated or updated.
* '''fix''' disables all appraisal, but generates new stored hashes for any file opened for read. If a file has an incorrect stored hash, it is updated to a correct one.
{{c|ima_policy{{=}}}} can take 1 of 3 values:
* '''tcb''' measures all executables run, all mmap'd files for execution (such as shared libraries), all kernel modules loaded, and all firmware loaded. Additionally, a files opened for read by root are measured as well.
* '''appraise_tcb''' appraises all files owned by root.
* '''secure_boot''' appraises all loaded modules, firmware, kexec'd kernel, and IMA policies. It also requires them to have an IMA signature as well. This is normally used with the <var>CONFIG_INTEGRITY_TRUSTED_KEYRING</var> option in the kernel in "secure boot" scenario, with the public key obtained from the OEM in firmware or via the MOK (Machine Owner Key) in ''shim''.

{{c|ima_policy{{=}}}} can be specified multiple times, and the result is the union of the policies.

=== Enable i_version mount option (optional) ===

Mount all file systems with the {{c|i_version}} support (which, sadly, means you need to mount it with {{c|iversion}} mount option - without the underscore). This is an optimization for IMA, allowing it to only recompute the hash of file when it actually changes instead of every time the file is opened.

{{CodeBox|title=Enabling i_version on all mounts|1=
# Example for a single partition, in /etc/fstab:
/dev/vda1  /  ext4  noatime,iversion  1 2
}}

For the root file system, it can be enabled through the {{c|rootflags}} kernel parameter as well so that it gets mounted immediately with i_version support when the Linux kernel mounts the root file system.

{{CodeBox|title=Using rootflags in the bootloader configuration|1=
# Example kernel line for a GRUB setup
GRUB_CMDLINE_LINUX="rootflags=i_version dolvm ima_appraise=enforce ima_policy=tcb ima_policy=appraise_tcb"}}

Note that the underscore needs to be present here, unlike in the fstab case.

=== Registering the file hashes for the system ===

{{Note|This is only applicable when IMA appraisal is enabled.}}

First boot with the {{c|ima_appraise{{=}}fix}} boot option. This will allow the system to boot up even when no (or wrong) hashes are registered.

Next, all files that will be appraised need read

{{RootCmd|1=find / -fstype ext4 -type f -uid 0 -exec dd if='{}' of=/dev/null count=0 status=none \;}}

Its also possible to use the {{c|evmctl}} utility which is part of {{Package|app-crypt/ima-evm-utils}}

{{RootCmd|1=find / -fstype ext4 -type f -uid 0 -exec evmctl ima_hash '{}' > /dev/null}}

However, this will hash all files even if the file has a {{c|dont_hash}} rule.

When done, the stored hash value should show as an extended attribute:

{{RootCmd|getfattr -m - -d /sbin/init|output=<pre>
# file: sbin/init
security.ima=0sAXr7Qmun5mkGDS286oZxCpdGEuKT
security.selinux="system_u:object_r:init_exec_t"
</pre>
}}

Finally, reboot with {{c|ima_appraise{{=}}enforce}}. The system should now run with appraisal enabled, causing the system to validate the hash against the stored value before using it. If it doesn't match, then the file is not loaded and any access towards it will be denied with a ''Permission denied'' error.

You can check if this works by booting with {{c|ima_appraise{{=}}off}} and changing the contents of a root-owned file (or the value of the extended attribute) and reboot with {{c|ima_appraise{{=}}enforce}}, or by directly editing virtual guest images.

=== Using digital signatures for immutable files ===

The IMA appraisal code also supports immutable files. In this case, an RSA-key based signature is taken of the file and stored in the extended attribute. The private key is used to sign the files, whereas the public key is used to verify the signature. This provides additional protection against tampering as the private key does not need to be available on the system while its running (only during the initial marking).

To sign such immutable files (like kernel modules and application code),the {{c|evmctl}} command provided by the {{Package|app-crypt/ima-evm-utils}} package needs be used. But first, setup the kernel keyring:

{{RootCmd|ima_id{{=}}`keyctl newring _ima @u`
|evmctl import --rsa /path/to/rsa_public.pem $ima_id}}

This allows the IMA subsystem to validate the signature (which is also needed when initially setting the signature) by loading the public key onto the IMA keyring. This needs to be done every time the system boots, so it makes sense to do so within an initramfs (early in the boot process):

{{RootCmd|find /lib/modules -name "*.ko" -type f -uid 0 -exec evmctl sign --imasig '{}' /path/to/rsa_private.pem \;}}

This private key can be generated first using {{c|openssl}}:

To generate an unencrypted private key (non-protected):

{{Cmd|openssl genrsa -out rsa_private.pem 1024}}

Or an encrypted private key (password-protected):

{{Cmd|openssl genrsa -des3 -out rsa_private.pem 1024}}

To generate the public key:

{{Cmd|openssl rsa -pubout -in rsa_private.pem -out rsa_public.pem}}

Immutable file support is mainly used to digitally sign the Linux kernel and the kernel modules and is supported through the EVM technology (which we will discuss in different documentation) but works well on ELF and other binaries as well.

== Using the IMA subsystem ==

=== Reading the integrity log ===

To read the integrity log as registered by the IMA subsystem, look at the {{Path|/sys/kernel/security/ima/ascii_runtime_measurements}} file:

{{RootCmd|head /sys/kernel/security/ima/ascii_runtime_measurements|output=<pre>
10 ddee6004dc3bd4ee300406cd93181c5a2187b59b ima-ng sha1:9797edf8d0eed36b1cf92547816051c8af4e45ee boot_aggregate
10 180ecafba6fadbece09b057bcd0d55d39f1a8a52 ima-ng sha1:db82919bf7d1849ae9aba01e28e9be012823cf3a /init
10 ac792e08a7cf8de7656003125c7276968d84ea65 ima-ng sha1:f778e2082b08d21bbc59898f4775a75e8f2af4db /bin/bash
10 0a0d9258c151356204aea2498bbca4be34d6bb05 ima-ng sha1:b0ab2e7ebd22c4d17d975de0d881f52dc14359a7 /lib64/ld-2.27.so
10 0d6b1d90350778d58f1302d00e59493e11bc0011 ima-ng sha1:ce8204c948b9fe3ae67b94625ad620420c1dc838 /etc/ld.so.cache
10 d69ac2c1d60d28b2da07c7f0cbd49e31e9cca277 ima-ng sha1:8526466068709356630490ff5196c95a186092b8 /lib64/libreadline.so.7.0
10 ef3212c12d1fbb94de9534b0bbd9f0c8ea50a77b ima-ng sha1:f80ba92b8a6e390a80a7a3deef8eae921fc8ca4e /lib64/libc-2.27.so
10 f805861177a99c61eabebe21003b3c831ccf288b ima-ng sha1:261a3cd5863de3f2421662ba5b455df09d941168 /lib64/libncurses.so.6.1
10 52f680881893b28e6f0ce2b132d723a885333500 ima-ng sha1:b953a3fa385e64dfe9927de94c33318d3de56260 /lib64/libnss_files-2.27.so
10 4da8ce3c51a7814d4e38be55a2a990a5ceec8b27 ima-ng sha1:99a9c095c7928ecca8c3a4bc44b06246fc5f49de /etc/passwd
</pre>}}

{{RootCmd|tail /sys/kernel/security/ima/ascii_runtime_measurements|output=<pre>
10 4848cf2c61234ab3f1b401393977672c9ddf06f1 ima-ng sha1:e3110d04ef7f0aa4bf202e26ab57922c850d26f8 /etc/pam.d/su
10 38939fd3ae9f769d3161be0e2d64caaf6bba7c05 ima-ng sha1:45cc4ba2611a425143b907b85910cfd1dbc9e10c /lib64/security/pam_rootok.so
10 a9a24168c14311a700f388e7d366c316c389e60a ima-ng sha1:07498365392e741def254e4cb11dd5f678a80716 /lib64/security/pam_wheel.so
10 e671c9879c366c1e4e334a73a37f31c6314e4938 ima-ng sha1:31eb4b6be306e0d7d65760f14833791e457bfd70 /lib64/security/pam_xauth.so
10 161dcb0153b5cfeab9a68e65c7373ddc6a69eaca ima-ng sha1:9d1344c4bd6ca2a507b1373eb4ba95fa1208bebb /etc/terminfo/x/xterm-256color
10 85327b8f29876b2e849e796193fe0024d2343bb4 ima-ng sha1:025eb281bccf4fe970682b07a2b0617759d0bd90 /bin/head
10 0be8f088844744f80eeb6daa89c82b5fc4499ba5 ima-ng sha1:810e9405ee37185d6eea6879c4a0e3369ac4e68e /bin/tail
10 9ade4647fe649b36db4ec11ef7c56093dba9548b ima-ng sha1:1135bb946dd98cf7a171e2e4c9c043981b9858aa /bin/getfattr
10 ad6bb7e7f79ee799244f15b6d9a253be744d79da ima-ng sha1:9fea4eb8658a8a06f2207a3e7b43acaa03a5aae9 /bin/ps
10 661d2b076d842975ef0295b84f988519ca431507 ima-ng sha1:5bd1adcf179695cdd3468b363b2979609c08cbab /lib64/libprocps.so.7.1.0
</pre>
}}

The columns (from left to right) are:

* '''PCR (Platform Configuration Register)''' in which the values are registered. This only makes sense if a TPM chip is in use.
* '''Template hash''' of the entry, which is a hash that combines the length and values of the file content hash and the pathname
* '''Template''' that registered the integrity value (ima-ng the case)
* '''File content''' hash which is the hash of the file itself

The default hash algorithm is SHA-1.

== Asked questions with answers ==

=== How do I know IMA with appraisal is working? ===

This is as simple as finding a file that does not have its hash value stored as an extended attribute while ima_appraise is in enforcing mode. 

{{RootCmd|getfattr -m . -d /etc/mtab|output=<pre>
getfattr: Removing leading '/' from absolute path names
# file: etc/mtab
security.selinux="system_u:object_r:etc_runtime_t"
</pre>}}

{{RootCmd|cat /etc/mtab|output=<pre>
cat: /etc/mtab: Permission denied
</pre>}}

{{RootCmd|dmesg {{!}} tail -1|output=<pre>
[  256.756465] type=1800 audit(1356637858.947:53): pid=3852 uid=0 auid=0 ses=2
subj=root:sysadm_r:sysadm_t op="appraise_data" cause="missing-hash" comm="cat"
name="/etc/mtab" dev="dm-2" ino=394144 res=0
</pre>
}}

In the above example, the IMA subsystem reports that the {{Path|/etc/mtab}} file misses its hash value (which should be stored as {{Path|security.ima}}) and as such is denying the {{c|cat}} application access to it.

If you can miss the file (such as with {{Path|/etc/mtab}}) you can remove it and regenerate it if you wish:

{{RootCmd|rm /etc/mtab
|cat /proc/mounts > /etc/mtab}}

If you are using SELinux:

{{RootCmd|restorecon /etc/mtab}}

Next:

{{RootCmd|evmctl ima_hash /etc/mtab
|getfattr -m . -d /etc/mtab|output=<pre>
getfattr: Removing leading '/' from absolute path names
# file: etc/mtab
security.ima=0sAUlIU5ffoobWOh0FsSIbgh9Ac8YK
security.selinux="root:object_r:etc_runtime_t"
</pre>
}}

=== I was able to edit an 'immutable' file and still run it. How come? ===

If you digitally signed a script using {{c|evmctl sign --imasig <file> <private-key>}} and then edited the file with {{c|vim}}, then this behavior is to be expected. {{c|vim}} removes the original file and replaces it with a new one. The newly created file is given an appropriate hash (but no digital signature of course) and thus you can still execute it.
Integrity Measurement Architecture/Recipes
The use of digital signatures is more for kernel modules and ELF binaries. But below an example of how it does work - if you edit the file rather than replace it.

{{RootCmd|evmctl sign --imasig ./test.sh /root/rsa_private.pem
|./test.sh|output=<pre>
Hello World (again)
</pre>}}

{{RootCmd|echo "echo \"And now...\"" >> test.sh}}

{{RootCmd|./test.sh|output=<pre>
bash: ./test.sh: Permission denied
</pre>}}

{{RootCmd|cat test.sh|output=<pre>
cat: test.sh: Permission denied
</pre>}}

{{RootCmd|dmesg {{!}} tail -2|output=<pre>
[  643.211490] type=1800 audit(1356639603.315:37): pid=3956 uid=0 auid=0 ses=3
subj=root:sysadm_r:sysadm_t op="appraise_data" cause="invalid-signature"
comm="bash" name="/bin/test.sh" dev="dm-2" ino=131466 res=0
[  649.123917] type=1800 audit(1356639609.227:38): pid=3958 uid=0 auid=0 ses=3
subj=root:sysadm_r:sysadm_t op="appraise_data" cause="invalid-signature"
comm="cat" name="/bin/test.sh" dev="dm-2" ino=131466 res=0
</pre>
}}

=== How do I load a custom IMA policy? ===

It is possible, and recommended to use a custom IMA policy. A breakdown of the default rules and snippets to rules for be included can by found in [[Integrity Measurement Architecture/Recipes]].

Make sure no empty lines are in the policy; if not, it will be refused. You can check the output of {{c|dmesg}} for hints why the policy was refused (it shows what was accepted, so the next line would be a not-accepted line), or the audit logs (but you will need to have {{c|auditd}} running) if you get lines such as ''audit_printk_skb: XX callbacks suppressed'' as you then might not have all the information you need.

Have the policy be loaded in as soon as possible, either in an initramfs or early in the boot process through an init script in the ''sysinit'' runlevel. I keep my policy in {{Path|/etc/ima}} and use the following small init script to load it early on:

{{CodeBox|title=Init script to load a custom ima policy|lang=bash|1=
#!/sbin/openrc-run
# Copyright 1999-2012 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/hardened/integrity/docs/ima-guide.xml,v 1.11 2013/03/09 13:55:21 swift Exp $
  
description="Load in custom IMA policy"
  
depend() {
        need sysfs
}
  
start() {
        ebegin "Loading custom IMA policy"
        cat /etc/ima/policy.conf > /sys/kernel/security/ima/policy
        eend $?
}
}}

{{Warning|If you use an initramfs, then you might notice that {{Path|/usr}} is not properly mounted. This is because busybox mount does not support the iversion mount option which is required. Update the initramfs to mount without iversion, and remount it as soon as possible later.}}

=== Online resources tell me I can use head -n 1 to regenerate the hashes ===

I have bad experiences with this method. Some files are left without a hash, or when I later enable EVM the EVM hash itself remains missing. The use of the {{c|evmctl}} command does the trick pretty well.
