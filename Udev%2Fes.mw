<languages />


{{Metadata|abstract=udev es el gestor de dispositivos para el núcleo Linux. Gestiona los nodos de dispositivo en /dev y también todos las acciones en espacio de usuario cuando se añaden o eliminan dispositivos.}}

{{Lowercase title}}
{{InfoBox stack
|{{InfoBox wikipedia|header=true}}
}}

'''udev''' es el gestor de dispositivos para el núcleo Linux. Principalmente gestiona los nodos de dispositivo en {{Path|/dev}} y también todos las acciones en espacio de usuario cuando se añaden o eliminan dispositivos. Eche también un vistazo a [Project:Eudev|eudev] una bifurcación de udev.

== ¿Qué es udev? ==

=== El directorio /dev ===

Cuando los usuarios de Linux hablan acerca del hardware de sus sistemas a gente que puede llegar a pensar que Linux es algún tipo de virus o marca de café, el uso de términos como "barra dev barra algo" provocará, sin dudas, miradas raras. Pero para el usuario afortunado (incluyendo al lector) el usar {{Path|/dev/sda1}} es solo una forma rápida de explicar que nos referimos a la primera partición del disco primer disco SATA. ¿O no? 

Todos sabemos lo que es un archivo de dispositivo. Algunos incluso saben por qué cuando miramos un poco más de cerca la salida de <code>ls
-l</code> en {{Path|/dev}} los archivos de dispositivo muestran unos números especiales. Pero lo que siempre damos por sentado es que el
primer disco SATA se llama {{Path|/dev/sda}}. Tal vez no lo vea así, pero esto es un fallo de diseño. 

Piense en los dispositivos que se enchufan en caliente como los USB, IEEE 1394, tarjetas PCI que se cambian en caliente ... ¿Cuál es el
primer dispositivo? ¿Y por cuánto tiempo? ¿Cómo se llamarán los demás dispositivos cuando el primero desaparezca? ¿Cómo afectará ésto a las transacciones en curso? ¿No sería divertido que un trabajo de impresión se cambiase de repente desde su flamante impresora láser nueva a la moribunda impresora de matriz solo porque alguien decidió desenchufar la impresora láser que era la primera impresora? 

Entra en escena ''udev''. Los objetivos del proyecto udev son a la vez interesantes y necesarios:

* Corre en espacio de usuario
* Crea y borra archivos de dispositivo dinámicamente
* Proporciona nombres consistentes
* Proporciona una API en espacio de usuario

Cada vez que se produce un cambio en la estructura de los dispositivos, el núcleo emite un ''uevent'' que recoge udev. Entonces,
udev sigue las reglas declaradas en los directorios
{{Path|/etc/udev/rules.d}}, {{Path|/run/udev/rules.d}} y {{Path|/lib/udev/rules.d}}. Basándose en la información contenida en el evento, busca la regla o reglas que necesita ejecutar y realiza las acciones requeridas. Estas acciones pueden consistir en la creación o eliminación de ficheros de dispositivo, pero pueden suponer también la carga de ficheros de firmware particulares en la memoria del núcleo.

== Instalación ==

{{Note/es|Si está actualizando, eche un vistazo a la [https://wiki.gentoo.org/wiki/Udev/upgrade página de actualización].}}

=== Núcleo ===

You need to activate the following kernel options:

<!-- See http://git.kernel.org/?p=linux/hotplug/udev.git;a=blob_plain;f=README -->
{{Kernel||<pre>
General setup  --->
    [*] Configure standard kernel features (expert users)  --->
        [ ] Enable deprecated sysfs features to support old userspace tools
        [*] Enable signalfd() system call
Enable the block layer  --->
    [*] Block layer SG support v4
Networking support  --->
    Networking options  --->
        <*> Unix domain sockets
Device Drivers  --->
    Generic Driver Options  --->
        ()  path to uevent helper
        [*] Maintain a devtmpfs filesystem to mount at /dev
    < > ATA/ATAPI/MFM/RLL support (DEPRECATED)  --->
File systems  --->
    [*] Inotify support for userspace
    Pseudo filesystems --->
        [*] /proc file system support
        [*] sysfs file system support
</pre>}}

=== Software ===

Portage knows the global USE flag ''udev'' for enabling support for udev in other packages. Enabling this USE flag (default in all ''linux'' [[profile]]s) will pull in {{Package|sys-fs/udev}} automatically:

{{File|/etc/portage/make.conf||<pre>
USE="... udev ..."
</pre>}}

The USE flags of udev are:

{{USEflag|package=sys-fs/udev
|acl+yes
|doc
|firmware-loader+yes
|gudev+yes
|introspection+yes
|kmod+yes
|openrc+yes
|selinux++no
|static-libs++no
}}

After setting this you want to update your system so the changes take effect:

{{Emerge|params+=--changed-use --deep|@world}}

== Configuration ==

=== Service ===

To start udev at boot time, add it your sysinit runlevel:
{{RootCmd|rc-update add udev sysinit}}

== Advanced Configuration ==

=== Rules ===

udev provides a set of rules that match against exported values of uevents (events sent by the kernel) and properties of the discovered device. A matching rule will possibly name and create a device node and run configured programs to set-up and configure the device.

The rule definitions are stored in {{Path|/lib/udev/rules.d}} (installed by packages) and {{Path|/etc/udev/rules.d}} (for end-user specified rules). In these directories, multiple rule files (with suffix {{Path|.rules}}) are traversed in alphanumerical order. Inside the rules files, udev will find expressions that might match a uevent together with the state to match (is the uevent because a device is added or removed) and the command to execute.

The event matching is based on information such as:
* the ''SUBSYSTEM'' of the uevent (for which type of device is the uevent fired)
* the ''ACTION'' that is taken (add, change or remove)
* one or more attributes (through ''ATTR'' or ''ATTRS''), such as the device class, vendor or other device information
* the kernel-provided name (through ''KERNEL''), such as sd* (for SCSI/SATA disks) or input* (for input devices such as mice and keyboards)
* one or more environment settings (through ''ENV''), used to send information between multiple rules

Based on this information, the rule can then state if 
* some information needs to be shared with later events (through environment variables)
* links need to be created in {{Path|/dev}}
* commands need to be executed

Udev does this for every rule that matches (so it does not stop after the first match) to allow a flexible device management approach.

=== Persistent device names ===

The kernel detects devices asynchronous, udev mirrors the kernel's [[sysfs]] filesystem and so the device are named and numbered in order of detection. So by default udev provides no persistent device names. However there are mechanismen for some device classes to provide these:

* udev creates for storage devices additional symlinks based on the device's id, label, uuid and path. See the {{Path|/dev/disk/by-*}} directory. So instead of using e.g. the device file {{Path|/dev/sda}} use the file {{Path|/dev/disk/by-label/SOME_LABEL}}.

* The same for input devices in the {{Path|/dev/input}} directory.

* Using custom rules you can create your own device files.

== Usage ==

Some useful commands are:

* Show all messages about a given device file:
: {{RootCmd|udevadm info --query{{=}}all --name{{=}}/dev/DEVICE_FILE}}

* Monitor udev activities:
: {{RootCmd|udevadm monitor}}

See the ''udevadm'' [[man page]] for more information.

== Troubleshooting ==

* {{Bug|udev|search=package}}

=== Log monitor messages ===

Log all message you see, when you run '''udevadm monitor''':

{{File|/etc/conf.d/udev||<pre>
udev_monitor="YES"
</pre>}}

It will create the new log file {{Path|/run/udev/udevmonitor.log}}.

=== Debug mode ===

Enable debug mode to get more log messages:

{{File|/etc/conf.d/udev||<pre>
udev_debug="YES"
</pre>}}

It will create the new log file {{Path|/run/udev/udevdebug.log}}.

=== Missing device files {{Path|/dev/null}} and {{Path|/dev/console}} ===

Some udev versions need these files and can't create them on their own. So you have to create them:

{{RootCmd
|mkdir test
|mount --bind / test
|cd test/dev
|mknod -m 660 console c 5 1
|mknod -m 660 null c 1 3
|cd ../..
|umount test
|rmdir test
}}

=== NIC assigned eth0, but is moved to eth1 ===

Those having dual network cards on their motherboards may run into a situation where ifconfig may show no eth0 or eth1.  Dmesg may show their NIC detected as eth0, and later moved to eth1. Performing a "ifconfig -a" will also show the NIC as eth1. This is caused by using the kernel assigned names in the first place. You should write your own rules like {{Path|/etc/udev/rules.d/70-my-network.rules}} to
use free names like lan0 or wireless0 or use the predictable interface names which are enabled by the default since version 197.

Remember to also remove old files from old versions of udev:

{{RootCmd|rm /etc/udev/rules.d/70-persistent-net.rules}}


[[Category:Core system]]
[[Category:Daemons]]
