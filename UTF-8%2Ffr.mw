<languages />

{{InfoBox stack
|{{InfoBox wikipedia|header=true}}
}}

{{Metadata|abstract=UTF-8 est un procédé de chiffrage de caractères sur un nombre variable d'octets (en l'occurrence de  1 à 4 octets) par symbole. Le premier octet de l' UTF-8 est utilisé pour les caractères de l'ASCII, conférant ainsi au jeu de caractères une rétrocompatibilité avec l'ASCII. UTF-8 signifie que les caractères ASCII et les caractères latins sont interchangeables au prix d'une légère augmentation de la taille des données, parce que seul le premier octet est utilisé. Les utilisateurs d'alphabets de l'Est comme le Japonais, à qui ont a assigné une plage d'octets plus élevée ne sont pas satisfait car cela conduit à une redondance de plus de 50% dans leurs données.}}

UTF-8 est un procédé de chiffrage de caractères sur un nombre variable d'octets (en l'occurrence de  1 à 4 octets) par symbole. Le premier octet de l' UTF-8 est utilisé pour les caractères de l'ASCII, conférant ainsi au jeu de caractères une rétrocompatibilité avec l'ASCII. UTF-8 signifie que les caractères ASCII et les caractères latins sont interchangeables au prix d'une légère augmentation de la taille des données, parce que seul le premier octet est utilisé. Les utilisateurs d'alphabets de l'Est comme le Japonais, à qui ont a assigné une plage d'octets plus élevée ne sont pas satisfait car cela conduit à une redondance de plus de 50% dans leurs données. 

== Encodage des caractères ==

=== Qu'est-ce que l'encodage des caractères ? ===

Les ordinateurs ne comprennent eux-mêmes pas les textes imprimés comme les humains. Pour les ordinateurs, chaque caractère est représenté par un nombre. Traditionnellement, chaque jeu de nombres utilisé pour représenter les alphabets et les caractères (connus sous le nom de système de codage, encodage, ou jeu de caractères) était limité en taille à cause de la limitation même du matériel constituant les ordinateurs. 

=== L'histoire de l'encodage des caractères ===

Le plus courant (ou du moins le plus largement accepté) des jeux de caractères est l''''ASCII''' (American Standard Code for Information Interchange). Il est largement reconnu que l'ASCII est la norme logicielle la plus réussie jamais créée. L'ASCII moderne a été normalisé en 1986 (ANSI X3.4, RFC 20, ISO/IEC 646:1991, ECMA-6) par l'American National Standards Institute. 

ASCII, a strictement parler, est encodé sur 7 chiffres binaires, ce qui signifie qu'il utilise des motifs de chiffres représentables avec 7 chiffres binaires. Ce qui correspond à la plage 0 à 127 en décimal. Ceci inclut 32 caractères de contrôle non visualisables, en majorité entre 0 et 31, auxquels s'ajoute le caractère de contrôle final, DEL ou delete, dont la représentation est 127. Tous les caractères entre 32 et 126 inclus, sont visualisables : l'espace, les marques de ponctuation, les lettres latines et les chiffres. 

Le huitième bit en ASCII était à l'origine utilisé comme bit de parité pour la détection d'erreurs. Si la détection d'erreurs n'est pas souhaitée, on peut le laisser à 0. Ceci signifie que, avec l'ASCII, chaque caractère est représenté par un seul octet. 

Bien que l'ASCII soit suffisant pour communiquer en anglais moderne, dans d'autres langues européennes qui comprennent des caractères accentués, les choses ne sont pas aussi simples. Les normes ISO 8859 ont été développées pour satisfaire ces besoins. Elles sont rétrocompatibles avec l'ASCII, mais au lieu de laisser le huitième chiffre binaire à 0, elles l'utilisent pour former un autre ensemble de 127 caractères dans chacun des encodages. Les limitations des normes ISO 8859 sont apparues très vite, et il y a aujourd'hui 15 variantes de la norme ISO 8859 (8859-1 à 8859-15). En dehors de la plage compatible avec l'ASCII, il y a souvent des conflits entre les lettres représentées par chacun des octets. Pour compliquer encore l'interopérabilité entre versions, la norme Windows-1252 est utilisée à leurs place dans certaines versions de Microsoft Windows pour les langues européennes. Il s'agit d'un jeu étendu de ISO-8859-1, cependant il en diffère de plusieurs façons. Tous ces jeux restent néanmoins compatibles avec ASCII. 

Le développement nécessaire d'encodages mono-octets pour des alphabets non latins, tels que EUC (Extended Unix Coding) qui est utilisé pour le Japonais et le Coréen (et dans une moindre mesure pour le Chinois) a créé encore plus de confusion. D'autres systèmes d'exploitation utilisaient encore des jeux de caractères différents pour les mêmes langues, par exemple, Shift-JIS et ISO-2022-JP. Les utilisateurs désireux d'afficher des glyphes cyrilliques avaient à choisir entre KOI8-R pour le Russe et le Bulgare ou KOI8-U pour l'Ukrainien, aussi bien que parmi les autres encodages cyrilliques comme le peu prisé ISO 8859-5 et le plus connu Windows-1251. Tous ces jeux de caractères rompaient la compatibilité avec ASCII. Il faudrait cependant mentionner que le jeu KOI8 place les caractères cyrilliques dans l'ordre latin, de telle manière que si le huitième chiffre binaire est retiré, le texte est déchiffrable sur un terminal ASCII via une translittération à casse inversée. 

Tout cela conduisait à la confusion générale, et à une presque totale incapacité à communiquer dans plusieurs langues ; en particulier à travers des alphabets différents. C'est là qu'Unicode entre en scène. 

=== Qu'est-ce qu'Unicode ? ===

La norme Unicode jette aux orties la limite traditionnelle d'un octet pour les jeux de caractères. Elle utilise 17 ''plans'' de 65 536 points de code pour décrire un maximum de 1 114 112 caractères. Comme le premier plan, aussi connu sous le nom de ''Basic Multilingual Plane (Plan Multilingue de Base)'' ou BMP, contient presque tous les caractères dont un utilisateur aura jamais besoin, beaucoup ont fait la supposition fausse que l'Unicode était un jeu de caractères encodé sur 16 chiffres binaires. 

Unicode a été cartographié de différentes manières, mais les deux plus courantes sont '''UTF''' (Unicode Transformation Format pour Format de transformation d'Unicode) et '''UCS''' (Universal Character Set pour Jeu de caractères universel). Le nombre après UTF indique le nombre de chiffres binaires dans chacun des éléments, tandis que le nombre après UCS indique le nombre d'octets. UTF-8 est devenu le moyen le plus répandu pour l'échange de texte Unicode en raison de sa nature 8 chiffres binaires pure ; c'est de ce fait l'objet de ce document.

=== Ce que UTF-8 peut faire ===

UTF-8 permet aux utilisateurs de travailler dans un environnement multilingue conforme aux normes et reconnu internationalement, avec une redondance des données comparativement faible. UTF-8 est le moyen privilégié pour transmettre les caractères non ASCII sur Internet, via des courriels, l'IRC, ou presque n'importe quel autre médium. En dépit de cela, beaucoup de gens considèrent la communication en ligne en UTF-8 comme abusive. Il est toujours bon d'être conscient de cela sur certains canaux, listes de diffusion, ou groupes Usenet avant d'employer des caractères non ASCII en UTF-8. 

== Installer l'UTF-8 sur Gentoo Linux ==

=== Trouver ou créer des locales UTF-8 ===

Maintenant que les principes d'Unicode ont été établis, il est temps d'utiliser UTF-8 !

Pour les utilisateurs qui veulent en savoir plus, une explication détaillée peut-être trouvée dans le [[Localization/Guide/fr|Guide de localisation Gentoo]]. 

Ensuite, l'utilisateur doit décider si une locale UTF-8 est déjà disponible pour la langue choisie, ou si elle doit être générée.

{{Cmd|locale -a {{!}} grep 'en_GB'|output=<pre>
en_GB
en_GB.utf8
</pre>
}}

De la sortie de la commande ci-dessus, chercher un résultat avec un suffixe similaire à <code>.utf8</code>. S'il n'y a aucun résultat avec un suffixe similaire, une locale compatible UTF-8 doit être créée. 

{{Note|N'exécuter le code suivant que si le système ne possède pas de locale UTF-8 disponible pour la langue choisie.}}

Remplacer "en_GB" avec le code de locale souhaité :
{{RootCmd|localedef -i en_GB -f UTF-8 en_GB.UTF-8}}

Une autre façon d'inclure une locale UTF-8 est de l'ajouter au fichier {{Path|/etc/locale.gen}} et de générer les locales nécessaires en utilisant la commande {{c|locale-gen}}. Les locales seront écrites dans le fichier {{Path|/usr/lib/locale/locale-archive}}.

{{CodeBox|title=Ligne dans /etc/locale.gen|1=
en_GB.UTF-8 UTF-8
}}

{{RootCmd|locale-gen|output=<pre>
 * Generating 1 locales (this might take a while) with 1 jobs
 *  (1/1) Generating en_GB.UTF-8 ...                            [ ok ]
 * Generation complete
</pre>}}

=== Définir la locale ===

Il y a une variable d'environnement qui doit être définie de manière à ce que le système utilise les nouvelles locales UTF-8 : <var>LC_CTYPE</var> (optionnellement, modifier la variable <var>LANG</var> pour également changer la langue du système). Il y a aussi différentes manières de la définir ; certains administrateurs systèmes préfèrent avoir un environnement UTF-8 pour un utilisateur donné, auquel cas ils la définissent dans leur fichier {{Path|~/.profile}} ({{Path|/bin/sh}} pour les utilisateurs de Bourne shell), {{Path|~/.bash_profile}} ou {{Path|~/.bashrc}} ({{Path|/bin/bash}} pour les utilisateurs de Bourne again shell). Plus de détails et de bonnes pratiques sont disponibles dans le [[Localization/Guide/fr|Guide de localisation Gentoo]]. 

D'autres encore préfèrent la définir globalement. Une circonstance particulière où il est fortement recommandé de procéder de cette manière est quand {{Path|/etc/init.d/xdm}} est utilisé, parce que ce script d'initialisation lance le gestionnaire d'écran et le bureau ''avant'' qu'aucun des scripts de démarrage mentionnés précédemment ne soit évalués. En d'autre termes, l'action est réalisée avant qu'aucune des variables ne soit chargée dans l'environnement. 

Définir la locale globalement doit être fait en utilisant le fichier {{Path|/etc/env.d/02locale}}. Ce fichier doit ressembler à quelque chose comme ce qui suit : 

{{CodeBox|title=Demonstration /etc/env.d/02locale|lang=bash|1=
## (Comme d'habitude, remplacer "en_GB.utf8" par la valeur de locale appropriée; chaque langue a une valeur différente!)
LANG="en_GB.utf8"
}}

{{Note|Il est possible de remplacer la variable <var>LC_CTYPE</var> par la variable <var>LANG</var>. Pour plus d'informations sur les catégories affectées par l'utilisation de <var>LC_CTYPE</var>, lire la [https://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html#Locale-Categories Documentation GNU].}}

Ensuite, l'environnement doit être mis à jour en exécutant la commande suivante : 

{{RootCmd|env-update|output=<pre>
>>> Regenerating /etc/ld.so.cache...
</pre>}}
{{RootCmd|source /etc/profile}}

Maintenant, exécuter la commande {{c|locale}} sans arguments pour voir si les variables correctes ont été chargées dans l'environnement. 

{{RootCmd|locale|output=<pre>
LANG=en_GB.utf8
LC_CTYPE="en_GB.utf8"
LC_NUMERIC="en_GB.utf8"
LC_TIME="en_GB.utf8"
LC_COLLATE="en_GB.utf8"
LC_MONETARY="en_GB.utf8"
LC_MESSAGES="en_GB.utf8"
LC_PAPER="en_GB.utf8"
LC_NAME="en_GB.utf8"
LC_ADDRESS="en_GB.utf8"
LC_TELEPHONE="en_GB.utf8"
LC_MEASUREMENT="en_GB.utf8"
LC_IDENTIFICATION="en_GB.utf8"
LC_ALL=
</pre>
}}

===Sinon, en utilisant eselect pour définir les locales ===
Même s'il est bon d'entretenir le système comme décrit ci-dessus, il est possible de vérifier la locale correctement configurée en utilisant l'utilitaire {{c|eselect}}.

Utiliser {{c|eselect}} pour lister toutes les locales disponibles sur le système :

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX *
  [3] en_GB.utf8
  [ ] (free form)
</pre>
}}

Utiliser {{c|eselect}} pour définir la locale est aussi simple que pour les lister. Une fois que la bonne locale a été choisie, exécuter:

{{RootCmd|eselect locale set 3 |output=<pre>
Setting LANG to en_GB.utf8 ...
</pre>
}}

Vérifier le résultat :

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX
  [3] en_GB.utf8 *
  [ ] (free form)
</pre>
}}

Au cas où il ait préféré d'avoir {{Path|/etc/env.d/02locale}} avec <code>.UTF-8</code> au lieu de <code>.utf8</code>, exécuter la commande {{c|eselect}} correspondante :

{{RootCmd|eselect locale set en_GB.UTF-8 |output=<pre>
Setting LANG to en_GB.UTF-8 ...
</pre>
}}

{{RootCmd|eselect locale list |output=<pre>
  [1] C
  [2] POSIX
  [3] en_GB.utf8
  [4] en_GB.UTF-8 *
  [ ] (free form)
</pre>
}}

Exécuter la commande suivante va mettre à jour les variables du shell :

{{RootCmd|env-update && source /etc/profile |output=<pre>
>>> Regenerating /etc/ld.so.cache...
</pre>
}}

C'est tout. Le système utilise désormais les locales UTF-8. Le prochain obstacle est la configuration des applications utilisées quotidiennement.

== Prise en charge par les applications ==

Lorsque Unicode commença à prendre son essor dans le monde du logiciel, les jeux de caractères multi-octets n'étaient pas très adaptés à des langages de programmation tels que le langage C, qui est le langage de base pour beaucoup de programmes couramment utilisés. Même aujourd'hui, certains programmes ne sont pas capables de prendre en charge l'UTF-8 correctement. Fort heureusement, la majorité des programmes, surtout les plus utilisés, sont supportés. 

=== Noms de fichiers, NTFS, et FAT ===

Il y a plusieurs options NLS (Native Language Support) dans le menu de configuration du noyau Linux, mais il est important d'éviter la confusion ! Pour la majeure partie, la seule chose qui doit être faite est de compiler la prise en charge de UTF-8 NLS dans le noyau, et de changer l'option par défaut de NLS en utf8. 

{{KernelBox|title=Etapes de configuration du noyau pour UTF-8 NLS|<pre>
File Systems -->
  Native Language Support -->
    (utf8) Default NLS Option
    <*> NLS UTF8
    ## (Sélectionner (<*>) aussi tout autre jeux de caractères utilisés par le système comme le système de fichiers FAT ou Joilet CD-ROMs.)
</pre>
}}

S'il est envisagé de monter des partitions NTFS, les utilisateurs peuvent avoir besoin de spécifier une option <code>nls=</code> via {{c|mount}}. S'il est envisagé de monter des partitions FAT,  les utilisateurs peuvent avoir besoin de spécifier une option <code>codepage=</code> via {{c|mount}}. En option, les utilisateurs peuvent aussi définir une ''page de code (codepage)'' par défaut pour FAT dans la configuration du noyau.

{{Note|Utiliser l'option <code>codepage</code> via la commande {{c|mount}} remplacera les paramètres utilisés dans le noyau.}}

{{KernelBox|title=Paramètres FAT dans la configuration du noyau|<pre>
File Systems -->
  DOS/FAT/NT Filesystems  -->
    (437) Default codepage for fat
</pre>
}}

Il faut éviter de définir le paramètre <code>Default iocharset for fat</code> (jeu de caractères par défaut pour fat) à UTF-8 ; ce n'est pas recommandé. A la place, passez l'option <code>utf8=true</code> au moment de monter une partition FAT. Pour plus d'informations, <code>man mount</code>, ou se reporter à la documentation du noyau à {{Path|/usr/src/linux/Documentation/filesystems/vfat.txt}}.

Pour changer l'encodage des noms de fichiers, {{Package|app-text/convmv}} peut être utilisé. 

{{Emerge|app-text/convmv}}

Le format de la commande {{c|convmv}} est le suivant :

{{RootCmd|convmv -f <encodage-actuel> -t utf-8 <nom-du-fichier>}}

Remplacer iso-8859-1 par le jeu de caractères à partir duquel la conversion est effectuée :

{{RootCmd|convmv -f iso-8859-1 -t utf-8 filename}}

Pour changer le ''contenu'' de fichiers, utiliser l'utilitaire {{c|iconv}}, il est fourni avec {{c|glibc}} et devrait être installé sur tous les systèmes Gentoo. Remplacer iso-8859-1 par le jeu de caractères à partir duquel la conversion est effectuée. Après avoir exécuté la commande, vérifier que la sortie est saine :

{{RootCmd|iconv -f iso-8859-1 -t utf-8 filename}}

Pour convertir un fichier, un autre fichier doit être créé :

{{RootCmd|iconv -f iso-8859-1 -t utf-8 filename > newfile}}

Le paquet recode ({{Package|app-text/recode}}) peut aussi être utilisé à cet effet.

=== La console système ===

Pour activer UTF-8 dans la console, éditer {{Path|/etc/rc.conf}}. Définir <code>unicode="yes"</code>, et lire aussi les commentaires du fichier -- c'est important d'avoir une police de caractères qui dispose d'une bonne plage de caractères pour une meilleure utilisation d'Unicode. Pour que cela fonctionne, s'assurer que la locale Unicode a été correctement créée. 

La variable <var>keymap</var>, définie dans {{Path|/etc/conf.d/keymaps}}, devrait spécifier une carte de clavier Unicode. 

{{CodeBox|title=Exemple d'extrait de /etc/conf.d/keymaps|lang=bash|1=
## (Remplacer "uk" par l'arrangement de clavier local)
keymap="uk"
}}

=== Ncurses et Slang ===

{{Note|Ignorer toute référence à Slang dans cette section si ce n'est pas installé ou si ce n'est pas nécessaire.}}

Il est sage d'ajouter [https://packages.gentoo.org/useflags/unicode <code>unicode</code>] aux options globales de la variable USE dans le fichier {{Path|[[:/etc/portage/make.conf#USE|/etc/portage/make.conf]]}}, et de réinstaller {{Package|sys-libs/ncurses}} et {{Package|sys-libs/slang}}. Portage le fera automatiquement si les options <code>--changed-use</code> ou <code>--newuse</code> sont utilisées. Exécuter la commande suivante pour installer le paquet : 

{{RootCmd|emerge --update --deep --newuse @world}}

Il faut également recompiler les paquets qui possèdent un lien vers ceux-là, maintenant que les changements de la variable USE ont été appliqués. L'outil à utiliser ({{c|revdep-rebuild}}) fait partie du paquet {{Package|app-portage/gentoolkit}}. 

{{RootCmd|revdep-rebuild --soname libncurses.so.5
|revdep-rebuild --soname libslang.so.1}}

=== KDE, GNOME, et Xfce ===

Tous les environnements de bureau majeurs prennent totalement en charge l'Unicode, et ne nécessitent pas d'autres étapes de configuration que celles décrites dans ce guide. Ceci est dû au fait que les boîtes à outils graphiques sous-jacentes (Qt ou GTK+2) sont prédisposées UTF-8 et que, par conséquent, les applications qui s'appuient sur ces boîtes à outils le sont également dès l'installation. 

{{:Input_methods/key_sequence/fr}}

Les exceptions à cette règle surviennent avec Xlib et GTK+1. GTK+1 requiert une spécification de police de caractères iso-10646-1 dans ~/.gtkrc, par exemple, <code>-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1</code>. C'est pourquoi, les applications utilisant Xlib ou Xaw doivent recevoir une spécification de police de caractères similaire ; autrement elles ne fonctionneront pas. 

{{Note|Si un vieux centre de contrôle de gnome1 est disponible, l'utiliser à la place. Choisir une police de caractères iso10646-1 à partir de là.}}

{{CodeBox|title=Fichier d'exemple ~/.gtkrc (pour GTK+1) qui défini une police compatible Unicode|1=
style "user-font"
{
    fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"
}
widget_class "*" style "user-font"
}}

Dans les applications qui prennent en charge les interfaces graphiques Qt et GTK+2, l'interface GTK+2 donnera en général de meilleurs résultats avec Unicode.

=== X11 et polices de caractères ===

Les polices de caractères TrueType prennent en charge l'Unicode, et la plupart des polices qui arrivent avec Xorg disposent d'une prise en charge étendue, bien qu'évidemment, tous les glyphes particuliers accessibles par Unicode aient été créés pour ces polices. Pour compiler les polices (y compris le jeu Bitstream Vera) avec la prise en charge des caractères est asiatiques dans X, s'assurer que l'option <code>cjk</code> de la variable USE est définie. Beaucoup d'autres applications utilisent cette option, c'est pourquoi, il est judicieux de l'ajouter aux options permanentes de la variable USE. 

Il y a aussi plusieurs paquets de polices de caractères dans Portage qui sont prédisposées Unicode. Voir la page [[Fontconfig/fr]] pour plus d'informations sur les polices recommandées et leur configuration.

=== Gestionnaires de fenêtres et émulateurs de terminal ===

Les gestionnaires de fenêtres qui ne sont pas construits sur GTK+ ou Qt n'ont généralement pas une très bonne prise en charge de l'Unicode, car ils utilisent souvent la bibliothèque Xft pour les polices. Si le gestionnaire de fenêtres n'utilise pas les polices Xft, il est alors possible d'utiliser la spécification de police de caractères mentionnée dans les sections précédentes en tant que police Unicode. 

Les émulateurs de terminal qui utilisent Xft et prennent en charge l'Unicode sont plus difficiles à trouver. En plus de Konsole et du terminal-gnome, les meilleures options dans Portage sont {{Package|x11-terms/rxvt-unicode}}, {{Package|x11-terms/xfce4-terminal}}, {{Package|gnustep-apps/terminal}}, {{Package|x11-terms/mlterm}}, ou {{Package|x11-terms/xterm}} quand il est compilé avec l'option <code>unicode</code> de la variable USE et invoqué comme {{c|uxterm}}. {{Package|app-misc/screen}} prend en charge l'UTF-8  également, lorsqu'il est invoqué comme {{c|screen -U}} ou lorsque ce qui suit est placé dans le fichier {{Path|~/.screenrc}} : 

{{CodeBox|title=Contenu de ~/.screenrc pour le support d'UTF-8|1=
defutf8 on
}}

=== Vim, emacs, xemacs et nano ===

[[Vim#Change_file_encoding|Vim]] fournit une prise en charge totale de l'UTF-8, et dispose d'une détection des fichiers UTF-8 en interne. Pour plus d'informations sur [[Vim#Change_file_encoding|Vim]], utiliser <code>:help mbyte.txt</code>. 

[[GNU Emacs]] depuis la version 23 et [[XEmacs]] version 21.5 prennent totalement en charge l'UTF-8. GNU Emacs 24 prend aussi en charge l'édition de textes bidirectionnels. 

Nano fournit une prise en charge totale de l'UTF-8 depuis la version 1.3.6.

=== Shells ===

Ordinairement, {{c|[[bash]]}} assure une prise en charge totale de l'UTF-8 via la bibliothèque GNU readline. Z shell ({{c|[[zsh]]}}) fournit une prise en charge de l'Unicode avec l'option <code>unicode</code> de la variable USE. 

Le shell C, {{c|tcsh}} et {{c|ksh}} ne fournissent aucune prise en charge de l'UTF-8.

=== Irssi ===

Irssi dispose d'une prise en charge totale de l'UTF-8, bien que cela nécessite la définition d'une option par l'utilisateur. 

{{Cmd|set term_charset UTF-8|prompt=[irssi] }}

Pour les canaux dans lesquels des caractères non-ASCII sont souvent échangés dans des jeux de caractères non-UTF-8, la commande {{c|/recode}} peut être utilisée pour convertir les caractères. Taper {{c|/help recode}}  pour plus d'informations.

=== Mutt ===

Le client de messagerie Mutt dispose d'une très bonne prise en charge d'Unicode. Pour utiliser UTF-8 avec Mutt, rien n'est à mettre dans les fichiers de configuration. Mutt travaille dans un environnement Unicode sans modification si tous les fichiers de configuration (y compris la signature) sont encodés UTF-8. 

{{Note|Il est toujours possible de voir '?' dans un courriel lu avec Mutt. Cela est le résultat de quelqu'un qui utilise un client de messagerie qui ne spécifie aucun jeu de caractères. Il n'y pas grand chose à faire d'autre que de lui demander de configurer son client correctement.}}

Une information complémentaire est disponible sur le [http://wiki.mutt.org/index.cgi?MuttFaq/Charset Mutt Wiki] .

=== Man ===

Les pages man sont une partie intégrante de toute machine Linux. Pour vérifier que tout texte Unicode dans les pages man est rendu correctement, éditer le fichier {{Path|/etc/man.conf}} et remplacer une ligne comme indiqué ci-dessous. C'est seulement nécessaire quand {{Package|sys-apps/man}} est utilisé au lieu de {{Package|sys-apps/man-db}}.

{{CodeBox|title=Changement dans man.conf pour le support Unicode|1=
## (Ceci est l'ancienne ligne)
NROFF           /usr/bin/nroff -Tascii -c -mandoc
## (Remplacer l'ancienne ligne par ceci)
NROFF           /usr/bin/nroff -mandoc -c
}}

=== links et elinks ===

Il s'agit ici de navigateurs textuels, et ce qui suit présente comment activer la prise en charge de l'UTF-8. Pour {{c|elinks}} et {{c|links}}, il y deux façons d'y parvenir, l'une en utilisant une option de configuration interne au navigateur, l'autre en éditant un fichier de configuration. Pour utiliser l'option interne du navigateur, ouvrir un page Web avec {{c|elinks}} ou {{c|links}}, puis, faire {{Key|Alt}}+{{Key|S}} au clavier pour entrer dans le menu de configuration. Sélectionner alors la dernière option <code>UTF-8 I/O</code> en pressant {{Key|Entrée}}. Sauvegarder et quitter le menu. Sur {{c|links}} il est possible d'avoir à faire à nouveau {{Key|Alt}}+{{Key|S}} et à appuyer sur la touche {{Key|S}} pour sauvegarder. Le fichier de configuration est présenté ci-dessous : 

{{CodeBox|title=Activer UTF-8 pour elinks/links|1=
## (Pour elinks, éditer /etc/elinks/elinks.conf ou ~/.elinks/elinks.conf et ajouter la ligne suivante.)
set terminal.linux.utf_8_io = 1

## (Pour links, éditer ~/.links/links.cfg et ajouter la ligne suivante.)
terminal "xterm" 0 1 0 us-ascii utf-8
}}

=== Samba ===

Samba est une suite logicielle qui met en œuvre le protocole SMB (Server Message Block) pour les systèmes UNIX tels que les Macs, Linux et FreeBSD. Le protocole est aussi parfois appelé le Common Internet File System (CIFS). Samba inclut aussi le système NetBIOS - utilisé pour le partage de fichiers à travers des réseaux Windows. 

Ajouter ce qui suit sous la section [global] :
{{RootCmd|nano -w /etc/samba/smb.conf|output=<pre>
dos charset = 1255
unix charset = UTF-8
display charset = UTF-8
</pre>
}}

=== Test complet ===

Il y a de nombreux sites web de test en UTF-8 et la plupart des [https://packages.gentoo.org/categories/www-client navigateurs web disponibles dans Gentoo] disposent d'une prise en charge complète de l'UTF-8. 

Lorsque l'un des navigateurs textuels est utilisé, il est important de bien s'assurer d'utiliser un terminal prédisposé UTF-8.

Si certains caractères s'affichent sous forme de boîte avec des lettres ou des chiffres dedans, cela signifie que la police de caractères utilisée ne dispose pas de caractère pour le symbole ou le glyphe attendu par UTF-8. À la place, elle affiche une boîte avec le code hexadécimal du symbole UTF-8. 

* [http://unicode-table.com/en/ unicode-table.com]
* [http://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html Une page de test Unicode de W3C] 
* [http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm Une page de test Unicode fournie par l'Université de Frankfort]

== Problèmes connus ==

=== Fichiers de configuration système (dans /etc) ===

La plupart des fichiers de configuration (tel que  {{Path|/etc/fstab}}) ne prennent pas en charge l'UTF-8. Il est recommandé de s'en tenir aux caractères ASCII pour ces fichiers.

== Ressources externes ==

* [https://fr.wikipedia.org/wiki/Unicode La page Wikipédia pour Unicode] 
* [https://fr.wikipedia.org/wiki/UTF-8 La page Wikipédia pour UTF-8] 
* [http://www.unicode.org Unicode.org] 
* [http://www.utf-8.com UTF-8.com] 
* [https://www.ietf.org/rfc/rfc3629.txt RFC 3629] 
* [https://www.ietf.org/rfc/rfc2277.txt RFC 2277] 
* [https://www.tbray.org/ongoing/When/200x/2003/04/26/UTF Characters vs. Bytes]
* [http://www.gnu.org/software/libc/manual/html_node/Locales.html The GNU C Library: Locales and Internationalization]
* [http://unifoundry.com/unicode-tutorial Unifoundry.com - Unicode Tutorial]
* [https://packages.gentoo.org/useflags/unicode unicode USE flag description]

[[Category:Localization]] {{Migrated|originalauthors=Thomas Martin, Alexander Simonov, Shyam Mani, nightmorph}}
