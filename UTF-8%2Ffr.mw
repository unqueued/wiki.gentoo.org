<languages />

UTF-8 est un encodage des caractères de longueur variable qui, dans ce cas, signifie qu'il utilise 1 à 4 octets par symbole. Le premier octet sert à encoder les caractères ASCII, donnant ainsi au jeu de caractères une totale compatibilité avec ASCII. UTF-8 signifie que les caractères ASCII et latins sont interchangeables moyennant un petit accroissement de la taille des données, parce que seul le premier chiffre binaire est utilisé. Les utilisateurs d'alphabets de l'est asiatique, comme les japonais, à qui ont a attribué une plage plus élevée d'octets sont insatisfaits, car cela conduit à plus de 50% de redondance dans leurs données. 

== Encodage des caractères ==

=== Qu'est-ce que l'encodage des caractères ? ===

Les ordinateurs ne comprennent pas les textes eux-mêmes. Au lieu de cela, chaque caractère est représenté par un nombre. Traditionnellement, chaque jeu de nombres utilisé pour représenter les alphabets et les caractères (connu sous le nom de système de codage, encodage ou jeu de caractères) était limité en taille à cause de la limitation même du matériel constituant les ordinateurs. 

=== L'histoire de l'encodage des caractères ===

Le plus courant (ou du moins le plus largement accepté) des jeux de caractères est l''''ASCII''' (American Standard Code for Information Interchange). Il est largement reconnu que l'ASCII est la norme  logicielle qui a connu le plus grand succès de tous les temps. L'ASCII moderne a été normalisé en 1986  (ANSI X3.4, RFC 20, ISO/IEC 646:1991, ECMA-6) par l'American National Standards Institute. 

ASCII, a strictement parler, est encodé sur 7 chiffres binaires, ce qui signifie qu'il utilise des motifs de chiffres représentables avec 7 chiffres binaires. Ce qui correspond à la plage 0 à 127 en décimal. Ceci inclut 32 caractères de contrôle non visualisables, en majorité entre 0 et 31, auxquels s'ajoute le caractère de contrôle final, DEL ou delete, dont la représentation est 127. Tous les caractères entre 32 et 126 inclus, sont visualisables : l'espace, les marques de ponctuation, les lettres latines et les chiffres. 

Le huitième bit en ASCII était à l'origine utilisé comme bit de parité pour la détection d'erreurs. Si cela n'est pas souhaité, on peut le laisser à 0. Ceci signifie que, avec l'ASCII, chaque caractère est représenté par un seul octet. 

Bien que l'ASCII soit suffisant pour communiquer en anglais moderne, dans d'autres langues européens qui comprennent des caractères accentués, les choses ne sont pas aussi simples. Les normes ISO 8859 ont été développées pour satisfaire ces besoins. Elles sont rétro-compatibles avec l'ASCII, mais au lieu de laisser le huitième chiffre binaire à 0, elles l'utilisent pour former un autre ensemble de 127 caractères dans chacun des encodages. Les limitations des normes ISO 8859 sont apparues très vite, et il y a aujourd'hui 15 variantes de la norme ISO 8859 (8859-1 à 8859-15). En dehors de la plage compatible avec l'ASCII, il y a souvent des conflits entre les lettres représentées par chacun des octets. Pour compliquer encore l'interopérabilité entre versions, Windows-1252 est utilisée à leur place dans certaines versions de Microsoft Windows pour les langues européennes. Il s'agit d'un jeu étendu de ISO-8859-1, cependant il en différe de plusieurs façons. Tous ces jeux restent néanmoins compatibles avec ASCII. 

Le développement nécessaire d'encodage mono-octet pour des alphabets non latins, tels que EUC (Extended Unix Coding) qui est utilisé pour le Japonais et le Coréen (et dans une moindre mesure pour le Chinois) a créé encore plus de confusion, tandis que d'autres systèmes d'exploitation utilisaient des jeux de caractères différents pour les mêmes langues, par exemple, Shift-JIS et ISO-2022-JP. Les utilisateurs désireux d'afficher des glyphes cyrilliques avaient à choisir entre KOI8-R pour le Russe et le Bulgare ou KOI8-U pour l'Ukrainien, aussi bien que parmi les autres encodages cyrilliques comme le peu prisé ISO 8859-5 et le plus connu Windows-1251. Tous ces jeux de caractères rompaient la compatibilité avec ASCII (quoi que le jeu KOI8 place les caractères cyrilliques dans l'ordre latin, de manière telle que si le huitième chiffre binaire est retiré, le texte est déchiffrable sur un terminal ASCII via une translittération à casse inversée.) 

Ceci a conduit à la confusion, et aussi à une presque totale incapacité à communiquer dans plusieurs langues, en particulier à travers des alphabets différents. C'est là qu' Unicode entre en scène. 

=== Qu'est-ce qu'Unicode ? ===

La norme Unicode jette aux orties la limite traditionnelle d'un octet pour les jeux de caractères. Elle  utilise 17 ''plans'' de 65.536 points de code pour décrire un maximum de 1.114.112 caractères. Comme le premier plan, aussi connu sous le nom de ''Basic Multilingual Plane (Plan Multilingue de Base)'' ou BMP, contient presque tout ce dont vous aurez jamais besoin, beaucoup ont fait la supposition fausse que l'Unicode était un jeu de caractères encodé sur 16 chiffres binaires. 

Unicode a été cartographié de différentes manières, mais les deux plus courantes sont '''UTF''' (Unicode Transformation Format pour Format de transformation d'Unicode) et '''UCS''' (Universal Character Set pour Jeu de caractères universel). Le nombre après UTF indique le nombre de chiffres binaires dans chacun des éléments, tandis que le nombre après UCS indique le nombre d'octets. UTF-8 est devenu le moyen le plus répandu pour l'échange de text Unicode en raison de sa nature 8 chiffres binaires pure, et fait l'objet de ce document. 

=== Que peut faire UTF-8 pour vous ? ===

UTF-8 vous permet de travailler dans un environnement multilingue conforme aux normes et reconnu internationalement, avec une redondance des données comparativement faible. UTF-8 est le moyen privilégié pour transmettre les caractères non ASCII sur Internet, via des courriels, l'IRC ou presque n'importe quel autre médium. En dépit de cela, beaucoup de gens considèrent la communication en ligne en UTF-8 comme abusive. Il est toujours bon d'être conscient de cela sur certains canaux, listes de diffusion ou groupes Usenet avant d'employer des caractères non ASCII en UTF-8. 

== Installer l' UTF-8 sur Gentoo Linux ==

=== Trouver ou créer des locales UTF-8  ===

Maintenant que vous comprenez les principes d'Unicode, vous êtes prêt à utiliser UTF-8 sur votre système. 

Le prérequis pour UTF-8 est d'avoir une version de glibc installée qui assure la prise en charge de la langue nationale. Le moyen recommandé pour réaliser cela, est le fichier {{Path|/etc/locale.gen}}. C'est cependant au-delà du champ de ce document d'expliquer l'utilisation de ce fichier. Ceci est expliqué dans le [https://wiki.gentoo.org/wiki/Localization/HOWTO Gentoo Localization Guide] . 

Ensuite, vous devez décider si une locale UTF-8 est déjà disponible pour votre langue, ou si vous devez en créer une. 

{{Cmd|locale -a {{!}} grep 'en_GB'|output=<pre>
en_GB
en_GB.UTF-8
</pre>
}}

De la sortie de cette commande, vous devez prendre le résultat avec un suffixe similaire à  <code>.UTF-8</code>. Si vous ne trouvez aucun résultat avec un suffixe similaire à  <code>.UTF-8</code>, vous devez créez une locale UTF-8 compatible. 


{{Note|Only execute the following code listing if you do not have a UTF-8 locale available for your language.}}

Replace "en_GB" with your desired locale setting:
{{RootCmd|localedef -i en_GB -f UTF-8 en_GB.UTF-8}}

Another way to include a UTF-8 locale is to add it to the {{Path|/etc/locale.gen}} file and generate necessary locales with <code>locale-gen</code> command. 

{{Code|Line in /etc/locale.gen|<pre>
en_GB.UTF-8 UTF-8
</pre>
}}

=== Setting the Locale ===

There is one environment variable that needs to be set in order to use our new UTF-8 locales: <code>LC_CTYPE</code> (or optionally <code>LANG</code> , if you want to change the system language as well). There are also many different ways to set it; some people prefer to only have a UTF-8 environment for a specific user, in which case they set them in their {{Path|~/.profile}} (if you use <code>/bin/sh</code> ), {{Path|~/.bash_profile}} or {{Path|~/.bashrc}} (if you use <code>/bin/bash</code> ). More details and best practices can be found in our [https://wiki.gentoo.org/wiki/Localization/HOWTO Localization Guide] . 

Others prefer to set the locale globally. One specific circumstance where the author particularly recommends doing this is when {{Path|/etc/init.d/xdm}} is in use, because this init script starts the display manager and desktop before any of the aforementioned shell startup files are sourced, and so before any of the variables are in the environment. 

Setting the locale globally should be done using {{Path|/etc/env.d/02locale}} . The file should look something like the following: 

{{Code|Demonstration /etc/env.d/02locale|<pre>
## (As always, change "en_GB.UTF-8" to your locale)
LANG="en_GB.UTF-8"
</pre>
}}

{{Note|You can also substitute <code>LC_CTYPE</code> for <code>LANG</code> . For more information on the categories affected by using <code>LC_CTYPE</code> , please read the [http://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html#Locale-Categories GNU locale page] .}}

Next, the environment must be updated with the change. 

{{RootCmd|env-update|output=<pre>
>>> Regenerating /etc/ld.so.cache...
 * Caching service dependencies ...
</pre>}}
{{RootCmd|source /etc/profile}}

Now, run <code>locale</code> with no arguments to see if we have the correct variables in our environment: 

{{RootCmd|locale|output=<pre>
LANG=en_GB.UTF-8
LC_CTYPE="en_GB.UTF-8"
LC_NUMERIC="en_GB.UTF-8"
LC_TIME="en_GB.UTF-8"
LC_COLLATE="en_GB.UTF-8"
LC_MONETARY="en_GB.UTF-8"
LC_MESSAGES="en_GB.UTF-8"
LC_PAPER="en_GB.UTF-8"
LC_NAME="en_GB.UTF-8"
LC_ADDRESS="en_GB.UTF-8"
LC_TELEPHONE="en_GB.UTF-8"
LC_MEASUREMENT="en_GB.UTF-8"
LC_IDENTIFICATION="en_GB.UTF-8"
LC_ALL=
</pre>
}}

That's everything. You are now using UTF-8 locales, and the next hurdle is the configuration of the applications you use from day to day. 

== Application Support ==

When Unicode first started gaining momentum in the software world, multibyte character sets were not well suited to languages like C, in which many of the day-to-day programs people use are written. Even today, some programs are not able to handle UTF-8 properly. Fortunately, most are! 

=== Filenames, NTFS, and FAT ===

There are several NLS options in the Linux kernel configuration menu, but it is important to not become confused! For the most part, the only thing you need to do is to build UTF-8 NLS support into your kernel, and change the default NLS option to utf8. 

{{Kernel|Kernel configuration steps for UTF-8 NLS|<pre>
File Systems -->
  Native Language Support -->
    (utf8) Default NLS Option
    <*> NLS UTF8
    ## (Also <*> other character sets that are in use in
    your FAT filesystems or Joilet CD-ROMs.)
</pre>
}}

If you plan on mounting NTFS partitions, you may need to specify an <code>nls=</code> option with mount. If you plan on mounting FAT partitions, you may need to specify a <code>codepage=</code> option with mount. Optionally, you can also set a default codepage for FAT in the kernel configuration. Note that the <code>codepage</code> option with mount will override the kernel settings. 

{{Kernel|FAT settings in kernel configuration|<pre>
File Systems -->
  DOS/FAT/NT Filesystems  -->
    (437) Default codepage for fat
</pre>
}}

You should avoid setting <code>Default iocharset for fat</code> to UTF-8, as it is not recommended. Instead, you may want to pass the option utf8=true when mounting your FAT partitions. For further information, see <code>man mount</code> and the kernel documentation at {{Path|/usr/src/linux/Documentation/filesystems/vfat.txt}} . 

For changing the encoding of filenames, <code>app-text/convmv</code> can be used. 

{{Emerge|app-text/convmv}}

The format of the <code>convmv</code> command is as follows:

{{RootCmd|convmv -f &lt;current-encoding&gt; -t utf-8 &lt;filename&gt;}}

Substitute iso-8859-1 with the charset you are converting from:

{{RootCmd|convmv -f iso-8859-1 -t utf-8 filename}}

For changing the ''contents'' of files, use the <code>iconv</code> utility, bundled with <code>glibc</code>. Subst muitute iso-8859-1 with the charset you are converting from, and check that the output is sane:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 filename}}

To convert a file, you must create another file:

{{RootCmd|iconv -f iso-8859-1 -t utf-8 filename &gt; newfile}}

{{Package|app-text/recode}} can also be used for this purpose. 

=== The System Console ===

{{Important|You need sys-apps/baselayout-1.11.9 or higher for Unicode on the console.}}

To enable UTF-8 on the console, you should edit {{Path|/etc/rc.conf}} and set <code>unicode="yes"</code> , and also read the comments in that file -- it is important to have a font that has a good range of characters if you plan on making the most of Unicode. For this to work, make sure you have properly created a Unicode locale. 

The <code>keymap</code> variable, set in {{Path|/etc/conf.d/keymaps}} , should have a Unicode keymap specified. 

{{Code|Example /etc/conf.d/keymaps snippet|<pre>
## (Change "uk" to your local layout)
keymap="uk"
</pre>
}}

=== Ncurses and Slang ===

{{Note|Ignore any mention of Slang in this section if you do not have it installed or do not use it.}}

It is wise to add <code>unicode</code> to your global USE flags in {{Path|/etc/portage/make.conf}} , and then to remerge <code>sys-libs/ncurses</code> and <code>sys-libs/slang</code> if appropriate. Portage will do this automatically when you update your system: 

{{RootCmd|emerge --update --deep --newuse world}}

We also need to rebuild packages that link to these, now the USE changes have been applied. The tool we use ( <code>revdep-rebuild</code> ) is part of the <code>gentoolkit</code> package. 

{{RootCmd|revdep-rebuild --soname libncurses.so.5
|revdep-rebuild --soname libslang.so.1}}

=== KDE, GNOME and Xfce ===

All of the major desktop environments have full Unicode support, and will require no further setup than what has already been covered in this guide. This is because the underlying graphical toolkits (Qt or GTK+2) are UTF-8 aware. Subsequently, all applications running on top of these toolkits should be UTF-8-aware out of the box. 

The exceptions to this rule come in Xlib and GTK+1. GTK+1 requires a iso-10646-1 FontSpec in the ~/.gtkrc, for example <code>-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1</code> . Also, applications using Xlib or Xaw will need to be given a similar FontSpec, otherwise they will not work. 

{{Note|If you have a version of the gnome1 control center around, use that instead. Pick any iso10646-1 font from there.}}

{{Code|Example ~/.gtkrc (for GTK+1) that defines a Unicode compatible font|<pre>
style "user-font"
{
    fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"
}
widget_class "*" style "user-font"
</pre>
}}

If an application has support for both a Qt and GTK+2 GUI, the GTK+2 GUI will generally give better results with Unicode. 

=== X11 and Fonts ===

TrueType fonts have support for Unicode, and most of the fonts that ship with Xorg have impressive character support, although, obviously, not every single glyph available in Unicode has been created for that font. To build fonts (including the Bitstream Vera set) with support for East Asian letters with X, make sure you have the <code>cjk</code> USE flag set. Many other applications utilise this flag, so it may be worthwhile to add it as a permanent USE flag. 

Also, several font packages in Portage are Unicode aware. 

{{Emerge|terminus-font intlfonts freefonts corefonts}}

=== Window Managers and Terminal Emulators ===

Window managers not built on GTK or Qt generally have very good Unicode support, as they often use the Xft library for handling fonts. If your window manager does not use Xft for fonts, you can still use the FontSpec mentioned in the previous section as a Unicode font. 

Terminal emulators that use Xft and support Unicode are harder to come by. Aside from Konsole and gnome-terminal, the best options in Portage are <code>x11-terms/rxvt-unicode</code> , <code>x11-terms/xfce4-terminal</code> , <code>gnustep-apps/terminal</code> , <code>x11-terms/mlterm</code> , or plain <code>x11-terms/xterm</code> when built with the <code>unicode</code> USE flag and invoked as <code>uxterm</code> . <code>app-misc/screen</code> supports UTF-8 too, when invoked as <code>screen -U</code> or the following is put into the {{Path|~/.screenrc}} : 

{{Code|~/.screenrc for UTF-8|<pre>
defutf8 on
</pre>
}}

=== Vim, Emacs, Xemacs and Nano ===

Vim provides full UTF-8 support, and also has builtin detection of UTF-8 files. For further information in Vim, use <code>:help mbyte.txt</code> . 

Emacs version 23 and Xemacs version 21.5 have full UTF-8 support. Emacs 24 will also support editing bidirectional text. 

Nano has provided full UTF-8 support since version 1.3.6. 

=== Shells ===

Currently, <code>bash</code> provides full Unicode support through the GNU readline library. Z Shell ( <code>zsh</code> ) offers Unicode support with the <code>unicode</code> USE flag. 

The C shell, <code>tcsh</code> and <code>ksh</code> do not provide UTF-8 support at all. 

=== Irssi ===

Irssi has complete UTF-8 support, although it does require a user to set an option. 

{{Cmd|set term_charset UTF-8|prompt=[irssi] }}

For channels where non-ASCII characters are often exchanged in non-UTF-8 charsets, the <code>/recode</code> command may be used to convert the characters. Type <code>/help recode</code> for more information. 

=== Mutt ===

The Mutt mail user agent has very good Unicode support. To use UTF-8 with Mutt, you don't need to put anything in your configuration files. Mutt will work under unicode enviroment without modification if all your configuration files (signature included) are UTF-8 encoded. 

{{Note|You may still see '?' in mail you read with Mutt. This is a result of people using a mail client which does not indicate the used charset. You can't do much about this than to ask them to configure their client correctly.}}

Further information is available from the [http://wiki.mutt.org/index.cgi?MuttFaq/Charset Mutt Wiki] . 

=== Man ===

Man pages are an integral part of any Linux machine. To ensure that any unicode in your man pages render correctly, edit {{Path|/etc/man.conf}} and replace a line as shown below. 

{{Code|man.conf changes for Unicode support|<pre>
## (This is the old line)
NROFF           /usr/bin/nroff -Tascii -c -mandoc
## (Replace the one above with this)
NROFF           /usr/bin/nroff -mandoc -c
</pre>
}}

=== elinks and links ===

These are commonly used text-based browsers, and we shall see how we can enable UTF-8 support on them. On <code>elinks</code> and <code>links</code> , there are two ways to go about this, one using the Setup option from within the browser or editing the config file. To set the option through the browser, open a site with <code>elinks</code> or <code>links</code> and then <code>Alt+S</code> to enter the Setup Menu then select Terminal options, or press <code>T</code> . Scroll down and select the last option <code>UTF-8 I/O</code> by pressing Enter. Then Save and exit the menu. On <code>links</code> you may have to do a repeat <code>Alt+S</code> and then press <code>S</code> to save. The config file option, is shown below. 

{{Code|Enabling UTF-8 for elinks/links|<pre>
## (For elinks, edit /etc/elinks/elinks.conf or ~/.elinks/elinks.conf and
add the following line)
set terminal.linux.utf_8_io = 1

## (For links, edit ~/.links/links.cfg and add the following
line)
terminal "xterm" 0 1 0 us-ascii utf-8
</pre>
}}

=== Samba ===

Samba is a software suite which implements the SMB (Server Message Block) protocol for UNIX systems such as Macs, Linux and FreeBSD. The protocol is also sometimes referred to as the Common Internet File System (CIFS). Samba also includes the NetBIOS system - used for file sharing over windows networks. 

add the following under the [global] section:
{{RootCmd|nano -w /etc/samba/smb.conf|output=<pre>
dos charset = 1255
unix charset = UTF-8
display charset = UTF-8
</pre>
}}

=== Testing it all out ===

There are numerous UTF-8 test websites around. <code>net-www/w3m</code> , <code>net-www/links</code> , <code>net-www/elinks</code> , <code>net-www/lynx</code> and all Mozilla based browsers (including Firefox) support UTF-8. Konqueror and Opera have full UTF-8 support too. 

When using one of the text-only web browsers, make absolutely sure you are using a Unicode-aware terminal. 

If you see certain characters displayed as boxes with letters or numbers inside, this means that your font does not have a character for the symbol or glyph that the UTF-8 wants. Instead, it displays a box with the hex code of the UTF-8 symbol. 

*  [http://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html A W3C UTF-8 Test Page] 
*  [http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm A UTF-8 test page provided by the University of Frankfurt] 

=== Input Methods ===

''Dead keys'' may be used to input characters in X that are not included on your keyboard. These work by pressing your right Alt key (or in some countries, AltGr) and an optional key from the non-alphabetical section of the keyboard to the left of the return key at once, releasing them, and then pressing a letter. The dead key should modify it. Input can be further modified by using the Shift key at the same time as pressing the AltGr and modifier. 

To enable dead keys in X, you need a layout that supports it. Most European layouts already have dead keys with the default variant. However, this is not true of North American layouts. Although there is a degree of inconsistency between layouts, the easiest solution seems to be to use a layout in the form "en_US" rather than "us", for example. The layout is set in {{Path|/etc/X11/xorg.conf}} like so: 

{{Code|/etc/X11/xorg.conf snippet|<pre>
Section "InputDevice"
    Identifier "Keyboard0"
    Driver     "kbd"
    Option     "XkbLayout" "en_US" ## # Rather than just "us"
    ## (Other Xkb options here)
EndSection
</pre>
}}

{{Note|The preceding change only needs to be applied if you are using a North American layout, or another layout where dead keys do not seem to be working. European users should have working dead keys as is.}}

This change will come into effect when your X server is restarted. To apply the change now, use the <code>setxkbmap</code> tool, for example, <code>setxkbmap en_US</code> . 

It is probably easiest to describe dead keys with examples. Although the results are locale dependent, the concepts should remain the same regardless of locale. The examples contain UTF-8, so to view them you need to either tell your browser to view the page as UTF-8, or have a UTF-8 locale already configured. 

When I press AltGr and [ at once, release them, and then press a, 'ä' is produced. When I press AltGr and [ at once, and then press e, 'ë' is produced. When I press AltGr and ; at once, 'á' is produced, and when I press AltGr and ; at once, release them, and then press e, 'é' is produced. 

By pressing AltGr, Shift and [ at once, releasing them, and then pressing a, a Scandinavian 'å' is produced. Similarly, when I press AltGr, Shift and [ at once, release ''only'' the [, and then press it again, '°' is produced. Although it looks like one, this (U+02DA) is not the same as a degree symbol (U+00B0).

AltGr can be used with alphabetical keys alone. For example, AltGr and m, a Greek lower-case letter mu is produced. AltGr and s produce a scharfes s or esszet, etc. As many European users would expect (because it is marked on their keyboard), AltGr and 4 (or E depending on the keyboard layout) produces a Euro sign, '€'. 

=== Resources ===

*  [http://en.wikipedia.org/wiki/Unicode The Wikipedia entry for Unicode] 
*  [http://en.wikipedia.org/wiki/UTF-8 The Wikipedia entry for UTF-8] 
*  [http://www.unicode.org Unicode.org] 
*  [http://www.utf-8.com UTF-8.com] 
*  [http://www.ietf.org/rfc/rfc3629.txt RFC 3629] 
*  [http://www.ietf.org/rfc/rfc2277.txt RFC 2277] 
*  [http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF Characters vs. Bytes] 

== Reported Issues or Problems ==

=== System Configuration Files (in /etc) ===

Most system configuration files, such as {{Path|/etc/fstab}} , do not support UTF-8. It is recommended to stick with the ASCII character set for these files. 

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* Thomas Martin
* Alexander Simonov
* Shyam Mani
* nightmorph
