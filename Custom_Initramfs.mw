''initramfs'' is a root filesystem that is embedded into the kernel and loaded at an early stage of the boot process. It is [[Article description::the successor of ''initrd''. It provides early userspace which can do things the kernel can't easily do by itself during the boot process.]]

Using ''initramfs'' is optional. By default, the kernel initializes hardware using built-in drivers, mounts the specified root partition, loads the [[init system]] of the installed Linux distribution. The init system then loads additional modules and starts services until it eventually allows you to log in. This is a good default behavior and sufficient for many users. ''initramfs'' is for users with advanced requirements; for users who need to do things as early as possible, even before the root partition is mounted.

Here are some examples of what you can do with ''initramfs'':

* Mount the root partition (for encrypted, logical, and otherwise special partitions);
* Provide a minimalistic rescue shell (if something goes wrong);
* Customize the boot process (e.g. print a welcome message, boot splash, etc.);
* Load modules (e.g. third party drivers);
* Anything the kernel can't do (as long as you can do it in user space, e.g. by executing commands).

If you don't have advanced requirements, you don't need ''initramfs''.

== Prerequisites ==

There are countless ways to make an ''initramfs''. You can choose not to create an ''initramfs'' at all but let tools, such as [[Genkernel]] or [[Dracut]], do the work for you. If you are lucky, one of them does what you want out of the box, and you don't need to bother with how ''initramfs'' works and what it does anymore. If you're unlucky, they don't do what you want and you have to extend their functionality, or even build an ''initramfs'' all by yourself.

An ''initramfs'' contains at ''least'' one file called {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}. This file is executed by the kernel as the main init process (PID 1). It has to do all the work. In addition, there can be any number of additional files and directories that are required by {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}. They are usually files you'll also find on any other root filesystem, such as {{Path|/dev}} for device nodes, {{Path|/proc}} for kernel information, {{Path|/bin}} for binaries, and so on. The structure of an ''initramfs'' can be simple, or it can be complicated, depending on what you are planning to do.

When the kernel mounts the ''initramfs'', your target root partition is not yet mounted, so you can't access any of your files. That means there is nothing but the ''initramfs''. So everything you need, everything you want, you have to include it in your ''initramfs''. If you want a shell, you have to include it in your ''initramfs''. If you want to mount something, you need a mount utility. If you need to load a module, your ''initramfs'' has to provide both the module, as well as a utility to load it. If the utility depends on libraries in order to work, you have to include the libraries as well. This seems complicated, and it is, because the ''initramfs'' has to function independently.

== Basics ==

In this section you will learn the ''easy and straightforward way to initramfs creation''. You will make a functional - albeit minimalistic - ''initramfs'' which you then can extend according to your own requirements.

=== Directory structure ===

Create a basic ''initramfs'' directory structure that will later become your ''initramfs'' root. For consistency, we'll work in {{Path|/usr/src/initramfs}}, but any location would do. If you choose another location, please adapt accordingly.

{{RootCmd|<nowiki>mkdir --parents /usr/src/initramfs/{bin,dev,etc,lib,lib64,mnt/root,proc,root,sbin,sys}</nowiki>}}

==== Device nodes ====

Most things the ''initramfs'' does will require a couple of device nodes to be present, especially the device for the root partition. Throughout this document, {{Path|/dev/sda1}} will be used as example device. Copy basic device nodes from the root filesystem to the ''initramfs'' example location:

{{RootCmd|cp --archive /dev/{null,console,tty,sda1} /usr/src/initramfs/dev/}}

Which devices you need exactly depends entirely on what you are going to use ''initramfs'' for. Please adapt to your own needs.

{{Note|More advanced approaches to device nodes are covered in the [[#Dynamic_devices|Dynamic devices]] section.}}

=== Applications ===
Any binary you want to execute at boot needs to be copied into your ''initramfs'' layout. You also need to copy any libraries that your binaries require. To see what libraries any particular binary requires, use the {{c|ldd}} tool. For example, the {{Package|dev-util/strace}} binary requires:

{{Cmd|ldd /usr/bin/strace|output=<pre>
    linux-vdso.so.1 (0x00007fff271ff000)
    libc.so.6 => /lib64/libc.so.6 (0x00007f5b954fe000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f5b958a9000)
</pre>}}

Here you see that for {{Path|/usr/bin/strace}} to work in your ''initramfs'', you not only need to copy {{Path|/usr/bin/strace}} to your {{Path|/usr/src/initramfs/bin}}, but also {{Path|/lib64/libc.so.6}} and {{Path|/lib64/ld-linux-x86-64.so.2}} to your {{Path|/usr/src/initramfs/lib64}}. The exception is {{Path|linux-vdso.so.1}} which is provided by the kernel.

Some applications might depend on other files and libraries to work. For example, {{Package|app-editor/nano}} needs a terminfo file {{Path|/usr/share/terminfo/l/linux}} from {{Package|sys-libs/ncurses}}, so you have to copy it to your ''initramfs'' as well. To find these dependencies, tools like {{c|equery}} and {{c|strace}} prove to be most helpful.

==== Busybox ====

Instead of collecting countless utilities and libraries (and never seeing the end of it), you can just use {{Package|sys-apps/busybox}}. It's a set of utilities for rescue and embedded systems, it contains a shell, utilities like {{c|ls}}, {{c|mkdir}}, {{c|cp}}, {{c|mount}}, {{c|insmod}}, and many more - all in a single binary called {{Path|/bin/busybox}}. For {{c|busybox}} to work properly in a ''initramfs'', you need to emerge it with the <code>static</code> USE flag enabled, then copy the {{Path|/bin/busybox}} binary into your ''initramfs'' layout as {{Path|/usr/src/initramfs/bin/busybox}}:

{{RootCmd
|USE{{=}}"static" emerge --ask --verbose sys-apps/busybox
|cp --archive /bin/busybox /usr/src/initramfs/bin/busybox}}

{{Note|Use {{c|ldd}} to verify that the binary is static.}}

=== Init ===

The file structure of your ''initramfs'' is almost complete. The only thing that is missing is {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} itself, the executable in the root of the ''initramfs'' that is executed by the kernel. Because {{Package|sys-apps/busybox}} includes a fully functional shell, this means you can write your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} binary as a simple shell script (instead of making it a complicated application written in Assembler or C that you'd have to compile).

The following example shows a minimalistic shell script, based on the {{c|busybox}} shell:

{{FileBox|filename=/usr/src/initramfs/init|title=minimalistic /init example|lang=bash|1=
#!/bin/busybox sh

# Mount the /proc and /sys filesystems.
mount -t proc none /proc
mount -t sysfs none /sys

# Do your stuff here.
echo "This script just mounts and boots the rootfs, nothing else!"

# Mount the root filesystem.
mount -o ro /dev/sda1 /mnt/root

# Clean up.
umount /proc
umount /sys

# Boot the real thing.
exec switch_root /mnt/root /sbin/init
}}

This example needs some device nodes to work, mainly the root block device. Change the script and copy the corresponding {{Path|/dev/}} node to fit your needs.

Don't forget to make the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} file executable:

{{RootCmd|chmod +x /usr/src/initramfs/init}}

=== Packaging ===

Your ''initramfs'' now has to be made available to the kernel at boot time. This is done by packaging it as a compressed cpio archive. This archive is then either embedded directly into the kernel image, or stored as a separate file which can be loaded by the [[bootloader]] during the boot process. Both methods perform equally well, simply choose the method you prefer.

==== Kernel configuration ====

With either method, you need to enable Initial RAM filesystem and RAM disk (initramfs/initrd) support.

{{KernelBox|title=CONFIG_BLK_DEV_INITRD{{=}}y|lang=text|1=
General setup  --->
    [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support
}}

{{Warning|Also enable all drivers, filesystems, compression methods and other settings that are required for booting and accessing your root partition. If you select such drivers as modules, you'll have to collect and integrate the module files into your ''initramfs'' and load them in your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}. Generally this means ''a lot'' of unnecessary extra work, so just use built-in drivers for now.}}

==== Embedding into the Kernel ====

If you want the ''initramfs'' to be embedded into the kernel image, set ''Initramfs source file(s)'' to the root of your ''initramfs'', (e.g. {{Path|/usr/src/initramfs}}):

{{KernelBox|title=CONFIG_INITRAMFS_SOURCE{{=}}"/usr/src/initramfs"|lang=text|1=
General setup  --->
    (/usr/src/initramfs) Initramfs source file(s)
}}

Now when you compile your kernel it will automatically put the files into a cpio archive and embed it into the kernel image. You will need to rebuild your kernel any time you make any changes to your ''initramfs''.

==== Creating a separate file ====

If you want to use a standalone archive file, you need to adjust the kernel settings accordingly:

{{KernelBox|title=Support inital ramdisk/ramfs compressed using <compression_method>|lang=text|1=
General setup  --->
    () Initramfs source file(s)
    [*]   Support initial ramdisk/ramfs compressed using gzip 
    []   Support initial ramdisk/ramfs compressed using bzip2
    []   Support initial ramdisk/ramfs compressed using LZMA 
    []   Support initial ramdisk/ramfs compressed using XZ   
    []   Support initial ramdisk/ramfs compressed using LZO  
    []   Support initial ramdisk/ramfs compressed using LZ4  
}}

For this example {{c|gzip}} is sufficient.

{{Warning|Not supporting a compression method for this example, will cause a '''kernel panic''' when booting!}}

You can create a standalone archive file by running the following commands:

{{RootCmd
|cd /usr/src/initramfs
|<nowiki>find . -print0 | cpio --null --create --verbose --format=newc | gzip --best > /boot/custom-initramfs.cpio.gz</nowiki>}}

This will create a file called {{Path|custom-initramfs.cpio.gz}} in your {{Path|/boot}}. You now need to instruct your bootloader to load this file along with the kernel.

===== Using GRUB =====

In case of GRUB, you do this with the '''initrd''' line:

{{FileBox|filename=/boot/grub/grub.cfg|title=GRUB2 initrd example|1=
linux 3.12.6-gentoo
initrd custom-initramfs.cpio.gz
}}

{{Warning|If you are unfamiliar with bootloader configuration, please refer to [[GRUB2]] or [[GRUB]].}}

In order to make this usable with {{c|grub-mkconfig}}, the filename {{Path|custom-initramfs.cpio.gz}} must be included in the GRUB helper scripts:

{{FileBox|filename=/etc/grub.d/10_linux|title grub-mkconfig helper script|1=
[...]
initrd_real=
for i in "initrd.img-${version}" "initrd-${version}.img" "initrd-${version}.gz" "custom-initramfs.cpio.gz" \
     "initrd-${version}" "initramfs-${version}.img" \
[...]
}}

{{FileBox|filename=/etc/grub.d/10_linux_xen|title grub-mkconfig helper script|1=
[...]
initrd=
for i in "initrd.img-${version}" "initrd-${version}.img" "initrd-${version}.gz" "custom-initramfs.cpio.gz" \
   "initrd-${version}" "initramfs-${version}.img" \
[...]
}}

{{Note|It is also possible to use the variable <var>${version}</var> for the filename in the helper script. This means that the file itself has to be renamed as well. The variable content corresponds to the output of {{c|uname --kernel-release}}.}}

After applying the changes, the file will be recognized running {{c|grub-mkconfig}}; the output may look like the following:

{{RootCmd|grub-mkconfig -o /boot/grub/grub.cfg|output=
<pre>
Generating grub configuration file ...
Found linux image: /boot/vmlinuz-4.14.83-gentoo
Found initrd image: /boot/custom-initramfs.cpio.gz
done
</pre>}}

===== Using EFI stub kernel =====

See [[EFI_stub_kernel#Optional:_Initramfs]]

==== External file list ==== 

An external file list, or cpio list, describes files to be included into the ''initramfs''. This file list is processed by an utility that comes with the Linux kernel, {{c|usr/gen_init_cpio}}. It can be used for both embedded and standalone ''initramfs'', either by using it as {{c|INITRAMFS_SOURCE}} directly or by running the utility from a shell. This lets you build the ''initramfs'' dynamically, always using the latest files from your system, but compared to populating a real directory {{Path|/usr/src/initramfs}}, it is less intuitive and requires more knowledge in regards to ''device nodes'' and such. The command {{c|file}} will prove as very useful to get information from special ''block'' or ''character'' devices.

{{Warning|This method is for advanced users. You may skip this section, if you feel uncomfortable with the next steps.}}

A minimalistic list may look like so:

{{FileBox|filename=/usr/src/initramfs.list|title=cpio list example|1=
# Custom Initramfs minimal example
dir /dev 0755 0 0
file /init /usr/src/initramfs/init 0755 0 0
}}

Create the cpio archive, compress it and move it to {{Path|/boot}}:

{{RootCmd
| cd /usr/src/linux
| usr/gen_init_cpio ../initramfs.list > ../initramfs.cpio
| gzip --best ../initramfs.cpio
| mv ../initramfs.cpio.gz /boot
}}

After that update the entries of your bootloader!

Instead of creating the list manually, there is the possibility to let the cpio list and archive be generated and compressed by two tools, which are provided by the kernel source files. It might be needed to compile these first; this is documented [[Early Userspace Mounting#Requirements|here]].

{{RootInvocation|/usr/src/linux/scripts/gen_initramfs_list.sh -h|output=<pre>
Usage:
scripts/gen_initramfs_list.sh [-o <file>] [-u <uid>] [-g <gid>] {-d | <cpio_source>} ...
        -o <file>      Create compressed initramfs file named <file> using
                       gen_init_cpio and compressor depending on the extension
        -u <uid>       User ID to map to user ID 0 (root).
                       <uid> is only meaningful if <cpio_source> is a
                       directory.  "squash" forces all files to uid 0.
        -g <gid>       Group ID to map to group ID 0 (root).
                       <gid> is only meaningful if <cpio_source> is a
                       directory.  "squash" forces all files to gid 0.
        <cpio_source>  File list or directory for cpio archive.
                       If <cpio_source> is a .cpio file it will be used
                       as direct input to initramfs.
        -d             Output the default cpio list.

All options except -o and -l may be repeated and are interpreted
sequentially and immediately.  -u and -g states are preserved across
<cpio_source> options so an explicit "-u 0 -g 0" is required
to reset the root/group mapping.
</pre>}}

Using the before created directory structure in {{Path|/usr/src/initramfs}} it may be executed like the following:

{{RootCmd
|cd /usr/src/linux
|scripts/gen_initramfs_list.sh -o ../custom-initramfs.cpio.gz /usr/src/initramfs
|ls -l ..
|collapse-output=true
|output=<pre>
total 1656
-rw-r--r--  1 root root 1675784 Dec  9 03:12 custom-initramfs.cpio.gz
drwxr-xr-x 12 root root    4096 Dec  9 00:16 initramfs
lrwxrwxrwx  1 root root      20 Nov 23 19:12 linux -> linux-4.14.83-gentoo
drwxr-xr-x 26 root root    4096 Dec  9 00:58 linux-4.14.83-gentoo
-rw-r--r--  1 root root    4830 Dec  9 01:07 README
</pre>}}

The script creates a cpio list by analyzing all directories and files within {{Path|/usr/src/initramfs}}. It then executes {{Path|usr/gen_init_cpio}} to generate the cpio archive file and finally compresses it using {{c|gzip}}; according to the filename suffix. The directory has to be changed before, since the shell script uses a relative path to {{Path|gen_init_cpio}}.

In order to comprehend, all steps can be done manually:

{{RootCmd
|scripts/gen_initramfs_list.sh /usr/src/initramfs {{!}} tee ../initramfs.list
|collapse-output=true
|output=<pre>

#####################
# /usr/src/initramfs
# Last modified: 1544312413.9519881540

dir /bin 755 0 0
file /bin/busybox /usr/src/initramfs/bin/busybox 755 0 0
dir /dev 755 0 0
nod /dev/console 600 0 0 c 5 1
nod /dev/null 666 0 0 c 1 3
nod /dev/sda1 660 0 6 b 8 1
nod /dev/tty 666 0 5 c 5 0
dir /etc 755 0 0
file /init /usr/src/initramfs/init 744 0 0
dir /lib64 755 0 0
dir /lib 755 0 0
dir /mnt 755 0 0
dir /mnt/root 755 0 0
dir /proc 755 0 0
dir /root 700 0 0
dir /sbin 755 0 0
dir /sys 755 0 0
</pre>}}

{{RootCmd
|usr/gen_init_cpio ../initramfs.list > ../initramfs.cpio
|gzip --best ../initramfs.cpio
|ls -l ..
|collapse-output=true
|output=<pre>
total 1660
drwxr-xr-x 12 root root    4096 Dec  9 00:16 initramfs
-rw-r--r--  1 root root 1675800 Dec  9 03:44 initramfs.cpio.gz
-rw-r--r--  1 root root     593 Dec  9 03:31 initramfs.list
lrwxrwxrwx  1 root root      20 Nov 23 19:12 linux -> linux-4.14.83-gentoo
drwxr-xr-x 26 root root    4096 Dec  9 00:58 linux-4.14.83-gentoo
-rw-r--r--  1 root root    4830 Dec  9 01:07 README
</pre>}}

The file {{Path|initramfs.cpio.gz}} can now be moved to {{Path|/boot}}.

{{RootCmd|mv ../initramfs.cpio.gz /boot}}

{{Warning|Do not forget to update the bootloader entries afterwards!}}

{{Note|In order to always have the latest binaries etc. in the initramfs, you might want to write a shell script which copies the files and calls the above tools; [https://gitlab.com/keks24/update-initramfs this example might be helpful]. Hardlinks do not work, as the inode will change when the original file gets overwritten, whereas the hardlink points to the old inode. Symbolic links do not work, as they will be recognised as ''slink'' and not as ''file'' when using {{Path|gen_initramfs_list.sh}}; this will render the initramfs '''unusable'''. <br/>
Remember: Be '''absolutely''' sure that your binaries on your system are either compiled statically or have the needed libraries! Package-based USE flags can be set in {{Path|/etc/portage/package.use}}.}}

=== Finalizing ===

You can now reboot your machine. On boot, the kernel will extract the files from your ''initramfs'' archive automatically and execute your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} script, which in turn should then take care of mounting your root partition and execute the init system of your installed Linux distribution.

== Functionality ==

Now that you've covered the ''initramfs'' basics, in this section you will learn how to extend your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} script with more advanced functionality.

=== Rescue shell ===

If you want to be dropped to a rescue shell if an error occurs, you can add the following function to your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} and call it when something goes wrong.

{{FileBox|filename=/usr/src/initramfs/init|title=Rescue shell functionality|lang=bash|1=
rescue_shell() {
    echo "Something went wrong. Dropping to a shell."
    exec sh
}
}}

In the example below, the {{Highlight|rescue_shell}} will be executed if the root partition fails to mount:

{{FileBox|filename=/usr/src/initramfs/init|title=Invoking the rescue shell|lang=bash|1=
mount -o ro /dev/sda1 /mnt/root {{!}}{{!}} rescue_shell
}}

=== Dynamic devices ===

For populating {{Path|/dev}} dynamically, you can use either devtmpfs or mdev. Please note that the kernel can take some time detecting devices (such as external USB drives), so you may also have to add a {{Highlight|sleep}} statement to your script.

==== devtmpfs ====

Provided by the kernel, devtmpfs is designed to offer device nodes during early boot.

{{KernelBox|title=CONFIG_DEVTMPFS{{=}}y|lang=text|1=
Device Drivers  --->
    Generic Driver Options  --->
        [*] Maintain a devtmpfs filesystem to mount at /dev
}}

You can include the following snippet in your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} script to have it mount at boot:

{{FileBox|filename=/usr/src/initramfs/init|title=mount devtmpfs|lang=bash|1=
mount -t devtmpfs none /dev
}}

Don't forget to unmount it again in the cleanup phase of the script:

{{FileBox|filename=/usr/src/initramfs/init|title=umount devtmpfs|lang=bash|1=
umount /dev
}}

==== mdev ====

Although devtmpfs is the preferred solution today, you can alternatively use mdev, the udev replacement of {{c|busybox}}.

{{KernelBox|title=CONFIG_UEVENT_HELPER{{=}}y|lang=text|1=
Device Drivers  --->
    Generic Driver Options  --->
        [*] Support for uevent helper
}}

For mdev to work, you have to make {{Path|/sbin/mdev}} a symlink to {{Path|/bin/busybox}} in your ''initramfs''.

{{RootCmd|ln --symbolic ../bin/busybox /usr/src/initramfs/sbin/mdev}}

Then add the following snippet to your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}, after mounting {{Path|/proc}} and {{Path|/sys}}:

{{FileBox|filename=/usr/src/initramfs/init|title=Adding mdev support to /init|lang=bash|1=
echo /sbin/mdev > /proc/sys/kernel/hotplug
mdev -s
}}

=== Mount by UUID or label ===

With [[#Dynamic_devices|Dynamic devices]] enabled, you might prefer to use UUID or label to mount the root partition instead of using a static device name. For that purpose, {{c|busybox}} comes with a utility called {{c|findfs}}.

{{FileBox|filename=/usr/src/initramfs/init|title=mount using findfs|lang=bash|1=
mount -o ro $(findfs UUID=845b2454-42a3-19ef-6ec5-238a358c365b) /mnt/root
# or
mount -o ro $(findfs LABEL=myroot) /mnt/root
}}

Doing it this way is simple, but it means that your UUID or label is hardcoded in the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}. Alternatively, you can also use [[#Kernel_parameters|Kernel parameters]].

==== Kernel parameters ====

If you want to use kernel parameters instead of hardcoding device names or UUIDs, you will have to parse {{Path|/proc/cmdline}}. There are many ways to do so, the following method is just an example to give you the general idea. It uses string manipulation of the shell and only supports <code>key=value</code> parameters. Add the following function to your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} and call it whenever you need a kernel parameter.

{{FileBox|filename=/usr/src/initramfs/init|title=Adding a simple cmdline parser function|lang=bash|1=
cmdline() {
    local value
    value=" $(cat /proc/cmdline) "
    value="${value##* ${1}=}"
    value="${value%% *}"
    [ "${value}" != "" ] && echo "${value}"
}
}}

The function is called with the name of the kernel parameter you are interested in. In the example below, it uses the root parameter to mount the root partition.

{{FileBox|filename=/usr/src/initramfs/init|title=Mount rootfs by cmdline|lang=bash|1=
mount -o ro $(findfs $(cmdline root)) /mnt/root
}}

It works for both <code>root=/dev/sda1</code> and <code>root=UUID=845b2454</code> but will fail when the parameter is missing.

=== LVM ===

If your root partition is located on a logical volume, you need to include the LVM binary in your ''initramfs''. You can get a static binary by enabling the <code>static</code> USE flag for {{Package|sys-fs/lvm2}}. Copy it to your ''initramfs'' {{Path|/sbin}} directory.

{{Note|The static LVM binary may also be called {{Path|/sbin/lvm.static}}. Use {{c|ldd}} to verify that the binary is static.}}

{{RootCmd|cp --archive /sbin/lvm /usr/src/initramfs/sbin/lvm}}

Now you can enable your LVM root partition in {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}. This example assumes that your volume group is called '''VG''', and your root volume is called '''root'''. Replace them with the names you chose when creating the volume.

{{FileBox|filename=/usr/src/initramfs/init|title=Setting up the root volume|lang=bash|1=
lvm vgscan --mknodes # creates /dev/mapper/control
lvm lvchange -a ly VG/root
lvm vgscan --mknodes # creates /dev/mapper/VG-root and /dev/VG/root
}}

The root partition may then be called {{Path|/dev/VG/root}} or {{Path|/dev/mapper/VG-root}}.

{{Note|Calling {{c|vgscan}} is optional, but recommended, just in case device nodes are missing.}}

Recent versions of {{Package|sys-fs/lvm2}} rely on {{Package|sys-fs/udev}} to create the named LV device nodes, but there is no udev in a simple ''initramfs''. The following choices are available:

* Use {{c|vgscan}} as shown above (simplest solution)
* [[#Mount_by_UUID_or_label|Mount by UUID or label]] instead of using {{Path|/dev/VG/root}}. It works because {{c|findfs}} is happy with just {{Path|/dev/dm-42}}
* Build a LVM binary with the <code>-udev</code> USE flag (specifically for the ''initramfs'' only!)
* Disable udev dependency by including a minimal {{Path|/etc/lvm/lvm.conf}} in the ''initramfs'':
  {{FileBox|filename=/usr/src/initramfs/etc/lvm/lvm.conf|title=Disable udev in lvm.conf|lang=bash|1=
activation {
    # Set to 0 to disable udev synchronisation (if compiled into the binaries).
    udev_sync = 0
    # Set to 0 to disable the udev rules installed by LVM2
    udev_rules = 0
}
}}

=== Software RAID ===

Normally the Linux kernel will automatically scan for any "Linux raid autodetect" partitions and start as many software RAIDs as it can find. But if you use an ''initramfs'', the kernel will not automatically scan for RAIDs until it is told to. In the following example instructs the kernel to scan for software RAIDs and start as many as it can find. This will actually start all autodetected arrays, not just {{Path|/dev/md0}}:

{{FileBox|filename=/usr/src/initramfs/init|title=Adding RAID autodetect support to /init|lang=bash|1=
raidautorun /dev/md0
}}

{{Note|[https://raid.wiki.kernel.org/index.php/RAID_superblock_formats#A_Note_about_kernel_autodetection_of_different_superblock_formats "Linux raid autodetect"] won't work for any recent setups, unless you specifically set up with partitions of type "fd" and used 0.90 metadata for your Software RAID.}}

==== mdadm ====

Without "Linux raid autodetect" partitions, or if you need an advanced RAID setup, you have to include {{Highlight|'''mdadm'''}} in your ''initramfs''. You can get a static binary by enabling the <code>static</code> USE flag for {{Package|sys-fs/mdadm}}.

Copy the binary {{Path|/sbin/mdadm}} and your {{Path|/etc/mdadm.conf}} into your ''initramfs'':

{{RootCmd
|cp --archive /sbin/mdadm /usr/src/initramfs/sbin
|cp --archive /etc/mdadm.conf /usr/src/initramfs/etc
}}

{{Note|Use {{c|mdadm --detail --scan}} if you do not yet have a {{Path|mdadm.conf}}.}}

Edit the {{Path|mdadm.conf}} in your ''initramfs'' to your liking. An example {{Path|mdadm.conf}} follows:

{{FileBox|filename=/usr/src/initramfs/etc/mdadm.conf|title=mdadm.conf example|lang=bash|1=
DEVICE /dev/sd?*
ARRAY /dev/md0 UUID=627125a5:abce6b82:6c738e49:50adadae
}}

This {{Path|mdadm.conf}} will scan all {{Path|/dev/sd?*}} devices and assemble the RAID device fitting the UUID 627125a5:abce6b82:6c738e49:50adadae.

{{Note|If your {{Path|mdadm.conf}} has additional conditions such as metadata and name, it may be more practical to remove them. The UUID alone should be sufficient.}}

Now you can initialize your Software RAID in {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}:

{{FileBox|filename=/usr/src/initramfs/init|title=Assemble software RAIDs with mdadm|lang=bash|1=
mdadm --assemble --scan
}}

With this, you should be able to mount your root partition {{Path|/dev/md0}}.

=== DM-Crypt ===

If your root partition is LUKS encrypted, you need to include the cryptsetup binary in your ''initramfs''. You can get a static binary by setting the <code>static</code> USE flag for {{Package|sys-fs/cryptsetup}}. Copy it to your ''initramfs'' {{Path|/sbin}} directory. Since cryptsetup also often requires the use of the kernel's random device, include them as well.

{{Note|If you have problems getting a static cryptsetup binary, try <code>nettle</code> or <code>kernel</code> instead of the default <code>gcrypt</code> USE flag.}}

Recompile the package {{Package|sys-fs/cryptsetup}} with the new USE flags. For example:

{{RootCmd
|USE{{=}}"-gcrypt nettle static" emerge --ask --verbose sys-fs/cryptsetup
|collapse-output=true
|output=<pre>
These are the packages that would be merged, in order:

Calculating dependencies... done!
[ebuild   R    ] sys-fs/cryptsetup-1.7.5-r1::gentoo  USE="nettle* nls static* udev -gcrypt* -kernel -libressl -openssl -pwquality -python -reencrypt -static-libs -urandom" PYTHON_TARGETS="python2_7 python3_6 -python3_4 -python3_5 (-python3_7)" 0 KiB

Total: 1 package (1 reinstall), Size of downloads: 0 KiB

Would you like to merge these packages? [Yes/No]
</pre>}}

It might also be needed to compile the package {{Package|sys-fs/lvm2}} with the <code>static-libs</code> USE flag:

{{RootCmd
|USE{{=}}"static-libs" emerge --ask --verbose sys-fs/lvm2
|collapse-output=true
|output=<pre>
These are the packages that would be merged, in order:

Calculating dependencies... done!
[ebuild  N     ] sys-devel/autoconf-archive-2018.03.13::gentoo  635 KiB
[ebuild  N     ] dev-libs/libaio-0.3.110::gentoo  USE="static-libs -test" ABI_X86="(64) -32 (-x32)" 42 KiB
[ebuild  N     ] dev-util/boost-build-1.65.0::gentoo  USE="-examples -python -test" PYTHON_TARGETS="python2_7" 80,662 KiB
[ebuild  N     ] dev-libs/boost-1.65.0:0/1.65.0::gentoo  USE="nls static-libs threads -context -debug -doc -icu -mpi -python -tools" ABI_X86="(64) -32 (-x32)" PYTHON_TARGETS="python2_7 python3_6 -python3_4 -python3_5" 0 KiB
[ebuild  N     ] sys-block/thin-provisioning-tools-0.7.0::gentoo  USE="-static -test" 226 KiB
[ebuild  N     ] sys-fs/lvm2-2.02.145-r2::gentoo  USE="readline static-libs thin udev (-clvm) (-cman) -corosync -device-mapper-only -lvm1 -lvm2create_initrd -openais (-selinux) -static -systemd" 0 KiB

Total: 6 packages (6 new), Size of downloads: 81,563 KiB

Would you like to merge these packages? [Yes/No]
</pre>}}

After that copy over the binary files:

{{RootCmd
|cp --archive /dev/{urandom,random} /usr/src/initramfs/dev
|cp --archive /sbin/cryptsetup /usr/src/initramfs/sbin/cryptsetup}}

Now you can unlock your encrypted root partition in {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}:

{{FileBox|filename=/usr/src/initramfs/init|title=Setting up LUKS encryption in /init|lang=bash|1=
cryptsetup --tries 5 luksOpen /dev/sda1 luksroot
}}

Once you entered your passphrase, your root partition will be available as {{Path|/dev/mapper/luksroot}}.

==== Encrypted keyfile ====

If you need encrypted keyfiles, use {{c|cryptsetup}} to encrypt them. It keeps your ''initramfs'' simple as that's the encryption tool you already have - no need to add other binaries. Plus, unlike some of the alternatives, it offers a nice password prompt.

The following example creates a random 512 byte key, encrypted with LUKS, and adds it to your LUKS container {{Path|/dev/sda1}}.

{{Note|
* Current versions of cryptsetup use 4096 instead of 2056 blocks for LUKS metadata. With the <code>--align-payload{{=}}1</code> parameter, it is back to 2056 blocks.
* {{c|cryptsetup}} also offers <code>--keyfile-size</code> and <code>--keyfile-offset</code> options, which can be used for other key sizes or multiple keys in one container.}}

{{RootCmd
|dd if{{=}}/dev/zero of{{=}}/usr/src/initramfs/root/key.luks count{{=}}2057
|cryptsetup --align-payload{{=}}1 luksFormat /usr/src/initramfs/root/key.luks
|cryptsetup open --type luks /usr/src/initramfs/root/key.luks lukskey
|dd if{{=}}/dev/urandom of{{=}}/dev/mapper/lukskey
|cryptsetup luksAddKey /dev/sda1 /dev/mapper/lukskey
}}

Unlocking the root device using this key in your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} can then be done like this:

{{FileBox|filename=/usr/src/initramfs/init|title=LUKS encryption with keyfiles|lang=bash|1=
# Obtain the key
cryptsetup --tries 5 luksOpen /root/key.luks lukskey

# Unlock the root partition
cryptsetup --key-file /dev/mapper/lukskey open --type luks /dev/sda1 luksroot

# Clean up the key
cryptsetup close lukskey
}}

As before, your root partition should then be available as {{Path|/dev/mapper/luksroot}}.

=== Networking ===

If you need networking in your ''initramfs'', all required network related drivers have to be built into your kernel, and you'll have to configure the network interfaces in your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}. How exactly this has to be done, depends on your network situation. The following sections cover only the most common cases.

==== Static IP ====

If your network situation allows you to use a static network IP, you can set it up using the {{c|ifconfig}} and {{c|route}} commands, both of which are included in Busybox. This is by far the easiest solution, so if it's at all possible, go for it.

{{FileBox|filename=/usr/src/initramfs/init|title=Static network IP setup in /init|lang=bash|1=
ifconfig eth0 10.0.2.15
route add default gw 10.0.2.2
}}

==== DHCP ====

To obtain a dynamic IP address from your network's DHCP server, you need a DHCP client. Busybox comes with a minimalistic DHCP client called {{c|udhcpc}}, which is sufficient for most users. Unfortunately, {{c|udhcpc}} has a dependency: it requires the help of a separate script to actually configure the network interface. An example for such a script is included in the Busybox distribution, but it's not installed by Gentoo. You will have to obtain it directly from the Busybox tarball (it's called {{Path|examples/udhcp/simple.script}}) or [https://git.busybox.net/busybox/plain/examples/udhcp/simple.script download it from the Busybox project page].

Copy the script to your ''initramfs'' and make it executable.

{{RootCmd
|cp simple.script /usr/src/initramfs/bin
|chmod +x /usr/src/initramfs/bin/simple.script}}

Edit the script's first line to read {{Highlight|color=darkred|#!/bin/busybox sh}} or create a symlink for {{Path|/bin/sh}}:

{{RootCmd|ln --symbolic busybox /usr/src/initramfs/bin/sh}}

Now, you can obtain a dynamic IP address for eth0 using DHCP:

{{FileBox|filename=/usr/src/initramfs/init|title=Network setup using DHCP|lang=bash|1=
ifconfig eth0 up
udhcpc -t 5 -q -s /bin/simple.script
}}

==== DNS ====

Your network should be up and running now. However, that's only if you know exactly which IPs to talk to. If all you have is a host or domain name, it's a different story entirely. In that case, you need to be able to resolve hostnames. Unfortunately, this is where our luck leaves us. Until now, everything could be done with just the static binary of Busybox - however, this is not the case with DNS.

{{Note|Additional libraries are required to make DNS work.}}

This is because {{Package|sys-libs/glibc}} itself dynamically includes additional libraries for DNS lookups. As long as you don't need that functionality, you're fine, but if you need it, you have no choice but to include those libraries in your ''initramfs''. The only alternative would be building Busybox against another libc such as {{Package|sys-libs/uclibc}}, however that would go beyond the scope of this article.

This is a good chance to demonstrate how to use ({{Package|dev-util/strace}}) to reveal hidden dependencies.

{{Cmd|<nowiki>strace busybox ping wiki.gentoo.org 2>&1 | grep open</nowiki>|output=<pre>
open("/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
open("/etc/host.conf", O_RDONLY|O_CLOEXEC) = 3
open("/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 3
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libnss_files.so.2", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/ld-linux-x86-64.so.2", O_RDONLY|O_CLOEXEC) = 3
open("/etc/hosts", O_RDONLY|O_CLOEXEC)  = 3
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libnss_dns.so.2", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libresolv.so.2", O_RDONLY|O_CLOEXEC) = 3
open("/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 3
</pre>}}

As you can see, the command accesses quite a lot of files, some of which are mandatory for it to work.

Copy the necessary libraries to your ''initramfs'':

{{RootCmd|cp /lib64/libnss_{dns,files}.so.2 /lib64/{libresolv,ld-linux-x86-64}.so.2 /lib64/libc.so.6 /usr/src/initramfs/lib64}}

Create a {{Path|/etc/resolv.conf}} with at least one useable nameserver. Note that this step may be done automatically if you use [[#DHCP|DHCP]].

{{RootCmd|echo nameserver 10.0.2.3 > /usr/src/initramfs/etc/resolv.conf}}

With this, DNS lookups should now work for you.

{{Note|1=If it still does not work, you might be suffering from [https://sourceware.org/bugzilla/show_bug.cgi?id=17250 bug 17250]. As a workaround, set <code>LD_LIBRARY_PATH="/lib64"</code> and try again.}}

== Troubleshooting ==

The following section tries to provide help with common issues and pitfalls you may run into.

=== Static vs. dynamic binaries ===

Any custom binaries you need to use in your ''initramfs'' before mounting have to be fully functional, independent from any files you may have installed on your root partition. This is much easier to achieve with static binaries (which usually work as single file) than with dynamic binaries (which need any number of additional libraries to work).

Gentoo provides static binaries for some ebuilds. Check if the ebuild for your binary offers a <code>static</code> or <code>-dynamic</code> USE flag. This is by far the easiest method to get a static binary, but unfortunately only a select few ebuilds support it.

Many applications also offer static builds with an option in their configure scripts. There is no standard name for the option, it may be <code>--enable-static</code> or something similar. When compiling a package manually, check the list of available options by using {{c|./configure --help}} to see if the package supports building static binaries.

You can check whether or not a binary is static by using the {{c|ldd}} command. The {{c|strace}} command is also very useful to find out about additional dependencies. By using {{c|equery files}} it is possible to see which files a certain package has brought into your system, some of which may also be candidates for additional dependencies of that package.

{{Note|
* See [[#Applications|Applications]] for a {{c|ldd}} usage example.
* See [[#DNS|DNS]] for a {{c|strace}} usage example.
}}

Including libraries into your ''initramfs'' in order to make a dynamic executable work is a last resort only. It makes the ''initramfs'' much larger than necessary and harder to maintain, as the dependencies might change with every update of the program in question.

==== lddtree ====

If you decide to go with dynamic binaries, {{Package|app-misc/pax-utils}} comes with a Python script {{c|lddtree}} which will handle the collection of libraries for you:

{{Note|If the {{c|--copy-to-tree}} option is missing, enable the <code>python</code> useflag.}}

{{RootCmd
|lddtree --copy-to-tree /usr/src/initramfs /usr/bin/nano
}}

That will copy the binary and all its libraries to your ''initramfs'' structure - but not any of the runtime dependencies. For more details refer to {{c|lddtree --help}}.

=== Kernel panics ===

When working with ''initramfs'' and writing custom init scripts for it, you may experience the following kernel panic on boot:

 Kernel panic - not syncing: Attempted to kill init!

This is not an error in the kernel, but an error in your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} script. This script is executed as the init process with PID 1. Unlike other processes, the PID 1 init process is special. It is the only process that is started by the kernel on boot. It's the process that takes care of starting other processes (boot process, init scripts) which in turn start other processes (daemons, login prompts, X), which in turn start other processes (bash, window manager, browser, ...). The init process is the mother of all other processes, and therefore it mustn't be killed. On shutdown, it's again the init process that takes care of cleaning up by shutting down other processes first, then running processes that will unmount the filesystems, until it is safe to actually do a shutdown without corrupting anything.

If you have some error in your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} script, that causes the init process to end, this basically means there are no processes left to run, there is nothing that could take care of cleaning up, and the kernel has no choice but to panic. For this reason there are some things in {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} that you can't do like you can do them in a normal shell script, like using return or exit, or letting the script just run a series of commands and then simply end.

If you want {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} to end, you have to pass the responsibility of the init process to another process using '''exec'''. See the examples above how '''exec''' is used to either run /sbin/init of the mounted root partition or to run a rescue shell in case something went wrong.

=== Job control ===

While working with ''initramfs'', especially the [[#Rescue_shell|Rescue shell]], you may come across this message:

 /bin/sh: can't access tty; job control turned off

The lack of job control is usually not a problem, since {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} is not supposed to be interactive. However, if you want to work with the Busybox shell on a regular basis, being unable to control programs with {{Key|Ctrl}}+{{Key|C}} or {{Key|Ctrl}}+{{Key|Z}} can easily become a huge issue. In worst case, if job control is not available, and a program refuses to quit, you have to reboot.

The [https://www.busybox.net/FAQ.html#job_control job control section in the Busybox FAQ] offers some help here. 
You can either use

{{RootCmd|setsid sh -c 'exec sh </dev/tty1 >/dev/tty1 2>&1'}}

or

{{RootCmd|setsid cttyhack sh}}

to start a shell on tty1 with job control enabled.

=== Salvaging ===

If for whatever reason you lost your {{Path|/usr/src/initramfs}} structure, but you still got either the kernel image with the built-in ''initramfs'', or the separate cpio archive, it's possible to salvage it from there. Although it may be easier to just redo it from scratch - if you've done it once, doing it again should be a piece of cake. So this is just in case.

==== Dismantling the Kernel ====

You can skip this step if your ''initramfs'' is a separate cpio archive already. Otherwise, you'll have to get the built-in cpio archive out of the kernel image. To do that, you have to dismantle it, which isn't easy, since the kernel image is a combination of boot sector and compressed archive itself. It also depends on the compression you are using for your kernel and for your ''initramfs''. For simplicity, this example assumes bzip2 - however, the principle is the same for other compression methods.

The utility of choice when dismantling kernel images is {{Package|app-misc/binwalk}}. It analyzes arbitrary files for known signatures, and prints their offsets. While there are usually a bunch of false matches in the output, it should be easy to pick the correct ones.

{{Cmd|binwalk bzImage|output=<pre>
DECIMAL     HEX         DESCRIPTION
-------------------------------------------------------------------------------------------------------------------
15949       0x3E4D      bzip2 compressed data, block size = 900k
3042172     0x2E6B7C    LZMA compressed data, properties: 0x9A, dictionary size: 4194304 bytes, uncompressed size: 9439488 bytes
4433597     0x43A6BD    LZMA compressed data, properties: 0xD8, dictionary size: 16777216 bytes, uncompressed size: 4213785 bytes
8530175     0x8228FF    ELF (NetBSD)
</pre>}}

{{Note|Newer versions also support {{c|binwalk --extract}} which will extract all found offsets directly.}}

A less sophisticated method would be to use {{c|grep}} to search for signatures. For bzip2, this is '''BZh'''. For gzip, use '''<nowiki>$'\x1f'$'\x8b'</nowiki>'''.

{{Cmd|grep --text --byte-offset --only-matching BZh bzImage|output=<pre>
15949:BZh
3946909:BZh
</pre>}}

In this case the offset we are looking for is '''15949''' bytes. Now you can extract the compressed kernel image:

{{Cmd|<nowiki>dd if=bzImage bs=15949 skip=1 | bunzip2 > Image</nowiki>}}

Now, you have the uncompressed kernel image. Somewhere within this image resides the compressed ''initramfs'' archive, so just iterate the previous process to find it. Depending on your kernel configuration, you're looking for another bzip2, gzip, or cpio container.

{{Cmd
|binwalk Image
|grep --text --byte-offset --only-matching BZh Image}}

Suppose the offset is 171424 bytes this time. Now you can extract the ''initramfs'' cpio archive:

{{Cmd|<nowiki>dd if=Image bs=171424 skip=1 | bunzip2 > initramfs.cpio</nowiki>}}

If you want to verify that you actually got a cpio archive from that, use the {{c|file}} command:

{{Cmd|file initramfs.cpio|output=<pre>
initramfs.cpio: ASCII cpio archive (SVR4 with no CRC)
</pre>}}

==== Extracting the cpio archive ====

If your ''initramfs'' cpio archive was a separate file, it needs to be uncompressed first.

{{Cmd|gunzip initramfs.cpio.gz}}

To extract the uncompressed {{Path|initramfs.cpio}}, you can do so with the following command:

{{Warning|This will overwrite files in your current directory. Do it in {{Path|/tmp/initramfs/}} or similar.}}

{{Cmd|cpio --extract --make-directories --format{{=}}newc --no-absolute-filenames < initramfs.cpio}}

With this, you should have successfully recovered your ''initramfs'' structure.

=== Integrated initramfs does not always update ===

If your ''initramfs'' is integrated into your kernel (instead of using a separate file), there's a possibility that a {{c|make bzImage}} does not actually update it every time. So you might be making changes to your ''initramfs'' but actually keep booting using your old, buggy one. In this case you have to manually delete the integrated image to force the kernel to integrate a fresh ''initramfs'' archive:

{{RootCmd|rm /usr/src/linux/usr/initramfs_data.cpio*}}

Alternatively, you could also {{c|make clean}}, but then the entire kernel will need to be recompiled.

=== Command not found ===

In Gentoo, busybox is configured as standalone shell by default, which allows busybox to execute its own applets directly. Without this setting, Busybox commands ({{c|mkdir}}, {{c|mount}}, ...) won't work unless there is explicitly a symlink created for them. You can do this at the top of your {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} script:

{{FileBox|filename=/usr/src/initramfs/init|title=Install Busybox symlinks to /init|lang=bash|
#!/bin/busybox sh

# Install symlinks to all busybox applets first.
/bin/busybox mkdir -p /usr/sbin /usr/bin /sbin /bin
/bin/busybox --install -s

# ...everything else below...
}}

Alternatively, you can create the symlinks directly in {{Path|/usr/src/initramfs}} so they will already be included in your ''initramfs''.

{{RootCmd
|mkdir -p /usr/src/initramfs/{usr/sbin,usr/bin,sbin,bin}
|chroot /usr/src/initramfs /bin/busybox --install -s
}}

=== Disappearing root ===

If your encrypted root (with cryptsetup/LUKS), for example {{Path|/dev/mapper/gentoo-root}}, is disappearing after the {{c|switch_root}} command you can recreate the device by entering:

{{RootCmd
|dmsetup mknodes
}}

=== Variations for switch_root ===

Some init setups require proc, sys and dev to be mounted before starting up. If you find you are having trouble with {{c|switch_root}} in your initramfs setup try replacing the {{c|umount}} command with a {{c|mount --move}} in your init script. 

For example, replace this.
{{FileBox|filename=/usr/src/initramfs/init |title=umount commands|
# Clean up
umount /proc
umount /sys
umount /dev

# Boot the real thing
exec switch_root /newroot /sbin/init
}}

With this.
{{FileBox|filename=/usr/src/initramfs/init |title=mount --move commands|
# Clean up
mount --move /proc /newroot/proc
mount --move /sys /newroot/sys
mount --move /dev /newroot/dev

# Boot the real thing
exec switch_root /newroot /sbin/init
}}
 
{{Important| umount is used to ensure that "real" init systems, like OpenRC, start in a clean state. You should ideally use umount if it is possible in this circumstance. }}

== Examples ==

See [[Custom_Initramfs/Examples]] for fully functional examples of finished {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} scripts.

== See also ==

* {{See also|Initramfs/Guide}}
* {{See also|Early Userspace Mounting}} Another worth to read article about custom initramfs

== External resources ==

* Official initramfs documentation locally (<kbd>less {{Path|/usr/src/linux/Documentation/filesystems/ramfs-rootfs-initramfs.txt}}</kbd>) or [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt online at kernel.org]
* [http://www.linuxfromscratch.org/blfs/view/stable/postlfs/initramfs.html Linux® From Scratch - About initramfs]
* [https://gitlab.com/keks24/update-initramfs Update your initramfs using pure Bash]
[[Category:Initramfs]]
