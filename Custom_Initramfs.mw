''initramfs'' is a root filesystem that is embedded into the kernel and loaded at an early stage of the boot process. It is the successor of ''initrd''. It provides early userspace which lets the system do things that the kernel cannot easily do by itself during the boot process.

Using ''initramfs'' is optional. By default, the kernel initializes hardware using built-in drivers, mounts the specified root partition, loads the init system of the installed Linux distribution. The init system then loads additional modules and starts services until it eventually allows users to log in. This is a good default behavior and sufficient for many users. An ''initramfs'' is generally for users with advanced requirements; for users who need to perform certain tasks as early as possible, even before the root partition is mounted.

Here are some examples of what can be done with an ''initramfs'':

* Mount the root partition (for encrypted, logical, and otherwise special partitions);
* Provide a minimalistic rescue shell (if something goes wrong during the init process);
* Customize the boot process (e.g. print a welcome message, boot splash, etc.);
* Load modules (e.g. third party drivers that cannot be integrated into the kernel directly);
* Anything the kernel is not able to do (as long as the task can be done in user space, e.g. by executing commands).

Users who do not have advanced requirements do not need to use ''initramfs''.

== Prerequisites ==

There are countless ways to make an ''initramfs''. Users can choose not to create an ''initramfs'' at all but let utilities, such as [[Genkernel]] or [[Dracut]], do the work for them. In some situations an automatically generated initramfs does what is needed 'out of the box.' If this is the case most users need not be bothered with how the ''initramfs'' works and what actions it is accomplishing. For less fortunate users an initramfs does not perform the needed actions, and its functionality must be extended. In special cases an ''initramfs'' will have to be (almost) entirely re-written in order to make proper operations possible.

An ''initramfs'' contains at ''least'' one file called {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}. This file is executed by the kernel as the main init process (PID 1). It has to do all the work. In addition, there can be any number of additional files and directories that are required by {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}. They are usually files that can be found on any root filesystem, such as {{Path|/dev}} for device nodes, {{Path|/proc}} for kernel information, {{Path|/bin}} for binaries, and so on. The structure of an ''initramfs'' can be simple, or it can be complicated, depending on the actions that are needed to be undertaken.

When the kernel mounts the ''initramfs'', the target root partition is not yet mounted, so it cannot provide access any files contained therein. As far as the system is concerned, this means nothing but the files in the ''initramfs'' are visible. Everything that is needed or wanted must be included in the ''initramfs''. If a rescue shell shell is desired, it must be included in the ''initramfs''. If something needs to be mounted, a mount utility must be included. If a module needs loaded, the ''initramfs'' has to provide both the module as well as a utility to load it. If the utility depends on certain libraries in order to work, the libraries must be included as well. This seems complicated, and it is, because the ''initramfs'' needs to be able function entirely independent from any other devices or filesystems. In order for all parts to work smoothly and seamlessly an ''initramfs'' should be a self-contained system.

== Basics ==

This section will detail the ''easy and straightforward way to initramfs creation''. It will provide instructions on how to make a functional - albeit minimalistic - ''initramfs'' which then can be extended according to each system's requirements.

=== Directory structure ===

It is time to create a basic ''initramfs'' directory structure that will become the ''initramfs''' root. For consistency in this article the {{Path|/usr/src/initramfs}} path will be used, however any location will do. If an alternate directory is chosen remember to consistently update the paths accordingly.

Create a basic directory structure:

{{RootCmd|<nowiki>mkdir -p /usr/src/initramfs/{bin,dev,etc,lib,lib64,mnt/root,proc,root,sbin,sys}</nowiki>}}

==== Device nodes ====

Most things the ''initramfs'' does will require a couple of device nodes to be present, especially the device for the root partition. Throughout this document, {{Path|/dev/sda1}} will be used as example device. Copy basic device nodes from the root filesystem to the ''initramfs'' example location:

{{RootCmd|cp -a /dev/{null,console,tty,sda1} /usr/src/initramfs/dev/}}

The devices needed depends entirely on what the ''initramfs'' is going to be used for. Feel free to adapt the structure to meet individual needs.

{{Note|More advanced approaches to device nodes are covered in this article during the [[#Dynamic_Devices|Dynamic Devices]] section.}}

=== Applications ===

Any binary required to be executed at boot needs to be copied into the ''initramfs''. Remember: any libraries required by the binaries also need to be copied. A way to discover which libraries the particular binary requires is to use the <tt>ldd</tt> tool. In the following example the <tt>ldd</tt> tool is used to examine what libraries the {{Package|dev-util/strace}} binary requires:

{{Cmd|ldd /usr/bin/strace|output=<pre>
    linux-vdso.so.1 (0x00007fff271ff000)
    libc.so.6 => /lib64/libc.so.6 (0x00007f5b954fe000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f5b958a9000)
</pre>}}

From the output of <tt>ldd</tt> it is possible to see in order for {{Path|/usr/bin/strace}} to work in an ''initramfs'' two libraries must be present with it. Explained with more verbosity, not only must {{Path|/usr/bin/strace}} be copied to the {{Path|/usr/src/initramfs/bin}} folder, but {{Path|/lib64/libc.so.6}} and {{Path|/lib64/ld-linux-x86-64.so.2}} must be copied to the {{Path|/usr/src/initramfs/lib64}} folder. Note that {{Path|linux-vdso.so.1}} is not needed.

Some applications may be depend on other files and libraries to work. For example, {{Package|app-editor/nano}} needs a terminfo file {{Path|/usr/share/terminfo/l/linux}} from {{Package|sys-libs/ncurses}}, so they must be copied to the ''initramfs'' as well. To find these types of dependencies tools like <tt>equery</tt> and <tt>strace</tt> prove to be most helpful.

==== Busybox ====

Instead of collecting countless utilities and libraries (and never seeing the end of it), using multi-tool binary packages such as {{Package|sys-apps/busybox}} is sometimes the best approach. Busybox is a set of utilities for rescue and embedded systems. It contains a shell, utilities like <tt>ls</tt>, <tt>mkdir</tt>, <tt>cp</tt>, <tt>mount</tt>, <tt>insmod</tt>, and many more - all in a single binary ({{Path|/bin/busybox}}). For <tt>busybox</tt> to work properly in an ''initramfs'', it will need to be emerged with the <code>static</code> USE flag enabled. Once correctly emerged copy the {{Path|/bin/busybox}} binary into the ''initramfs'' layout as {{Path|/usr/src/initramfs/bin/busybox}}:

{{RootCmd
|USE{{=}}"static" emerge -av busybox
|cp -a /bin/busybox /usr/src/initramfs/bin/busybox}}

{{Note|Verify a static binary is being copied by using the <tt>ldd</tt> tool.}}

=== Init ===

The file structure of the ''initramfs'' is almost complete. The only thing that is missing is {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} itself. {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} is the executable in the root of the ''initramfs'' that is executed by the kernel once it is loaded into memory. Because {{Package|sys-apps/busybox}} includes a fully functional shell, this means the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} binary can be written as a simple shell script (instead of making it a complicated application written in Assembly or C). When an interpreter is available, writing the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} in a shell language avoids the need to compiling which will dramatically save time when attempting to debug any issues that may develop.

The following example displays the executable as a minimalistic shell script, based on the <tt>busybox</tt> shell (sh):

{{FileBox|filename=/usr/src/initramfs/init|title=minimalistic /init example|lang=bash|1=
#!/bin/busybox sh

# Mount the /proc and /sys filesystems.
mount -t proc none /proc
mount -t sysfs none /sys

# Do stuff here.
echo "This script mounts and boots the rootfs!"

# Mount the root filesystem.
mount -o ro /dev/sda1 /mnt/root

# Clean up.
umount /proc
umount /sys

# Boot the real root.
exec switch_root /mnt/root /sbin/init
}}

This example needs some device nodes to work, mainly the root block device. Change the script and copy the corresponding {{Path|/dev/}} node to suit each need.

Do not forget to make the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} file executable:

{{RootCmd|chmod +x /usr/src/initramfs/init}}

=== Packaging the initramfs ===

The ''initramfs'' now has to be made available to the kernel at boot time. This is done by packaging it as a compressed cpio archive. This archive is then either embedded directly into the kernel image, or stored as a separate file which can be loaded by GRUB during the boot process. Both methods perform equally well, simply choose the method that is most convenient.

==== Kernel configuration ====

With either method, support for the Initial RAM filesystem and RAM disk (initramfs/initrd) must be enabled for correct ''initramfs'' functionality. Be sure the kernel includes the following options:

{{KernelBox|title=<nowiki>CONFIG_BLK_DEV_INITRD=y</nowiki>|1=<pre>
General setup  --->
    [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support
</pre>}}

Be sure to enable all drivers, filesystems, and other settings that are required for booting and accessing the root partition. When selecting such drivers as modules remember to collect and integrate the module files into the ''initramfs'' and load them into memory via the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}. Generally this means ''a lot'' of unnecessary extra work, so use built-in drivers for now.

==== Embedding into the Kernel ====

For the ''initramfs'' to be embedded into the kernel image, edit the kernel configuration to set the ''Initramfs source file(s)'' to the root directory of the ''initramfs'' (e.g. {{Path|/usr/src/initramfs}}):

{{KernelBox|title=<nowiki>CONFIG_INITRAMFS_SOURCE="/usr/src/initramfs"</nowiki>|1=<pre>
General setup  --->
    (/usr/src/initramfs) Initramfs source file(s)
</pre>}}

Now when the kernel is compiled it will automatically put the files into a cpio archive and embed it into the kernel image. A disadvantage to using this method is that the kernel must be rebuilt any time changes to the ''initramfs'' (adding a file, making a script change, etc.).

==== Creating a separate file ====

Creating a standalone archive file can be done by running the following commands:

{{RootCmd
|cd /usr/src/initramfs
|<nowiki>find . -print0 | cpio --null -ov --format=newc | gzip -9 > /boot/custom-initramfs.cpio.gz</nowiki>}}

This will create a file called {{Path|my-custom-initramfs.cpio.gz}} in the system's {{Path|/boot}} directory. To instruct a bootloader such as GRUB2 to load this file at boot time, do so with the '''initrd''' line:

{{FileBox|filename=/boot/grub/grub.cfg|title=GRUB2 initrd example||1=
linux 3.12.6-gentoo
initrd custom-initramfs.cpio.gz
}}

{{Note|For readers who are unfamiliar with bootloader configurations, please refer to the [[GRUB]] or [[GRUB2]] articles.}}

=== Finalizing ===

It is now time to reboot the machine. On boot, the kernel should extract the files from the ''initramfs'' archive automatically and execute the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} script. In turn this should take care of mounting the system's root partition and execute the {{Path|init}} file of the installed Linux distribution.

== Functionality ==

Now that the basics of ''initramfs'' have been covered, this section will explain how to extend the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} script with advanced functionality.

=== Rescue shell ===

If an error occurs during the init process, a wise idea is drop into to a rescue shell so that debugging can be preformed as needed. The following function can be added to the {{Path|{{Highlight|color=darkgreen|/init}}}} program to be referenced when something goes wrong:

{{FileBox|filename=/usr/src/initramfs/init|title=Rescue shell functionality|lang=bash|1=
rescue_shell() {
    echo "Something went wrong. Dropping to a shell."
    exec sh
}
}}

In the example below, the {{Highlight|rescue_shell}} will be executed if the root partition fails to mount:

{{FileBox|filename=/usr/src/initramfs/init|title=Invoking the rescue shell|lang=bash|1=
mount -o ro /dev/sda1 /mnt/root <nowiki>||</nowiki> rescue_shell
}}

=== Dynamic devices ===

For populating {{Path|/dev}} dynamically, either devtmpfs or mdev can be used. Note that the Kernel can take some time detecting devices (such as external USB drives), so a {{Highlight|sleep}} statement may need to be added to the script in order to find all present devices.

==== devtmpfs ====

Provided by the kernel, devtmpfs is designed to offer device nodes during early boot.

{{KernelBox|title=CONFIG_DEVTMPFS{{=}}y|1=<pre>
Device Drivers  --->
    Generic Driver Options  --->
        [*] Maintain a devtmpfs filesystem to mount at /dev
</pre>}}

The following snippet can be included in the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} script to have it mount at boot:

{{FileBox|filename=/usr/src/initramfs/init|title=Adding devtmpfs mount support to /init|lang=bash|1=
mount -t devtmpfs none /dev
}}

Do not forget to unmount devtmpfs it in the cleanup phase of the script:

{{FileBox|filename=/usr/src/initramfs/init|title=umount devtmpfs|lang=bash|1=
umount /dev
}}

==== mdev ====

Although devtmpfs is the modern preferred solution, an alternate method is to use mdev, which is <tt>busybox</tt>'s udev replacement.

{{KernelBox|title=CONFIG_UEVENT_HELPER{{=}}y|1=<pre>
Device Drivers  --->
    Generic Driver Options  --->
        [*] Support for uevent helper
</pre>}}

For mdev to work, {{Path|/sbin/mdev}} must be symlinked to {{Path|/bin/busybox}} in the ''initramfs'':

{{RootCmd|ln -s ../bin/busybox /usr/src/initramfs/sbin/mdev}}

The following snippet must be added to the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}, after mounting the {{Path|/proc}} and {{Path|/sys}} filesystems:

{{FileBox|filename=/usr/src/initramfs/init|title=Adding mdev support to /init|lang=bash|1=
echo /sbin/mdev > /proc/sys/kernel/hotplug
mdev -s
}}

=== Mount by UUID or label ===

With [[#Dynamic_Devices|Dynamic devices]] enabled, it may be preferable to use UUID or label to mount the root partition instead of using a static device name. For that purpose, <tt>busybox</tt> comes with a utility called <tt>findfs</tt>.

{{FileBox|filename=/usr/src/initramfs/init|title=mount using findfs|lang=bash|1=
mount -o ro $(findfs UUID=845b2454-42a3-19ef-6ec5-238a358c365b) /mnt/root
# or
mount -o ro $(findfs LABEL=myroot) /mnt/root
}}

Doing it this way is simple, but it means that the UUID or label is hardcoded in the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}. Alternatively, [[#Kernel_Parameters|Kernel parameters]] can also be used.

==== Kernel parameters ====

To use kernel parameters instead of hardcoding device names or UUIDs, the kernel's {{Path|/proc/cmdline}} file will need to be parsed. There are many ways to do so, the following method is an example to give the general idea of {{Path|cmdline}} parsing. It uses string manipulation of the shell and only supports <code>key=value</code> parameters. Add the following function to the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} and call it whenever a kernel parameter is needed.

{{FileBox|filename=/usr/src/initramfs/init|title=Adding a simple cmdline parser function|lang=bash|1=
cmdline() {
    local value
    value=" $(cat /proc/cmdline) "
    value="${value##* $1=}"
    value="${value%% *}"
    [ "$value" != "" ] && echo "$value"
}
}}

The function is called with the name of the kernel parameter. In the example below it uses the root parameter to mount the root partition.

{{FileBox|filename=/usr/src/initramfs/init|title=Mount rootfs by cmdline|lang=bash|1=
mount -o ro $(findfs $(cmdline root)) /mnt/root
}}

It works for both <code>root=/dev/sda1</code> and <code>root=UUID=845b2454</code> but will fail when the parameter is missing.

=== LVM ===

If the root partition is located on a logical volume, then the LVM binary must be included in the ''initramfs''. A static binary can be generated by enabling the <code>static</code> USE flag for {{Package|sys-fs/lvm2}}. Copy it to the ''initramfs''' {{Path|/sbin}} directory.

{{Note|The static LVM binary may also be called {{Path|/sbin/lvm.static}}. Verify using the <tt>ldd</tt> tool that a static binary is being copied.}}

{{RootCmd|cp -a /sbin/lvm /usr/src/initramfs/sbin/lvm}}

After the above step has been performed, the LVM root partition can be enabled in the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} file. This example assumes the volume group is called '''VG''', and the root volume is called '''root'''. Replace them with the appropriate names used to create the volume.

{{FileBox|filename=/usr/src/initramfs/init|title=Setting up the root volume|lang=bash|1=
lvm vgscan --mknodes # creates /dev/mapper/control
lvm lvchange -a ly VG/root
lvm vgscan --mknodes # creates /dev/mapper/VG-root and /dev/VG/root
}}

The root partition may then be called {{Path|/dev/VG/root}} or {{Path|/dev/mapper/VG-root}}.

{{Note|Calling {{Highlight|'''vgscan'''}} is optional, but recommended, just in case device nodes are missing.}}

Recent versions of {{Package|sys-fs/lvm2}} rely on {{Package|sys-fs/udev}} to create the named LV device nodes, but there is no udev in a simple ''initramfs''. The following choices are available:

* Use <tt>vgscan</tt> as shown above (simplest solution);
* [[#Mount_by_UUID_or_label|Mount by UUID or label]] instead of using {{Path|/dev/VG/root}}. It works because <tt>findfs</tt> is happy with just {{Path|/dev/dm-42}};
* Build a LVM binary with the <code>-udev</code> USE flag (specifically for the ''initramfs'' only!);
* Disable udev dependency by including a minimal {{Path|/etc/lvm/lvm.conf}} in the ''initramfs'':
  {{FileBox|filename=/usr/src/initramfs/etc/lvm/lvm.conf|title=Disable udev in lvm.conf|lang=bash|1=
activation {
    # Set to 0 to disable udev synchronisation (if compiled into the binaries).
    udev_sync = 0
    # Set to 0 to disable the udev rules installed by LVM2
    udev_rules = 0
}
}}

=== Software RAID ===

Normally the Linux kernel will automatically scan for any "Linux raid autodetect" partitions and start as many software RAIDs as it can find. However, if an ''initramfs'' is used the kernel will not automatically scan for RAIDs until it is told to. The following example instructs the kernel to scan for software RAIDs and start as many as it can find. This method will actually start all autodetected arrays, not just {{Path|/dev/md0}}:

{{FileBox|filename=/usr/src/initramfs/init|title=Adding RAID autodetect support to /init|lang=bash|1=
raidautorun /dev/md0
}}

{{Note|[https://raid.wiki.kernel.org/index.php/RAID_superblock_formats#A_Note_about_kernel_autodetection_of_different_superblock_formats "Linux raid autodetect"] will not work for any recent setups, unless the system was specifically set up with partitions of type "fd" and used 0.90 metadata for your Software RAID.}}

==== mdadm ====

When not using "Linux raid autodetect" partitions, or when a more advanced RAID setup exists, the <tt>mdadm</tt> binary must be included in the ''initramfs''. As stated above, a static binary can be generated by enabling the <code>static</code> USE flag when installing{{Package|sys-fs/mdadm}}.

Copy the binary {{Path|/sbin/mdadm}} and the {{Path|/etc/mdadm.conf}} file into the ''initramfs'':

{{RootCmd
|cp -a /sbin/mdadm /usr/src/initramfs/sbin
|cp -a /etc/mdadm.conf /usr/src/initramfs/etc
}}

{{Note|Use <tt>mdadm --detail --scan</tt> if the {{Path|mdadm.conf}} file does not exist.}}

Edit the {{Path|mdadm.conf}} in the ''initramfs'' as needed. An example {{Path|mdadm.conf}} follows:

{{FileBox|filename=/usr/src/initramfs/etc/mdadm.conf|title=mdadm.conf example|lang=bash|1=
DEVICE /dev/sd?*
ARRAY /dev/md0 UUID=627125a5:abce6b82:6c738e49:50adadae
}}

This {{Path|mdadm.conf}} will scan all {{Path|/dev/sd?*}} devices and assemble the RAID device fitting the UUID 627125a5:abce6b82:6c738e49:50adadae.

{{Note|If the {{Path|mdadm.conf}} has additional conditions such as metadata and name, it may be more practical to remove them. The UUID alone should be sufficient.}}

Now initialize the Software RAID in the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}:

{{FileBox|filename=/usr/src/initramfs/init|title=Assemble software RAIDs with mdadm|lang=bash|1=
mdadm --assemble --scan
}}

By implementing these steps it should be possible to mount a root partition located on {{Path|/dev/md0}}.

=== DM-Crypt ===

If the root partition is LUKS encrypted, the cryptsetup binary needs to be included in the ''initramfs''. A static binary can be generated by setting the <code>static</code> USE flag and emerging the {{Package|sys-fs/cryptsetup}} package. Copy the binary to the ''initramfs''' {{Path|/sbin}} directory. Since cryptsetup also often requires the use of the kernel's random device, they need to be included as well.

{{RootCmd
|cp -a /dev/{urandom,random} /usr/src/initramfs/dev
|cp -a /sbin/cryptsetup /usr/src/initramfs/sbin/cryptsetup}}

It is now possible to unlock an encrypted root partition in the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}:

{{FileBox|filename=/usr/src/initramfs/init|title=Setting up LUKS encryption in /init|lang=bash|1=
cryptsetup -T 5 luksOpen /dev/sda1 luksroot
}}

Once the passphrase has been entered the root partition will be available as {{Path|/dev/mapper/luksroot}}.

==== Encrypted keyfile ====

If encrypted keyfiles are needed, use <tt>cryptsetup</tt> to encrypt them. It keeps the ''initramfs'' simple since it will be using the encryption tool that is already available - no need to add other binaries. Plus, unlike some of the alternatives, it offers a nice password prompt.

The following example creates a random 512 byte key, encrypted with LUKS, and adds it to a LUKS container {{Path|/dev/sda1}}.

{{Note|Current versions of cryptsetup use 4096 instead of 2056 blocks for LUKS metadata. With the <code>--align-payload{{=}}1</code> parameter, it is back to 2056 blocks.

<tt>cryptsetup</tt> also offers <code>--keyfile-size</code> and <code>--keyfile-offset</code> options. These can be used for keys with sizes other than 512 bytes, or even multiple keys inside the same LUKS container.}}

{{RootCmd
|dd if{{=}}/dev/zero of{{=}}/usr/src/initramfs/root/key.luks count=2057
|cryptsetup --align-payload{{=}}1 luksFormat /usr/src/initramfs/root/key.luks
|cryptsetup luksOpen /usr/src/initramfs/root/key.luks lukskey
|dd if{{=}}/dev/urandom of{{=}}/dev/mapper/lukskey
|cryptsetup luksAddKey /dev/sda1 /dev/mapper/lukskey
}}

Unlocking the root device using this key in the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} can then be done like this:

{{FileBox|filename=/usr/src/initramfs/init|title=LUKS encryption with keyfiles|lang=bash|1=
# Obtain the key
cryptsetup -T 5 luksOpen /root/key.luks lukskey

# Unlock the root partition
cryptsetup --key-file /dev/mapper/lukskey luksOpen /dev/sda1 luksroot

# Clean up the key
cryptsetup luksClose lukskey
}}

As before, the root partition should then be available as {{Path|/dev/mapper/luksroot}}.

=== Networking ===

To add network support to the ''initramfs'', all required network-related drivers must be built into the kernel, and the network interfaces will have to be configured in the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}}. How exactly this has to be done, depends on the network situation. The following sections cover only the most common cases.

==== Static IP ====

If the network situation allows for the use of a static network IP, it can be configured using the <tt>ifconfig</tt> and <tt>route</tt> commands, both of which are included with Busybox. This is by far the easiest solution, so if it is at all possible, go for it.

{{FileBox|filename=/usr/src/initramfs/init|title=Static network IP setup in /init|lang=bash|1=
ifconfig eth0 10.0.2.15
route add default gw 10.0.2.2
}}

==== DHCP ====

To obtain a dynamic IP address from the network's DHCP server, a DHCP client is needed. Busybox comes with a minimalistic DHCP client called <tt>udhcpc</tt>, which is sufficient for most users. Unfortunately, <tt>udhcpc</tt> has a dependency: it requires the help of a separate script to actually configure the network interface. An example for such a script is included in the Busybox distribution, but it is not installed by Portage. It will have to be obtained directly from either the Busybox tarball (it is called {{Path|examples/udhcp/simple.script}}) or [http://git.busybox.net/busybox/plain/examples/udhcp/simple.script by downloading it from the Busybox project page]. Either method will work. Downloading is probably the easiest route.

Copy the script to the ''initramfs'' and remember to make it executable.

{{RootCmd
|cp simple.script /usr/src/initramfs/bin
|chmod +x /usr/src/initramfs/bin/simple.script}}

Edit the script's first line to read {{Highlight|color=darkred|#!/bin/busybox sh}} or create a symlink for {{Path|/bin/sh}}:

{{RootCmd|ln -s busybox /usr/src/initramfs/bin/sh}}

It should now be possible to obtain a dynamic IP address for the network interface using DHCP:

{{FileBox|filename=/usr/src/initramfs/init|title=Network setup using DHCP|lang=bash|1=
ifconfig eth0 up
udhcpc -t 5 -q -s /bin/simple.script
}}

==== DNS ====

The network should now be up and running. However, that is only if the system knows exactly which IPs to talk to. For situations that only have a host or domain name, it is a different story entirely. In that case, system must be able to resolve hostnames. Unfortunately, this is where simplicity takes a leave of absence. Until now, everything could be done with just the static binary of Busybox - however, this is not the case with DNS.

{{Note|Additional libraries are required to make DNS work.}}

This is because {{Package|sys-libs/glibc}} itself dynamically includes additional libraries for DNS lookups. As long as this type of functionality is not needed, it is fine, but if they are needed, then there is no choice but to include the libraries in the ''initramfs''. The only alternative would be building (recompiling) Busybox against another libc such as {{Package|sys-libs/uclibc}}, however that would go far beyond the scope of this article.

This is a good chance to demonstrate how to use the <tt>strace</tt> ({{Package|dev-util/strace}}) tool to reveal hidden dependencies.

{{Cmd|<nowiki>strace busybox ping wiki.gentoo.org 2>&1 | grep open</nowiki>|output=<pre>
open("/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
open("/etc/host.conf", O_RDONLY|O_CLOEXEC) = 3
open("/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 3
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libnss_files.so.2", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/ld-linux-x86-64.so.2", O_RDONLY|O_CLOEXEC) = 3
open("/etc/hosts", O_RDONLY|O_CLOEXEC)  = 3
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libnss_dns.so.2", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libresolv.so.2", O_RDONLY|O_CLOEXEC) = 3
open("/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 3
</pre>}}

As visible above, the command accesses quite a lot of files, some of which are mandatory for it to work.

Copy the necessary libraries to the ''initramfs'':

{{RootCmd|cp /lib64/libnss_{dns,files}.so.2 /lib64/{libresolv,ld-linux-x86-64}.so.2 /lib64/libc.so.6 /usr/src/initramfs/lib64}}

Create a {{Path|/etc/resolv.conf}} file with at least one useable nameserver. Note that this step may be done automatically if [[#DHCP|DHCP]] is used.

{{RootCmd|echo nameserver 10.0.2.3 > /usr/src/initramfs/etc/resolv.conf}}

With these steps taken DNS lookups should now be possible.

{{Note|1=If it still does not work, you might be suffering from [https://sourceware.org/bugzilla/show_bug.cgi?id=17250 bug 17250]. As a workaround, set <code>LD_LIBRARY_PATH="/lib64"</code> and try again.}}

== Troubleshooting ==

The following section tries to provide help for common issues and pitfalls.

=== Static vs. dynamic binaries ===

Any custom binaries required in the ''initramfs'' before mounting the root partition have to be fully functional, independent from any files that may be installed on the root partition. This is much easier to achieve with static binaries (which usually work as single file) than with dynamic binaries (which need any number of additional libraries to work).

Gentoo package maintainers have provided static binaries for some ebuilds. Check if the ebuild for the desired binary offers a <code>static</code> or <code>-dynamic</code> USE flag. This is by far the easiest method to get a static binary, but unfortunately only a select few ebuilds are supported.

Many applications offer static builds with an option in their configure scripts. There is no standard name for the option, it may be <code>--enable-static</code> or something similar. When compiling a package manually, check the list of available options by using <tt>./configure --help</tt> to see if the package supports building static binaries.

As mentioned earlier in this article, it is possible to verify if binary is static by using the <tt>ldd</tt> command. The <tt>strace</tt> command is also very useful to find out about additional dependencies. By using <tt>equery files</tt> it is possible to see which files a certain package has brought into the system, some of which may also be candidates for additional dependencies of that package.

{{Note|
* See [[#Applications|Applications]] for a <tt>ldd</tt> usage example.
* See [[#DNS|DNS]] for a <tt>strace</tt> usage example.
}}

Including libraries into the ''initramfs'' in order to make a dynamic executable work should only be taken as a last resort . Not only does including dynamic executable make the ''initramfs'' much larger (since the libraries are needed), they also make it more complicated to maintain than necessary; the dependencies (libraries) for each dynamic programs might change with each new version of the program.

=== Kernel panics ===

When working with an ''initramfs'' and writing custom init scripts for it, it is not uncommon to experience kernel panics on boot:

 Kernel panic - not syncing: Attempted to kill init!

This is not an error in the kernel, but an error in the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} script. This script is executed as the init process with PID 1. Unlike other processes, the PID 1 init process is special. It is the only process that is started by the kernel on boot. It is the process that takes care of starting other processes (boot process, init scripts) which in turn start other processes (daemons, login prompts, X), which in turn start even more processes (bash, window manager, browsers, etc.). The init process is the mother of all other processes, and therefore it must not be killed. On shutdown, it is again the init process that takes care of cleaning up by shutting down other processes first, then running processes that will unmount the filesystems, until it is safe to actually do a shutdown without corrupting anything.

When experiencing some error in the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} script, that causes the init process to end, it basically means there are no processes left to run, there is nothing that could take care of cleaning up, and the kernel has no choice but to panic. For this reason there are some things in the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} that cannot be performed as they can in a normal shell script, a return or an exit statement, or letting the script run a series of commands that end the init process after they are finished.

When wanting the {{Highlight|color=darkgreen|'''/init'''}} to end, you have to pass the responsibility of the init process to another process using <tt>exec</tt>. See the examples above for how <tt>exec</tt> is used to either run {{Path|/sbin/init}} of the mounted root partition or to run a rescue shell in case something went wrong.

=== Job control ===

While working with ''initramfs'', especially the [[#Rescue_shell|Rescue shell]], the following message may be displayed:

 /bin/sh: can't access tty; job control turned off

The lack of job control is usually not a problem, since the {{Path|{{Highlight|color=darkgreen|'''/ini'''t}}}} is not supposed to be interactive. However, when wanting to work with the Busybox shell on a regular basis, being unable to control programs with {{Key|Ctrl}}+{{Key|C}} or {{Key|Ctrl}}+{{Key|Z}} as one would normally do with jobs can easily become an issue. In worst case, if job control is not available, and a program refuses to quit, the machine will have to be rebooted.

The [http://www.busybox.net/FAQ.html#job_control job control section] in the Busybox FAQ offers some help here. 
According the the FAQ either

{{RootCmd|setsid sh -c 'exec sh </dev/tty1 >/dev/tty1 2>&1'}}

or

{{RootCmd|setsid cttyhack sh}}

can be used to start a shell on tty1 with jobcontrol enabled.

=== Salvaging ===

If for whatever reason the {{Path|/usr/src/initramfs}} structure has been lost or destroyed, but a copy of the kernel image with the built-in ''initramfs'' or the separate cpio archive is still available, it is possible to re-create it. Although it may be easier to redo it from scratch (if it has been done once, doing it again should be a piece of cake, right?). So this is just-in-case.

==== Dismantling the Kernel ====

This step can be skipped if the ''initramfs'' is a separate cpio archive already. Otherwise, the built-in cpio archive must be extracted from the kernel image. To do that, it must be dismantled, which is not easy, since the kernel image is a combination of a boot sector and compressed archive itself. It also depends on the compression being use for the kernel and the ''initramfs''. For simplicity, this example assumes bzip2 compresses has been used; with that being said the principle is the same for other compression methods.

The utility of choice when dismantling kernel images is {{Package|app-misc/binwalk}}. In analyzes arbitrary files for known signatures, and prints their offsets. While there are usually a bunch of false matches in the output, it should be easy to pick the correct ones.

{{Cmd|binwalk bzImage|output=<pre>
DECIMAL     HEX         DESCRIPTION
-------------------------------------------------------------------------------------------------------------------
15949       0x3E4D      bzip2 compressed data, block size = 900k
3042172     0x2E6B7C    LZMA compressed data, properties: 0x9A, dictionary size: 4194304 bytes, uncompressed size: 9439488 bytes
4433597     0x43A6BD    LZMA compressed data, properties: 0xD8, dictionary size: 16777216 bytes, uncompressed size: 4213785 bytes
8530175     0x8228FF    ELF (NetBSD)
</pre>}}

{{Note|Newer versions also support <tt>binwalk --extract</tt> which will extract all found offsets directly.}}

A less sophisticated method would be to use <tt>grep</tt> to search for signatures. For bzip2 compression, this is '''BZh'''. For gzip, use '''<nowiki>$'\x1f'$'\x8b'</nowiki>'''.

{{Cmd|grep -a -b --only-matching BZh bzImage|output=<pre>
15949:BZh
3946909:BZh
</pre>}}

In this case the offset to search for is '''15949''' bytes. Now it is possible to extract the compressed kernel image:

{{Cmd|<nowiki>dd if=bzImage bs=15949 skip=1 | bunzip2 > Image</nowiki>}}

Now the kernel image has been extracted. Somewhere within this image resides the compressed ''initramfs'' archive, so just iterate the previous process to find it. Depending on the kernel configuration, another bzip2, gzip, or cpio container should be searched for.

{{Cmd
|binwalk Image
|grep -a -b --only-matching BZh Image}}

Suppose the offset is 171424 bytes this time, extract the ''initramfs'' cpio archive using this command:

{{Cmd|<nowiki>dd if=Image bs=171424 skip=1 | bunzip2 > initramfs.cpio</nowiki>}}

To verify that a cpio archive was extracted from that, use the <tt>file</tt> command:

{{Cmd|file initramfs.cpio|output=<pre>
initramfs.cpio: ASCII cpio archive (SVR4 with no CRC)
</pre>}}

==== Extracting the cpio archive ====

If the ''initramfs'' cpio archive was a separate file, it needs to be uncompressed first.

{{Cmd|gunzip initramfs.cpio.gz}}

To extract the uncompressed {{Path|initramfs.cpio}}, you can do so with the following command:

{{Warning|This will overwrite files in the current directory. For safe extraction do it in {{Path|/tmp/initramfs/}} or similar directory.}}

{{Cmd|cpio -i -d -H newc --no-absolute-filenames < initramfs.cpio}}

The ''initramfs'' structure should be successfully recovered.

=== Integrated initramfs does not always update ===

If the ''initramfs'' is integrated into the kernel (instead of using a separate ''initramfs'' file), there is a possibility that the <tt>make bzImage</tt> does not actually update it every time. It is more than possible that changes have been made to the ''initramfs'' but tests have been performed using the old, buggy version. In this case it is necessary to manually delete the integrated image in order to force the kernel to integrate a fresh ''initramfs'' archive:

{{RootCmd|rm /usr/src/linux/usr/initramfs_data.cpio*}}

Alternatively, the same action can completed using the <tt>make clean</tt> command, but then the entire kernel will need to be recompiled, which will take quite a bit longer.

=== Command not found ===

In Gentoo, Busybox is configured as standalone shell by default, which allows Busybox to execute its own applets directly. Without this setting, standard Busybox commands (<tt>mkdir</tt>, <tt>mount</tt>, etc.) will not work unless there is explicitly a symlink created for them. This symlink should be created at the top of the {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} script:

{{FileBox|filename=/usr/src/initramfs/init|title=Install Busybox symlinks to /init|lang=bash|
#!/bin/busybox sh

# Install symlinks to all busybox applets first.
/bin/busybox mkdir -p /usr/sbin /usr/bin /sbin /bin
/bin/busybox --install -s

# ...everything else below...
}}

An alternative method is to create the symlinks directly in the {{Path|/usr/src/initramfs}} directory so they will already be included in the ''initramfs'':

{{RootCmd
|mkdir -p /usr/src/initramfs/{usr/sbin,usr/bin,sbin,bin}
|chroot /usr/src/initramfs /bin/busybox --install -s
}}

== Custom init script examples ==

Fully functional examples of finished {{Path|{{Highlight|color=darkgreen|'''/init'''}}}} scripts can be found in the  [[Custom_Initramfs/Examples|custom init script examples]] sub-article.

== See also ==
* [[Initramfs/HOWTO]]
* [[Dracut]]
* [[Genkernel]]

== External resources ==

* Official initramfs documentation locally (<kbd>less {{Path|/usr/src/linux/Documentation/filesystems/ramfs-rootfs-initramfs.txt}}</kbd>) or [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt online at kernel.org]

[[Category:Initramfs]]
