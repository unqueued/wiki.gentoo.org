{{WIP|author=frostschutz}}

''initramfs'' is a root filesystem which is embedded into the kernel and loaded at an early stage of the boot process. It is the successor of ''initrd''. It provides early userspace which lets you do things that the kernel can't easily do by itself during the boot process.

Using ''initramfs'' is optional. By default, the kernel initializes hardware using built-in drivers, mounts the specified root partition, loads the init system of the installed Linux distribution. The init system then loads additional modules and starts services until it finally allows you to log in. This is a good default behaviour and sufficient for many users. ''initramfs'' is for users with advanced requirements, for users who need to do things as early as possible, before the root partition is mounted.

Here are some examples of what you can do with ''initramfs'':

* Customize the boot process (e.g. print a welcome message, boot splash, ...)
* Load modules (e.g. a third party driver that can not be integrated into the kernel directly)
* Mount the root partition (for encrypted, logical, and otherwise special partitions)
* Provide a minimalistic rescue shell (if something goes wrong)
* Anything the kernel can't do (as long as you can do it in user space, e.g. by executing commands) 

If you don't have advanced requirements, you do not need ''initramfs''.

== Prerequisites ==

There are countless ways to make an ''initramfs''. You can choose not to create an ''initramfs'' at all but let other apps, such as [[Genkernel]] or [[Dracut]], do the work for you. If you are lucky, one of them does what you want out of the box, and you don't need to bother with how ''initramfs'' works and what it does anymore. If you're unlucky, they don't do what you want and you have to extend their functionality, or even build an ''initramfs'' all by yourself.

The ''initramfs'' usually contains at least one file, {{Path|/init}}. This file is executed by the kernel as the main init process (PID 1). It has to do all the work. In addition, there can be any number of additional files and directories that are required by {{Path|/init}}. They are usually files you will also find on any other root filesystem, such as {{Path|/dev}} for device nodes, {{Path|/proc}} for kernel information, {{Path|/bin}} for binaries, and so on. The structure of the ''initramfs'' can be simple, or it can be complicated, depending on what you are planning to do.

When the kernel mounts the ''initramfs'', your target root partition is not yet mounted, so you can't access any of your files. That means there is nothing but the ''initramfs''. So everything you need, everything you want, you have to include it in your ''initramfs''. If you want a shell, you have to include it in your ''initramfs''. If you want to mount something, you need a mount utility. If you need to load a module, your ''initramfs'' has to provide both the module, as well as a utility to load it. If the utility depends on libraries in order to work, you have to include the libraries as well. This seems complicated, and it is, because the ''initramfs'' has to function independently.

== Basics ==

In this section you will learn the ''easy and straightforward way to initramfs creation''. You will make a functional - albeit minimalistic - ''initramfs'' which you then can extend according to your own requirements. 

=== Directory Structure ===

Create the directory that will later become your ''initramfs'' root. For consistency. we'll work in {{Path|/usr/src/initramfs}}, but any directory would do. Create the ''initramfs'' root directory and cd into it.

{{RootCmd|mkdir /usr/src/initramfs}}
{{RootCmd|cd /usr/src/initramfs}}

Create a basic directory layout.

{{RootCmd|mkdir -p bin dev etc lib lib64 mnt/root proc root sbin sys}}

==== Device Nodes ====

Most things you do in ''initramfs'' will require a couple of device nodes to be present, especially the device for your root partition. Throughout this document, {{Path|/dev/sda1}} will be used as example device. Copy basic device nodes.

{{RootCmd|cp -a /dev/{null,console,tty,sda1} /usr/src/initramfs/dev/}}

Which devices you need exactly depends entirely on what you are going to use ''initramfs'' for. Please adapt to your own needs.

{{Note|More advanced approaches to device nodes are covered later on in the [[Initramfs/Custom#Dynamic_Devices]] section.}}

=== Applications ===

Any binary you want to execute at boot needs to be copied into your ''initramfs'' layout. You also need to copy any libraries that your binaries require. To see what libraries any particular binary requires, use the tool '''ldd'''. An example examining what libraries {{Package|dev-util/strace}} requires:

{{Cmd|ldd /usr/bin/strace|output=<pre>
	linux-vdso.so.1 (0x00007fff271ff000)
	libc.so.6 => /lib64/libc.so.6 (0x00007f5b954fe000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f5b958a9000)
</pre>}}

Here you see that for {{Path|/usr/bin/strace}} to work in your ''initramfs'', you not only need to copy {{Path|/usr/bin/strace}} to your {{Path|/usr/src/initramfs/bin}}, but also {{Path|/lib64/libc.so.6}} and {{Path|/lib64/ld-linux-x86-64.so.2}} to your {{Path|/usr/src/initramfs/lib64}}. Note that you don't need the {{Path|linux-vdso.so.1}}.

Additionally, some applications may be depend on other files and libraries to work. For example, {{Package|app-editor/nano}} also needs a terminfo file {{Path|/usr/share/terminfo/l/linux}} from {{Package|sys-libs/ncurses}}, so that has to be copied to your ''initramfs'' as well. To find these dependencies, tools like '''equery''' and '''strace''' prove to be helpful. 

==== Busybox ====

Instead of collecting countless utilities and libraries (and never seeing the end of it), you can just use {{Package|sys-apps/busybox}}. It's a set of utilities for rescue and embedded systems, it contains a shell, utilities like ls, mkdir, cp, mount, insmod, and many more - all in a single binary called {{Path|/bin/busybox}}. For busybox to work properly in a ''initramfs'', you'll firstly need to emerge it with the '''static''' USE flag enabled, then copy the {{Path|/bin/busybox}} binary into your ''initramfs'' layout as {{Path|/usr/src/initramfs/bin/busybox}}:

{{RootCmd
|<nowiki>USE="static" emerge -av busybox</nowiki>
|cp -a /bin/busybox /usr/src/initramfs/bin/busybox}}

{{Note|Check with '''ldd''' that you're copying a static binary.}}

=== Init ===

The file structure of your ''initramfs'' is almost complete. The only thing that is missing is {{Path|/init}}, the executable in the root of the ''initramfs'' that is executed by the kernel once it is loaded. Because {{Package|sys-apps/busybox}} includes a fully functional shell, this means you can write your {{Path|/init}} binary as a simple shell script (instead of making it a complicated application written in Assembler or C that you have to compile).

The following example realizes this executable as a minimalistic shell script, based on the busybox shell: 

{{File|/usr/src/initramfs/init||<pre>
#!/bin/busybox sh

# Mount the /proc and /sys filesystems.
mount -t proc none /proc
mount -t sysfs none /sys

# Do your stuff here.
echo "This script mounts rootfs and boots it up, nothing more!"

# Mount the root filesystem.
mount -o ro /dev/sda1 /mnt/root

# Clean up.
umount /proc
umount /sys

# Boot the real thing.
exec switch_root /mnt/root /sbin/init
</pre>}}

This example needs some device nodes to work, mainly the root block device. Change the script and copy the the corresponding {{Path|/dev/}} node to fit your needs.

Lastly, make the {{Path|/init}} executable:

{{RootCmd|chmod +x /usr/src/initramfs/init}}

=== Packaging Your Initramfs ===

Your ''initramfs'' now has to be made available to your kernel at boot time. This is done by packaging it as a compressed cpio archive. This archive is then either embedded directly into your kernel image, or stored as a separate file which can be loaded by grub during the boot process. Both methods perform equally well, simply choose the method that you find most convenient. 

==== Kernel Configuration ====

With either method, you need to enable support for Initial RAM filesystem and RAM disk (initramfs/initrd) support for the initramfs functionality. 

{{Kernel|<nowiki>CONFIG_BLK_DEV_INITRD=y</nowiki>|<pre>
General setup  --->
    [*] Initial RAM filesystem and RAM disk (initramfs/initrd) supportoption1
</pre>}}

==== Embedding into the Kernel ====

If you want the ''initramfs'' to be embedded into the kernel image, edit your kernel config and set ''Initramfs source file(s)'' to the root of your ''initramfs'', (e.g {{Path|/usr/src/initramfs}}): 

{{Kernel|<nowiki>CONFIG_INITRAMFS_SOURCE="/usr/src/initramfs"</nowiki>|<pre>
General setup  --->
    (/usr/src/initramfs) Initramfs source file(s)
</pre>}}

Now when you compile your kernel it will automatically put the files into a cpio archive and embed it into the kernel image. You will need to rebuild your kernel any time you make any changes to your ''initramfs''. 

==== Creating a Separate File ====

You can create a standalone archive file by running the following commands: 

{{RootCmd
|cd /usr/src/initramfs
|find . -print0 | cpio --null -ov --format=newc | gzip -9 > /boot/my-custom-initramfs.cpio.gz}}

This will create a file called {{Path|my-custom-initramfs.cpio.gz}} in your {{Path|/boot}} directory. You now need to instruct grub to load this file at boot time, you do this with the '''initrd''' line.

{{File|grub.cfg||<pre>
linux 3.12.6-gentoo
initrd my-custom-initramfs.cpio.gz
</pre>}}

{{Note|If you are unfamiliar with bootloader configuration, please refer to [[GRUB2]] or [[GRUB]].}}

=== Finalizing ===

You can now reboot your machine. On boot, the kernel will extract the files from your ''initramfs'' archive automatically and execute your {{Path|/init}} script, which in turn should then take care of mounting your root partition and exec the init of your installed Linux distribution.

== Functionality ==

Now that you've covered the ''initramfs'' basics, in this section you will learn how to extend your {{Path|/init}} script with more advanced functionality. 

=== Rescue Shell ===

If you want to be dropped to a rescue shell if an error occurs, you can add the following function to your {{Path|/init}} and call it when something goes wrong.

{{File|/usr/src/initramfs/init|Rescue Shell|<pre>
rescue_shell() {
    echo "Something went wrong. Dropping you to a shell."
    busybox --install -s
    exec /bin/sh
}
</pre>}}

In the example below, the {{Highlight|rescue_shell}} will be executed if the root partition fails to mount:

{{File|/usr/src/initramfs/init||<pre>
mount -o ro /dev/sda1 /mnt/root || rescue_shell
</pre>}}

==== Remote Rescue Shell ====
=== Dynamic Devices ===

For populating {{Path|/dev}} dynamically, you can use either devtmpfs or mdev. Please note that the kernel can take some time detecting devices (such as external USB drives), so you may also have to add a {{Highlight|sleep}} statement to your script.

==== devtmpfs ====

Provided by the kernel, devtmpfs is designed to offer device nodes early at bootup.

{{Kernel|<nowiki>CONFIG_DEVTMPFS=y</nowiki>|<pre>
Device Drivers  --->
    Generic Driver Options  --->
        [*] Maintain a devtmpfs filesystem to mount at /dev
</pre>}}

You can include the following snippet in your {{Path|/init}} script to have it mount at boot:

{{File|/usr/src/initramfs/init||<pre>
mount -t devtmpfs none /dev
</pre>}}

Don't forget to unmount it again in the cleanup phase of the script:

{{File|/usr/src/initramfs/init||<pre>
umount /dev
</pre>}}

==== mdev ====

Alternatively, you can use mdev, the udev replacement of busybox. For mdev to work, you have to make {{Path|/sbin/mdev}} a symlink to {{Path|/bin/busybox}} in your ''initramfs''.

{{RootCmd|ln -s ../bin/busybox /usr/src/initramfs/sbin/mdev}}

Then add the following snippet to your {{Path|/init}}, after mounting {{Path|/proc}} and {{Path|/sys}}: 

{{File|/usr/src/initramfs/init||<pre>
echo /sbin/mdev > /proc/sys/kernel/hotplug
mdev -s
</pre>}}

=== LVM ===

If your root partition is located on a logical volume, you need to include the LVM binary in your ''initramfs''. You can get a static binary by enabling the '''static''' USE-Flag for {{Package|sys-fs/lvm2}}. Copy it to your ''initramfs'' {{Path|/sbin}} directory.

{{Note|The static LVM binary may also be called {{Path|/sbin/lvm.static}}. Check with '''ldd''' that you're copying a static binary.}}

{{RootCmd|cp -a /sbin/lvm /usr/src/initramfs/sbin/lvm}}

Now you can enable your LVM root partition in {{Path|/init}}. This example assumes that your volume group is called '''VG''', and your root volume is called '''Root'''. Replace them with the names you chose when creating the volume. 

{{File|/usr/src/initramfs/init||<pre>
lvm vgscan --mknodes
lvm lvchange -a ly VG/Root
</pre>}}

Your root partition may then be called {{Path|/dev/VG/Root}} or {{Path|/dev/mapper/VG-Root}}.

=== Software RAID ===

Normally the Linux kernel will automatically scan for any "Linux raid autodetect" partitions (msdos type: fd) and start as many software RAIDs (with 0.90 metadata) as it can find. But if you use an ''initramfs'', the kernel will not automatically scan for RAIDs until it is told to. In the following example instructs the kernel to scan for software RAIDs and start as many as it can find. This will actually start all arrays, not just {{Path|/dev/md0}}:

{{File|/usr/src/initramfs/init||<pre>
raidautorun /dev/md0
</pre>}}

{{Note|"Linux raid autodetect" is deprecated and won't work for any recent setups, unless you specifically set up your system with msdos partitions of type "fd" and used 0.90 metadata for your Software RAID.}}

==== mdadm ====

If you are not using "Linux raid autodetect" partitions, or need to do more advanced RAID setup, then you can use mdadm instead. You will need to include the mdadm binary in your initramfs. You can get a static binary by enabling the '''static''' USE-Flag for {{Package|sys-fs/mdadm}}.

Copy the binary {{Path|/sbin/mdadm}} and your {{Path|/etc/mdadm.conf}} into your ''initramfs'':

{{RootCmd
|cp -a /sbin/mdadm /usr/src/initramfs/sbin
|cp -a /etc/mdadm.conf /usr/src/initramfs/etc
}}

{{Note|Use mdadm --detail --scan you do not yet have a {{Path|mdadm.conf}}.}}

Edit the {{Path|mdadm.conf}} in your ''initramfs'' to your liking. An example {{Path|mdadm.conf}} follows:

{{File|/usr/src/initramfs/etc/mdadm.conf||<pre>
DEVICE /dev/sd?*
ARRAY /dev/md0 UUID=627125a5:abce6b82:6c738e49:50adadae
</pre>}}

This {{Path|mdadm.conf}} will scan all {{Path|/dev/sd?*}} devices and assemble the RAID device fitting the UUID 627125a5:abce6b82:6c738e49:50adadae.

{{Note|If your {{Path|mdadm.conf}} has additional conditions such as metadata and name, it may be more practical to remove them. The UUID alone should be sufficient.}}

Now you can initialize your Software RAID in {{Path|/init}}:

{{File|/usr/src/initramfs/init||<pre>
mdadm --assemble --scan
</pre>}}

=== DM-Crypt ===

If your root partition is LUKS encrypted, you need to include the cryptsetup binary in your ''initramfs''. You can get a static binary by setting the '''static''' USE-Flag for {{Package|sys-fs/cryptsetup}}. Copy it to your ''initramfs'' {{Path|/sbin}} directory. Since cryptsetup also often requires the use of the kernel's random device, include them as well.

{{RootCmd
|cp -a /dev/{urandom,random} /usr/src/initramfs/dev
|cp -a /sbin/cryptsetup /usr/src/initramfs/sbin/cryptsetup}}

Now you can unlock your encrypted root partition in {{Path|/init}}:

{{File|/usr/src/initramfs/init||<pre>
cryptsetup -T 5 luksOpen /dev/sda1 luksroot
</pre>}}

Once you entered your passphrase, your root partition will be available as {{Path|/dev/mapper/luksroot}}.

==== Encrypted Keyfile ====

If you need encrypted keyfiles, use {{Highlight|cryptsetup}} to encrypt them. It keeps your ''initramfs'' simple as that's the encryption tool you already have - no need to add other binaries. Plus, unlike some of the alternatives, it offers a nice password prompt.

The following example creates a random 512 byte key, encrypted with LUKS, and adds it to your LUKS container {{Path|/dev/sda1}}.

{{Note|Current versions of cryptsetup use 4096 instead of 2056 blocks for LUKS metadata. With the <nowiki>--align-payload=1</nowiki> parameter, it's back to 2056 blocks.
<br />cryptsetup also offers --keyfile-size and --keyfile-offset options. You can use this for keys with other sizes than 512 bytes, or even multiple keys inside the same LUKS container.}}

{{RootCmd
|<nowiki>dd if=/dev/zero of=/usr/src/initramfs/root/key.luks count=2057</nowiki>
|<nowiki>cryptsetup --align-payload=1 luksFormat /usr/src/initramfs/root/key.luks</nowiki>
|cryptsetup luksOpen /usr/src/initramfs/root/key.luks lukskey
|<nowiki>dd if=/dev/urandom of=/dev/mapper/lukskey</nowiki>
|cryptsetup luksAddKey /dev/sda1 /dev/mapper/lukskey}}

Unlocking the root device using this key in your {{Path|/init}} can then be done like this: 

{{File|/usr/src/initramfs/init||<pre>
# Obtain the key
cryptsetup -T 5 luksOpen /root/key.luks lukskey

# Unlock the root partition
cryptsetup --key-file /dev/mapper/lukskey luksOpen /dev/sda1 luksroot

# Clean up the key
cryptsetup luksClose lukskey
</pre>}}

As before, your root partition should then be available as {{Path|/dev/mapper/luksroot}}.

=== Networking ===
==== Static IP ====
==== DHCP ====
==== DNS ====
=== Kernel Modules ===
=== UUID/LABEL Root Mounting ===
=== Bootsplash ===
=== Bootchart ===
=== Systemd ===

== Troubleshooting ==
=== Multiple initramfs ===
=== Static vs. Dynamic binaries ===
=== Kernel panics ===
=== Job Control ===
=== Salvaging ===
==== Dismantling the Kernel ====
==== Extracting the cpio archive ====
=== Files in initramfs unreachable ===
=== Integrated initramfs doesn't always update ===
== Resources ==
