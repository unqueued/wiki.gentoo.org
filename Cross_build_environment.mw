==Introduction==
Cross build environments are needed for different situations

* To cross build software for a slow target host on a fast build host. If the target has a different architecture additionally a qemu chroot is needed.
* To build software with a different toolchain (i.e. different libc versions)
* When a specialized system environment is needed
** i.e. a seperate multilib system for binaries with abnormal dependencies which you don't want to mix with your main system (like the steam platform)
** i.e. a base image for docker containers

==Create the cross toolchain==
* Install crossdev: {{Emerge|crossdev}}
* Create the toolchain. For the raspberry-pi it would look like {{RootCmd|crossdev --stable -v -t armv6j-hardfloat-linux-gnueabi|prompt=example #|color=blue}}
* For a amd64-multilib environment it would look like {{RootCmd|crossdev --stable -v -t x86_64-multilib-linux-gnu|prompt=example #|color=blue}}
* Target (-t) takes a tuple ARCH-VENDOR-OS-LIBC; see 'crossdev -t help'

==Update the target build configuration==
* The target make.conf should be changed according to the installation handbook. For the base system at least these options should be checked, the rest can be configured later: {{FileBox|filename=/usr/<TARGET>/etc/portage/make.conf|1=ARCH=arm #check your target architecture
FEATURES=buildpkg #remove buildpkg if you don't want all binary packages in $ROOT/packages
USE="${ARCH} -pam -acl" #disable acl to build the base system, enable it later if it's needed
#set your CFLAGS, you can't use -march=native here if the target has a different cpu
#for the raspberry-pi it could be
#CFLAGS="-Ofast -mfpu=vfp -mfloat-abi=hard -march=armv6zk -mtune=arm1176jzf-s -fomit-frame-pointer -pipe -fno-stack-protector -U_FORTIFY_SOURCE"
#for Allwinner A20 cpu it could be
#CFLAGS="-Ofast -fomit-frame-pointer -pipe -fno-stack-protector -U_FORTIFY_SOURCE -mcpu=cortex-a7 -mtune=cortex-a7 -mfloat-abi=hard -mfpu=neon-vfpv4 -funsafe-math-optimizations"
#set the build jobs aproppriate to the number of cpu cores
#MAKEOPTS="-j5"}}

* Set the appropriate make profile. For the raspberry-pi it would be {{RootCmd|cd /usr/armv6j-hardfloat-linux-gnueabi/etc/portage && rm make.profile && ln -s /usr/portage/profiles/default/linux/arm/13.0/armv6j make.profile|prompt=example #|color=blue}}
* If you build on amd64 see the lib64-bug #known-bugs-and-limitation

==Build the base system==
It can be built from scratch or a stage3 tarball can be unpacked into /usr/<TARGET>. To build it from scratch:
* Build the system packages {{RootCmd|<TARGET>-emerge -uva --keep-going @system}} for the raspberry-pi it would be {{RootCmd|armv6j-hardfloat-linux-gnueabi-emerge -uva --keep-going @system|prompt=example #|color=blue}} (Do not care about failed packages, this will be fixed later)
* Build other essential packages {{RootCmd|<TARGET>-emerge -uva1 â€“keep-going $(egrep '^[a-z]+' /usr/portage/profiles/default/linux/packages.build)}}
* To build the failed packages it is needed to compile them "natively", which means in this case, that the packes need to be compiled in the target chroot enviroment. If the target host has a different architecture a qemu-chroot is needed. For targets that the build host cpu can handle directly the following steps can be skipped and you can chroot directly into the target environment.
** prepare qemu (in this case for the arm architecture) {{RootCmd|1=QEMU_USER_TARGETS="arm" QEMU_SOFTMMU_TARGETS="arm" USE="static-user static-libs" emerge --ask --buildpkg --oneshot qemu}}
** install qemu to the build environment {{RootCmd|1=cd /usr/<TARGET> && ROOT=$PWD/ emerge --ask --usepkgonly --oneshot --nodeps qemu}}
** A first test: {{RootCmd|/etc/init.d/qemu-binfmt start && cd /usr/<TARGET> && chroot . /bin/bash --login}} If it works, leave the chroot and go on with the next steps.
** Optional: This step is not necessary in most cases. To make the target environment emulation more complete, a wrapper can be used, that passes the the correct cpu option to qemu. The following would be an example for the raspberry-pi cpu option for qemu (-cpu arm1176). Please check if the command at the end (qemu-arm) is present on your build host. {{CodeBox|1=
#include <string.h>
#include <unistd.h>
 
int main(int argc, char **argv, char **envp) {
    char *newargv[argc + 3];
 
    newargv[0] = argv[0];
    newargv[1] = "-cpu";
    newargv[2] = "arm1176";
 
    memcpy(&newargv[3], &argv[1], sizeof(*argv) * (argc - 1));
    newargv[argc + 2] = NULL;
    return execve("/usr/bin/qemu-arm", newargv, envp);
}|lang=cpp}}
*** Build it with {{RootCmd|gcc -static qemu-wrapper.c -Ofast -s -o /usr/armv6j-hardfloat-linux-gnueabi/usr/local/bin/qemu-wrapper|prompt=example #|color=blue}}

==Chroot into the target environment==
* Create a chroot script {{FileBox|title=Example for raspberry-pi|filename=/usr/local/bin/chroot-armv6j|1=
/etc/init.d/qemu-binfmt start

#next two line are optional. Activate if the the qemu-wrapper is used.
#echo '-1' > /proc/sys/fs/binfmt_misc/arm #deregister wrong arm
#echo ':arm:M::\x7fELF\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x28\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\x00\xff\xfe\xff\xff\xff:/usr/local/bin/qemu-wrapper:' > /proc/sys/fs/binfmt_misc/register

cd /usr/armv6j-hardfloat-linux-gnueabi
mount -t proc none proc
mount -o bind /dev dev
mount -o bind /usr/portage usr/portage
mount -o bind /usr/local/portage usr/local/portage
mount -o bind /usr/src/raspberrypi-sources usr/src/linux
mount -o bind /lib/modules lib/modules
mount -o bind /sys sys
cp /etc/resolv.conf etc/resolv.conf
#mount -o bind /tmp tmp
#mount -o bind /dev/pts dev/pts #only for X
 
chroot . /bin/bash --login
 
#umount dev/pts
#umount tmp
umount sys
umount lib/modules
umount usr/src/linux
umount usr/local/portage
umount usr/portage
umount dev
umount proc|lang=bash}}
* To chroot into the new environment run the script {{RootCmd|chroot-armv6j|prompt=example #|color=blue}} and complete the set up of your build environment
** Create the portage temp dir {{RootCmd|ln -s /tmp /usr/armv6j-hardfloat-linux-gnueabi/tmp}}
** Update /etc/locale.gen and /etc/env.d/02locale and run {{RootCmd|locale-gen}} after that.
** Check/Reload config {{RootCmd|gcc-config -l;ldconfig -v;env-update; source /etc/profile}}
** To run emerge inside the chroot it is needed to pass other config variables to portage, it can be done with an alias: {{RootCmd|<nowiki>echo 'alias emerge-chroot="ROOT=/ CBUILD=$(grep CHOST= /etc/portage/make.conf|cut -d= -f2) HOSTCC=$CBUILD emerge"' > /etc/bash/bashrc.d/emerge-chroot && source /etc/profile</nowiki>}}
** Packages, that refused the cross compilation can now be build with: {{RootCmd|emerge-chroot --ask --update -v --keep-going @system}}
* After installation of the base system the target environment can be finished according to the installation handbook
==Known bugs and limitations==
* On amd64 build hosts, some cross compiled packages end up in the target environment in /usr/lib64 even if it is not a 64bit target, so set a symlink {{RootCmd|1=cd /usr/<TARGET>/usr && cd /usr/<TARGET>/usr && ln -s lib lib64}}
* Some packages, that create new system users fail to create them in the target environment and create them in build host instead (i.e. openssh). You need to create the user manually or emerge it in the chroot again.

[[Category:Cross building]]
