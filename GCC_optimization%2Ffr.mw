<languages />

Ce guide est une introduction à l'optimisation de code compilé en recourant à des variables CFLAGS et CXXFLAGS saines. Il présente aussi la théorie sousjacente à l'optimisation en général.

== Introduction ==

Que sont les variables CFLAGS et CXXFLAGS ?

CFLAGS et CXXFLAGS sont des variables d'environnement utilisées pour dire aux compilateurs de la collection GNU, <code>gcc</code>, quels types de commutateurs utiliser lors de la compilation du code source. CFLAGS concerne le code écrit en C, tandis que CXXFLAGS concerne le code écrite en C++. 

Elles peuvent être utilisées pour diminuer le nombre de messages de débogage pour un programme, augmenter le niveau d'alerte, et bien-sûr, optimiser le code produit.  Le [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Invoking-GCC.html#Invoking-GCC manuel de GNU gcc (en anglais)] tient à jour une liste exhaustive des options disponibles et de leurs objectifs. 

=== Comment sont-elles utilisées ? ===

Les variables CFLAGS et CXXFLAGS peuvent être utilisées de deux façons. Premièrement, elles peuvent être utilisées ''par programme'' dans des Makefiles générés par automake. 

Cependant, ceci ne devrait pas être fait lors de l'installation de paquets provenant de l'arbre de Portage. Au lieu de cela, définissez vos variables CFLAGS et CXXFLAGS dans le fichier {{Path|/etc/portage/make.conf}}. De cette manière, tous les paquets seront compilés en utilisant les options que vous y aurez définies. 

{{Code|CFLAGS in /etc/portage/make.conf|<pre>
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Comme vous pouvez le voir, CXXFLAGS est définie pour utiliser toutes les options présentes dans CFLAGS. C'est ce que vous devriez faire sans risque la plupart du temps. Vous ne devriez jamais spécifier des options additionnelles dans CXXFLAGS. 

=== Erreurs de conception ===

ALors que CFLAGS et CXXFLAGS peuvent être un moyen efficace de produire des binaires plus compacts et/ou plus rapides, elles peuvent aussi empêcher votre code de fonctionner, augmenter sa taille, ralentir son exécution et même causer des erreurs de compilation. 

Les options de CFLAGS ne sont pas une baguette magique ; elles ne feront pas tourner votre système plus vite ou ne réduiront pas la taille de vos binaires automatiquement. Ajouter de plus en plus d'options dans l'espoir d'optimiser  votre système est une recette garantie d'échec. Il y a un point à partir duquel les retours seront négatifs. 

Malgré toute la vantardise que  vous trouverez sur Internet, des options de  CFLAGS et CXXFLAGS agressives créeront du tort à vos programmes plus qu'elles ne leur feront de bien. Souvenez-vous que  ces options ont été conçues pour être employées à des endroits précis pour des  objectifs précis.  La simple raison qu'une option particulière de CFLAGS est profitable à un morceau de code, ne signifie pas qu'elle convient à n'importe quelle  programme  que vous installerez sur votre machine ! 

=== Prêt ? ===

Maintenant que vous avez pris conscience des risques potentiels, jetons un coup d'œil à quelques optimisations saines et sûres pour votre ordinateur. Elles vous maintiendront en bons termes avec les développeurs la prochaine fois que vous rapporterez un problème sur [http://bugs.gentoo.org Bugzilla]. (Les développeurs vous demanderont généralement de recompiler un paquet avec des options de la variable CFLAGS minimales, pour voir si le problème subsiste. Souvenez-vous que des options agressives peuvent causer du tort à votre code.) 

== Optimiser ==

=== Les bases ===

L'objectif derrière l'utilisation des options des variables CFLAGS et CXXFLAGS est de créer un code parfaitement adapté à votre système ; il devrait fonctionner parfaitement tout en étant aussi compact et rapide que possible. Parfois, ces conditions sont incompatibles entre elles, c'est pourquoi nous nous en tiendrons à des combinaisons réputées pour bien fonctionner. Idéalement, elles sont les meilleurs disponibles pour toute architecture de processeur. Nous parlerons des options agressives plus tard, ainsi vous saurez à quoi vous en tenir. Nous ne discuterons pas chacune des options listées dans le manuel de  <code>gcc</code> (elles sont des centaines), mais nous couvrirons les options les plus basiques et courantes. 

{{Note|À chaque fois que vous ne savez pas ce que fait une option, reportez-vous au chapitre concerné du [http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Optimize-Options.html#Optimize-Options manuel de gcc] . Si vous restez perplexe, essayez un moteur de recherche, ou vérifiez la  [http://gcc.gnu.org/lists.html liste de diffusion] de  <code>gcc</code> .}}

=== -march ===

La première, et la plus importante, option est <code>-march</code>. Elle dit au compilateur quel code il devrait produire pour votre [http://en.wikipedia.org/wiki/Microarchitecture architecture] de processeur (ou ''arch'') ; elle dit qu'il devrait produire du code pour un certain type de processeur. Des processeurs différents ont des aptitudes différentes, prennent en charge différents jeux d'instructions, et ont des manières différentes d'exécuter le code. L'option <code>-march</code> renseigne le compilateur pour qu'il produise le code spécifique à votre processeur, en tenant compte de toutes les aptitudes, fonctionnalités, jeux d'instructions, comportements, etc. de ce processeur. 

Même si la variable CHOST dans le fichier {{Path|/etc/portage/make.conf}} spécifie l'architecture générale utilisée, <code>-march</code> devrait quand même être utilisée pour que les programmes soient optimisés pour votre processeur spécifique.  Les processeur x86 et x86-64 (parmi d'autres) devrait utiliser l'option  <code>-march</code>. 

De quel type de processeur disposez-vous ? Pour le trouver, exécutez la commande suivante : 

{{Cmd|cat /proc/cpuinfo}}

Maintenant, regardons l'option  <code>-march</code> en action. Ceci est un exemple pour un ancien Pentium III : 

{{Code|/etc/portage/make.conf: Pentium III|<pre>
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>
}}

En voici un autre pour un processeur AMD 64-bit : 

{{Code|/etc/portage/make.conf: AMD64|<pre>
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
</pre>
}}

S'il vous reste un doute quand au type de votre processeur, vous pouvez utiliser l'option <code>-march=native</code>. Lorsque cette option est utilisée, GCC détecte automatiquement votre processeur et positionne lui-même  les options appropriées pour ce processeur. '''Néanmoins, celle-ci ne devrait pas être utilisée si votre intention est de compiler des paquets pour un autre processeur !''' 

Si vous compilez des paquets sur un ordinateur, mais avez l'intention les exécuter sur un autre (comme c'est parfois le cas lorsqu'on compile sur un ordinateur récent et rapide pour un ordinateur plus ancien et plus lent), alors ''n'utilisez pas'' l'option <code>-march=native</code>.
''Native'' signifie que ce code  s'exécutera ''seulement''  sur ce type de processeur. Les applications compilées avec l'option <code>-march=native</code> sur un processeur AMD Athlon 64 ne pourront pas tourner sur un ancien processeur VIA C3. 

Sont aussi disponibles, les options <code>-mtune</code> et <code>-mcpu</code>. Ces options sont normalement utilisées quand il n'y a pas d'option <code>-march</code> disponible ; certaines architecture de processeur peuvent demander les options<code>-mtune</code> ou même <code>-mcpu</code>. Malheureusement, le comportement de <code>gcc</code> n'est pas très cohérent sur la manière d'interpréter une option d'une architecture à une autre. 

Sur les processeurs x86 et x86-64, <code>-march</code> produira un code spécifique pour ce type de processeur en utilisant tout le jeu d'instructions disponibles et l'ABI (Application Binary Interface) correcte ; il n'y aura pas de rétrocompatibilité pour des processeurs plus anciens ou différents. Si vous n'avez pas besoin d'exécuter le code sur autre chose que le système sur lequel vous faites tourner Gentoo, continuez à utiliser  <code>-march</code>. Vous devriez seulement considérer l'utilisation de <code>-mtune</code>  pour le cas où vous avez besoin de générer du code pour un processeur plus ancien comme les i386 et I486. <code>-mtune</code>  produit un code plus générique que march</code> ; bien qu'il adapte le code pour un certain processeur, il ne prend pas en compte l'ensemble du jeu d'instructions et de l'ABI. N'utilisez pas <code>-mcpu</code>  sur des systèmes x86 ou x86-64,  car cette option est maintenant déconseillée pour ces architectures. 

Seuls les processeurs non x86/x-86-64 (comme Sparc, Alpha et PowerPC) peuvent nécessiter <code>-mtune</code> ou <code>-mcpu</code> plutôt que  <code>-march</code>.  Sur ces architectures, <code>-mtune</code>/ <code>-mcpu</code> donneront parfois des résultats identiques à ceux fournis par <code>-march</code> (sur x86/x86-64)... mais avec un nom d'option différent. Là encore, le comportement de <code>gcc</code>  et le nommage des options n'est pas cohérent à travers les différentes architectures, c'est pourquoi, vous devez consulter le [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Submodel-Options.html#Submodel-manuel des options ]  de <code>gcc</code>  pour déterminer laquelle utiliser pour votre système. 

{{Note|Pour plus de suggestions sur les réglages  <code>-march</code>/ <code>-mtune</code>/ <code>-mcpu</code>, lisez le chapitre 5 du  5 [http://www.gentoo.org//doc/fr/handbook/ manuel d'installation de Gentoo] adapté à votre architecture. Lisez aussi, la liste  des  [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Submodel-Options.html#Submodel-Options options spécifiques à l'architecture] du manuel de <code>gcc</code>, et les explications plus détaillées sur les différences entre  <code>-march</code> , <code>-mcpu</code> et <code>-mtune</code>.}}

=== -O ===

Vient ensuite l'option <code>-O</code>. Elle contrôle le niveau global d'optimisation. Ceci rend le temps de  compilation quelque peu plus long, et peut nécessiter plus de mémoire, en particulier si vous augmentez le niveau d'optimisation. 

Il y a 5 réglages de <code>-O</code> : <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> et <code>-Os</code>. Vous ne devriez en utiliser qu'un dans  {{Path|/etc/portage/make.conf}}. 

With the exception of <code>-O0</code> , the <code>-O</code> settings each activate several additional flags, so be sure to read the gcc manual's chapter on [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Optimize-Options.html#Optimize-Options optimization options] to learn which flags are activated at each <code>-O</code> level, as well as some explanations as to what they do. 

Let's examine each optimization level: 

*  <code>-O0</code> : This level (that's the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in CFLAGS or CXXFLAGS. Your code will not be optimized; it's not normally desired.

*  <code>-O1</code> : This is the most basic optimization level. The compiler will try to produce faster, smaller code without taking much compilation time. It's pretty basic, but it should get the job done all the time.

*  <code>-O2</code> : A step up from <code>-O1</code> . This is the ''recommended'' level of optimization unless you have special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code> . With <code>-O2</code> , the compiler will attempt to increase code performance without compromising on size, and without taking too much compilation time.

*  <code>-O3</code> : This is the highest level of optimization possible, and also the riskiest. It will take a longer time to compile your code with this option, and in fact it ''should not be used system-wide with <code>gcc</code> 4.x'' . The behavior of <code>gcc</code> has changed significantly since version 3.x. In 3.x, <code>-O3</code> has been shown to lead to marginally faster execution times over <code>-O2</code> , but this is no longer the case with <code>gcc</code> 4.x. Compiling all your packages with <code>-O3</code> ''will'' result in larger binaries that require more memory, and will significantly increase the odds of compilation failure or unexpected program behavior (including errors). The downsides outweigh the benefits; remember the principle of diminishing returns. '''Using <code>-O3</code> is not recommended for <code>gcc</code> 4.x.''' 

*  <code>-Os</code> : This level will optimize your code for size. It activates all <code>-O2</code> options that don't increase the size of the generated code. It can be useful for machines that have extremely limited disk storage space and/or have CPUs with small cache sizes. However, it can cause quite a few problems, which is why it is filtered out by many of the ebuilds in the tree. Using <code>-Os</code> is not recommended.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilations error out, check to make sure that you aren't using <code>-O3</code> . As a fallback option, try setting your CFLAGS and CXXFLAGS to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems) and recompile the package. 

=== -pipe ===

A common flag is <code>-pipe</code> . This flag actually has no effect on the generated code, but it makes the compilation process faster. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, gcc might get killed. In that case, do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code> ) on architectures where doing so does not interfere with debugging (such as x86-64), but you may need to activate it yourself by adding it to your flags. Though the GNU <code>gcc</code> manual does not specify all architectures it is turned on by using <code>-O</code> , you will need to explicitly activate it on x86. However, using this flag will make debugging hard to impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. However, if you don't plan to do much software debugging and haven't added any other debugging-related CFLAGS such as <code>-ggdb</code> , then you can try using <code>-fomit-frame-pointer</code> . 

{{Important|Do ''not'' combine <code>-fomit-frame-pointer</code> with the similar flag <code>-momit-leaf-frame-pointer</code> . Using the latter flag is discouraged, as <code>-fomit-frame-pointer</code> already does the job properly. Furthermore, <code>-momit-leaf-frame-pointer</code> has been shown to negatively impact code performance.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE] , [http://en.wikipedia.org/wiki/SSE2 SSE2] , [http://en.wikipedia.org/wiki/SSSE3 SSE3] , [http://en.wikipedia.org/wiki/MMX MMX] , and [http://en.wikipedia.org/wiki/3dnow 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to check if your CPU supports these by running <code>cat /proc/cpuinfo</code> . The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

You normally don't need to add any of these flags to {{Path|/etc/portage/make.conf}} as long as you are using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code> ). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these you'll need to enable additional flags where appropriate after checking the output of <code>cat /proc/cpuinfo</code> . 

{{Note|You should check the [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options list] of x86 and x86-64-specific flags to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then you don't need to specify it; it will be turned on by using the proper <code>-march</code> setting.}}

== Optimization FAQs ==

=== But I get better performance with -funroll-loops -fomg-optimize! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt your applications when used system-wide. Even the <code>gcc</code> [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> makes code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code> , <code>-fforce-mem</code> , <code>-fforce-addr</code> , and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

The truth of the matter is that they are dangerously aggressive flags. Take a good look around the [http://forums.gentoo.org Gentoo Forums] and [http://bugs.gentoo.org Bugzilla] to see what those flags do: nothing good! 

You don't need to use those flags globally in CFLAGS or CXXFLAGS. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat your code and get your bugs marked INVALID or WONTFIX. 

You don't need dangerous flags like these. '''Don't use them''' . Stick to the basics: <code>-march</code> , <code>-O</code> , and <code>-pipe</code> . 

=== What about -O levels higher than 3? ===

Some users boast about even better performance obtained by using <code>-O4</code> , <code>-O9</code> , and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept CFLAGS like <code>-O4</code> , but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code> , nothing more. 

Need more proof? Examine the <code>gcc</code> [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup source code] : 

{{Code|-O source code|<pre>
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>
}}

As you can see, any value higher than 3 is treated as just <code>-O3</code> . 

=== What about redundant flags? ===

Oftentimes CFLAGS and CXXFLAGS that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}} . Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all CFLAGS and CXXFLAGS, or it may replace <code>-O</code> with a different level. 

The [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] outlines where and how flag filtering/replacing works. 

It's possible to circumvent <code>-O</code> filtering by redundantly listing the flags for a certain level, such as <code>-O3</code> , by doing things like: 

{{Code|Specifying redundant CFLAGS|<pre>
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>
}}

However,'''this is not a smart thing to do'''. CFLAGS are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers'' . Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

You will most likely continue to run into problems when you build a package with unacceptable flags. When you report your troubles on Bugzilla, the flags you use in {{Path|/etc/portage/make.conf}} will be readily visible and you will be told to recompile without those flags. Save yourself the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume that you know better than the developers. 

=== What about LDFLAGS? ===

The Gentoo developers have already set basic, safe LDFLAGS in the base profiles, so you don't need to change them. 

=== Can I use per-package flags? ===

{{Warning|Using per-package flags complicates debugging and support. Make sure you mention in your bug reports if you make use of this feature and what the changes are you made.}}

Information on how to use per-package environment variables (including CFLAGS) is described in the [http://www.gentoo.org//doc/en/handbook/handbook-amd64.xml?part=3&chap=6#doc_chap2 Gentoo Handbook, "Per-Package Environment Variables"] . 

== Resources ==

The following resources are of some help in further understanding optimization: 

* The [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/ GNU gcc manual] 

* Chapter 5 of the [http://www.gentoo.org//doc/en/handbook/ Gentoo Installation Handbooks] 

* <code>man make.conf</code>

* [http://en.wikipedia.org Wikipedia]

* The [http://forums.gentoo.org Gentoo Forums]

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* nightmorph
