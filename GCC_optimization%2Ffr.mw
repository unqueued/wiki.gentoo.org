<languages />

{{Metadata|abstract=Ce guide est une introduction à l'optimisation de code compilé en recourant à des variables CFLAGS et CXXFLAGS saines. Il présente aussi la théorie sous-jacente à l'optimisation en général. }}

Ce guide est [[Article description::une introduction à l'optimisation de code compilé en recourant à des variables <var>CFLAGS</var> et <var>CXXFLAGS</var> saines.]] Il présente aussi la théorie sous-jacente à l'optimisation en général.

== Introduction ==

Que sont les variables CFLAGS et CXXFLAGS ?

<div class="mw-translate-fuzzy">
<var>CFLAGS</var> et <var>CXXFLAGS</var> sont des variables d'environnement utilisées pour dire aux compilateurs de la collection GNU, (gcc), quels types de commutateurs utiliser lors de la compilation du code source.
La variable <var>CFLAGS</var> concerne le code écrit en C, tandis que la variable <var>CXXFLAGS</var> concerne le code écrit en C++.
</div>

Parce que la majorité des paquets constituant un système Gentoo sont écrits en C ou C++, ce sont deux variables qu'un administrateur voudra généralement paramétrer correctement, car elles influencent beaucoup la manière dont le système est construit.

<div class="mw-translate-fuzzy">
Elles peuvent être utilisées pour diminuer le nombre de messages de débogage pour un programme, augmenter le niveau d'alerte, et bien-sûr, optimiser le code produit.  Le [https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC manuel de  gcc (en anglais)] tient à jour une liste exhaustive des options disponibles et de leurs objectifs.
</div>

=== Comment sont-elles utilisées ? ===

<div class="mw-translate-fuzzy">
Les variables <var>CFLAGS</var> et <var>CXXFLAGS</var> peuvent être utilisées de deux façons. Premièrement, elles peuvent être utilisées ''par programme'' dans des Makefiles générés par le programme {c|automake}}.
</div>

{{CodeBox|title=Activer CFLAGS dans /etc/portage/make.conf|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important|Bien qu'il soit possible d'avoir plusieurs ligne pour les options de la variable USE, faire de même avec <var>CFLAGS</var> conduira à des problèmes avec des programmes tels que {{c|cmake}}. Assurez-vous que la déclaration des <var>CFLAGS</var> tient sur une seule ligne avec le moins d'espaces possible pour éviter ces problèmes. Reportez-vous au {{Bug|500034}} comme exemple.}}

Comme vu dans l’exemple ci-dessus, la variable <var>CXXFLAGS</var> est définie pour utiliser toutes les options présentes dans <var>CFLAGS</var>. La plupart des systèmes doivent être configurés de cette manière. Les options additionnelles pour <var>CXXFLAGS</var> sont moins courantes et ne s'appliquent pas assez généralement pour qu'il soit utile de les paramétrer globalement.

{{Tip|L'article [[Safe_CFLAGS|Safe CFLAGS]] peut être utile aux débutants pour optimiser leur système.}}

=== Erreurs de conception ===

<div class="mw-translate-fuzzy">
Bien que <var>CFLAGS</var> et <var>CXXFLAGS</var> puissent être un moyen efficace de produire des binaires plus compacts et/ou plus rapides, elles peuvent aussi empêcher votre code de fonctionner, augmenter sa taille, ralentir son temps d'exécution.Leurs attribuer des valeurs incorrecte peut causer des erreurs de compilation ǃ
</div>

Ne pas oublier que les variables <var>CFLAGS</var> globales configurées dans {{Path|/etc/portage/make.conf}} s'appliqueront à tous les paquets du système, ainsi l'administrateur définit généralement seulement des options vastes et universelles. Chaque paquet modifie ensuite ces options dans ebuild ou directement dans le système de 'build' pour générer un ensemble de paramètres utilisés pendant la compilation.

=== Prêt ? ===

Ayant pris conscience des risques potentiels, on peut s'attarder sur des optimisations sûres et sans danger. Celles-ci permettent de maintenir une bonne entente avec les développeurs la prochaine fois qu'un problème sera rapporté sur [http://bugs.gentoo.org Bugzilla]. (En effet, les développeurs demandent généralement de recompiler un paquet avec des options <var>CFLAGS</var> minimales, pour voir si le problème subsiste. Ne pas oublier que des options agressives peuvent gâcher le code !) 

== Optimiser ==

=== Les bases ===

L'objectif derrière les options des variables <var>CFLAGS</var> et <var>CXXFLAGS</var> est de créer un code parfaitement adapté au système ; il devrait fonctionner parfaitement tout en étant aussi compact et rapide que possible. Parfois, ces conditions sont mutuellement incompatibles, c'est pourquoi ce guide se limitera à des combinaisons réputées pour bien fonctionner. Idéalement, ce sont les meilleurs possibles pour toute architecture de processeur. À titre d'information, les options agressives seront traitées plus tard. Toutes les options listées dans le manuel GCC (il y en a des centaines) ne seront pas traitées, mais seulement les plus basiques et courantes seront étudiées. 

{{Note|Si une option est inconnue, se reporter au chapitre correspondant dans le [https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manuel GCC]. Si ce dernier n'est pas assez limpide, utiliser un moteur de recherche ou regarder la [https://gcc.gnu.org/lists.html liste de diffusion de GCC].}}

=== -march ===

<div class="mw-translate-fuzzy">
La première, et la plus importante des options est <code>-march</code>. Elle indique au compilateur quel code il devrait produire pour votre [https://en.wikipedia.org/wiki/Microarchitecture architecture] de processeur (ou ''arch'') ; elle indique à GCC qu'il devrait produire du code pour un certain type de processeur. Des processeurs différents ont des aptitudes différentes, prennent en charge différents jeux d'instructions et ont des manières différentes d'exécuter le code. L'option <code>-march</code> renseigne le compilateur pour qu'il produise le code spécifique au processeur, en tenant compte de toutes les aptitudes, fonctionnalités, jeux d'instructions, comportements, etc. de ce processeur, à condition que le code source soit disposé à les utiliser. Par exemple, pour bénéficier des instructions AVX, le code source doit être adapté pour les supporter.
</div>

<code>-march=</code> is an ISA selection option; it tells the compiler that it may use the instructions from the [[Wikipedia:Instruction_set_architecture|ISA]]. On an Intel/AMD64 platform with <code>-march=native -O2</code> or lower OPT level, the code will likely end up with AVX instructions used but using shorter SSE XMM registers. To take full advantage of AVX YMM registers, the <code>-ftree-vectorize</code>, <code>-O3</code> or <code>-Ofast</code> options should be used as well<ref>GNU GCC Bugzilla, [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57952#c8 AVX/AVX2 no ymm registers used in a trivial reduction]. Retrieved on 2017/07/18.</ref>.

<code>-ftree-vectorize</code> is an optimization option (default at <code>-O3</code> and <code>-Ofast</code>), which attempts to vectorize loops using the selected ISA if possible.  The reason it isn't enabled at <code>-O2</code> is that it doesn't always improve code, it can make code slower as well, and usually makes the code larger; it really depends on the loop etc. 

Même si la variable <var>CHOST</var> dans le fichier {{Path|/etc/portage/make.conf}} spécifie l'architecture générale utilisée, <code>-march</code> devrait quand même être utilisée pour que les programmes soient optimisés pour le processeur spécifique du système. Les processeur x86 et x86-64 (parmi d'autres) devrait utiliser l'option  <code>-march</code>. 

De quel type de processeur dispose le système ? Pour le savoir, exécutez la commande suivante : 

{{Cmd|cat /proc/cpuinfo}}

or even install {{Package|app-portage/cpuid2cpuflags}} and add the available CPU-specific options to the {{Path|make.conf}} file, which the tool does through e.g. the [[CPU FLAGS X86|CPU_FLAGS_X86]] variable:

{{Cmd|cpuid2cpuflags|output=<pre>
CPU_FLAGS_X86: aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3</pre>}}

{{RootCmd|echo "CPU_FLAGS_X86{{=}}'aes avx avx2 f16c fma3 mmx mmxext popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3'" >> /etc/portage/make.conf}}

Pour avoir plus de détails, y compris sur les valeurs <code>march</code> et <code>mtune</code>, deux commande peuvent être utilisées:

<div class="mw-translate-fuzzy">
{{Cmd|<nowiki>gcc -c -Q -march=native --help=target</nowiki>}}
</div>

* The second command will show the compiler directives for building the header file, but without actually performing the steps and instead showing them on the screen (<code>-###</code>). The final output line is the command that holds all the optimization options and architecture selection:
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

Maintenant, regardons l'option <code>-march</code> en action. Ceci est un exemple pour un ancien Pentium III : 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium III example|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

En voici un autre pour un processeur AMD 64-bit : 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64 example|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

S'il vous reste un doute quand au type de votre processeur, vous pouvez utiliser l'option <code>-march=native</code>. Lorsque cette option est utilisée, GCC tentera de détecte automatiquement le processeur et attribuer lui-même  les options appropriées pour celui-ci. '''Néanmoins,  <code>-march=native</code> ne doit utilisée si vous voulez ou envisagez de compiler des paquets pour un autre processeur !''' 

{{Warning|N'utilisez '''PAS''' <code>-march{{=}}native</code> ou <code>-mtune{{=}}native</code> dans les variables <var>CFLAGS</var> et/ou <var>CXXFLAGS</var> de {{Path|make.conf}} lors de compilation avec {{c|[[Distcc#-march.3Dnative|distcc]]}}.}}

<div class="mw-translate-fuzzy">
Si vous compilez des paquets sur un ordinateur, mais avez l'intention les exécuter sur un autre (comme c'est parfois le cas lorsqu'on compile sur un ordinateur récent et rapide pour un ordinateur plus ancien et plus lent), alors ''n'utilisez pas'' l'option <code>-march=native</code>.
''Native'' signifie que ce code  s'exécutera ''seulement''  sur ce type de processeur. Les applications compilées avec l'option <code>-march=native</code> sur un processeur AMD Athlon 64 '''ne pourront pas''' tourner sur un ancien processeur VIA C3.
</div> 

Sont aussi disponibles, les options <code>-mtune</code> et <code>-mcpu</code>. Ces options sont normalement utilisées quand il n'y a pas d'option <code>-march</code> disponible ; certaines architecture de processeur peuvent demander les options<code>-mtune</code> ou même <code>-mcpu</code>. Malheureusement, le comportement de GCC n'est pas très cohérent sur la manière dont va ce comporter une option d'une architecture à une autre. 

<div class="mw-translate-fuzzy">
Sur les processeurs x86 et x86-64, <code>-march</code> produira un code spécifique pour ce type de processeur en utilisant tout le jeu d'instructions disponibles et l'ABI (Application Binary Interface) correcte ; il n'y aura pas de rétrocompatibilité pour des processeurs plus anciens ou différents. Si vous n'avez pas besoin d'exécuter le code sur autre chose que le système sur lequel vous faites tourner Gentoo, continuez à utiliser  <code>-march</code>. Vous devriez seulement considérer l'utilisation de <code>-mtune</code>  pour le cas où vous avez besoin de générer du code pour un processeur plus ancien comme les i386 et I486. <code>-mtune</code>  produit un code plus générique que march</code> ; bien qu'il adapte le code pour un certain processeur, il ne prend pas en compte l'ensemble du jeu d'instructions et de l'ABI. N'utilisez pas <code>-mcpu</code>  sur des systèmes x86 ou x86-64,  car cette option est maintenant déconseillée pour ces architectures.
</div> 

<div class="mw-translate-fuzzy">
Seuls les processeurs non x86/x-86-64 (comme Sparc, Alpha et PowerPC) peuvent nécessiter <code>-mtune</code> ou <code>-mcpu</code> plutôt que  <code>-march</code>.  Sur ces architectures, <code>-mtune</code>/ <code>-mcpu</code> donneront parfois des résultats identiques à ceux fournis par <code>-march</code> (sur x86/x86-64)... mais avec un nom d'option différent. Là encore, le comportement de <code>gcc</code>  et le nommage des options n'est pas cohérent à travers les différentes architectures, c'est pourquoi, vous devez consulter le [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-manuel des options ]  de <code>gcc</code>  pour déterminer laquelle utiliser pour votre système.
</div> 

<div class="mw-translate-fuzzy">
{{Note|Pour plus de suggestions sur les réglages  <code>-march</code>/ <code>-mtune</code>/ <code>-mcpu</code>, lisez le chapitre 5 du  5 [http://www.gentoo.org//doc/fr/handbook/ manuel d'installation de Gentoo] adapté à votre architecture. Lisez aussi, la liste  des  [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options options spécifiques à l'architecture] du manuel de <code>gcc</code>, et les explications plus détaillées sur les différences entre  <code>-march</code> , <code>-mcpu</code> et <code>-mtune</code>.}}
</div>

<div class="mw-translate-fuzzy">
=== -O ===
</div>

{{Warning|Using <code>-O3</code> or <code>-Ofast</code> may cause some packages to break during the compilation.}}

{{Note|To print all packages that were built with specified <var>CFLAGS</var>/<var>CXXFLAGS</var> it's possible to use the following command: <code>grep Ofast /var/db/pkg/*/*/CFLAGS</code>}}

<div class="mw-translate-fuzzy">
Vient ensuite l'option <code>-O</code>. Elle contrôle le niveau global d'optimisation. Ceci rend le temps de  compilation quelque peu plus long, et peut nécessiter plus de mémoire, en particulier si vous augmentez le niveau d'optimisation.
</div> 

<div class="mw-translate-fuzzy">
Il y a 5 réglages de <code>-O</code> : <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , <code>-Os</code>, <code>-Og</code>, and <code>-Ofast</code> . Vous ne devriez en utiliser qu'un dans  {{Path|/etc/portage/make.conf}}.
</div>

<div class="mw-translate-fuzzy">
À l'exception de <code>-O0</code> ,les réglages de <code>-O</code> activent chacun une série d'options additionnelles, c'est pourquoi vous devriez lire le chapitre sur les  [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options  options d'optimisation] dans le manuel de  gcc, pour connaître les options qui sont activées par chacun des niveaux de   <code>-O</code>, et des explications sur ce qu'elles font.
</div> 

<div class="mw-translate-fuzzy">
Examinons les différents niveaux d'optimisation :
</div> 

<div class="mw-translate-fuzzy">
*  <code>-O0</code> : ce niveau (la lettre O suivi du chiffre 0 ) supprime complètement toute optimisation et est la valeur par défaut si un aucune option <code>-O</code> n'est précisée dans  CFLAGS ou CXXFLAGS. Ceci diminue le temps de compilation et peut améliorer les informations de débogage, mais quelques applications ne fonctionneront pas correctement sans que l'optimisation ne soit activée. Cette option n'est pas recommandée sauf dans un but de débogage.
</div>

<div class="mw-translate-fuzzy">
*  <code>-O1</code> : C'est le niveau d'optimisation le plus basique. Le compilateur va essayer de produire un code plus rapide et plus compact sans prendre trop de temps de compilation. C'est très basique mais ça fait toujours le travail.
</div>

<div class="mw-translate-fuzzy">
*  <code>-O2</code> : Un échelon au-dessus de  <code>-O1</code> . C'est le niveau ''recommandé'' d'optimisation  si vous n'avez de besoin  spécifique.  <code>-O2</code> active quelques options de plus que <code>-O1</code> . Avec <code>-O2</code> , le compilateur va essayer d'augmenter la performance sans compromettre la taille et sans prendre trop de temps en compilation.
</div>

<div class="mw-translate-fuzzy">
*  <code>-O3</code> : C'est le plus haut niveau d'optimisation possible. Il active des optimisations qui sont coûteuses en terme de temps de compilation et d'usage de la mémoire. Compiler tous vos paquets avec <code>-O3</code> ne garantit pas une amélioration de la performance. En réalité, dans de nombreuses situation, cela ralentit le système  à cause des binaires plus volumineux qui réclament plus de mémoire. De plus cette option est réputé casser de nombreux paquets. C'est pourquoi  utiliser   <code>-O3</code> n'est pas recommandé.

 4.x.'''
</div>

<div class="mw-translate-fuzzy">
*  <code>-Os</code> : Cette option optimise la taille de votre code. Elle active toutes les options activée par  <code>-O2</code> qui n'augmentent pas la taille du code. Elle peut être utile pour des machines qui ont un espace disque très limité et/ou ont des processeurs avec un cache de petite taille.
</div>

*  <code>-Og</code> : In gcc 4.8, un nouveau niveau d'optimisation général , -Og a été introduit.Il répond au besoin d'une compilation rapide et une amélioration du débogage tout en procurant un niveau de performance en exécution raisonnable.   Le ressenti en développement devrait être meilleur qu'avec le niveau d'optimisation <code>-O0</code>. Notez que <code>-Og</code> n'implique pas <code>-g</code>, il se contente de désactiver les optimisations qui pourrait interférer avec le débogage.

*  <code>-Ofast</code>: nouveau dans GCC 4.7, consiste en  <code>-O3</code> plus <code>-ffast math</code>, <code>-fno-protect-parens<c/ode>, et <code>-fstack-arrays</code>. Cette option brise la conformité stricte avec les normes, et n'est pas recommandée en utilisation.

<div class="mw-translate-fuzzy">
Comme mentionné précédemment, <code>-O2</code> est le niveau d'optimisation recommandé. Si des erreurs de compilation se produisent, vérifiez que vous n'utilisez pas  <code>-O3</code> . Comme option de repli, essayez de définir un niveau d'optimisation plus faible dans  CFLAGS et CXXFLAGS, comme  <code>-O1</code> ou même <code>-O0 -g2 -ggdb</code> (pour le rapport des erreurs et la vérification de problèmes possibles) et recompilez le paquet.
</div>

=== -pipe ===

<div class="mw-translate-fuzzy">
Une option commune est <code>-pipe</code>. Celle-ci n'a aucun effet sur le code produit, mais réduit le temps de compilation. Elle indique au compilateur d'utiliser des ''pipelines'' pendant la compilation à la place de fichiers temporaires  qui requièrent plus de mémoire. Sur les systèmes avec peu de mémoire, gcc peut se retrouver tué. Dans un tel cas, n'utilisez pas cette option.
</div> 

=== -fomit-frame-pointer ===

<div class="mw-translate-fuzzy">
C'est une option très commune conçue pour réduire la taille du code généré. Elle est activée pour tous les niveaux de l'option <code>-O</code> (excepté <code>-O0</code> ) sur les architectures pour lesquelles procéder de cette manière n'interfère pas avec le débogage (comme x86-64), mais vous pouvez avoir besoin de l'activer vous-même en l'ajoutant à vos options. Bien que le manuel de <code>gcc</code> ne précise pas toutes les architectures sur lesquelles cette option est activée par l'utilisation de l'option GNU <code>gcc</code>, vous pourrez avoir besoin de l'activer sur x86. Néanmoins, l'utilisation de cette option rendra le débogage difficile voire impossible.
</div> 

<div class="mw-translate-fuzzy">
En particulier, cela rend le dépannage des applications écrites en Java beaucoup plus difficile, même si Java n'est pas le seul code affecté par l'utilisation de cette option. C'est pourquoi même si l'option apporte des bénéfices, elle rend le débogage plus difficile ; les ''backtraces'' en particulier seront inutiles. Cependant, si vous n'envisagez pas de faire beaucoup de débogage, et n'avez pas ajouté d'autres options en rapport avec le débogage à CFLAGS comme <code>-ggdb</code>, alors vous pouvez essayer d'utiliser <code>-fomit-frame-pointer</code>.
</div> 

{{Important| ''Ne combinez pas'' <code>-fomit-frame-pointer</code> avec l'option similaire  <code>-momit-leaf-frame-pointer</code> . Utiliser cette dernière option est déconseillé car <code>-fomit-frame-pointer</code> fait déjà le travail proprement. De plus, <code>-momit-leaf-frame-pointer</code> a démontré un impact négatif sur la performance du code.}}

=== -msse, -msse2, -msse3, -mmmx et -m3dnow ===

<div class="mw-translate-fuzzy">
Ces options activent les  jeux d'instructions [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE] , [http://en.wikipedia.org/wiki/SSE2 SSE2] , [http://en.wikipedia.org/wiki/SSSE3 SSE3] , [http://en.wikipedia.org/wiki/MMX MMX] et  [http://en.wikipedia.org/wiki/3dnow 3DNow!] pour les architectures x86 and x86-64. Ils sont utiles avant tout dans le multimedia, les jeux et autres applications utilisant les calculs en virgule flottante de manière intensive, bien qu'ils incluent aussi plusieurs autres améliorations mathématiques. Ces jeux d'instructions se rencontrent dans les processeurs les plus modernes.
</div> 

<div class="mw-translate-fuzzy">
{{Important|Vérifiez que votre processeur les prend en charge en exécutant la commande  <code>cat /proc/cpuinfo</code> . La sortie présentera tous les jeux d'instructions additionnels pris en charge. Notez que '''pni''' n'est qu'un nom différent pour  SSE3.}}
</div>

<div class="mw-translate-fuzzy">
Vous n'avez normalement pas besoin d'ajouter ces options à  {{Path|/etc/portage/make.conf}} tant que vous utilisez l'option <code>-march</code> (par exemple, <code>-march=nocona</code> implique <code>-msse3</code> ). Quelques exceptions notables sont les processeurs plus récents VIA et AMD64 qui prennent en charge des instructions qui ne découlent pas de l'utilisation de   <code>-march</code> (telles que SSE3). Pour de tels processeurs, vous devrez activer des options additionnelles là ou c'est approprié après avoir vérifié la sortie de  <code>cat /proc/cpuinfo</code> .
</div> 

<div class="mw-translate-fuzzy">
{{Note|Vous devriez vérifier la  [http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_64-Options.html#i386-and-x86_64-Options liste] des options spécifiques aux  x86 et x86-64 pour voir lesquels de ces jeux d'instructions sont activés par l'option  propre  au type de processeur. Si un jeu d'instruction est listé alors vous n'avez pas besoin de  le spécifier ; il sera  activé automatiquement par l'utilisation de l'option  <code>-march</code> propre au processeur.}}
</div>

== FAQs sur l'optimisation==

=== Mais j'obtiens de meilleures performance avec -funroll-loops -fomg-optimize ! ===

<div class="mw-translate-fuzzy">
Non, vous le ''pensez'' uniquement parce que quelqu'un vous a convaincu qu'utiliser plus d'options agressives est mieux. Les options agressives ne feront qu'endommager vos applications quand elles sont utilisées à l'échelle du système entier. Même  le [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manuel] de <code>gcc</code> dit qu'utiliser <code>-funroll-loops</code> et <code>-funroll-all-loops</code> rend le code plus volumineux et plus lent. Néanmoins, pour quelques obscures raisons, ces deux options, ainsi que <code>-ffast-math</code> , <code>-fforce-mem</code>, <code>-fforce-addr</code> et d'autres options similaires, continuent à être très populaires parmi ceux qui désirent avoir les droits les plus grands à la vantardise.
</div> 

La vérité sur ce sujet, c'est qu'il y a des options dangereusement agressives. Jetez donc un coup d'œil aux [https://forums.gentoo.org/ forums Gentoo ] et à  [https://bugs.gentoo.org/ Bugzilla] pour savoir ce que ces options font réellement : rien de bon ! 

<div class="mw-translate-fuzzy">
Vous n'avez pas besoin d'utiliser ces options globalement dans CFLAGS ou CXXFLAGS. Cela ne fera que dégrader la performance. Elles peuvent vous faire penser que vous avez une haute performance en fonctionnant à la limite, mais elles ne font que faire grossir votre code et vous apporter des bogues marquées INVALID ou WONTFIX.
</div> 

<div class="mw-translate-fuzzy">
Vous n'avez pas besoin de telles options dangereuses. '''Ne les utilisez pas !'''. Contentez-vous de vous en tenir aux basiques : <code>-march</code> , <code>-O</code> et <code>-pipe</code>.
</div>

=== Que dire des niveaux  -O supérieurs à  3 ? ===

<div class="mw-translate-fuzzy">
Quelques utilisateurs se vantent même d'obtenir une meilleure performance en utilisant <code>-O4</code> , <code>-O9</code>  et plus, mais en réalité, une option <code>-O</code> d'un niveau supérieur à 3 n'a aucun effet. Le compilateur peut accepter des options telles que <code>-O4</code>  pour CFLAGS, mais il n'en fait rien. Il ne cherche à optimiser que jusqu'à  <code>-O3</code>, rien de plus.
</div> 

<div class="mw-translate-fuzzy">
Vous avez besoin de preuves ? Jetez un coup d'œil au [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup code source]  de  <code>gcc</code> :
</div> 

<div class="mw-translate-fuzzy">
{{Code|-O source code|<pre>
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>
}}
</div>

    case OPT_LEVELS_3_PLUS_AND_SIZE:
      enabled = (level >= 3 {{!}}{{!}} size);
      break;
}}

<div class="mw-translate-fuzzy">
Comme vous pouvez le constater, aucune valeur supérieure à <code>-O3</code> n'est prise en compte.
</div>

=== What about compiling outside the target machine? ===

Some readers might wonder if compiling outside the target machine with a strictly inferior CPU or GCC sub-architecture will result in inferior optimization results (compared to a native compilation). The answer is simple: '''No'''.  Regardless of the actual hardware on which the compilation takes place and the CHOST for which GCC was built, as long as the same arguments are used <small>(except for <code>-march=native</code>)</small> and the same version of GCC is used <small>(although minor version might be different)</small>, the resulting optimizations are strictly the same.

To exemplify, if Gentoo is installed on a machine whose GCC's CHOST is ''i686-pc-linux-gnu'', and a [[Distcc]] server is setup on another computer whose GCC's CHOST is ''i486-linux-gnu'', then there is no need to be afraid that the results would be less optimal because of the strictly inferior sub-architecture of the remote compiler and/or hardware. The result would be as optimized as a native build, as long as the same options are passed to both compilers (and the <code>-march</code> parameter doesn't get a <code>native</code> argument).  In this particular case the target architecture needs to be specified explicitly as explained in [[Distcc#-march.3Dnative|Distcc and -march=native]].

The only difference in behavior between two GCC versions built targeting different sub-architectures is the implicit default argument for the <code>-march</code> parameter, which is derived from the GCC's CHOST when not explicitly provided in the command line.

=== Que dire des options  redondantes ? ===

<div class="mw-translate-fuzzy">
Très souvent des options CFLAGS et CXXFLAGS qui sont activées par des niveaux de <code>-O</code>  sont spécifiées de manière redondante dans {{Path|/etc/portage/make.conf}}.  Quelques fois cela est fait par ignorance, mais c'est aussi fait pour éviter le filtrage d'options ou le remplacement d'options.
</div> 

<div class="mw-translate-fuzzy">
Le filtrage/remplacement d'options est fait dans de nombreux ebuilds de l'arbre de Portage. C'est généralement fait parce que la compilation de certains paquets échoue à certains niveaux de  <code>-O</code>, ou quand le code source est trop sensible pour que des options supplémentaires soient ajoutées. L'ebuild soit filtrera quelques options de CFLAGS et CXXFLAGS, soit remplacera le niveau de  <code>-O</code> par un autre.
</div> 

<div class="mw-translate-fuzzy">
Le [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Manuel du développeur de Gentoo]  indique quand et comment le filtrage/remplacement d'options  fonctionne.
</div> 

Il est possible de contrecarrer le filtrage de  <code>-O</code>  en listant de manière redondante les options d'un certain niveau, (tel que  <code>-O3</code>)  en faisant ceci : 

<div class="mw-translate-fuzzy">
{{Code|Specifying redundant CFLAGS|<pre>
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>
}}
</div>

<div class="mw-translate-fuzzy">
Néanmoins, '''ce n'est pas très élégant de le faire.''' Les options de CFLAGS sont filtrées pour une raison ! Quand des options sont filtrées, cela signifie que ce n'est pas sûr de compiler un paquet avec de telles options. Clairement, ce n'est ''pas '' sûr de compiler tout votre système avec l'option <code>-O3</code> si quelques unes des options activées par ce niveau sont susceptibles de provoquer des problèmes à certains paquets. En conséquence, vous ne devriez pas essayer d'être ''plus intelligent'' que les développeurs qui maintiennent ces paquets. ''Faites confiance'' aux développeurs''' ! . Le filtrage et le remplacement d'options est fait pour votre intérêt ! Si un ebuild spécifie des options alternatives, n'essayez pas de l'éviter.
</div> 

<div class="mw-translate-fuzzy">
Vous continuerez probablement à rencontrer des problèmes si vous compilez un paquet avec des options inacceptables. Quand vous rapportez vos problèmes sur Bugzilla, les options que vous utilisez dans {{Path|/etc/portage/make.conf}}  seront pleinement visibles et on vous demandera de recompiler le paquet sans ces options. Évitez d'avoir à recompiler en n'utilisant pas ces options redondantes dès l'origine ! Ne supposez pas de manière automatique que vous en savez plus que les développeurs.
</div>

=== Que dire de  LDFLAGS ? ===

<div class="mw-translate-fuzzy">
Les développeurs de Gentoo ont déjà défini des options de base sûres de la variable LDFLAGS  dans les profils de base. Vous n'avez donc pas besoin de les changer.
</div>

=== Puis-je utiliser des options par paquet ? ===

<div class="mw-translate-fuzzy">
{{Warning/fr |L'utilisation d'options par paquet complique le débogage et l'assistance.  Pensez à signaler dans vos rapport de bogues si vous utilisez cette fonctionnalité et quels changements vous avez faits.}}
</div>

<div class="mw-translate-fuzzy">
Une information sur comment utiliser les variables d'environnement par paquet (y compris CFLAGS) est fournie dans le [http://www.gentoo.org//doc/fr/handbook/handbook-amd64.xml?part=3&chap=6#doc_chap2 manuel de Gentoo , "Variables d'environnement par paquet"] .
</div>

== See also ==

* [[Handbook:AMD64/Installation/Stage#Configuring_compile_options|Configuring compile options]] (AMD64 Handbook)

<div class="mw-translate-fuzzy">
== Ressources ==
</div>

Les ressources suivantes vous seront utiles pour aller plus loin dans la compréhension de l'optimisation : 

<div class="mw-translate-fuzzy">
* La  [http://gcc.gnu.org/onlinedocs/gcc/ documentation en ligne sur gcc ]
</div> 

<div class="mw-translate-fuzzy">
* <code>man make.conf</code>
</div>

* [https://en.wikipedia.org/ Wikipedia]

* Les  [https://forums.gentoo.org/ forums de Gentoo]

== References ==

{{reflist}}

{{Migrated|originalauthors={{Dev|nightmorph}}}}


[[Category:Compilation]]
