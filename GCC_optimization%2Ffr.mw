<languages />

{{Metadata|abstract=Ce guide est une introduction à l'optimisation du code compilé via des options de compilation CFlAGS et CXXFLAGS sûres et saines. Il décrit également la théorie de l'optimisation en général. }}

Ce guide est une introduction à l'optimisation de code compilé en recourant à des variables <var>CFLAGS</var> et <var>CXXFLAGS</var> saines. Il présente aussi la théorie sous-jacente à l'optimisation en général.

== Introduction ==

Que sont les variables CFLAGS et CXXFLAGS ?

<var>CFLAGS</var> et <var>CXXFLAGS</var> sont des variables d'environnement utilisées pour dire aux compilateurs de la collection GNU, (gcc), quels types de commutateurs utiliser lors de la compilation du code source.
La variable <var>CFLAGS</var> concerne le code écrit en C, tandis que la variable <var>CXXFLAGS</var> concerne le code écrit en C++. 

Elles peuvent être utilisées pour diminuer le nombre de messages de débogage pour un programme, augmenter le niveau d'alerte, et bien-sûr, optimiser le code produit.  Le [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC manuel de  gcc (en anglais)] tient à jour une liste exhaustive des options disponibles et de leurs objectifs.

=== Comment sont-elles utilisées ? ===

<var>CFLAGS</var> and <var>CXXFLAGS</var> can be used in two ways. First, they can be used per-program with Makefiles generated by the {{c|automake}} program. 

Cependant, ceci ne devrait pas être fait lors de l'installation de paquets provenant de l'arbre de Portage. Au lieu de cela,pour les systèmes bases sur Gentoo, définissez vos variables <var>CFLAGS</var> et <var>CXXFLAGS</var> dans le fichier {{Path|/etc/portage/make.conf}}. De cette manière, tous les paquets seront compilés en utilisant les options définies dans {{Path|make.conf}}.

{{CodeBox|title=Activer CFLAGS dans /etc/portage/make.conf|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important|Bien qu'il soit possible d'avoir plusieurs ligne pour les options de la variable USE, faire la même chose avec  <var>CFLAGS</var> conduira à des problèmes avec des programmes tels que {{c|cmake}}. Assurez-vous que la déclaration des <var>CFLAGS</var> tient sur une seule ligne avec le moins d'espaces que possible pour éviter ces problèmes. Reportez-vous au {{Bug|500034}} comme exemple.}}

Comme vous pouvez le voir dans l’exemple ci-dessus, la variable <var>CXXFLAGS</var> est définie pour utiliser toutes les options présentes dans <var>CFLAGS</var>. La grande majorité des systèmes doivent être configure de cette manière.L'utilisation d'options additionnelles pour <var>CXXFLAGS </var> sont ''extrêmement rare'' dans les cas classique d'utilisation.

=== Erreurs de conception ===

Bien que <var>CFLAGS</var> et <var>CXXFLAGS</var> puissent être un moyen efficace de produire des binaires plus compacts et/ou plus rapides, elles peuvent aussi empêcher votre code de fonctionner, augmenter sa taille, ralentir son temps d'exécution.Leurs attribuer des valeurs incorrecte peut causer des erreurs de compilation ǃ 

Les options de <var>CFLAGS</var> ne sont pas une baguette magique ; elles ne feront pas tourner le système plus vite ou ne réduiront pas la taille de vos binaires automatiquement. Ajouter de plus en plus d'options dans l'espoir d'optimiser  votre système est une recette garantie d'échec. Il y a un point rapidement atteins à partir duquel les retours seront négatifs. 

Malgré toute la vantardise que 'on peut trouver sur Internet, des options de <var>CFLAGS</var> et <var>CXXFLAGS</var> agressives sont plus susceptible d’être néfaste aux programmes que bénéfique. Souvenez-vous que  ces options ont été conçues pour être employées à des endroits précis pour des  objectifs précis.Peu fonctionne comme prévue lors d'une utilisation généralisé.

=== Prêt ? ===

Being aware of the risks involved, take a look at some sane, safe optimizations. These will hold in good stead and will be endearing to developers the next time a problem  is reported on [https://bugs.gentoo.org/ Bugzilla]. (Developers will usually request the user to recompile a package with minimal <var>CFLAGS</var> to see if the problem persists. Remember: aggressive flags can ruin code!) 

== Optimiser ==

=== Les bases ===

The goal behind <var>CFLAGS</var> and <var>CXXFLAGS</var> is to create code tailor-made to your system; it should function perfectly while being lean and fast, if possible. Sometimes these conditions are mutually exclusive, so this guide will stick to combinations known to work well. Ideally, they are the best available for any CPU architecture. For informational purposes, aggressive flag use will be covered later. Not every option listed on the GCC manual (there are hundreds) will be discussed, but basic, most common flags will be reviewed. 

{{Note|À chaque fois que vous ne savez pas ce que fait une option, reportez-vous au chapitre concerné du [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manuel de gcc] . Si vous restez perplexe, essayez un moteur de recherche, ou vérifiez la  [http://gcc.gnu.org/lists.html liste de diffusion de GCC] .}}

=== -march ===

The first and most important option is <code>-march</code>. This tells the compiler what code it should produce for the system's [https://en.wikipedia.org/wiki/Microarchitecture processor architecture] (or ''arch''); it tells GCC that it should produce code for a certain kind of CPU. Different CPUs have different capabilities, support different instruction sets, and have different ways of executing code. The <code>-march</code> flag will instruct the compiler to produce specific code for the system's CPU, with all its capabilities, features, instruction sets, quirks, and so on. 

Even though the <code>CHOST</code> variable in {{Path|/etc/portage/make.conf}} specifies the general architecture used, <code>-march</code> should still be used so that programs can be optimized for the system specific processor. x86 and x86-64 CPUs (among others) should make use of the <code>-march</code> flag. 

De quel type de processeur dispose le système ? Pour le savoir, exécutez la commande suivante : 

{{Cmd|cat /proc/cpuinfo}}

Pour avoir plus de détails, y compris sur les valeurs <code>march</code> et <code>mtune</code>, deux commande peuvent être utilisées:

* The first command tells the compiler not to do any linking (<code>-c</code>), and instead of interpreting the <code>--help</code> option for clarifying command line options, it now shows if certain options are enabled or disabled (<code>-Q</code>). In this case, the options shown are those enabled for the selected target:
: {{Cmd|gcc -c -Q -march{{=}}native --help{{=}}target}}

* The second command will show the compiler directives for building the header file, but without actually performing the steps and instead showing them on the screen (<code>-###</code>). The final output line is the command that holds all the optimization options and architecture selection:
: {{Cmd|gcc -### -march{{=}}native /usr/include/stdlib.h}}

Maintenant, regardons l'option <code>-march</code> en action. Ceci est un exemple pour un ancien Pentium III : 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium III example|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

En voici un autre pour un processeur AMD 64-bit : 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64 example|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

S'il vous reste un doute quand au type de votre processeur, vous pouvez utiliser l'option <code>-march=native</code>. Lorsque cette option est utilisée, GCC tentera de détecte automatiquement le processeur et attribuer lui-même  les options appropriées pour celui-ci. '''Néanmoins,  <code>-march=native</code> ne doit utilisée si vous voulez ou envisagez de compiler des paquets pour un autre processeur !''' 

{{Warning|N'utilisez '''PAS''' <code>-march{{=}}native</code> ou <code>-mtune{{=}}native</code> dans les variables <var>CFLAGS</var> et/ou <var>CXXFLAGS</var> de {{Path|make.conf}} lors de compilation avec {{c|[[Distcc#-march.3Dnative|distcc]]}}.}}

Si vous compilez des paquets sur un ordinateur, mais avez l'intention les exécuter sur un autre (comme c'est parfois le cas lorsqu'on compile sur un ordinateur récent et rapide pour un ordinateur plus ancien et plus lent), alors ''n'utilisez pas'' l'option <code>-march=native</code>.
''Native'' signifie que ce code  s'exécutera ''seulement''  sur ce type de processeur. Les applications compilées avec l'option <code>-march=native</code> sur un processeur AMD Athlon 64 '''ne pourront pas''' tourner sur un ancien processeur VIA C3. 

Sont aussi disponibles, les options <code>-mtune</code> et <code>-mcpu</code>. Ces options sont normalement utilisées quand il n'y a pas d'option <code>-march</code> disponible ; certaines architecture de processeur peuvent demander les options<code>-mtune</code> ou même <code>-mcpu</code>. Malheureusement, le comportement de GCC n'est pas très cohérent sur la manière dont va ce comporter une option d'une architecture à une autre. 

On x86 and x86-64 CPUs, <code>-march</code> will generate code specifically for that CPU using its available instruction sets and the correct ABI; it will have no backwards compatibility for older/different CPUs. Consider using <code>-mtune</code> when generating code for older CPUs such as i386 and i486. <code>-mtune</code> produces more generic code than <code>-march</code>; though it will tune code for a certain CPU, it does not take into account available instruction sets and ABI. Do not use <code>-mcpu</code> on x86 or x86-64 systems, as it is deprecated for those arches. 

Only non-x86/x86-64 CPUs (such as Sparc, Alpha, and PowerPC) may require <code>-mtune</code> or <code>-mcpu</code> instead of <code>-march</code>. On these architectures, <code>-mtune</code> / <code>-mcpu</code> will sometimes behave just like <code>-march</code> (on x86/x86-64) but with a different flag name. Again, GCC's behavior and flag naming is not consistent across architectures, so be sure to check the GCC [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] to determine which one should be used. 

{{Note|For more suggested <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> settings, please read chapter 5 of the appropriate [[HandBook:Main_Page|Gentoo Installation Handbook]] for the arch. Also, read the GCC manual's list of [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options], as well as more detailed explanations about the differences between <code>-march</code>, <code>-mcpu</code>, and <code>-mtune</code>.}}

=== -O ===

Next up is the <code>-O</code> variable. This variable controls the overall level of optimization. Changing this value will make the code compilation take more time and will use much more memory, especially as the level of optimization is increased. 

There are seven <code>-O</code> settings: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code>, and <code>-Ofast</code>. Only use one of them in {{Path|/etc/portage/make.conf}}

À l'exception de <code>-O0</code> ,les réglages de <code>-O</code> activent chacun une série d'options additionnelles, c'est pourquoi vous devriez lire le chapitre sur les  [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options  options d'optimisation] dans le manuel de  gcc, pour connaître les options qui sont activées par chacun des niveaux de   <code>-O</code>, et des explications sur ce qu'elles font. 

Let us examine each optimization level: 

*  <code>-O0</code>: This level (that is the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in <var>CFLAGS</var> or <var>CXXFLAGS</var>. This reduces compilation time and can improve debugging info, but some applications will not work properly without optimization enabled. This option is not recommended except for debugging purposes.

*  <code>-O1</code>: the most basic optimization level. The compiler will try to produce faster, smaller code without taking much compilation time. It is basic, but it should get the job done all the time.

*  <code>-O2</code>: A step up from <code>-O1</code>. The ''recommended'' level of optimization unless the system has special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code>. With <code>-O2</code>, the compiler will attempt to increase code performance without compromising on size, and without taking too much compilation time.

*  <code>-O3</code>: the highest level of optimization possible. It enables optimizations that are expensive in terms of compile time and memory usage.  Compiling with <code>-O3</code> is not a guaranteed way to improve performance, and in fact, in many cases, can slow down a system due to larger binaries and increased memory usage. <code>-O3</code> is also known to break several packages. Using <code>-O3</code> is not recommended.

*  <code>-Os</code>: optimizes code for size. It activates all <code>-O2</code> options that do not increase the size of the generated code. It can be useful for machines that have extremely limited disk storage space and/or CPUs with small cache sizes.

*  <code>-Og</code> : In gcc 4.8, un nouveau niveau d'optimisation général , -Og a été introduit.Il répond au besoin d'une compilation rapide et une amélioration du débogage tout en procurant un niveau de performance en exécution raisonnable.   Le ressenti en développement devrait être meilleur qu'avec le niveau d'optimisation <code>-O0</code>. Notez que <code>-Og</code> n'implique pas <code>-g</code>, il se contente de désactiver les optimisations qui pourrait interférer avec le débogage.

*  <code>-Ofast</code>: nouveau dans GCC 4.7, consiste en  <code>-O3</code> plus <code>-ffast math</code>, <code>-fno-protect-parens<c/ode>, et <code>-fstack-arrays</code>. Cette option brise la conformité stricte avec les normes, et n'est pas recommandée en utilisation.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and while not using <code>-O2</code>, try rebuilding with that option. As a fallback option, try setting the <var>CFLAGS</var> and <var>CXXFLAGS</var> to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).

=== -pipe ===

A common flag is <code>-pipe</code>. This flag has no effect on the generated code, but it makes the compilation process ''faster''. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, GCC might get killed. In those cases do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but it may need to be activated. In that case add it to the flags. Though the GCC manual does not specify all architectures, it is turned on by using the <code>-O</code> option. It's still necessary to explicitly enable the <code>-fomit-frame-pointer</code> option, to activate it on x86-32 with GCC up to version 4.6, or when using <code>-Os</code> on x86-32 with any version of GCC. However, using <code>-fomit-frame-pointer</code> will make debugging hard or impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. When not doing software debugging and no other debugging-related <var>CFLAGS</var> such as <code>-ggdb</code> have been used, then try using <code>-fomit-frame-pointer</code>. 

{{Important| ''Ne combinez pas'' <code>-fomit-frame-pointer</code> avec l'option similaire  <code>-momit-leaf-frame-pointer</code> . Utiliser cette dernière option est déconseillé car <code>-fomit-frame-pointer</code> fait déjà le travail proprement. De plus, <code>-momit-leaf-frame-pointer</code> a démontré un impact négatif sur la performance du code.}}

=== -msse, -msse2, -msse3, -mmmx et -m3dnow ===

These flags enable the [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions Streaming SIMD Extentions] (SSE), [http://en.wikipedia.org/wiki/SSE2 SSE2], [http://en.wikipedia.org/wiki/SSSE3 SSE3], [http://en.wikipedia.org/wiki/MMX_(instruction_set) MMX], and [http://en.wikipedia.org/wiki/3dnow 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to see if the CPU supports these instruction sets by running <kbd>cat /proc/cpuinfo</kbd>. The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

Normally none of these flags need to be added to {{Path|/etc/portage/make.conf}}, as long as the system is using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code>). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these additional flags will need to be enabled where appropriate after checking {{Path|/proc/cpuinfo}}. 

{{Note|Check the [http://gcc.gnu.org/onlinedocs/gcc/x86-Options.html list of x86 and x86-64-specific flags] to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then it does not need to be separately specified; it will be turned on by using the proper <code>-march</code> setting.}}

== FAQs sur l'optimisation==

=== Mais j'obtiens de meilleures performance avec -funroll-loops -fomg-optimize ! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt applications when used system-wide. Even the GCC [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> will make code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

La vérité sur ce sujet, c'est qu'il y a des options dangereusement agressives. Jetez donc un coup d'œil aux [https://forums.gentoo.org/ forums Gentoo ] et à  [https://bugs.gentoo.org/ Bugzilla] pour savoir ce que ces options font réellement : rien de bon ! 

You do not need to use those flags globally in <var>CFLAGS</var> or <var>CXXFLAGS</var>. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat the code and get your bugs marked INVALID or WONTFIX. 

Vous n'avez pas besoin de telles options dangereuses. '''Ne les utilisez pas !'''. Contentez-vous de vous en tenir aux basiques : <code>-march</code> , <code>-O</code> et <code>-pipe</code>.

=== Que dire des niveaux  -O supérieurs à  3 ? ===

Some users boast about even better performance obtained by using <code>-O4</code>, <code>-O9</code>, and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept <var>CFLAGS</var> like <code>-O4</code>, but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code>, nothing more. 

Need more proof? Examine the [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup source code]: 

{{CodeBox|title=-O source code|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

Comme vous pouvez le constater, aucune valeur supérieure à <code>-O3</code> n'est prise en compte.

=== What about compiling outside the target machine? ===

Some readers might wonder if compiling outside the target machine with a strictly inferior CPU or GCC sub-architecture will result in inferior optimization results (compared to a native compilation). The answer is simple: '''No'''.  Regardless of the actual hardware on which the compilation takes place and the CHOST for which GCC was built, as long as the same arguments are used <small>(except for <code>-march=native</code>)</small> and the same version of GCC is used <small>(although minor version might be different)</small>, the resulting optimizations are strictly the same.

To exemplify, if Gentoo is installed on a machine whose GCC's CHOST is ''i686-pc-linux-gnu'', and a [[Distcc]] server is setup on another computer whose GCC's CHOST is ''i486-linux-gnu'', then there is no need to be afraid that the results would be less optimal because of the strictly inferior sub-architecture of the remote compiler and/or hardware. The result would be as optimized as a native build, as long as the same options are passed to both compilers (and the <code>-march</code> parameter doesn't get a <code>native</code> argument).  In this particular case the target architecture needs to be specified explicitly as explained in [[Distcc#-march.3Dnative|Distcc and -march=native]].

The only difference in behavior between two GCC versions built targeting different sub-architectures is the implicit default argument for the <code>-march</code> parameter, which is derived from the GCC's CHOST when not explicitly provided in the command line.

=== Que dire des options  redondantes ? ===

Oftentimes <var>CFLAGS</var> and <var>CXXFLAGS</var> that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}}. Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all <var>CFLAGS</var> and <var>CXXFLAGS</var>, or it may replace <code>-O</code> with a different level. 

Le [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Manuel du développeur de Gentoo]  indique quand et comment le filtrage/remplacement d'options  fonctionne. 

Il est possible de contrecarrer le filtrage de  <code>-O</code>  en listant de manière redondante les options d'un certain niveau, (tel que  <code>-O3</code>)  en faisant ceci : 

{{CodeBox|title=Specifying redundant CFLAGS|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

However, '''this is not a smart thing to do'''. <var>CFLAGS</var> are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers''. Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

Vous continuerez probablement à rencontrer des problèmes si vous compilez un paquet avec des options inacceptables. Quand vous rapportez vos problèmes sur Bugzilla, les options que vous utilisez dans {{Path|/etc/portage/make.conf}}  seront pleinement visibles et on vous demandera de recompiler le paquet sans ces options. Évitez d'avoir à recompiler en n'utilisant pas ces options redondantes dès l'origine ! Ne supposez pas de manière automatique que vous en savez plus que les développeurs.

=== Que dire de  LDFLAGS ? ===

The Gentoo developers have already set basic, safe <var>LDFLAGS</var> in the base profiles, so they do not need to be changed.

=== Puis-je utiliser des options par paquet ? ===

{{Warning/fr |L'utilisation d'options par paquet complique le débogage et l'assistance.  Pensez à signaler dans vos rapport de bogues si vous utilisez cette fonctionnalité et quels changements vous avez faits.}}

Information on how to use per-package environment variables (including <var>CFLAGS</var>) is described in the [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]].

== Ressources ==

Les ressources suivantes vous seront utiles pour aller plus loin dans la compréhension de l'optimisation : 

* La  [http://gcc.gnu.org/onlinedocs/gcc/ documentation en ligne sur gcc ] 

* Gentoo Handbook - [[Handbook:AMD64/Installation/Stage#Configuring_compile_options|Configuring compile options]]

* <kbd>man make.conf</kbd>

* [https://en.wikipedia.org/ Wikipedia]

* Les  [https://forums.gentoo.org/ forums de Gentoo]

{{Migrated|originalauthors=nightmorph}}
