{{Lowercase title}}

<languages />


{{Metadata|abstract=DM-Crypt es un sistema de cifrado de discos que utiliza el framework API de cifrado del núcleo y el subsistema mapeador de dispositivos.}}

{{InfoBox stack
|{{InfoBox homepage|http://code.google.com/p/cryptsetup/wiki/DMCrypt|header=true}}
|{{InfoBox wikipedia}}
}}

'''dm-crypt''' es un sistema de cifrado de discos que utiliza el marco API de cifrado del núcleo y el subsistema mapeador de dispositivos. Con dm-crypt, los administradores no solo pueden cifrar discos enteros, volúmenes lógicos o particiones, sino también ficheros individuales.

El subsistema de dm-crypt da soporte a la estructura ''Linux Unified Key Setup (LUKS)'', lo que permite usar múltiples claves para acceder a los datos cifrados, así como manipular las claves (esto es, cambiar las claves, añadir frases de acceso adicionales, etc.). A pesar de que dm-crypt soporta configuraciones no solo para LUKS, este artículo se centrará en la funcionalidad de LUKS, sobre todo debido a su flexibilidad, capacidad de gestión, así como por su amplio apoyo por parte de la comunidad.

== Configuración ==

Hay dos requisitos previos antes de poder comenzar a usar dm-crypt:

# Configurar el núcleo de Línux.
# Instalar el paquete {{Package|sys-fs/cryptsetup}}.

=== Configurar el núcleo ===

Para usar dm-crypt hay una serie de entradas de configuración que deben quedar definidas.

En primer lugar, se debe incluir soporte para la infraestructura del ''mapeador de dispositivos'' así como para el ''objetivo a cifrar'':

{{Kernel|Activar mapeador de dispositivos y objetivo a cifrar|<pre>
[*] Enable loadable module support
    Device Drivers --->
        [*] Multiple devices driver support (RAID and LVM) --->
            <*> Device mapper support
            <*> Crypt target support
</pre>}}

Luego, el núcleo de Línux necesita tener soporte para el conjunto de las API criptográficas que el administrador desee utilizar para el cifrado. Este se puede encontrar en la sección ''Cryptographic API'':

{{Kernel|Activar las funciones de la API de criptografía|<pre>
[*] Cryptographic API --->
    <*> SHA224 and SHA256 digest algorithm
</pre>
}}

Si se ha cifrado el sistema de ficheros root, entonces se debe crear un sistema de ficheros RAM inicial en el que el sistema de ficheros root sea descifrado antes de montarlo. Por lo tanto, esto requiere soporte para initramfs:

{{Kernel|Activar soporte initramfs|<pre>
General setup  --->
    [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support
</pre>}}

=== Instalar cryptsetup ===

El paquete {{Package|sys-fs/cryptsetup}} proporciona la orden <code>cryptsetyp</code>, que se utiliza para abrir o cerrar el soporte que sirve de almacenamiento cifrado, así como para gestionar las frases de acceso o claves asociadas con él.

{{Emerge|sys-fs/cryptsetup}}

== Almacenamiento cifrado ==

=== Fichero de claves o frase de acceso ===

Para comenzar con el almacenamiento cifrado, el administrador tendrá que decidir qué método utilizar para la clave de cifrado. Con <code>cryptsetup</code> la elección consistirá en una frase de acceso o en un fichero de claves. En el caso de un fichero de claves, este puede ser cualquier fichero, pero se recomienda utilizar un fichero con datos aleatorios que esté protegido adecuadamente (teniendo en cuenta que el acceso a este fichero de claves permitirá tener acceso a todos los datos cifrados).

Para crear un fichero de claves, se puede utilizar la orden <code>dd</code>:

{{RootCmd|dd if{{=}}/dev/urandom of{{=}}/etc/keys/enc.key bs{{=}}1 count{{=}}4096}}

En las siguientes secciones, mostraremos todas las órdenes para ambas situaciones —frase de acceso y fichero de claves—. Por supuesto, solo un método es necesario.

=== Crear una plataforma de almacenamiento encriptada ===

Con el fin de crear una plataforma de almacenamiento cifrada (que puede ser un disco, partición, fichero, ...) utilice la orden <code>cryptsetup</code> con la opción ''luksFormat ''.

Por ejemplo, para tener {{Path|/dev/vdb2}} como medio de almacenamiento para albergar los datos cifrados:

{{RootCmd|cryptsetup -s 512 luksFormat /dev/vdb2|output=<pre>
This will overwrite data on /dev/vdb2 irrevocably.
  
Are you sure? (Type uppercase yes): YES
Enter LUKS passphrase: ...
Verify passphrase: ...
</pre>}}

Para utilizar un fichero de claves, en lugar de una frase de acceso:

{{RootCmd|cryptsetup -s 512 luksFormat /dev/vdb2 /etc/keys/enc.key|output=<pre>
This will overwrite data on /dev/vdb2 irrevocably.
  
Are you sure? (Type uppercase yes): YES
</pre>}}

El parámetro <code>-s 512</code> le dice a <code> cryptsetup </code> qué longitud de clave (''KeyLength'') utilizar para la clave de cifrado vigente (a diferencia de la frase de acceso o fichero de claves, que se utilizan para tener acceso a esta clave de cifrado actual).

=== Abrir el almacenamiento encriptado ===

Con el fin de abrir el almacenamiento cifrado (es decir, que los datos reales sean accesibles a través del descifrado transparente), utilice la orden ''luksOpen''.

{{RootCmd|cryptsetup luksOpen /dev/vdb2 myname|output=<pre>
Enter passphrase for /dev/vdb2: ...
</pre>}}

Si se utiliza un fichero de claves, la orden se vería así:

{{RootCmd|cryptsetup luksOpen -d /etc/keys/enc.key /dev/vdb2 myname}}

When the command finishes succesfully, then a new device file called {{/dev/mapper/myname}} will be made available. This device file can then be mounted as a regular storage location:

{{RootCmd|mount /dev/mapper/myname /home}}

=== Closing the encrypted storage ===

In order to close the encrypted storage (i.e. ensure that the real data is no longer accessible through transparent decryption), use the ''luksClose'' command:

{{RootCmd|cryptsetup luksClose myname}}

Of course, make sure that the device is no longer in use.

== Manipulating LUKS keys ==

LUKS keys are used to access the real encryption key. They are stored in slots in the header of the (encrypted) partition, disk or file.

=== Listing the slots ===

With the ''luksDump'' command, information about the encrypted partition, disk or file can be shown. This includes the slots:

{{RootCmd|cryptsetup luksDump /dev/vdb2|output=<pre>
LUKS header information for /dev/vdb2
  
Version:        1
Cipher name:    aes
Cipher mode:    xts-plain64
Hash spec:      sha1
Payload offset: 4096
MK bits:        512
MK digest:      34 3b ec ac 10 af 19 e7 e2 d4 c8 90 eb a8 da 3c e4 4f 2e ce
MK salt:        ff 7c 7f 53 db 53 48 02 a4 32 dc e0 22 fc a3 51
                06 ba b3 48 b3 28 13 a8 7a 68 43 d6 46 79 14 fe
MK iterations:  59375
UUID:           2921a7c9-7ccb-4300-92f4-38160804e08c
  
Key Slot 0: ENABLED
        Iterations:             241053
        Salt:                   90 0f 0f db cf 66 ea a9 6c 7c 0c 0d b0 28 05 2f
                                8a 5c 14 54 98 62 1a 29 f3 08 25 0c ec c2 b1 68
        Key material offset:    8
        AF stripes:             4000
Key Slot 1: ENABLED
        Iterations:             273211
        Salt:                   01 4c 26 ed ff 18 75 31 b9 89 5d a6 e0 b5 f4 14
                                48 d0 23 47 a9 85 78 fb 76 c4 a9 d0 cd 63 fb d7
        Key material offset:    512
        AF stripes:             4000
Key Slot 2: DISABLED
Key Slot 3: DISABLED
Key Slot 4: DISABLED
Key Slot 5: DISABLED
Key Slot 6: DISABLED
Key Slot 7: DISABLED
</pre>}}

In the above example, two slots are used. Note that ''luksDump'' does not give away anything sensitive - it is merely displaying the LUKS header content. No decryption key has to be provided in order to call ''luksDump''.

=== Adding a keyfile or passphrase ===

In order to add an additional keyfile or passphrase to access the encrypted storage, use the ''luksAddKey'' option:

{{RootCmd|cryptsetup luksAddKey /dev/vdb2|output=<pre>
Enter any passphrase: (Enter a valid, previously used passphrase to unlock the key)
Enter new passphrase for key slot: ... 
Verify passphrase: ...
</pre>}}

To use a keyfile to unlock the key (but still add in a passphrase):

{{RootCmd|cryptsetup luksAddKey -d /etc/keys/enc.key /dev/vdb2|output=<pre>
Enter new passphrase for key slot: ...
Verify passphrase: '''
</pre>}}

If a keyfile is to be added (say {{Path|/etc/keys/backup.key}}:

{{RootCmd|cryptsetup luksAddKey /dev/vdb2 /etc/keys/backup.key}}

Or, to use the first keyfile to unlock the main key:

{{RootCmd|cryptsetup luksAddKey -d /etc/keys/enc.key /dev/vdb2 /etc/keys/backup.key}}

=== Removing a keyfile or passphrase ===

With the ''luksRemoveKey'' a keyfile or passphrase can be removed (so they can no longer be used to decrypt the storage):

{{RootCmd|cryptsetup luksRemoveKey /dev/vdb2|output=<pre>
Enter LUKS passphrase to be deleted: ...
</pre>}}

Or to remove a keyfile:

{{RootCmd|cryptsetup luksRemoveKey -d /etc/keys/backup.key /dev/vdb2}}

Make sure that at least one method for accessing the data is still available. Once a passphrase or keyfile is removed for use, this cannot be recovered again.

=== Emptying a slot ===

Suppose the passphrase or keyfile is no longer known, then the slot can be freed. Of course, this does require prior knowledge of which slot that the passphrase or keyfile was stored in.

For instance, to empty out slot 2 (which is the third slot as slots are numbered starting from 0):

{{RootCmd|cryptsetup luksKillSlot /dev/vdb2 2}}

This command will ask for a valid passphrase before continuing. Or one can pass on the keyfile to use:

{{RootCmd|cryptsetup luksKillSlot -d /etc/keys/enc.key /dev/vdb2 2}}

== Additional resources ==

* [[DM-Crypt LUKS]] on the Gentoo Wiki provides a more elaborate approach on using encrypted file systems for Gentoo Linux installations


[[Category:Core system]]
